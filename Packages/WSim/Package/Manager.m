(* ::Package:: *)

(* Autogenerated Package *)

$WSimRequiredSettings::usage="";
WSimValidateObject::usage="";
WSimInitialize::usage="";
WSimReset::usage="";


WSimGetPropagator::usage="Generates the actual propagator function";
WSimValidatePropagator::usage="Ensure propagator is compiled";
WSimPropagateWalkers::usage="Propagates an object's walkers";
WSimEquilibrateSystem::usage="";
WSimStepSystem::usage=""


WSimPlotTrajectory::usage="";
WSimPlotSnapshot::usage="";
WSimAnimateTrajectories::usage="";


Begin["`Private`"];


PackageLoadPacletDependency["SymbolObjects`"];
<<SymbolObjects`Package`


(* ::Subsection:: *)
(*Object Setup*)



(* ::Subsubsection::Closed:: *)
(*$WSimRequiredSettings*)



$WSimRequiredSettings=
	{
		"PropagatorGenerator",
		"WalkerValidationFunction",
		"PlotFunction"
		};


(* ::Subsubsection::Closed:: *)
(*WSimValidateObject*)



WalkerSimulator::noopa="WSim object missing `` settings.";


WSimValidateObject[obj_]:=
	With[
		{
			keys=Keys@obj, 
			extraNeeds=Replace[obj["RequiredProperties"], Except[_List]->{}]
			},
		Replace[
			Complement[
				Join[
					$WSimRequiredSettings,
					extraNeeds
					], 
				keys
				],
			{
				k:{__}:>
					(
						Message[WalkerSimulator::noopa, StringRiffle[k, ", "]];
						False
						),
				{}->True
				}
			]
		]


(* ::Subsubsection::Closed:: *)
(*WSimInitialize*)



WSimInitialize//Clear


WSimInitialize[
	class_,
	obj_,
	classFile:_String|None:None,
	walkers:_List,
	ops:___?OptionQ
	]:=
	(
		AssociateTo[
			obj,
			{
				"Class"->classFile,
				"Walkers"->walkers,
				"Trajectory"->
					{Replace[walkers, {l_List, ___?OptionQ}:>l, 1]},
				ops
				}
			];
		If[StringQ@classFile, WSimLoadClass[obj, classFile]];
		If[WSimValidateObject[obj],
			obj["TrajectoryTimes"]=
				{obj["CurrentTime"]};
			obj["InitialConditions"]=
				Block[{$SObjGetNew=False},
					obj[[{"Walkers", "TimeStep", "CurrentTime"}]]
					];
			obj,
			$Failed
			]
		)


(* ::Subsubsection::Closed:: *)
(*WSimReset*)



WSimReset[obj_]:=
	Block[{$SObjGetDecorate=False},
		obj["CurrentTime"]=obj["InitialConditions", "CurrentTime"];
		obj["TimeStep"]=obj["InitialConditions", "TimeStep"];
		obj["Walkers"]=obj["InitialConditions", "Walkers"];
		AssociateTo[
			obj,
			{
				"Trajectory"->
					{obj["Walkers"]},
				"TrajectoryTimes"->
					{obj["CurrentTime"]},
				"Runtime"->
					0.,
				"Steps"->
					0
				}
			];
		]


(* ::Subsection:: *)
(*Propagation Methods*)



(* ::Subsubsection::Closed:: *)
(*WSimValidatePropagator*)



WalkerSimulator::perfwarn=
	"Warning: ``. Performance may be significantly impacted";


Needs["CompiledFunctionTools`"];


WSimValidatePropagator[propFunc_]:=
	Module[
		{
			propStr
			},
		If[Head[propFunc]=!=CompiledFunction,
			Message[WalkerSimulator::perfwarn, "Propagator function isn't compiled"],
			propStr=CompilePrint[propFunc];
			If[StringContainsQ[propStr, "MainEvaluate"],
				Message[WalkerSimulator::perfwarn, "Propagator function calls MainEvaluate"]
				];
			];
		True
		]


(* ::Subsubsection::Closed:: *)
(*WSimGetPropagator*)



WalkerSimulator::badprop=
	"Propagator is invalid.";


WSimGetPropagator[obj_]:=
	With[{mprop=obj["PropagatorGenerator"][obj]},
		If[WSimValidatePropagator@mprop, 
			mprop,
			Message[WalkerSimulator::badprop];
			Throw@$Failed
			]
		]


(* ::Subsubsection::Closed:: *)
(*WSimPropagateWalkers*)



WSimPropagateWalkers[obj_, tInit_, dt_, nSteps_, traj_]:=
	Module[
		{
			prop=
				obj["Propagator"],
			walkers=
				Developer`ToPackedArray@obj["Walkers"],
			st=obj["SimulationTime"],
			ct=obj["CurrentTime"],
			tUnit=obj["TimeUnits"],
			newTraj,
			runTime
			},
		{runTime, newTraj}=
			AbsoluteTiming@prop[
				walkers,
				tInit,
				dt,
				nSteps,
				traj
				];
		obj["Steps"]+=nSteps;
		obj["Runtime"]+=runTime;
		obj["StepTime"]=obj["Runtime"]/obj["Steps"];
		obj["Walkers"]=
			Developer`ToPackedArray@newTraj[[-1]];
		obj["Trajectory"]=
			Developer`ToPackedArray@Join[obj["Trajectory"], newTraj];
		obj["CurrentTime"]=
			Which[
				StringQ@tUnit, 
					UnitConvert[
							Quantity[dt*nSteps, tUnit]+
								If[QuantityQ@tInit, 
									tInit, 
									Quantity[tInit, tUnit]
									],
							tUnit
							],
				QuantityQ@ct,
					Quantity[dt*nSteps+tInit, QuantityUnit@ct],
				True,
					dt*nSteps+tInit
				];
		obj["TrajectoryTimes"]=
			Join[
				obj["TrajectoryTimes"], 
				Rest@Subdivide[ct, obj["CurrentTime"], Length@newTraj]
				];
		obj["CurrentTime"]
		];


WSimPropagateWalkers[obj_]:=
	Module[
		{
			tUnit=obj["TimeUnits"],
			tCur=obj["CurrentTime"],
			tInit,
			ts=obj["TimeStep"], 
			st=obj["SimulationTime"], 
			samp=obj["TrajectorySampling"],
			nstep
			},
		ts=
			If[StringQ@tUnit&&QuantityQ@ts,
					QuantityMagnitude@
						UnitConvert[ts, tUnit],
					QuantityMagnitude@ts
					];
		st=
			If[StringQ@tUnit&&QuantityQ@st,
				QuantityMagnitude@
					UnitConvert[st, tUnit],
				QuantityMagnitude@st
				];
		nstep=
			Ceiling@If[ts==0, st, st/ts];
		samp=
			Replace[
				Floor@
					If[StringQ@tUnit&&QuantityQ@samp,
						st/QuantityMagnitude@UnitConvert[samp, tUnit],
						samp
						],
				Except[_Integer]->1
				];
		tInit=
			QuantityMagnitude@
				If[StringQ@tUnit&&QuantityQ@tCur, 
					UnitConvert[tCur, tUnit],
					tCur
					];
		WSimPropagateWalkers[
			obj, 
			tInit,
			ts,
			nstep,
			samp
			]
		]


(* ::Subsubsection::Closed:: *)
(*WSimEquilibrateSystem*)



WSimEquilibrateSystem[obj_, howLong_:1000]:=
	With[{t1=obj["TrajectorySampling"], t2=obj["SimulationTime"], t3=obj["TimeStep"]},
		Internal`WithLocalSettings[
			obj["TrajectorySampling"]=1;
			obj["SimulationTime"]=
				If[QuantityQ@t3&&QuantityQ@howLong,
					Floor[QuantityMagnitude[howLong/UnitConvert[t3, QuantityUnit@howLong]]],
					Floor@QuantityMagnitude@howLong
					];
			obj["TimeStep"]=0,
			obj["Propagate"][],
			obj["TrajectorySampling"]=t1;
			obj["SimulationTime"]=t2;
			obj["TimeStep"]=t3
			]
		]


(* ::Subsubsection::Closed:: *)
(*WSimStepSystem*)



WSimStepSystem[obj_, howMany_:1]:=
	With[{t1=obj["TrajectorySampling"], st=obj["SimulationTime"], ts=obj["TimeStep"]},
		Internal`WithLocalSettings[
			obj["TrajectorySampling"]=1;
			obj["SimulationTime"]=
				howMany*
					If[QuantityQ@st&&QuantityQ@ts,
						UnitConvert[ts, QuantityUnit@st],
						ts
						];,
			obj["Propagate"][],
			obj["TrajectorySampling"]=t1;
			obj["SimulationTime"]=st;
			]
		]


(* ::Subsection:: *)
(*Plotting Methods*)



(* ::Subsubsection::Closed:: *)
(*WSimPlotTrajectory*)



WSimPlotTrajectory//Clear


WSimPlotTrajectory[
	obj_, 
	plotFun:_String|Automatic:Automatic,
	trajSel:{__Integer}|_Span|All:All, 
	ops:OptionsPattern[]
	]:=
	Module[
		{
			ts=obj["TimeStep"],
			st=obj["SimulationTime"],
			tsamp=Replace[obj["TrajectorySampling"], Except[_Integer]->1], 
			steps,
			walkers=obj["Trajectory"],
			pl=
				If[plotFun===Automatic, 
					obj["PlotFunction"],
					Lookup[Replace[obj["ExtraPlotFunctions"], Except[_?OptionQ]:><||>],
						plotFun,
						obj["PlotFunction"]
						]
					],
			timeSteps,
			times=obj["TrajectoryTimes"],
			wbf=Replace[obj["WalkerBoxFunction"], _Missing:>CoordinateBounds],
			fullWalkers,
			cbs,
			potPlot
			},
		If[Length@walkers>0,
			walkers=walkers[[trajSel]];
			timeSteps=QuantityMagnitude@times[[trajSel]];
			fullWalkers=Flatten[walkers, 1];
			cbs=wbf[fullWalkers];
			Replace[Lookup[Flatten@{ops}, PlotRange],
				l_List:>
					Set[
						cbs,
						MapThread[
							If[ListQ@#2&&Length@#2==2&&AllTrue[#2, NumericQ], #2, #]&,
							{
								PadRight[cbs, Length@l, {0, 0}],
								l
								}
							]
						]
				];
			MapThread[
				pl[#, cbs, #2, obj, ops]&,
				{
					walkers,
					timeSteps
					}
				],
			$Failed
			]
		]


(* ::Subsubsection::Closed:: *)
(*WSimAnimateTrajectories*)



WSimAnimateTrajectories//Clear


WSimAnimateTrajectories[
	obj_, 
	plotFun:_String|Automatic:Automatic,
	trajSel:{__Integer}|_Span|All:All, 
	ops:OptionsPattern[]
	]:=
	DynamicModule[
		{
			tl=
				If[TrueQ@Lookup[{ops}, Rasterize, False],
						Map[Rasterize[#, Sequence@@FilterRules[{ops}, Options@Rasterize]]&],
						Identity
						]@WSimPlotTrajectory[obj, plotFun, trajSel, ops]
			},
		Interpretation[
			Animate[
				tl[[i]], 
				{{i, 1, "Snapshot"}, 1, Length@tl, 1},
				Evaluate@FilterRules[{ops}, Options@Animate]
				],
			tl
			]
		]


(* ::Subsubsection::Closed:: *)
(*WSimPlotSnapshot*)



WSimPlotSnapshot//Clear


WSimPlotSnapshot[obj_, 
	plotFun:_String|Automatic:Automatic, 
	which:_Integer:-1, ops:OptionsPattern[]
	]:=
	WSimPlotTrajectory[obj, plotFun, {which}, ops][[1]]


End[];



