(* ::Package:: *)

(* Autogenerated Package *)

(* ::Subsubsection::Closed:: *)
(*Formats*)



$ChemFormatsMolFormatPatterns::usage=
	"Patterns for detecting mol form";
ChemFormatsDetectMolFormat::usage=
	"Detects a molecule format";


ChemFormatsMolToZMatrix::usage=
	"Turns a list of atom-coordinate pairs into a ZMatrix";
ChemFormatsEnumerateZMatrixStrings::usage=
	"Enumerates and cleans ZMatrix strings";
ChemFormatsZMatrixToMol::usage=
	"Turns a ZMatrix into a list of atoms-coordinate pairs";
ChemFormatsZMatrixToString::usage=
	"Converts a ZMatrix to a string";


ChemFormatsMolToRules::usage="Generates rules for a MOL file";
ChemFormatsMolToString::usage="Converts atom list into MOL or SDF string";
ChemFormatsMolRulesToString::usage="Generates a string from a set of MOL rules";


ChemFormatsMolToStringWrapper::usage="A little wrapper for these conversions";
ChemFormatsOBConvert::usage="Conversion wrapper to OpenBabel";
ChemFormatsOBImport::usage="Conversion wrapper to import unsupported formats via OB";


Begin["`Private`"];


(* ::Subsection:: *)
(*Conversion Utils*)



(* ::Subsubsection::Closed:: *)
(*DetectMolFormat*)



(* ::Subsubsubsection::Closed:: *)
(*$ChemFormatsMolFormatPatterns*)



$ChemFormatsMolFormatPatterns=
	<|
		"MolTable"->
			{
				Optional[{_Integer,_Integer},{0,0}],
				{_String,_List,___}..,
				{_Integer,_Integer,___}...
				},
		"SDFTable"->
			{
				{
					Optional[{_Integer,_Integer},{0,0}],
					{_String,_List,___}..,
					{_Integer,_Integer,___}...
					}..
				},
		"ZMatrix"->
			{
				{_String},
				{_String, _Integer, __?NumericQ}...
				},
		"SDFRules"->
			{
				Repeated[_->{__List}]
				},
		"MolRules"->
			{
				Repeated[_->_List]
				}
		|>;


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsDetectMolFormat*)



ChemFormatsDetectMolFormat[s_String]:=
	Which[
		StringStartsQ[s, "InChI"],
			"InChI",
		Length@StringCases[s,"\n"]===0,
			"SMILES",
		Length@StringCases[s, "M  END"~~Whitespace~~"$$$$"]>0,
			"SDF",
		Length@StringCases[s, "M  END"]===1,
			"MOL",
		StringContainsQ[
			StartOfLine~~(Whitespace|"")~~(WordCharacter..)~~
				Repeated[Whitespace~~(DigitCharacter..~~"."~~DigitCharacter..)]
			],
			"XYZ",
		StringStartsQ[StringTrim[s], LetterQ..~~(Whitespace|"")~~"\n"],
			"ZMatrix",
		True,
			$Failed
		];


ChemFormatsDetectMolFormat[l_List]:=
	l/.
		Append[KeyValueMap[Rule[#2, #]&, $ChemFormatsMolFormatPatterns], _->$Failed]


(* ::Subsubsection::Closed:: *)
(*GenerateZMatrix*)



$ZMatrixInRadians=True


(* ::Subsubsubsection::Closed:: *)
(*zmBits*)



zmNorm=
	Function[{crd1,crd2},
		Norm[crd2-crd1]
		];
zmVAngle=
	Function[{crd1,crd2,crd3},
		VectorAngle[
			crd2-crd3,
			crd2-crd1
			]*If[!TrueQ[$ZMatrixInRadians], 1/Degree, 1]
		];
zmDAngle=
	Function[{crd1,crd2,crd3,crd4},
		With[{caxis=crd3-crd2},
			VectorAngle[
				Cross[crd4-crd3,caxis],
				Cross[crd2-crd1,-caxis]
				]*If[!TrueQ[$ZMatrixInRadians], 1/Degree, 1]
			]
		];


(* ::Subsubsubsection::Closed:: *)
(*zmatrixEntry*)



(* ::Text:: *)
(*
	Compute ZMatrix entry for a given atom, total set of atoms, and atoms for comparison
*)



zmatrixEntry//Clear


zmatrixEntry[
	atom_, 
	atoms_, 
	which:_Integer?Positive|{Repeated[_Integer?Positive, {1, 3}]}|None
	]:=
	Switch[
		which,
		1,
			{First@atom},
		None,
			{First@atom},
		2,
			{(* Atom type *)
				First@atom,
				1,
					(* Calculate norm to first atom *)
					zmNorm[
						Last@atom,
						Last@atoms[[1]]
						]
				},
		{_},
			{(* Atom type *)
				First@atom,
				which[[1]],
					(* Calculate norm to specified atom *)
					zmNorm[
						Last@atom,
						Last@atoms[[which[[1]]]]
						]
				},
		3,
			{(* Atom type *)
				First@atom,
				2,
					(* Calculate norm to second atom *)
					zmNorm[
						Last@atom,
						Last@atoms[[2]]
						],
				1,
					(* Calculate angle to first atom *)
					zmVAngle[
						Last@atom,
						Last@atoms[[2]],
						Last@atoms[[1]]
						]
				},
		{_, _},
			{(* Atom type *)
				First@atom,
				which[[1]],
					(* Calculate norm to first specified atom *)
					zmNorm[
						Last@atom,
						Last@atoms[[which[[1]]]]
						],
				which[[2]],
					(* Calculate angle to second specified atom *)
					zmVAngle[
						Last@atom,
						Last@atoms[[which[[1]]]],
						Last@atoms[[which[[2]]]]
						]
				},
		_Integer,
			{(* Atom type *)
				First@atom,
				(* Use previous atom in ZMatrix *)
				which-1,
					zmNorm[
						Last@atom,
						Last@atoms[[which-1]]
						],
				(* Use 2 ago *)
				which-2,
					zmVAngle[
						Last@atom,
						Last@atoms[[which-1]],
						Last@atoms[[which-2]]
						],
				(* Use 3 ago *)
				which-3,
					zmDAngle[
						Last@atom,
						Last@atoms[[which-1]],
						Last@atoms[[which-2]],
						Last@atoms[[which-3]]
						]
				},
		{_, _, _},
			{(* Atom type *)
				First@atom,
				(* Use previous atom in ZMatrix *)
				which[[1]],
					zmNorm[
						Last@atom,
						Last@atoms[[which[[1]]]]
						],
				(* Use 2 ago *)
				which[[2]],
					zmVAngle[
						Last@atom,
						Last@atoms[[which[[1]]]],
						Last@atoms[[which[[2]]]]
						],
				(* Use 3 ago *)
				which[[3]],
					zmDAngle[
						Last@atom,
						Last@atoms[[which[[1]]]],
						Last@atoms[[which[[2]]]],
						Last@atoms[[which[[3]]]]
						]
				}
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsMolToZMatrix*)



(* ::Text:: *)
(*
	This might be broken as I can\[CloseCurlyQuote]t remember what I was doing with it...
*)



Options[ChemFormatsMolToZMatrix]=
	{
		"ZMatrixOrder"->Automatic,
		"UseRadians"->Automatic
		};
ChemFormatsMolToZMatrix[atoms_List, ops:OptionsPattern[]]:=
	PackageExceptionBlock["ZMatrixFormat"]@
	Block[
		{
			$ZMatrixInRadians=
				Replace[OptionValue["UseRadians"], Except[True|False]->$ZMatrixInRadians]
				},
		Module[
			{
				ats=atoms,
				atomOrder=Range[Length@atoms],
				which=
					Replace[OptionValue["ZMatrixOrder"],
						{
							w:{{__Integer}..}:>
								SortBy[w, Length],
							Except[{__Integer}]:>
								Range[Length@atoms]
							}
						]
				},
			Switch[Length/@which[[{1, -1}]],
				{0, 0},
					If[Intersection[which, atomOrder]=!=atomOrder,
							PackageRaiseException[
								"ZMatrixFormat",
								"ZMatrix ordering `` doesn't contain all atoms",
								"MessageParameters"->{which}
								]
						];
					If[Length[which]=!=Length[atomOrder],
							PackageRaiseException[
								"ZMatrixFormat",
								"ZMatrix ordering `` contains too many atoms",
								"MessageParameters"->{which}
								]
						];
					atomOrder=which;
					which=Range[Length@which],
				{1, 4},
					atomOrder=
						which[[All, 1]];
					which=
						Prepend[which[[2;;, 2;;]], None],
				{1, 2},
					If[Length@which>2, 
							PackageRaiseException[
								"ZMatrixFormat",
								"ZMatrix can only have one line of length 1 and one of length 2"
								]
						];
					which=Prepend[which, None],
				{1, 3},
					which=Prepend[which, None],
				Except[{0, 0}|{1, 3}],
					PackageRaiseException[
						"ZMatrixFormat",
						"ZMatrix lines must vary in length between 1 and 3"
						];
				];
			ats=ats[[atomOrder]];
			which=which/.Thread[atomOrder->Range[Length@ats]];
			MapThread[
				zmatrixEntry[#, ats, #2]&,
				{
					ats,
					which
					}
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*EnumerateZMatrixStrings*)



ChemZMatrixStringVarRules[s_String]:=
	With[{
		main=
			Map[
				#[[1]]->
					Replace[Rest[#],
						{
							{main_, step_, inc_}:>
								Map[ToString,
									ToExpression[main]+Range[0, ToExpression[step]]*ToExpression[inc]
									]
							}
						]&,
				Map[StringSplit]@StringSplit[s, "\n"]
				]
		},
		Map[Thread[Keys@main->#]&, Tuples[Values@main]]
		]


ChemUtilsPreCleanZMatrixString[s_String]:=
	Fold[
		#2[#]&,
		s,
		{
			StringTrim, 
			StringDelete[StartOfString~~"!"~~(Except["\n"]...)~~"\n"],
			StringDelete[Longest["!"~~(Except["\n"]...)]],
			StringDelete[StartOfLine~~(Except["\n", Whitespace])],
			StringDelete[(Except["\n", Whitespace])~~EndOfLine],
			StringReplace[Repeated["\n", {2, \[Infinity]}]->"\n\n"]
			}
		];


ChemFormatsEnumerateZMatrixStrings[s_String]:=
	Module[
		{
			main=
					ChemUtilsPreCleanZMatrixString[s],
			bits,
			bonds=""
			},
		bits=
			StringTrim/@
				ReplaceAll[
					StringSplit[
						StringSplit[
							main, 
							"\n\n"|("\n"~~Except[WhitespaceCharacter]..~~":")
							],
						"\n"~~n:NumberString:>"JoinMe!"->n,
						2
						],
					{
						{
							{m_String}, {vars___String, "JoinMe!"->n_, bonds_String}
							}|
						{
							{m_String}, {vars___String},{b1___String, "JoinMe!"->n_, b2_String}
							}:>
								{
									m,
									vars,
									b1<>"\n"<>n<>b2
									},
						{{m_String}, {vars__String}}:>
							{m, vars}
						}
					];
		If[Length@bits>1&&StringStartsQ[Last@bits, NumberString],
			bonds=Last@bits;
			bits=Most@bits
			];
		StringTrim@
			Switch[Length@bits,
				1,
					bits<>"\n\n"<>bonds,
				2,
					Map[
						StringReplace[
							bits[[1]], 
							#
							]<>"\n\n"<>bonds&,
						ChemZMatrixStringVarRules@bits[[2]]
						],
				_,
					MapThread[
						StringReplace[
							bits[[1]], 
							Join[##]
							]<>"\n\n"<>bonds&,
						Map[ChemZMatrixStringVarRules, Rest@bits]
						]
				]
		]


(* ::Subsubsection::Closed:: *)
(*ZMatrixToString*)



ChemFormatsZMatrixToString[mat_List]:=
	Module[
		{
			zmValues,
			zmVars,
			zmBonds
			},
		zmValues=Cases[mat, {_String, __}];
		zmVars=Cases[mat, v:(_->{__}):>v];
		zmBonds=Cases[mat, {_Integer, _Integer, ___}];
		StringReplace[
			StringRiffle[
				{
					ExportString[zmValues, "Table"],
					If[Length@zmVars>0, 
						"Variables:\n"<>
							ExportString[
								Replace[zmVars_, (k_->{v__}):>{k, "->", v}, 1],
								"Table"
								], 
							""
						],
					If[Length@zmBonds>0, ExportString[zmBonds, "Table"], ""]
					},
				"\n"
				],
			"->"->"="
			]//StringTrim
		]


(* ::Subsubsection::Closed:: *)
(*GenerateMolTable*)



Clear[molTableNormed, molTableVAngled, molTableDAngled]


(* ::Text:: *)
(*Should extend this to generate ZMatrices that aren\[CloseCurlyQuote]t centered at (0, 0, 0) but will do that another day*)



(* ::Subsubsubsection::Closed:: *)
(*molTableNormed*)



(* ::Text:: *)
(*
	First type:
		Simply place it at a normed distance away from a point
*)



molTableNormed[crd1_, norm_]:=
	crd1+{norm, 0, 0}


(* ::Subsubsubsection::Closed:: *)
(*molTableVAngled*)



(* ::Text:: *)
(*
	Second type:
		Place the normed version at an angle
*)



molTableVAngled[crd1_, crd2_, norm_, angle_]:=
		crd1+
			RotationMatrix[
				angle*If[$ZMatrixInRadians, 1, Degree],
				With[{c=Cross[crd2-crd1, {1, 0, 0}]},
					If[c=={0, 0, 0}, 
						Cross[crd2-crd1, {0, 1, 0}],
						c
						]
					]
				].(norm*Normalize[crd2-crd1])


(* ::Subsubsubsection::Closed:: *)
(*molTableDAngled*)



(* ::Text:: *)
(*
	Third type:
		Place the normed version at an angle and then do the dihedral transform preserving these
*)



ChemFormatsZMatrixToMol::colin=
	"Coordinates ``, ``, and `` are collinear. \
Z axis will be used for dihedral";


molTableDAngled[crd1_, crd2_, crd3_, norm_, ang_, dihed_]:=
	Module[
		{
			ax21=crd2-crd1, 
			ax31=crd3-crd1,
			normalVec,
			baseVec,
			dihedAxis,
			angle=ang*If[$ZMatrixInRadians, 1, Degree],
			dangle=dihed*If[$ZMatrixInRadians, 1, Degree]
			},
		normalVec=Cross[ax21, ax31];
		If[normalVec=={0, 0, 0},
			Message[ChemFormatsZMatrixToMol::colin, crd1, crd2, crd2];
			normalVec=Cross[ax21, {0, 0, 1}]
			];
		If[normalVec=={0, 0, 0}, normalVec=Cross[ax21, {0, 1, 0}]];
		baseVec=
			RotationMatrix[angle, normalVec].(norm*Normalize[ax21]);
		crd1+
			RotationMatrix[dangle, ax21].baseVec
		];


(* ::Subsubsubsection::Closed:: *)
(*molTableEntry*)



molTableEntry[line_, previousAtoms_]:=
	Switch[{line, Length@previousAtoms},
		{{_String, _?NumericQ, _?NumericQ, _?NumericQ}, _},
			{line[[1]], line[[2;;4]]},
		{_, 0}|{{_String}, _},
			{line[[1]], {0.,0.,0.}},
		{{_String, 1, __}, 1}|
			{{_String, _Integer, _?NumericQ}, _Integer?(#>=line[[2]]>0&)},
			{
				line[[1]],
				With[{crd1=previousAtoms[[line[[2]], 2]], n=line[[3]]},
					molTableNormed[crd1, n]
					]
				},
		{{_String, 1|2, _, 1|2, __}, 2}|
			{
				{_String, _Integer, _?NumericQ, _Integer, _?NumericQ}, 
				_Integer?(#>=Max@{line[[2]], line[[4]], 0}&)
				},
			{line[[1]],
				With[
					{
						crd1=previousAtoms[[line[[2]],2]],n=line[[3]],
						crd2=previousAtoms[[line[[4]],2]],a=line[[5]]
						},
					molTableVAngled[
						crd1, crd2,
						n, a
						]
					]
				},
		{
			{_String, _Integer, _?NumericQ, _Integer, _?NumericQ, _Integer, _?NumericQ}, 
			_Integer?(#>=Max@{line[[2]], line[[4]], line[[6]], 0}&)
			},
			{
				line[[1]],
				With[
					{
						crd1=previousAtoms[[line[[2]], 2]],n=line[[3]],
						crd2=previousAtoms[[line[[4]], 2]],a=line[[5]],
						crd3=previousAtoms[[line[[6]], 2]],d=line[[7]]
						},
					molTableDAngled[
						crd1, crd2, crd3,
						n, a, d
						]
					]
				},
		_,
			PackageRaiseException[
				"ZMatrixToMol",
				"Couldn't parse ZMatrix line ``: ``",
				"MessageParameters"->{1+Length@previousAtoms, line}
				]
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsZMatrixToMol*)



Options[ChemFormatsZMatrixToMol]=
	{
		"UseRadians"->Automatic
		};
ChemFormatsZMatrixToMol[zmMatrix:{{_String},___List}, ops:OptionsPattern[]]:=
	PackageExceptionBlock["ZMatrixToMol"]@
		Block[
			{
				$ZMatrixInRadians=
					Replace[OptionValue["UseRadians"], Except[True|False]->$ZMatrixInRadians]
				},
			Fold[
				Append[#, molTableEntry[Take[#2, UpTo[7]], #]]&,
				{},
			 zmMatrix
			 ]
			]


(* ::Subsubsection::Closed:: *)
(*GenerateMolRules*)



ChemFormatsMolToRules[
	molTable:{
		Optional[{_Integer,_Integer},{0,0}],
		atoms:{_String,_List,___}..,
		bonds:{_Integer,_Integer,___}...
		}
	]:=
	{
		"VertexTypes"->{atoms}[[All,1]],
		"VertexCoordinates"->{atoms}[[All,2]],
		"EdgeRules"->
			Rule@@@{bonds}[[All,;;2]],
		"EdgeTypes"->
			Replace[{bonds}[[All,-1]],
				{
					1->"Single",
					2->"Double",
					3->"Triple",
					_->"Single"
					},
				1
				],
		"FormalCharges"->
			Replace[{atoms}, {{_,_,_, c_}:>c, _->0}, 1]
		}


ChemFormatsMolToRules[
	molTables:{
		Repeated@
			{
				Optional[{_Integer,_Integer},{0,0}],
				{_String,_List,___}..,
				{_Integer,_Integer,___}...
				}
		}
	]:=
	Thread[
		{"VertexTypes","VertexCoordinates",
			"EdgeTypes","EdgeRules","FormalCharges"}->
		Lookup[
			ChemFormatsMolToRules/@molTables,
			{"VertexTypes","VertexCoordinates",
				"EdgeTypes","EdgeRules","FormalCharges"}
			]
		]


ChemFormatsMolToRules[
	zm_List?(ChemFormatsDetectMolFormat[#]==="ZMatrix"&)
	]:=
	ChemFormatsMolToRules@
		ChemFormatsZMatrixToMol[zm]


(* ::Subsubsection::Closed:: *)
(*GenerateMolString*)



ChemFormatsMolToString//Clear


(* ::Subsubsubsection::Closed:: *)
(*iChemFormatsMolToString*)



iChemFormatsMolToString[molData_, "MolRules", target_:"MOL"]:=
	ChemFormatsMolRulesToString[molData, target];
iChemFormatsMolToString[molData_, "ZMatrix"|"MolTable", target_:"MOL"]:=
	iChemFormatsMolToString[
		ChemFormatsMolToRules@molData,
		"MolRules",
		target
		];
iChemFormatsMolToString[molData_, "SDFRules", target_:"SDF"]:=
	iChemFormatsMolRulesToString[molData, target];
iChemFormatsMolToString[molData_, "SDFTable", target_:"SDF"]:=
	iChemFormatsMolToString[
		ChemFormatsMolToRules@molData,
		"SDFRules",
		target
		];


(* ::Subsubsubsection::Closed:: *)
(*MolToString*)



ChemFormatsMolToString[molData_, format_:Automatic]:=
	iChemFormatsMolToString[molData, ChemFormatsDetect[molData], 
		Replace[format, Automatic:>Sequence@@{}]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsMolToStringWrapper*)



ChemFormatsMolToStringWrapper[mainFmt_, target_][data_]:=
	iChemFormatsMolToString[data, mainFmt, target]


(* ::Subsubsection::Closed:: *)
(*MolRulesToString*)



(* ::Subsubsubsection::Closed:: *)
(*$MolRulesExportPropertiesKeys*)



$MolRulesExportPropertiesKeys=
	<|
		"MOL"->
			{
				"VertexTypes",
				"VertexCoordinates",
				"EdgeRules",
				"EdgeTypes",
				"FormalCharges"
				},
		"SDF":>$MolRulesExportKeys["MOL"],
		"MOL2":>
			Join[$MolRulesExportKeys["MOL"], {"ResidueAtoms", "ResidueCoordinates"}],
		"XYZ"->
			{
				"VertexTypes",
				"VertexCoordinates"
				}
		|>


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsMolRulesToString*)



(* ::Subsubsubsubsection::Closed:: *)
(*MOL*)



ChemFormatsMolRulesToString[rules_?OptionQ, "MOL"]:=
	StringDelete[
		"Created with the Wolfram Language : www.wolfram.com"
		]@
		ExportString[
			Normal@
				AssociationThread[
					$MolRulesExportPropertiesKeys["MOL"],
					Lookup[
						rules,
						$MolRulesExportPropertiesKeys["MOL"],
						{}
						]
					],
			"MOL"
			];


(* ::Subsubsubsubsection::Closed:: *)
(*SDF*)



ChemFormatsMolRulesToString[rules_?OptionQ, "SDF"]:=
	ExportString[
		Normal@
			AssociationThread[
				$MolTableRuleKeys,
				Replace[
					Lookup[
						rules,
						$MolTableRuleKeys,
						{}
						],
					l:Except[{__List}, _List]:>{l},
					1
					]
				],
		"SDF"
		];


(* ::Subsubsubsubsection::Closed:: *)
(*MOL2*)



ChemFormatsMolRulesToString[rules_?OptionQ, "MOL2"]:=
	StringDelete[
		"Created with the Wolfram Language : www.wolfram.com"
		]@
		ExportString[
			Normal@
				AssociationThread[
					$MolRulesExportPropertiesKeys["MOL2"],
					Lookup[
						rules,
						$MolRulesExportPropertiesKeys["MOL2"],
						{}
						]
					],
			"MOL2"
			];


(* ::Subsubsubsubsection::Closed:: *)
(*XYZ*)



ChemFormatsMolRulesToString[rules_?OptionQ, "XYZ"]:=
	StringDelete[
		"Created with the Wolfram Language : www.wolfram.com"
		]@
		ExportString[
			Normal@
				AssociationThread[
					$MolRulesExportPropertiesKeys["XYZ"],
					Lookup[
						rules,
						$MolRulesExportPropertiesKeys["XYZ"],
						{}
						]
					],
			"XYZ"
			];


(* ::Subsubsection::Closed:: *)
(*ChemFormatsOBConvert*)



ChemFormatsOBConvert//Clear
ChemFormatsOBConvert[data_, form:(_String->_String)|_String, ops:OptionsPattern[]]:=
	OBFormatConvert[data, 
		form, 
		ops
		];
ChemFormatsOBConvert[form:(_String->_String)|_String][data_, ops:OptionsPattern[]]:=
	ChemFormatsOBConvert[data, form, ops];


(* ::Subsubsection::Closed:: *)
(*ChemFormatsOBImport*)



ChemFormatsOBImport//Clear
ChemFormatsOBImport[data_String, form:_String, ops:OptionsPattern[]]:=
	ImportString[
		ChemFormatsOBConvert[data, form->"MOL", ops],
		"MolTable"
		];
ChemFormatsOBImport[form:_String][data_String, ops:OptionsPattern[]]:=
	ChemFormatsOBImport[data, form, ops];


End[];



