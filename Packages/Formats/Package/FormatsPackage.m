(* ::Package:: *)

(* Autogenerated Package *)

(* ::Subsubsection::Closed:: *)
(*Formats*)



$ChemFormatsMolFormatPatterns::usage=
	"Patterns for detecting mol form";
ChemFormatsDetectMolFormat::usage=
	"Detects a molecule format";


$ChemOpenBabelReadFormats::usage=
	"The formats OpenBabel can read from";
$ChemOpenBabelWriteFormats::usage=
	"The formats OpenBabel can write to";


ChemFormatsMolToZMatrix::usage=
	"Turns a list of atom-coordinate pairs into a ZMatrix";
ChemFormatsEnumerateZMatrixStrings::usage=
	"Enumerates and cleans ZMatrix strings";
ChemFormatsZMatrixToMol::usage=
	"Turns a ZMatrix into a list of atoms-coordinate pairs";
ChemFormatsZMatrixToString::usage=
	"Converts a ZMatrix to a string";


ChemFormatsMolToRules::usage="Generates rules for a MOL file";
ChemFormatsMolToString::usage="Converts atom list into MOL or SDF string";
ChemFormatsMolRulesToString::usage="Generates a string from a set of MOL rules";


ChemFormatsMolToStringWrapper::usage="A little wrapper for these conversions";
ChemFormatsOBConvert::usage="Conversion wrapper to OpenBabel";
ChemFormatsOBImport::usage="Conversion wrapper to import unsupported formats via OB";


Begin["`Private`"];


(* ::Subsection:: *)
(*File Formats*)



(* ::Subsubsection::Closed:: *)
(*OpenBabel*)



(* ::Subsubsubsection::Closed:: *)
(*$ChemOpenBabelWriteFormats*)



$ChemOpenBabelWriteFormats=
	{
		"ACESIN","ADF","ALC","ASCII","BGF",
		"BOX","BS","C3D1","C3D2","CAC",
		"CACCRT","CACHE","CACINT","CAN","CDJSON",
		"CDXML","CHT","CIF","CK","CML",
		"CMLR","COM","CONFABREPORT","CONFIG","CONTCAR",
		"CONTFF","COPY","CRK2D","CRK3D","CSR",
		"CSSR","CT","CUB","CUBE","DALMOL",
		"DMOL","DX","ENT","EXYZ","FA",
		"FASTA","FEAT","FH","FHIAIMS","FIX",
		"FPS","FPT","FRACT","FS","FSA",
		"GAMIN","GAU","GJC","GJF","GPR",
		"GR96","GRO","GUKIN","GUKOUT","GZMAT",
		"HIN","INCHI","INCHIKEY","INP","JIN",
		"K","LMPDAT","LPMD","MCDL","MCIF",
		"MDFF","MDL","ML2","MMCIF","MMD",
		"MMOD","MNA","MOL","MOL2","MOLD",
		"MOLDEN","MOLF","MOLREPORT","MOP","MOPCRT",
		"MOPIN","MP","MPC","MPD","MPQCIN",
		"MRV","MSMS","NUL","NW","ORCAINP",
		"OUTMOL","PAINT","PCJSON","PCM","PDB",
		"PDBQT","PNG","POINTCLOUD","POSCAR","POSFF",
		"POV","PQR","PQS","QCIN","REPORT",
		"RSMI","RXN","SD","SDF","SMI",
		"SMILES","STL","SVG","SY2","TDD",
		"TEXT","THERM","TMOL","TXT","TXYZ",
		"UNIXYZ","VASP","VMOL","XED","XYZ",
		"YOB","ZIN"
		};


(* ::Subsubsubsection::Closed:: *)
(*$ChemOpenBabelReadFormats*)



$ChemOpenBabelReadFormats=
	{
		"ABINIT","ACESOUT","ACR","ADFOUT","ALC",
		"AOFORCE","ARC","AXSF","BGF","BOX",
		"BS","C09OUT","C3D1","C3D2","CACCRT",
		"CAN","CAR","CASTEP","CCC","CDJSON",
		"CDX","CDXML","CIF","CK","CML",
		"CMLR","CONFIG","CONTCAR","CONTFF","CRK2D",
		"CRK3D","CT","CUB","CUBE","DALLOG",
		"DALMOL","DAT","DMOL","DX","ENT",
		"EXYZ","FA","FASTA","FCH","FCHK",
		"FCK","FEAT","FHIAIMS","FRACT","FS",
		"FSA","G03","G09","G92","G94",
		"G98","GAL","GAM","GAMESS","GAMIN",
		"GAMOUT","GOT","GPR","GRO","GUKIN",
		"GUKOUT","GZMAT","HIN","HISTORY","INCHI",
		"INP","INS","JIN","JOUT","LOG",
		"LPMD","MCDL","MCIF","MDFF","MDL",
		"ML2","MMCIF","MMD","MMOD","MOL",
		"MOL2","MOLD","MOLDEN","MOLF","MOO",
		"MOP","MOPCRT","MOPIN","MOPOUT","MPC",
		"MPO","MPQC","MRV","MSI","NWO",
		"ORCA","OUT","OUTMOL","OUTPUT","PC",
		"PCJSON","PCM","PDB","PDBQT","PNG",
		"POS","POSCAR","POSFF","PQR","PQS",
		"PREP","PWSCF","QCOUT","RES","RSMI",
		"RXN","SD","SDF","SIESTA","SMI",
		"SMILES","SMY","SY2","T41","TDD",
		"TEXT","THERM","TMOL","TXT","TXYZ",
		"UNIXYZ","VASP","VMOL","XML","XSF",
		"XYZ","YOB"
		};


(* ::Subsection:: *)
(*Format Detection*)



(* ::Subsubsection::Closed:: *)
(*DetectMolFormat*)



(* ::Subsubsubsection::Closed:: *)
(*$ChemFormatsMolFormatPatterns*)



$ChemFormatsMolFormatPatterns=
	<|
		"MolTable"->
			{
				Optional[{_Integer,_Integer},{0,0}],
				{_String,_List,___}..,
				{_Integer,_Integer,___}...
				},
		"SDFTable"->
			{
				{
					Optional[{_Integer,_Integer},{0,0}],
					{_String,_List,___}..,
					{_Integer,_Integer,___}...
					}..
				},
		"ZMatrix"->
			{
				{_String},
				{_String, _Integer, __?NumericQ}...,
				{_Integer,_Integer,___}...
				},
		"SDFRules"->
			{
				Repeated[_->{__List}]
				},
		"MolRules"->
			{
				Repeated[_->_List]
				}
		|>;


(* ::Subsubsubsection::Closed:: *)
(*chemFormatsSMIQ*)



chemFormatsSMIQ[s_]:=
	Length@StringCases[s,"\n"]===0&&
		StringMatchQ[
			ToLowerCase@s,
			Repeated[
				Alternatives@@
					Join[
						Map[
							"["<>#<>"]"&,
							ToLowerCase@
								Select[Keys@$ChemElements, StringQ[#]&&StringLength[#]<3&]
							],
						{".", "="},
						ToLowerCase@{"B", "C", "N", "O", "P", "S", "F", "Cl", "Br", "I"},
						Map[
							"["~~#~~(Repeated["+"|"-"|DigitCharacter])~~"]"&,
							ToLowerCase@
								Select[Keys@$ChemElements, StringQ[#]&&StringLength[#]<3&]
							]
						]
				]~~((Whitespace~~__)|"")
			]


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsDetectMolFormat*)



ChemFormatsDetectMolFormat//Clear


ChemFormatsDetectMolFormat[s_String]:=
	Which[
		StringStartsQ[s, "InChI"],
			"InChI",
		Length@StringCases[s, "M  END"~~Whitespace~~"$$$$"]>0,
			"SDF",
		Length@StringCases[s, "M  END"]===1,
			"MOL",
		StringContainsQ[
			s,
			StartOfLine~~(Whitespace|"")~~(WordCharacter..)~~
				Repeated[Whitespace~~(DigitCharacter..~~"."~~DigitCharacter..)]
			],
			"XYZ",
		StringStartsQ[StringTrim[s], LetterCharacter..~~(Whitespace|"")~~"\n"],
			"ZMatrix",
		chemFormatsSMIQ[StringTrim@s],
			"SMILES",
		True,
			$Failed
		];


ChemFormatsDetectMolFormat[l_List]:=
	l/.
		Append[KeyValueMap[Rule[#2, #]&, $ChemFormatsMolFormatPatterns], _->$Failed]


(* ::Subsection:: *)
(*Conversion Utils*)



(* ::Subsubsection::Closed:: *)
(*MolToZMatrix*)



$ZMatrixInRadians=True


(* ::Subsubsubsection::Closed:: *)
(*zmBits*)



(* ::Text:: *)
(*
	Norm calc
*)



zmNorm=
	Function[{crd1,crd2},
		Norm[crd2-crd1]
		];


(* ::Text:: *)
(*
	Angle calc
*)



zmVAngle=
	Function[{crd1,crd2,crd3},
		VectorAngle[
			crd2-crd3,
			crd2-crd1
			]*If[!TrueQ[$ZMatrixInRadians], 1/Degree, 1]
		];


(* ::Text:: *)
(*
	Dihedral calc
*)



zmDAngle=
	Function[{crd1,crd2,crd3,crd4},
		Module[
			{
				b1=crd2-crd1,
				b2=crd3-crd2,
				b3=crd4-crd3,
				n1,
				n2,
				m1
				},
			n1=Normalize@Cross[b1, b2];
			n2=Normalize@Cross[b2, b3];
			m1=Cross[n1, Normalize[b2]];
			ArcTan[n1.n2, m1.n2]*If[!TrueQ[$ZMatrixInRadians], 1/Degree, 1]
			]
		];


(* ::Subsubsubsection::Closed:: *)
(*zmatrixEntry*)



(* ::Text:: *)
(*
	Compute ZMatrix entry for a given atom, total set of atoms, and atoms for comparison
*)



zmatrixEntry//Clear


zmatrixEntry[
	atom_, 
	atoms_, 
	which:_Integer?Positive|{Repeated[_Integer?Positive, {1, 3}]}|None
	]:=
	Switch[
		which,
		1,
			{First@atom},
		None,
			{First@atom},
		2,
			{(* Atom type *)
				First@atom,
				1,
					(* Calculate norm to first atom *)
					zmNorm[
						Last@atom,
						Last@atoms[[1]]
						]
				},
		{_},
			{(* Atom type *)
				First@atom,
				which[[1]],
					(* Calculate norm to specified atom *)
					zmNorm[
						Last@atom,
						Last@atoms[[which[[1]]]]
						]
				},
		3,
			{(* Atom type *)
				First@atom,
				2,
					(* Calculate norm to second atom *)
					zmNorm[
						Last@atom,
						Last@atoms[[2]]
						],
				1,
					(* Calculate angle to first atom *)
					zmVAngle[
						Last@atom,
						Last@atoms[[2]],
						Last@atoms[[1]]
						]
				},
		{_, _},
			{(* Atom type *)
				First@atom,
				which[[1]],
					(* Calculate norm to first specified atom *)
					zmNorm[
						Last@atom,
						Last@atoms[[which[[1]]]]
						],
				which[[2]],
					(* Calculate angle to second specified atom *)
					zmVAngle[
						Last@atom,
						Last@atoms[[which[[1]]]],
						Last@atoms[[which[[2]]]]
						]
				},
		_Integer,
			{(* Atom type *)
				First@atom,
				(* Use previous atom in ZMatrix *)
				which-1,
					zmNorm[
						Last@atom,
						Last@atoms[[which-1]]
						],
				(* Use 2 ago *)
				which-2,
					zmVAngle[
						Last@atom,
						Last@atoms[[which-1]],
						Last@atoms[[which-2]]
						],
				(* Use 3 ago *)
				which-3,
					zmDAngle[
						Last@atom,
						Last@atoms[[which-1]],
						Last@atoms[[which-2]],
						Last@atoms[[which-3]]
						]
				},
		{_, _, _},
			{(* Atom type *)
				First@atom,
				(* Use previous atom in ZMatrix *)
				which[[1]],
					zmNorm[
						Last@atom,
						Last@atoms[[which[[1]]]]
						],
				(* Use 2 ago *)
				which[[2]],
					zmVAngle[
						Last@atom,
						Last@atoms[[which[[1]]]],
						Last@atoms[[which[[2]]]]
						],
				(* Use 3 ago *)
				which[[3]],
					zmDAngle[
						Last@atom,
						Last@atoms[[which[[1]]]],
						Last@atoms[[which[[2]]]],
						Last@atoms[[which[[3]]]]
						]
				}
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsMolToZMatrix*)



(* ::Text:: *)
(*
	This might be broken as I can\[CloseCurlyQuote]t remember what I was doing with it...
*)



Options[ChemFormatsMolToZMatrix]=
	{
		"ZMatrixOrder"->Automatic,
		"UseRadians"->Automatic
		};
ChemFormatsMolToZMatrix[atoms_List, ops:OptionsPattern[]]:=
	PackageExceptionBlock["ZMatrixFormat"]@
	Block[
		{
			$ZMatrixInRadians=
				Replace[OptionValue["UseRadians"], Except[True|False]->$ZMatrixInRadians]
				},
		Module[
			{
				bonds=Cases[Rest@atoms, {_Integer, _Integer, ___}],
				ats=N@Cases[atoms, {_String, _List, ___}],
				atomOrder,
				atomReordering,
				which
				},
			atomOrder=
				Range[Length@ats];
			which=
				Replace[OptionValue["ZMatrixOrder"],
					{
						w:{{__Integer}..}:>
							SortBy[w, Length],
						Except[{__Integer}]:>
							Range[Length@ats]
						}
					];
			Switch[Length/@which[[{1, -1}]],
				{0, 0},
					If[Intersection[which, atomOrder]=!=atomOrder,
							PackageRaiseException[
								"ZMatrixFormat",
								"ZMatrix ordering `` doesn't contain all atoms",
								"MessageParameters"->{which}
								]
						];
					If[Length[which]=!=Length[atomOrder],
							PackageRaiseException[
								"ZMatrixFormat",
								"ZMatrix ordering `` contains too many atoms",
								"MessageParameters"->{which}
								]
						];
					atomOrder=which;,
				{1, 4},
					atomOrder=
						which[[All, 1]];
					which=
						Prepend[which[[2;;, 2;;]], None],
				{1, 2},
					If[Length@which>2, 
							PackageRaiseException[
								"ZMatrixFormat",
								"ZMatrix can only have one line of length 1 and one of length 2"
								]
						];
					which=Prepend[which, None],
				{1, 3},
					which=Prepend[which, None],
				Except[{0, 0}|{1, 3}],
					PackageRaiseException[
						"ZMatrixFormat",
						"ZMatrix lines must vary in length between 1 and 3"
						];
				];
			ats=ats[[atomOrder]];
			atomReordering=Thread[atomOrder->Range[Length@ats]];
			which=which/.atomReordering;
			bonds=
				SortBy[
					Replace[bonds,
						{a_, b_, e___}:>
							Join[Sort[{a, b}/.atomReordering], {e}],
						1
						],
					#[[;;2]]&
					];
			Join[
				MapThread[
					zmatrixEntry[#, ats, #2]&,
					{
						ats,
						which
						}
					],
				bonds
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*EnumerateZMatrixStrings*)



(* ::Subsubsubsection::Closed:: *)
(*ChemZMatrixStringVarRules*)



ChemZMatrixStringVarRules[s_String]:=
	With[{
		main=
			Map[
				#[[1]]->
					Replace[Rest[#],
						{
							{main_, step_, inc_}:>
								Map[ToString,
									ToExpression[main]+Range[0, ToExpression[step]]*ToExpression[inc]
									]
							}
						]&,
				Map[StringSplit]@StringSplit[s, "\n"]
				]
		},
		Map[Thread[Keys@main->#]&, Tuples[Values@main]]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemUtilsPreCleanZMatrixString*)



ChemUtilsPreCleanZMatrixString[s_String]:=
	Fold[
		#2[#]&,
		s,
		{
			StringTrim, 
			StringDelete[StartOfString~~"!"~~(Except["\n"]...)~~"\n"],
			StringDelete[Longest["!"~~(Except["\n"]...)]],
			StringDelete[StartOfLine~~(Except["\n", Whitespace])],
			StringDelete[(Except["\n", Whitespace])~~EndOfLine],
			StringReplace[Repeated["\n", {2, \[Infinity]}]->"\n\n"]
			}
		];


(* ::Subsubsubsection::Closed:: *)
(*chemFormatsEnumZMatValidVarString*)



chemFormatsEnumZMatValidVarString[s_]:=
	StringTrim[s]==""||StringStartsQ[StringTrim@s, LetterCharacter]


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsEnumerateZMatrixStrings*)



ChemFormatsEnumerateZMatrixStrings[s_String]:=
	Module[
		{
			main=
					ChemUtilsPreCleanZMatrixString[s],
			bits,
			bonds=""
			},
		bits=
			StringTrim/@
				ReplaceAll[
					StringSplit[
						StringSplit[
							main, 
							"\n\n"|("\n"~~Except[WhitespaceCharacter]..~~":")
							],
						"\n"~~n:NumberString:>"JoinMe!"->n,
						2
						],
					{
						{
							{m_String}, 
							{
								vars___String?chemFormatsEnumZMatValidVarString, 
								b1:___String?(Not@*chemFormatsEnumZMatValidVarString),
								"JoinMe!"->n_, 
								b2_String
								}
							}|
						{
							{m_String}, 
							{vars___?chemFormatsEnumZMatValidVarString},
							{b1___String, "JoinMe!"->n_, b2_String}
							}:>
								{
									m,
									vars,
									b1<>"\n"<>n<>b2
									},
						{
							{m_String}, 
							{vars__String?chemFormatsEnumZMatValidVarString}
							}:>
							{m, vars},
						{
							{m_String}, 
							{vars__String?chemFormatsEnumZMatValidVarString}
							}:>
							{m, vars}
						}
					];
		If[Length@bits>1&&StringStartsQ[Last@bits, NumberString],
			bonds=Last@bits;
			bits=Most@bits
			];
		StringTrim@
			Switch[Length@bits,
				1,
					bits<>"\n\n"<>bonds,
				2,
					Map[
						StringReplace[
							bits[[1]], 
							#
							]<>"\n\n"<>bonds&,
						ChemZMatrixStringVarRules@bits[[2]]
						],
				_,
					MapThread[
						StringReplace[
							bits[[1]], 
							Join[##]
							]<>"\n\n"<>bonds&,
						Map[ChemZMatrixStringVarRules, Rest@bits]
						]
				]
		]


(* ::Subsubsection::Closed:: *)
(*ZMatrixToString*)



ChemFormatsZMatrixToString[mat_List]:=
	Module[
		{
			zmValues,
			zmVars,
			zmBonds
			},
		zmValues=Cases[mat, {_String, ___}];
		zmVars=Cases[mat, v:(_->{__}):>v];
		zmBonds=Cases[mat, {_Integer, _Integer, ___}];
		StringReplace[
			StringRiffle[
				{
					ExportString[zmValues, "Table"],
					If[Length@zmVars>0, 
						"Variables:\n"<>
							ExportString[
								Replace[zmVars_, (k_->{v__}):>{k, "->", v}, 1],
								"Table"
								], 
							""
						],
					If[Length@zmBonds>0, ExportString[zmBonds, "Table"], ""]
					},
				"\n"
				],
			"->"->"="
			]//StringTrim
		]


(* ::Subsubsection::Closed:: *)
(*GenerateMolTable*)



Clear[molTableNormed, molTableVAngled, molTableDAngled]


$ZMatrixToMolOrigin=N@{0, 0, 0};
$ZMatrixToMolAxisSystem=N@IdentityMatrix[3];


(* ::Text:: *)
(*Should extend this to generate ZMatrices that aren\[CloseCurlyQuote]t centered at (0, 0, 0) but will do that another day*)



(* ::Subsubsubsection::Closed:: *)
(*molTableNormed*)



(* ::Text:: *)
(*
	First type:
		Simply place it at a normed distance away from a point
*)



molTableNormed[crd1_, norm_]:=
	crd1+norm*$ZMatrixToMolAxisSystem[[1]];


(* ::Subsubsubsection::Closed:: *)
(*molTableVAngled*)



(* ::Text:: *)
(*
	Second type:
		Place the normed version at an angle
*)



molTableVAngled[crd1_, crd2_, norm_, angle_]:=
		crd1+
			RotationMatrix[
				angle*If[$ZMatrixInRadians, 1, Degree],
				With[{c=Cross[crd2-crd1, $ZMatrixToMolAxisSystem[[1]]]},
					If[c=={0, 0, 0}, 
						Cross[crd2-crd1, $ZMatrixToMolAxisSystem[[2]]],
						c
						]
					]
				].(norm*Normalize[crd2-crd1])


(* ::Subsubsubsection::Closed:: *)
(*molTableDAngled*)



(* ::Text:: *)
(*
	Third type:
		Place the normed version at an angle and then do the dihedral transform preserving these
*)



ChemFormatsZMatrixToMol::colin=
	"Coordinates ``, ``, and `` are collinear. \
Z axis will be used for dihedral";


molTableDAngled[crd1_, crd2_, crd3_, norm_, ang_, dihed_]:=
	Module[
		{
			ax21=crd2-crd1, 
			ax31=crd3-crd1,
			normalVec,
			baseVec,
			dihedAxis,
			angle=ang*If[$ZMatrixInRadians, 1, Degree],
			dangle=dihed*If[$ZMatrixInRadians, 1, Degree]
			},
		normalVec=Cross[ax21, ax31];
		If[normalVec=={0, 0, 0},
			Message[ChemFormatsZMatrixToMol::colin, crd1, crd2, crd2];
			normalVec=Cross[ax21, $ZMatrixToMolAxisSystem[[3]]]
			];
		If[normalVec=={0, 0, 0}, normalVec=Cross[ax21, $ZMatrixToMolAxisSystem[[2]]]];
		baseVec=
			RotationMatrix[angle, normalVec].(norm*Normalize[ax21]);
		crd1+
			RotationMatrix[dangle, ax21].baseVec
		];


(* ::Subsubsubsection::Closed:: *)
(*molTableEntry*)



molTableEntry[line_, previousAtoms_]:=
	Switch[{line, Length@previousAtoms},
		{{_String, _?NumericQ, _?NumericQ, _?NumericQ}, _},
			{line[[1]], line[[2;;4]]},
		{_, 0}|{{_String}, _},
			{line[[1]], {0, 0, 0}},
		{{_String, 1, __}, 1}|
			{{_String, _Integer, _?NumericQ}, _Integer?(#>=line[[2]]>0&)},
			{
				line[[1]],
				With[{crd1=previousAtoms[[line[[2]], 2]], n=line[[3]]},
					molTableNormed[crd1, n]
					]
				},
		{{_String, 1|2, _, 1|2, __}, 2}|
			{
				{_String, _Integer, _?NumericQ, _Integer, _?NumericQ}, 
				_Integer?(#>=Max@{line[[2]], line[[4]], 0}&)
				},
			{line[[1]],
				With[
					{
						crd1=previousAtoms[[line[[2]],2]],n=line[[3]],
						crd2=previousAtoms[[line[[4]],2]],a=line[[5]]
						},
					molTableVAngled[
						crd1, crd2,
						n, a
						]
					]
				},
		{
			{_String, _Integer, _?NumericQ, _Integer, _?NumericQ, _Integer, _?NumericQ}, 
			_Integer?(#>=Max@{line[[2]], line[[4]], line[[6]], 0}&)
			},
			{
				line[[1]],
				With[
					{
						crd1=previousAtoms[[line[[2]], 2]],n=line[[3]],
						crd2=previousAtoms[[line[[4]], 2]],a=line[[5]],
						crd3=previousAtoms[[line[[6]], 2]],d=line[[7]]
						},
					molTableDAngled[
						crd1, crd2, crd3,
						n, a, d
						]
					]
				},
		_,
			PackageRaiseException[
				"ZMatrixToMol",
				"Couldn't parse ZMatrix line ``: ``",
				"MessageParameters"->{1+Length@previousAtoms, line}
				]
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsZMatrixToMol*)



Options[ChemFormatsZMatrixToMol]=
	{
		"UseRadians"->Automatic,
		"Origin"->Automatic,
		"AxisSystem"->Automatic
		};
ChemFormatsZMatrixToMol[zmMatrix:{{_String},___List}, ops:OptionsPattern[]]:=
	PackageExceptionBlock["ZMatrixToMol"]@
		Block[
			{
				$ZMatrixInRadians=
					Replace[OptionValue["UseRadians"], Except[True|False]->$ZMatrixInRadians],
				$ZMatrixToMolOrigin=
					Replace[OptionValue["Origin"], 
						Except[{Repeated[_?NumericQ, {3}]}]->$ZMatrixToMolOrigin],
				$ZMatrixToMolAxisSystem=
					Replace[
						OptionValue["AxisSystem"], 
						{
							m:{_, _, _}?SquareMatrixQ:>
								Map[Normalize, m],
							_->$ZMatrixToMolAxisSystem
							}
						]
				},
			Map[
				#+{0, $ZMatrixToMolOrigin}&,
				Fold[
					Append[#, molTableEntry[Take[#2, UpTo[7]], #]]&,
					{},
				 zmMatrix
				 ]
				]
			]


(* ::Subsubsection::Closed:: *)
(*GenerateMolRules*)



ChemFormatsMolToRules[
	molTable:{
		Optional[{_Integer,_Integer},{0,0}],
		atoms:{_String,_List,___}..,
		bonds:{_Integer,_Integer,___}...
		}
	]:=
	{
		"VertexTypes"->{atoms}[[All, 1]],
		"VertexCoordinates"->(100*{atoms}[[All, 2]]),
		"EdgeRules"->
			Rule@@@{bonds}[[All,;;2]],
		"EdgeTypes"->
			Replace[{bonds}[[All,-1]],
				{
					1->"Single",
					2->"Double",
					3->"Triple",
					_->"Single"
					},
				1
				],
		"FormalCharges"->
			Replace[{atoms}, {{_,_,_, c_}:>c, _->0}, 1]
		}


ChemFormatsMolToRules[
	molTables:{
		Repeated@
			{
				Optional[{_Integer,_Integer},{0,0}],
				{_String,_List,___}..,
				{_Integer,_Integer,___}...
				}
		}
	]:=
	Thread[
		{"VertexTypes","VertexCoordinates",
			"EdgeTypes","EdgeRules","FormalCharges"}->
		Thread@Lookup[
			ChemFormatsMolToRules/@molTables,
			{"VertexTypes","VertexCoordinates",
				"EdgeTypes","EdgeRules","FormalCharges"}
			]
		]


ChemFormatsMolToRules[
	zm_List?(ChemFormatsDetectMolFormat[#]==="ZMatrix"&)
	]:=
	ChemFormatsMolToRules@
		ChemFormatsZMatrixToMol[zm]


(* ::Subsubsection::Closed:: *)
(*GenerateMolString*)



ChemFormatsMolToString//Clear


(* ::Subsubsubsection::Closed:: *)
(*iChemFormatsMolToString*)



iChemFormatsMolToString[molData_, "MolRules", target_:"MOL"]:=
	ChemFormatsMolRulesToString[molData, target];
iChemFormatsMolToString[molData_, "ZMatrix"|"MolTable", target_:"MOL"]:=
	iChemFormatsMolToString[
		ChemFormatsMolToRules@molData,
		"MolRules",
		target
		];
iChemFormatsMolToString[molData_, "SDFRules", target_:"SDF"]:=
	ChemFormatsMolRulesToString[molData, target];
iChemFormatsMolToString[molData_, "SDFTable", target_:"SDF"]:=
	iChemFormatsMolToString[
		ChemFormatsMolToRules@molData,
		"SDFRules",
		target
		];


(* ::Subsubsubsection::Closed:: *)
(*MolToString*)



ChemFormatsMolToString[molData_, format_:Automatic]:=
	iChemFormatsMolToString[molData, ChemFormatsDetect[molData], 
		Replace[format, Automatic:>Sequence@@{}]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsMolToStringWrapper*)



ChemFormatsMolToStringWrapper[mainFmt_, target_][data_, ops:OptionsPattern[]]:=
	iChemFormatsMolToString[data, mainFmt, target]


(* ::Subsubsection::Closed:: *)
(*MolRulesToString*)



(* ::Subsubsubsection::Closed:: *)
(*$MolRulesExportPropertiesKeys*)



$MolRulesExportPropertiesKeys=
	<|
		"MOL"->
			{
				"VertexTypes",
				"VertexCoordinates",
				"EdgeRules",
				"EdgeTypes",
				"FormalCharges"
				},
		"SDF":>$MolRulesExportPropertiesKeys["MOL"],
		"MOL2":>
			Join[
				$MolRulesExportPropertiesKeys["MOL"], 
				{"ResidueAtoms", "ResidueCoordinates"}
				],
		"XYZ"->
			{
				"VertexTypes",
				"VertexCoordinates"
				}
		|>


(* ::Subsubsubsection::Closed:: *)
(*ChemFormatsMolRulesToString*)



(* ::Subsubsubsubsection::Closed:: *)
(*MOL*)



ChemFormatsMolRulesToString[rules_?OptionQ, target:"MOL"]:=
	Replace[
		{
			s_String:>
				StringDelete[s, "Created with the Wolfram Language : www.wolfram.com"],
			_:>
				PackageRaiseException["FormatConvert",
					"Failed to export `` to format ``",
					"MessageParameters"->{rules, target}
					]
			}
		]@
		ExportString[
			Normal@
				AssociationThread[
					$MolRulesExportPropertiesKeys[target],
					Lookup[
						rules,
						$MolRulesExportPropertiesKeys[target],
						{}
						]
					],
			target
			];


(* ::Subsubsubsubsection::Closed:: *)
(*SDF*)



ChemFormatsMolRulesToString[rules_?OptionQ, target:"SDF"]:=
	Replace[
		{
			s_String:>
				StringDelete[s, "Created with the Wolfram Language : www.wolfram.com"],
			_:>
				PackageRaiseException["FormatConvert",
					"Failed to export `` to format ``",
					"MessageParameters"->{rules, target}
					]
			}
		]@
		ExportString[
			Normal@
				ReplacePart[#,
					"VertexCoordinates":>
						Replace[#["VertexCoordinates"],
							l:{{__?NumericQ}..}:>{l}
							]
					]&@
					AssociationThread[
						$MolRulesExportPropertiesKeys[target],
						Replace[
							Lookup[
								rules,
								$MolRulesExportPropertiesKeys[target],
								{}
								],
							{
								l:Except[{__List}, _List]:>{l}
								},
							1
							]
						],
			target
			];


(* ::Subsubsubsubsection::Closed:: *)
(*MOL2*)



ChemFormatsMolRulesToString[rules_?OptionQ, target:"MOL2"]:=
	Replace[
		{
			s_String:>
				StringDelete[s, "Created with the Wolfram Language : www.wolfram.com"],
			_:>
				PackageRaiseException["FormatConvert",
					"Failed to export `` to format ``",
					"MessageParameters"->{rules, target}
					]
			}
		]@
		ExportString[
			Normal@
				AssociationThread[
					$MolRulesExportPropertiesKeys[target],
					Replace[
						Lookup[
							Join[
								rules,
								{
									"ResidueAtoms"->
										Replace[
											Lookup[rules, "VertexTypes"],
											{
												l:{__String}:>{{l}},
												l:{{__String}, {__String}}:>{l}
												}
											],
									"ResidueCoordinates"->
										Replace[
											Lookup[rules, "VertexCoordinates"],
											{
												l:{{__?NumericQ}..}:>{{l}},
												l:{{{__?NumericQ}..}..}:>{l}
												}
											]
									}
								],
							$MolRulesExportPropertiesKeys[target],
							{}
							],
						{
							l:Except[{__List}, _List]:>{l}
							},
						1
						]
					],
			target
			];


(* ::Subsubsubsubsection::Closed:: *)
(*XYZ*)



ChemFormatsMolRulesToString[rules_?OptionQ, "XYZ"]:=
	StringDelete[
		"Created with the Wolfram Language : www.wolfram.com"
		]@
		ExportString[
			Normal@
				AssociationThread[
					$MolRulesExportPropertiesKeys["XYZ"],
					Lookup[
						rules,
						$MolRulesExportPropertiesKeys["XYZ"],
						{}
						]
					],
			"XYZ"
			];


(* ::Subsubsection::Closed:: *)
(*ChemFormatsOBConvert*)



ChemFormatsOBConvert//Clear
ChemFormatsOBConvert[data_, form:(_String->_String)|_String, ops:OptionsPattern[]]:=
	PackageExceptionBlock["OpenBabelRun"]@
		OBFormatConvert[
			data, 
			form, 
			ops
			];
ChemFormatsOBConvert[form:(_String->_String)|_String][data_, ops:OptionsPattern[]]:=
	ChemFormatsOBConvert[data, form, ops];


(* ::Subsubsection::Closed:: *)
(*ChemFormatsOBImport*)



ChemFormatsOBImport//Clear
ChemFormatsOBImport[data_String, form:_String, ops:OptionsPattern[]]:=
	PackageExceptionBlock["OpenBabelRun"]@
		ImportString[
			ChemFormatsOBConvert[data, form->"MOL", ops],
			"MolTable"
			];
ChemFormatsOBImport[form:_String][data_String, ops:OptionsPattern[]]:=
	ChemFormatsOBImport[data, form, ops];


End[];



