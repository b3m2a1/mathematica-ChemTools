(* ::Package:: *)

(* Autogenerated Package *)

ImportGaussianJob::usage=
  "Imports data from a Gaussian job";
ImportFormattedCheckpointFile::usage=
  "Imports results from an FChk file";
ImportGaussianLog::usage=
  "Imports data from a log file";
ImportNWChemOut::usage=
  "Imports data from a log file";


Begin["`Private`"];


(* ::Subsection:: *)
(*GaussianJob*)



(* ::Subsubsection::Closed:: *)
(*iGaussianRead*)



(* ::Subsubsubsection::Closed:: *)
(*iGaussianReadLink0*)



iGaussianReadLink0[link0Block_]:=
  Map[
    If[StringContainsQ[#, "="],
      Rule@@StringSplit[#, "=", 2],
      #
      ]&,
    Select[
      StringSplit[StringTrim@link0Block, "%"|Whitespace],
      Not@*StringMatchQ[""|Whitespace]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*iGaussianReadDirectives*)



iGaussianReadDirectives[directives_]:=
  Map[
    If[StringContainsQ[#, "="],
      Rule@@StringSplit[#, "=", 2],
      #
      ]&,
    Select[
      StringSplit[StringTrim@directives, "#"|Whitespace],
      Not@*StringMatchQ[""|Whitespace]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*iGaussianJobReadChargeAndMultiplicity*)



iGaussianJobReadChargeAndMultiplicity[mult_]:=
  Map[
    Which[
      StringMatchQ[#, NumberString], 
        Floor@Internal`StringToDouble[#], 
      StringMatchQ[#, Whitespace|""],
        Nothing,
      True,
        #
      ]&,
    StringTrim@StringSplit[mult, ","|" "]
    ];


(* ::Subsubsubsection::Closed:: *)
(*iGaussianJobReadAtoms*)



iGaussianJobReadAtoms[atoms_]:=
  ImportString[atoms, "Table"];


(* ::Subsubsubsection::Closed:: *)
(*iGaussianJobReadVariables*)



iGaussianJobReadVariables[vars_]:=
  Map[
    Map[
      Which[
        StringMatchQ[#, NumberString], 
          Internal`StringToDouble[#], 
        StringMatchQ[#, Whitespace|""],
          Nothing,
        True,
          #
        ]&,
      StringSplit[StringTrim@#]
      ]&, 
    StringSplit[vars, "\n"]
    ];


(* ::Subsubsubsection::Closed:: *)
(*iGaussianJobReadBonds*)



iGaussianJobReadBonds[bonds_]:=
  ImportString[bonds, "Table"];


(* ::Subsubsubsection::Closed:: *)
(*iGaussianJobPrecleanSpec*)



iGaussianJobPrecleanSpec[s_]:=
  Fold[
    #2[#]&,
    s,
    {
      StringTrim, 
      StringDelete[StartOfString~~"!"~~(Except["\n"]...)~~"\n"],
      StringDelete[Longest["!"~~(Except["\n"]...)]],
      StringDelete[StartOfLine~~(Except["\n", Whitespace])],
      StringDelete[(Except["\n", Whitespace])~~EndOfLine],
      StringReplace[Repeated["\n", {2, \[Infinity]}]->"\n\n"]
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*iGaussianJobReadSystem*)



iGaussianJobReadSystem[systemSpec_]:=
  Module[
    {
      specText=iGaussianJobPrecleanSpec[systemSpec],
      mults,
      atoms,
      vars,
      consts,
      bonds
      },
    {mults, specText}=StringSplit[specText, "\n", 2];
    atoms=
      First@
        StringCases[specText,
          Repeated[
            (Whitespace|"")~~LetterCharacter~~Except["\n"|":"]...~~("\n"|EndOfString)
            ]
          ];
    specText=StringTrim[specText, atoms];
    vars=
      StringCases[specText,
        StartOfLine~~Except["\n"]..~~":"~~(Whitespace|"")~~"\n"~~
          varBlock:
            Repeated[
              (Whitespace|"")~~LetterCharacter~~Except["\n"|":"]..~~("\n"|EndOfString)
              ]:>varBlock
        ];
    Which[
      Length@vars>1, 
        consts=vars[[2]];
        vars=vars[[1]],
      Length@vars==1,
        vars=vars[[1]];
        consts="",
      True,
        vars="";
        consts="";
      ];
    bonds=
      StringTrim@Replace[
        StringCases[
          StringDelete[specText, Alternatives@@vars],
          Repeated[
            (Whitespace|"")~~DigitCharacter~~Except["\n"|":"]..~~("\n"|EndOfString)
            ]
          ],
        {
          {}->"",
          {e_, ___}:>e
          }
        ];
    <|
      "MultiplicityAndCharge"->
        iGaussianJobReadChargeAndMultiplicity@mults,
      "Atoms"->
        iGaussianJobReadAtoms@atoms,
      "Variables"->
        iGaussianJobReadVariables@vars,
      "Constants"->
        iGaussianJobReadVariables@consts,
      "Bonds"->
        iGaussianJobReadBonds@bonds
      |>
    ]


(* ::Subsubsubsection::Closed:: *)
(*iGaussianJobRead*)



iGaussianJobRead[cleanText_]:=
  With[{baseSplit=StringTrim@StringSplit[cleanText, Repeated["\n", {2, \[Infinity]}], 4]},
    <|
      "Header"->
        <|
          "Link0"->iGaussianReadLink0@baseSplit[[1]],
          "Directives"->iGaussianReadDirectives@baseSplit[[2]],
          "Description"->StringTrim@baseSplit[[3]]
          |>,
      "System"->
        iGaussianJobReadSystem@baseSplit[[4]]
      |>
    ];


(* ::Subsubsubsection::Closed:: *)
(*iGaussianJobRead1*)



iGaussianJobRead1[fullText_]:=
  iGaussianJobRead@
    StringTrim@
      StringReplace[Repeated["\n", {3, \[Infinity]}]->"\n\n"]@
        Fold[
          StringDelete,
          fullText,
          {
            (StartOfLine~~"!"~~Except["\n"]...~~"\n"),
            "!"~~Except["\n"]..
            }
          ];


(* ::Subsubsection::Closed:: *)
(*ImportGaussianJob*)



ImportGaussianJob[file:_String?FileExistsQ|_InputStream, ops:OptionsPattern[]]:=
  ImportGaussianJob[ReadString@file];
ImportGaussianJob[str_String?(Not@*FileExistsQ)]:=
  iGaussianJobRead1[str];
ImportGaussianJob[file:_String|_InputStream, "MolTable", ops:OptionsPattern[]]:=
  With[{dats=ImportGaussianJob[file]["System"]},
    ImportString[#, "ZMatrix"]&@
      StringRiffle@
        Join[
          dats["Atoms"],
          {{"Variables:"}},
          dats["Variables"],
          {{""}},
          dats["Bonds"]
          ]
    ];
ImportGaussianJob[file:_String|_InputStream, "Graphics3D", ops:OptionsPattern[]]:=
  ChemGraphics3D[Rest[#], ops]&/@
    ImportGaussianJob[file, "MolTable"];


(* ::Subsection:: *)
(*ELStructLogRead*)



(* ::Subsubsection::Closed:: *)
(*iELStructLogRead*)



$ElStructLogReadListRecords=All;


iELStructLogRead//ClearAll


iELStructLogRead[
  log_InputStream, recSeps_, postProcess_,
  mode:Read:Read
  ]/;!TrueQ[$ELStructLogReadEOF]:=
  With[
    {
      sp=
        Quiet@StreamPosition@log,
      res=
        Read[log, Record, 
          RecordSeparators->recSeps
          ]
      },
    If[res===EndOfFile,
      $ELStructLogReadEOF=
        Quiet@Check[SetStreamPosition[log, sp], True];
      Missing["NotFound"],
      postProcess@res
      ]
    ];
iELStructLogRead[
  log_InputStream, recSeps_, postProcess_,
  mode:ReadList
  ]/;!TrueQ[$ELStructLogReadEOF]:=
  With[
    {
      sp=
        Quiet@StreamPosition@log,
      res=
        ReadList[log, Record, 
          Replace[$ElStructLogReadListRecords,
            Except[_Integer?Positive]:>Sequence@@{}
            ],
          RecordSeparators->recSeps
          ]
      },
    $ELStructLogReadEOF=
      Quiet@Check[SetStreamPosition[log, sp], True];
    postProcess@
      If[IntegerQ@#&&#<0&@$ElStructLogReadListRecords,
        res[[$ElStructLogReadListRecords;;]],
        res
        ]
    ];
iELStructLogRead[
  log_InputStream, recSeps_, postProcess_, 
  ___
  ]/;TrueQ[$ELStructLogReadEOF]=
  Missing["EndOfFile"]


(* ::Subsubsection::Closed:: *)
(*ElStructLogRead*)



ElStructLogRead[logFile:_String?FileExistsQ, key_, fallback_]:=
  With[{or=OpenRead[logFile]},
    Replace[$Failed:>(Close[or];$Failed)]@
      CheckAbort[
        With[{res=fallback[or, key]},
          Close[or];
          res
          ],
        $Failed
        ]
    ];
ElStructLogRead[logString_String, key_, fallback_]:=
  With[{or=StringToStream[logString]},
    Replace[$Failed:>(Close[or];$Failed)]@
      CheckAbort[
        With[{res=fallback[or, key]},
          Close[or];
          res
          ],
        $Failed
        ]
    ];


(* ::Subsection:: *)
(*GaussianLog*)



(* ::Subsubsection::Closed:: *)
(*GaussianLogRead*)



GaussianLogRead//Clear


(* ::Subsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[logFile:_String?FileExistsQ, key_]:=
  ElStructLogRead[logFile, key, GaussianLogRead];
GaussianLogRead[logString_String, key_]:=
  ElStructLogRead[logString, key, GaussianLogRead];


(* ::Subsubsubsection::Closed:: *)
(*InputZMatrix*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadZMatrixBlock[zmat_]:=
  With[{
    bits=
      StringSplit[
        StringSplit[StringTrim@zmat, "\n", 2][[2]],
        "Variables:"
        ]
    },
    Prepend[
      #[[1]]->Rest[#]&/@
        ImportString[
          StringSplit[StringTrim@bits[[2]], "\n"~~(Whitespace|"")~~"\n"][[1]], 
          "Table"
          ],
      Map[
        Which[
          Length@#>5,
            MapAt[
              Quantity[#, "Angstroms"]&, 
              MapAt[Quantity[#, "AngularDegrees"]&, #, {{5}, {7}}],
              {3}
              ],
          Length@#>3,
            MapAt[
              Quantity[#, "Angstroms"]&, 
              MapAt[Quantity[#, "AngularDegrees"]&, #, {5}], 
              {3}
              ],
          Length@#>1,
              MapAt[Quantity[#, "Angstroms"]&, #, {3}],
          True,
            #
          ]&,
        ImportString[
          StringTrim@First@bits,
          "Table"
          ]
        ]
      ]
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "InputZMatrix"]:=
  iELStructLogRead[
    log,
    {{"Z-matrix:"}, {"NAtoms="}},
    gaussianLogReadZMatrixBlock
    ]


(* ::Subsubsubsection::Closed:: *)
(*AtomPositions*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseCartesianCoordinates[s:{__String}]:=
  Map[
    StringCases[
      (
        Whitespace~~which:DigitCharacter..~~
        Whitespace~~what:DigitCharacter..~~
        Whitespace~~type:DigitCharacter..~~
        Whitespace~~x:NumberString~~
        Whitespace~~y:NumberString~~
        Whitespace~~z:NumberString
        ):>
          {
            ChemDataLookup[Floor@Internal`StringToDouble@what, "Symbol"], 
            Internal`StringToDouble/@{x, y, z}
            }
        ],
    s
    ];
gaussianLogReadParseCartesianCoordinates[{}]:=
  {}


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$glrCartCoordStartTag=
" ---------------------------------------------------------------------
 Center     Atomic      Atomic             Coordinates (Angstroms)
 Number     Number       Type             X           Y           Z
 ---------------------------------------------------------------------";
$glrCartCoordEndTag=
" ---------------------------------------------------------------------";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "AtomPositions"]:=
  iELStructLogRead[
    log,
    {
      {$glrCartCoordStartTag},
      {$glrCartCoordEndTag}
      },
    gaussianLogReadParseCartesianCoordinates,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*CartesianCoordinates*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseRawCartesianCoordinates[s:{__String}]:=
  Developer`ToPackedArray@
    Map[
      StringCases[
        (
          Whitespace~~which:DigitCharacter..~~
          Whitespace~~what:DigitCharacter..~~
          Whitespace~~type:DigitCharacter..~~
          Whitespace~~x:NumberString~~
          Whitespace~~y:NumberString~~
          Whitespace~~z:NumberString
          ):>
            Map[ 
              Internal`StringToDouble,
              {x, y, z}
              ]
          ],
      s
      ];
gaussianLogReadParseRawCartesianCoordinates[{}]:=
  {}


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "CartesianCoordinates"]:=
  iELStructLogRead[
    log,
    {
      {$glrCartCoordStartTag},
      {$glrCartCoordEndTag}
      },
    gaussianLogReadParseRawCartesianCoordinates,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*CartesianCoordinateVectors*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseRawCartesianCoordinateVectors[s:{__String}]:=
  Flatten/@gaussianLogReadParseRawCartesianCoordinates[s];
gaussianLogReadParseRawCartesianCoordinateVectors[{}]:=
  {}


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "CartesianCoordinateVectors"]:=
  iELStructLogRead[
    log,
    {
      {$glrCartCoordStartTag},
      {$glrCartCoordEndTag}
      },
    gaussianLogReadParseRawCartesianCoordinateVectors,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrices*)
 


(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseZMatrices[s:{__String}]:=
  Map[
    StringCases[
      {
        what:LetterCharacter..~~Whitespace~~EndOfLine:>
          {what},
        (* norm type *)
        what:LetterCharacter..~~
          Whitespace~~
        n1:DigitCharacter..~~Whitespace~~r:NumberString~~
          "("~~Repeated[_, {6}]~~")"~~EndOfLine:>
          {what, Floor@Internal`StringToDouble@n1, Internal`StringToDouble@r},
        (* norm angle *)
        what:LetterCharacter..~~Whitespace~~
          n1:DigitCharacter..~~Whitespace~~r:NumberString~~
            "("~~Repeated[_, {6}]~~")"~~Whitespace~~
          n2:DigitCharacter..~~Whitespace~~a:NumberString~~
            "("~~Repeated[_, {6}]~~")"~~EndOfLine:>
          {what, 
            Floor@Internal`StringToDouble@n1, Internal`StringToDouble@r,
            Floor@Internal`StringToDouble@n2, Internal`StringToDouble@a
            },
        (* norm angle dihedral *)
        what:LetterCharacter..~~Whitespace~~
          n1:DigitCharacter..~~Whitespace~~r:NumberString~~
            "("~~Repeated[_, {6}]~~")"~~Whitespace~~
          n2:DigitCharacter..~~Whitespace~~a:NumberString~~
            "("~~Repeated[_, {6}]~~")"~~Whitespace~~
          n3:DigitCharacter..~~Whitespace~~d:NumberString:>
          {what, 
            Floor@Internal`StringToDouble@n1, Internal`StringToDouble@r,
            Floor@Internal`StringToDouble@n2, Internal`StringToDouble@a,
            Floor@Internal`StringToDouble@n3, Internal`StringToDouble@d
            }
        }
      ],
    s
    ];
gaussianLogReadParseZMatrices[{}]:=
  {}


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$glrZMatrixStartTag=
"---------------------------------------------------------------------------------------------------
                            Z-MATRIX (ANGSTROMS AND DEGREES)
   CD    Cent   Atom    N1       Length/X        N2       Alpha/Y        N3        Beta/Z          J
 ---------------------------------------------------------------------------------------------------
";


$glrZMatrixEndTag=
" ---------------------------------------------------------------------";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "ZMatrices"]:=
  iELStructLogRead[
    log,
    {
      {$glrZMatrixStartTag}, 
      {$glrZMatrixEndTag}
      },
    gaussianLogReadParseZMatrices,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixCoordinates*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseZMatrixCoordinates[s:{__String}]:=
  Developer`ToPackedArray@Map[
    StringCases[
      {
        what:LetterCharacter..~~Whitespace~~EndOfLine:>
          {0., 0., 0.},
        (* norm type *)
        what:LetterCharacter..~~
          Whitespace~~
        n1:DigitCharacter..~~Whitespace~~r:NumberString~~
          "("~~Repeated[_, {6}]~~")"~~EndOfLine:>
          {Internal`StringToDouble@r, 0., 0.},
        (* norm angle *)
        what:LetterCharacter..~~Whitespace~~
          n1:DigitCharacter..~~Whitespace~~r:NumberString~~
            "("~~Repeated[_, {6}]~~")"~~Whitespace~~
          n2:DigitCharacter..~~Whitespace~~a:NumberString~~
            "("~~Repeated[_, {6}]~~")"~~EndOfLine:>
          Internal`StringToDouble/@{r, a, "0"},
        (* norm angle dihedral *)
        what:LetterCharacter..~~Whitespace~~
          n1:DigitCharacter..~~Whitespace~~r:NumberString~~
            "("~~Repeated[_, {6}]~~")"~~Whitespace~~
          n2:DigitCharacter..~~Whitespace~~a:NumberString~~
            "("~~Repeated[_, {6}]~~")"~~Whitespace~~
          n3:DigitCharacter..~~Whitespace~~d:NumberString:>
          Internal`StringToDouble/@{r, a, d}
        }
      ],
    s
    ];
gaussianLogReadParseZMatrixCoordinates[{}]:=
  {}


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "ZMatrixCoordinates"]:=
  iELStructLogRead[
    log,
    {
      {$glrZMatrixStartTag}, 
      {$glrZMatrixEndTag}
      },
    gaussianLogReadParseZMatrixCoordinates,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixCoordinateVectors*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseZMatrixCoordinateVectors[s:{__String}]:=
  Flatten/@gaussianLogReadParseZMatrixCoordinates[s];
gaussianLogReadParseZMatrixCoordinates[{}]:=
  {}


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "ZMatrixCoordinateVectors"]:=
  iELStructLogRead[
    log,
    {
      {$glrZMatrixStartTag}, 
      {$glrZMatrixEndTag}
      },
    gaussianLogReadParseZMatrixCoordinateVectors,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*MullikenCharges*)



gaussianLogReadParseMullikenCharges[s:{__String}]:=
  Map[
    StringCases[
      (
        which:DigitCharacter..~~
        Whitespace~~what:LetterCharacter..~~
        Whitespace~~charge:NumberString..~~
        (Whitespace|"")~~(EndOfLine|EndOfString)
        ):>
          {
            what, 
            Internal`StringToDouble@charge
            }
        ],
    s
    ];
gaussianLogReadParseMullikenCharges[{}]:=
  {}


GaussianLogRead[log_InputStream, "MullikenCharges"]:=
  iELStructLogRead[
    log,
    {
      {"Mulliken charges:"}, 
      {"Sum of Mulliken charges"}
      },
    gaussianLogReadParseMullikenCharges,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*MultipoleMoments*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseMultipoleMoments//Clear


gaussianLogReadParseMultipoleMoments[s_String, n_:All, tag_:Automatic]:=
  Association@
    Map[
      #[[1]]->
        With[
          {
            vals=
              StringCases[#[[2]], 
                k:("X"|"Y"|"Z")..~~"="~~Whitespace~~val:NumberString:>
                Replace[Characters@k,
                  {
                    "X"->1,
                    "Y"->2,
                    "Z"->3
                    },
                  1
                  ]->Internal`StringToDouble@val
                ]
            },
          With[
            {
              symms=
                SortBy[
                  DeleteDuplicatesBy[
                    Flatten[
                      Thread[
                        Tuples[#[[1]], Length[#[[1]]]]->
                          #[[2]]
                        ]&/@vals
                      ], 
                    First
                    ], 
                  First
                  ]
              },
            If[Mod[Length[symms], 3]==0, 
              If[!NumericQ@#[[1]], RawArray["Real32", #], #]&@
              Nest[
                If[Mod[Length[#], 3]==0,
                  Partition[#, 3],
                  #
                  ]&, 
                Last/@symms,
                Length@vals[[1, 1]]-1
                ]
              ]
            ]
          ]&,
      Partition[
        StringSplit[
          Replace[tag, Automatic:>$glrMultMomStartTag]<>s,
          Longest[
            (StartOfLine|StartOfString)~~
              (type:(WordCharacter|" ")..)~~" moment "~~Except[":"]..~~":"
            ]:>
            StringDelete[type, Whitespace]
          ],
        2
        ][[n]]
      ];
gaussianLogReadParseMultipoleMoments[s:{__String}, n_:All, tag_:Automatic]:=
  gaussianLogReadParseMultipoleMoments[#, n, tag]&/@s;
gaussianLogReadParseMultipoleMoments[__]:=
  {};


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$glrMultMomStartTag="Dipole moment (";
$glrMultMomEndTag=" N-N=";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "MultipoleMoments"]:=
  iELStructLogRead[
    log,
    {
      {$glrMultMomStartTag}, 
      {$glrMultMomEndTag}
      },
    gaussianLogReadParseMultipoleMoments,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*DipoleMoments*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseDipoleMoments[s_]:=
  Developer`ToPackedArray@gaussianLogReadParseMultipoleMoments[s, {1}][[All, 1]]


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$glrDipMomEndTag="Quadrupole moment (";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "DipoleMoments"]:=
  iELStructLogRead[
    log,
    {
      {$glrMultMomStartTag}, 
      {$glrDipMomEndTag}
      },
    gaussianLogReadParseDipoleMoments,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*QuadrupoleMoments*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseQuadrupoleMoments[s_]:=
  Developer`ToPackedArray@
    gaussianLogReadParseMultipoleMoments[s, {1}, $glrDipMomEndTag][[All, 1]]


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$glrQuadMomEndTag="Traceless Quadrupole moment (";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "QuadrupoleMoments"]:=
  iELStructLogRead[
    log,
    {
      {$glrDipMomEndTag}, 
      {$glrQuadMomEndTag}
      },
    gaussianLogReadParseQuadrupoleMoments,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*OctapoleMoments*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseOctapoleMoments[s_]:=
  Developer`ToPackedArray@
    gaussianLogReadParseMultipoleMoments[s, {1}, $glrOctMomStartTag][[All, 1]]


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$glrOctMomStartTag="Octapole Moment (";
$glrOctMomEndTag="Hexadecapole moment (";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "OctapoleMoments"]:=
  iELStructLogRead[
    log,
    {
      {$glrOctMomStartTag}, 
      {$glrOctMomEndTag}
      },
    gaussianLogReadParseOctapoleMoments,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*HexadecapoleMoments*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseHexadecapoleMoments[s_]:=
  Developer`ToPackedArray@
    gaussianLogReadParseMultipoleMoments[s, {1}, $glrOctMomEndTag][[All, 1]]


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "HexadecapoleMoments"]:=
  iELStructLogRead[
    log,
    {
      {$glrOctMomEndTag}, 
      {$glrMultMomEndTag}
      },
    gaussianLogReadParseHexadecapoleMoments,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*HFEnergies*)



gaussianLogReadParseHFEnergies//Clear


gaussianLogReadParseHFEnergies[s_]:=
  Internal`StringToDouble/@StringTrim[s]


GaussianLogRead[log_InputStream, "HartreeFockEnergies"]:=
  iELStructLogRead[
    log,
    {{"SCF Done:  E(RHF) ="}, {"A.U."}},
    gaussianLogReadParseHFEnergies,
    ReadList
    ];


(* ::Subsubsubsection::Closed:: *)
(*MP2Energies*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadParseMP2Energies//Clear


gaussianLogReadParseMP2Energies[s_]:=
  Internal`StringToDouble@
    StringReplacePart[#, "E", {-4, -4}]&/@
    StringTrim[s]


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "MP2Energies"]:=
  iELStructLogRead[
    log,
    {{"EUMP2 ="}, {"\n"}},
    gaussianLogReadParseMP2Energies,
    ReadList
    ];


(* ::Subsubsubsection::Closed:: *)
(*ScanTable*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



gaussianLogReadScanBlock[scan_]:=
  Module[
    {
      splits=
        StringTrim[
          StringSplit[scan, Repeated[Repeated["-"]|"  "]~~Repeated["-"], 2],
          Repeated[Repeated["-"]|"  "]~~Repeated["-"]
          ],
      headers,
      vars,
      energyPos,
      tab
      },
    headers=StringSplit[splits[[1]]];
    energyPos=First@FirstPosition[headers, "SCF"];
    vars=Append[Take[headers, {2, energyPos-1}], "V"];
    tab=
      MapAt[
        #&,
        Partition[
          ReadList[StringToStream@splits[[2]], Number], 
          Length@headers
          ][[All, Append[Range[2, energyPos-1], -1]]],
        {All, -1}
        ];
    vars->Developer`ToPackedArray@tab
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$glrScanBlockStart="scan:";
$glrScanBlockEnd="\n  \n";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



GaussianLogRead[log_InputStream, "ScanTable"]:=
  iELStructLogRead[
    log,
    {{$glrScanBlockStart}, {$glrScanBlockEnd}},
    gaussianLogReadScanBlock
    ];


(* ::Subsubsubsection::Closed:: *)
(*OptimizationScan*)



gaussianLogReadOptScanBlock[scan_]:=
  Transpose@
    KeyValueMap[Thread[Rule[Replace[#, "Eigenvalues"->"Energy"], #2]]&]@
      KeySortBy[Replace[{"Eigenvalues"->1, _->0}]]@
      GroupBy[
        DeleteCases[{}]@
        Flatten[
          ImportString[#, "Table"]&/@
            StringReplace[
              StringSplit[scan, "\n"~~Repeated[Whitespace~~DigitCharacter..]~~"\n"],
              {
                "--"->"  ",
                "-"->" -"
                }
              ],
          1
          ],
        First->Rest,
        Flatten
        ]


GaussianLogRead[log_InputStream, "OptimizationScan"]:=
  iELStructLogRead[
    log,
    {{"Summary of Optimized Potential Surface Scan"}, {"-----------------"}},
    gaussianLogReadOptScanBlock
    ];


(* ::Subsubsubsection::Closed:: *)
(*ComputerTimeElapsed*)



gaussianLogReadTimeElapsedBlock[elapsed_]:=
  With[
    {
      times=Internal`StringToDouble@StringCases[elapsed, NumberString],
      units={"Days", "Hours", "Minutes", "Seconds"}
      },
    With[{mlen=Min[Length/@{times, units}]},
      Quantity[
        MixedMagnitude[Take[times, mlen]],
        MixedUnit[Take[units, mlen]]
        ]
      ]
    ];


GaussianLogRead[log_InputStream, "ComputerTimeElapsed"]:=
  iELStructLogRead[
    log,
    {{"cpu time:"}, {"\n"}},
    gaussianLogReadTimeElapsedBlock
    ];


(* ::Subsubsubsection::Closed:: *)
(*Blurb*)



GaussianLogRead[log_InputStream, "Blurb"]:=
  iELStructLogRead[
    log,
    {{"\n\n\n"}, {"\n Job "}},
    StringTrim
    ]


(* ::Subsubsubsection::Closed:: *)
(*StartDateTime*)



gaussianLogReadParseStartDateTime[s_String]:=
  DateObject@
    First@
      StringSplit[
        Last@
          StringSplit[
            s,
            " at "
            ],
        ","
        ]


GaussianLogRead[log_InputStream, "StartDateTime"]:=
  iELStructLogRead[log,
    {{"Leave Link"}, {"\n (Enter"}},
    gaussianLogReadParseStartDateTime
    ]


(* ::Subsubsubsection::Closed:: *)
(*EndDateTime*)



gaussianLogReadParseEndDateTime[s_String]:=
  DateObject@Last@
    StringSplit[s, " at "]


GaussianLogRead[log_InputStream, "EndDateTime"]:=
  iELStructLogRead[
    log,
    {{"Normal termination of Gaussian"}, {"\n"}},
    gaussianLogReadParseEndDateTime
    ]


(* ::Subsubsection::Closed:: *)
(*ImportGaussianLog*)



(* ::Subsubsubsection::Closed:: *)
(*Keywords*)



$GaussianLogKeywords=
  {
    "StartDateTime",
    "AtomPositions",
    "CartesianCoordinates",
    "CartesianCoordinateVectors",
    "MullikenCharges",
    "MultipoleMoments",
    "DipoleMoments",
    "QuadrupoleMoments",
    "OctapoleMoments",
    "HexadecapoleMoments",
    "HartreeFockEnergies",
    "MP2Energies",
    "InputZMatrix",
    "InputZMatrixVariables",
    "ZMatrices",
    "ZMatrixCoordinates",
    "ZMatrixCoordinateVectors",
    "ScanTable",
    "OptimizationScan",
    "Blurb",
    "ComputerTimeElapsed",
    "EndDateTime"
    };
$GaussianLogAllKeywords=
  {
    "StartDateTime",
    "InputZMatrix",
    "ScanTable",
    "Blurb",
    "ComputerTimeElapsed",
    "EndDateTime"
    };
$GaussianLogExtraKeywords=
  {
    "ScanQuantityArray",
    "HartreeFockEnergyQuantityArray",
    "MP2EnergyQuantityArray",
    "ScanCoordinateQuantityArray",
    "CartesianCoordinateQuantityArray",
    "ZMatrixCoordinateQuantityArray",
    "MultipoleQuantityArray",
    "DipoleQuantityArray",
    "OptimizationScanQuantityArray",
    "OptimizationScanZMatrices"
    };


(* ::Subsubsubsection::Closed:: *)
(*Main*)



ImportGaussianLog//Clear


Options[ImportGaussianLog]=
  {
    "ImportedElements"->Automatic,
    "NumberOfRecords"->Automatic
    };
ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  k_String,
  n_:All
  ]:=
  Block[{$ElStructLogReadEOF, $ElStructLogReadListRecords=n},
    Replace[
      GaussianLogRead[file, k],
      _GaussianLogRead->Missing["UnknownKey", k]
      ]
    ];
ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  k:{__String},
  n_:All
  ]:=
  Block[{$ElStructLogReadEOF, $ElStructLogReadListRecords=n},
    AssociationMap[
      Replace[
        ImportGaussianLog[file, #],
        _GaussianLogRead->Missing["UnknownKey", #]
        ]&,
      SortBy[
        k, 
        Position[$GaussianLogKeywords, #]&
        ]
      ]
    ];
ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  ops:OptionsPattern[]
  ]:=
  ImportGaussianLog[
    file, 
    Replace[
      OptionValue["ImportedElements"],
      {
        Automatic->$GaussianLogAllKeywords,
        All->$GaussianLogKeywords
        }
      ],
    Replace[
      OptionValue["NumberOfRecords"],
      {
        Automatic->$ElStructLogReadListRecords
        }
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*ScanQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "ScanQuantityArray"
  ]:=
  With[{bits=ImportGaussianLog[file, {"InputZMatrix", "ScanTable"}]},
    If[MissingQ@bits["ScanTable"],
      bits["ScanTable"],
      With[{
        keys=First@bits["ScanTable"], 
        vals=Last@bits["ScanTable"], 
        zm=bits[["InputZMatrix", 1]],
        uc=
          QuantityMagnitude@
            UnitConvert[
              Quantity[1, "Hartrees"], 
              "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
              ]
        },
        With[
          {
            types=
              Map[
                Switch[FirstPosition[zm, #], 
                  {_, 3, ___}, "Angstroms",
                  _, "AngularDegrees"
                  ]&,
                Most@keys
                ]
            },
        Map[QuantityVariable, keys]->
          QuantityArray[
            MapAt[uc*#&, vals, {All, -1}], 
            Append[types, "Wavenumbers"]
            ]
          ]
        ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*CartesianCoordinateQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "CartesianCoordinateQuantityArray"
  ]:=
  QuantityArray[
    ImportGaussianLog[file, "CartesianCoordinates"],
    ConstantArray["Angstroms", 3]
    ];


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixCoordinateQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "ZMatrixCoordinateQuantityArray"
  ]:=
  QuantityArray[
    ImportGaussianLog[file, "ZMatrixCoordinates"],
    {"Angstroms", "AngularDegrees", "AngularDegrees"}
    ];


(* ::Subsubsubsection::Closed:: *)
(*HartreeFockEnergyQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "HartreeFockEnergyQuantityArray"
  ]:=
  QuantityArray[
    UnitConvert[
      Quantity[1, "Hartrees"], 
      "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
      ]*Developer`ToPackedArray[ImportGaussianLog[file, "HartreeFockEnergies"]],
    "Wavenumbers"
    ];


(* ::Subsubsubsection::Closed:: *)
(*MP2EnergyQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "MP2EnergyQuantityArray"
  ]:=
  QuantityArray[
    QuantityMagnitude[
      UnitConvert[
        Quantity[1, "Hartrees"], 
        "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
        ]
      ]*Developer`ToPackedArray[ImportGaussianLog[file, "MP2Energies"]],
    "Wavenumbers"
    ];


(* ::Subsubsubsection::Closed:: *)
(*MutipoleQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "MutipoleQuantityArray"
  ]:=
  MapIndexed[
    QuantityArray[
      #,
      ConstantArray[
        Switch[#2[[1, 1]],
          "Dipole",
            "Debyes",
          _?(StringContainsQ["Quadrupole"]),
            "Debyes"*"Angstroms",
          "Octapole",
            "Debyes"*"Angstroms"*"Angstroms",
          "Hexadecapole",
            "Debyes"*"Angstroms"*"Angstroms"*"Angstroms"
          ],
        3
        ]
      ]&,
    ImportGaussianLog[file, "MutipoleMoments"]
    ]


(* ::Subsubsubsection::Closed:: *)
(*DipoleQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "DipoleQuantityArray"
  ]:=
  QuantityArray[
    ImportGaussianLog[file, "DipoleMoments"],
    ConstantArray["Debyes", 3]
    ];


(* ::Subsubsubsection::Closed:: *)
(*ScanDipoleSurface*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "ScanDipoleSurface"
  ]:=
  Module[
    {
      bits=
        ImportGaussianLog[file, 
          {"DipoleMoments", "InputZMatrix", "ScanTable"}
          ],
      keys,
      coords,
      zm,
      dips,
      types
      },
    If[MissingQ@bits["ScanTable"],
      bits["ScanTable"],
      keys=First@bits["ScanTable"];
      coords=Last@bits["ScanTable"];
      dips=bits["DipoleMoments"];
      zm=bits[["InputZMatrix", 1]];
      types=
        Map[
          Switch[FirstPosition[zm, #], 
            {_, 3, ___}, "Angstroms",
            _, "AngularDegrees"
            ]&,
          Most@keys
          ];
      Map[QuantityVariable, Join[keys, {"\[Mu]x", "\[Mu]y", "\[Mu]z"}]]->
        QuantityArray[
          MapThread[
            Join[#[[;;-2]], #2]&,
            {
              coords,
              dips
              }
            ],
          Join[types, ConstantArray["Debyes", 3]]
          ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*QuadrupoleQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "QuadrupoleQuantityArray"
  ]:=
  QuantityArray[
    ImportGaussianLog[file, "QuadrupoleMoments"],
    ConstantArray["Debyes"*"Angstroms", 3]
    ];


(* ::Subsubsubsection::Closed:: *)
(*OctapoleQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "OctapoleQuantityArray"
  ]:=
  QuantityArray[
    ImportGaussianLog[file, "OctapoleQuantityArray"],
    ConstantArray["Debyes"*"Angstroms"*"Angstroms", 3]
    ];


(* ::Subsubsubsection::Closed:: *)
(*OptimizationScanQuantityArray*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "OptimizationScanQuantityArray"
  ]:=
  With[{bits=ImportGaussianLog[file, {"InputZMatrix", "OptimizationScan"}]},
    If[MissingQ@bits[[2]],
      bits[[2]],
      With[{
        keys=Keys@First@bits[[2]], 
        vals=Values@bits[[2]], 
        zm=bits[[1, 1]],
        uc=
          QuantityMagnitude@
            UnitConvert[
              Quantity[1, "Hartrees"], 
              "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
              ]
        },
        With[
          {
            types=
              Map[
                Switch[FirstPosition[zm, #], 
                  {_, 3, ___}, "Angstroms",
                  _, "AngularDegrees"
                  ]&,
                Most@keys
                ]
            },
        Map[QuantityVariable, keys]->
          QuantityArray[
            MapAt[uc*#&, vals, {All, -1}], 
            Append[types, "Wavenumbers"]
            ]
          ]
        ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*OptimizationScanZMatrices*)



ImportGaussianLog[
  file:_String?FileExistsQ|_InputStream,
  "OptimizationScanZMatrices"
  ]:=
  With[{bits=ImportGaussianLog[file, {"InputZMatrix", "OptimizationScan"}]},
    If[MissingQ@bits[[2]],
      bits[[2]],
      With[{
        keys=Keys@First@bits[[2]], 
        vals=Values@bits[[2]], 
        zm=bits[[1, 1]],
        uc=
          QuantityMagnitude@
            UnitConvert[
              Quantity[1, "Hartrees"], 
              "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
              ]
        },
        With[
          {
            types=
              Map[
                Switch[FirstPosition[zm, #], 
                  {_, 3, ___}, "Angstroms",
                  _, "AngularDegrees"
                  ]&,
                Most@keys
                ]
            },
        ReplaceAll[zm/.q_Quantity:>QuantityMagnitude[q],
          Thread[keys->#]&/@
            QuantityMagnitude@
              QuantityArray[
                MapAt[uc*#&, vals, {All, -1}], 
                Append[types, "Wavenumbers"]
                ]
            ]
          ]
        ]
      ]
    ]


(* ::Subsection:: *)
(*NWChemLog*)



(* ::Subsubsection::Closed:: *)
(*NWChemLogRead*)



(* ::Subsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[logFile:_String?FileExistsQ, key_]:=
  ElStructLogRead[logFile, key, NWChemLogRead];
NWChemLogRead[logString_String, key_]:=
  ElStructLogRead[logString, key, NWChemLogRead];


(* ::Subsubsubsection::Closed:: *)
(*InputZMatrix*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



nwLogReadZMatrixBlock[zmat_]:=
  With[{
    bits=
      StringSplit[
        StringSplit[StringTrim@zmat, "\n", 2][[2]],
        "Variables:"
        ]
    },
    Prepend[
      #[[1]]->Rest[#]&/@
        ImportString[
          StringSplit[StringTrim@bits[[2]], "\n"~~(Whitespace|"")~~"\n"][[1]], 
          "Table"
          ],
      Map[
        Which[
          Length@#>5,
            MapAt[
              Quantity[#, "Angstroms"]&, 
              MapAt[Quantity[#, "AngularDegrees"]&, #, {{5}, {7}}],
              {3}
              ],
          Length@#>3,
            MapAt[
              Quantity[#, "Angstroms"]&, 
              MapAt[Quantity[#, "AngularDegrees"]&, #, {5}], 
              {3}
              ],
          Length@#>1,
              MapAt[Quantity[#, "Angstroms"]&, #, {3}],
          True,
            #
          ]&,
        ImportString[
          StringTrim@First@bits,
          "Table"
          ]
        ]
      ]
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "InputZMatrix"]:=
  iELStructLogRead[
    log,
    {{"Z-matrix:"}, {"NAtoms="}},
    nwLogReadZMatrixBlock
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrix*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



nwLogReadZMatsBlock//Clear


nwLogReadZMatsBlock[dipz_, 
  bits:_:{"Names", "Indices", "Values"}, 
  moo:_:{"Stretches", "Bends", "Torsions"}
  ]:=
  Module[
    {
      stretches={},
      bends={},
      torsions={},
      zmats,
      inds,
      fns,
      modes=moo
      },
    If[MemberQ[modes, "Stretches"],
      stretches=
        StringCases[dipz,
          {
            "Stretch    "~~name:Repeated[_, {8}]~~"  "~~
              I:Repeated[_, {5}]~~" "~~
              J:Repeated[_, {5}]~~" "~~
              Repeated[_, {17}]~~" "~~
              v:Repeated[_, {10}]:>
                {name, {I, J}, v}
                }
            ]
      ];
    If[MemberQ[modes, "Bends"],
      bends=
        StringCases[dipz,
          {
            "Bend       "~~name:Repeated[_, {8}]~~"  "~~
              I:Repeated[_, {5}]~~" "~~
              J:Repeated[_, {5}]~~" "~~
              K:Repeated[_, {5}]~~" "~~
              Repeated[_, {11}]~~" "~~
              v:Repeated[_, {10}]:>
                {name, {I, J, K}, v}
            }
          ]
      ];
    If[MemberQ[modes, "Torsions"],
     torsions=
        StringCases[dipz,
          {
            "Torsion    "~~name:Repeated[_, {8}]~~"  "~~
              I:Repeated[_, {5}]~~" "~~
              J:Repeated[_, {5}]~~" "~~
              K:Repeated[_, {5}]~~" "~~
              L:Repeated[_, {5}]~~" "~~
              Repeated[_, {5}]~~" "~~
              v:Repeated[_, {10}]:>
                {name, {I, J, K, L}, v}
            }
          ]
      ];
    MapThread[
        If[Length@Flatten@#===0, 
          modes=DeleteCases[modes, #2];
          Replace[#3, Hold[s_]:>Set[s, Nothing]], 
          #
          ]&,
        {
          {stretches, bends, torsions},
          {"Stretches", "Bends", "Torsions"},
          Thread@Hold@{stretches, bends, torsions}
          }
        ];
    inds=Replace[bits, {"Names"->1, "Indices"->2, "Values"->3}, 1];
    fns={
      Map[If[#=="        ", None, StringTrim@#]&],
      Floor@*Map[Map[Internal`StringToDouble]],
      Map[Internal`StringToDouble]
      };
    zmats=Map[Transpose, 
      Thread[{stretches, bends, torsions}[[All, All, All, inds]]], 
      {2}];
    zmats=
      Fold[
        Developer`ToPackedArray@
          MapAt[#2[[1]], #, Thread[{Range[Length@modes], #2[[2]]}]]&,
        #,
        Thread[
          {
            fns[[inds]],
            Range[Length@inds]
            }
          ]
        ]&/@zmats;
    Which[
      Length@bits==1&&Length@modes==1,
        zmats[[All, 1, 1]],
      Length@bits==1,
        zmats[[All, All, 1]],
      Length@modes==1,
        zmats[[All, 1]],
      True,
        zmats
        ]
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$nwzmatstart="Type          Name      I     J     K     L     M      Value
      ----------- --------  ----- ----- ----- ----- ----- ----------";


$nwzmatend=" 
 
";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrices"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixNames*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixNames"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Names"}, {"Stretches", "Bends", "Torsions"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixIndices*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixIndices"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Indices"}, {"Stretches", "Bends", "Torsions"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixValues*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixValues"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Values"}, {"Stretches", "Bends", "Torsions"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixStretches*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixStretches"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Names", "Indices", "Values"}, {"Stretches"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixBends*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixBends"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Names", "Indices", "Values"}, {"Bends"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixTorsions*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixTorsions"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Names", "Indices", "Values"}, {"Torsions"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixStretchNames*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixStretchNames"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Names"}, {"Stretches"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixBendNames*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixBendNames"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Names"}, {"Bends"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixTorsionNames*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixTorsionNames"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Names"}, {"Torsions"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixStretchIndices*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixStretchIndices"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Indices"}, {"Stretches"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixBendIndices*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixBendIndices"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Indices"}, {"Bends"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixTorsionIndices*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixTorsionIndices"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Indices"}, {"Torsions"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixStretchValues*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixStretchValues"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Values"}, {"Stretches"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixBendValues*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixBendValues"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Values"}, {"Bends"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixTorsionValues*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "ZMatrixTorsionValues"]:=
  iELStructLogRead[
    log,
    {{$nwzmatstart}, {$nwzmatend}},
    nwLogReadZMatsBlock[#, {"Values"}, {"Torsions"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*XYZTables*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



nwLogReadCartBlock[dipz_, bits_:{"Elements", "Coordinates"}]:=
  Module[
    {
      dats,
      els,
      coords
      },
    dats=
      StringCases[dipz,
        {
          StartOfLine~~" "~~el:(LetterCharacter|DigitCharacter)..~~Whitespace~~
            x:Repeated[_, {11}]~~"    "~~
            y:Repeated[_, {11}]~~"    "~~
            z:Repeated[_, {11}]:>
              {el, Internal`StringToDouble/@{x, y, z}}
          }
        ];
    bits;
    Which[
      AllTrue[{"Elements", "Coordinates"}, MemberQ[bits, #]&],
        dats,
      MemberQ[bits, "Elements"],
        dats[[All, All, 1]],
      True,
        Developer`ToPackedArray@dats[[All, All, 2]]
      ]
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$nwcartkeystart=
  "XYZ format geometry
            -------------------";


$nwcartkeyend=
  "
 
 ==============================================================================";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "XYZTables"]:=
  iELStructLogRead[
    log,
    {{$nwcartkeystart}, {$nwcartkeyend}},
    nwLogReadCartBlock,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*CartesianCoordinates*)



NWChemLogRead[log_InputStream, "CartesianCoordinates"]:=
  iELStructLogRead[
    log,
    {{$nwcartkeystart}, {$nwcartkeyend}},
    nwLogReadCartBlock[#, {"Coordinates"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*SCFBlock*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



$nwenergyNameMap=<|
  "SCF energy"->"SCFEnergy",
  "MP2 energy"->"MP2Energy",
  "DFT energy"->"DFTEnergy",
  "One electron energy"->"OneElectronEnergy",
  "Coulomb energy"->"CoulombEnergy",
  "Exchange-Corr. energy"->"ExchangeCorrelationEnergy",
  "Nuclear repulsion energy"->"NuclearRepusionEnergy",
  "Dispersion correction"->"DispersionCorrection",
  "Numeric. integr. density"->"IntegratedDensity"
  |>;


nwLogReadSCFBlock[blahkz_, 
  spat_:Automatic
  ]:=
  Module[
    {
      bitz,
      pat=Replace[spat, Automatic:>Alternatives@@Keys[$nwenergyNameMap]]
      },
    Association/@
      StringCases[blahkz,
        p:pat~~" ="~~Whitespace~~v:NumberString:>
          (Lookup[$nwenergyNameMap, p, p]->Internal`StringToDouble[v])
        ]
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$nwscfblockstart=
  "convergence    iter        energy";


$nwscfblockend=
  "Total iterative time =";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "SCFBlock"]:=
  iELStructLogRead[
    log,
    {{$nwscfblockstart}, {$nwscfblockend}},
    nwLogReadSCFBlock,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*Energies*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "Energies"]:=
  iELStructLogRead[
    log,
    {{$nwscfblockstart}, {$nwscfblockend}},
    nwLogReadSCFBlock[#, Alternatives@@Keys@$nwenergyNameMap[[;;3]]]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*DFTEnergy*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "DFTEnergy"]:=
  iELStructLogRead[
    log,
    {{$nwscfblockstart}, {$nwscfblockend}},
    nwLogReadSCFBlock[#, 
      Alternatives@@Keys@Select[$nwenergyNameMap, #=="DFTEnergy"&]
      ]~Lookup~"DFTEnergy"&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*MP2Energy*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "MP2Energy"]:=
  iELStructLogRead[
    log,
    {{$nwscfblockstart}, {$nwscfblockend}},
    nwLogReadSCFBlock[#, 
      Alternatives@@Keys@Select[$nwenergyNameMap, #=="MP2Energy"&]
      ]~Lookup~"MP2Energy"&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*SCFEnergy*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "SCFEnergy"]:=
  iELStructLogRead[
    log,
    {{$nwscfblockstart}, {$nwscfblockend}},
    nwLogReadSCFBlock[#, 
      Alternatives@@Keys@Select[$nwenergyNameMap, #=="SCFEnergy"&]
      ]~Lookup~"SCFEnergy"&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*Elements*)



NWChemLogRead[log_InputStream, "ElementTables"]:=
  iELStructLogRead[
    log,
    {{$nwcartkeystart}, {$nwcartkeyend}},
    nwLogReadCartBlock[#, {"Elements"}]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*DipoleMoment*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



(*"   Dipole moment        "" Debye(s)
             DMX       "" DMXEFC        ""
             DMY       "" DMYEFC        ""
             DMZ       "" DMZEFC        ""*)


nwLogReadDipoleBlock[dipz_, parts_:{"Centers", "DipoleVectors", "EFCVectors"}]:=
  Module[
    {
      centers,
      dipoles,
      total
      },
    centers=
      First/@StringCases[dipz,
        {
          "X =      "~~x:Repeated[_, {10}]~~
            " Y =      "~~y:Repeated[_, {10}]~~
            " Z =      "~~z:Repeated[_, {10}]:>
              {x, y, z}
          },
        1
        ];
    dipoles=
      First/@StringCases[dipz,
        "Dipole moment       "~~n:Repeated[_, {13}]~~" Debye(s)
             DMX       "~~x:Repeated[_, {13}]~~
             " DMXEFC       "~~xef:Repeated[_, {13}]~~"
             DMY       "~~y:Repeated[_, {13}]~~
             " DMYEFC       "~~yef:Repeated[_, {13}]~~"
             DMZ       "~~z:Repeated[_, {13}]~~
             " DMZEFC       "~~zef:Repeated[_, {13}]:>
             {
               {x, y, z},
               {xef, yef, zef}
               },
      1
      ];
    Developer`ToPackedArray@{
      If[parts~MemberQ~"Centers",
        Map[Internal`StringToDouble, #]&/@centers,
        Nothing
        ],
      If[parts~MemberQ~"DipoleVectors",
        Map[Internal`StringToDouble, #[[1]]]&/@dipoles,
        Nothing
        ],
      If[parts~MemberQ~"EFCVectors",
        Map[Internal`StringToDouble, #[[2]]]&/@dipoles,
        Nothing
        ]
      }
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$nwdipolekeystart=
  "-------------
          Dipole Moment
          -------------";


$nwdipolekeyend=
  "1 a.u. =";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "DipoleMoments"]:=
  iELStructLogRead[
    log,
    {{$nwdipolekeystart}, {$nwdipolekeyend}},
    nwLogReadDipoleBlock,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*CSSDDipoleMoment*)



(* ::Subsubsubsubsection::Closed:: *)
(*Parse*)



(*"   Dipole moment        "" Debye(s)
             DMX       "" DMXEFC        ""
             DMY       "" DMYEFC        ""
             DMZ       "" DMZEFC        ""*)


nwLogReadDipoleBlock[dipz_, parts_:{"Centers", "DipoleVectors", "EFCVectors"}]:=
  Module[
    {
      centers,
      dipoles,
      total
      },
    centers=
      First/@StringCases[dipz,
        {
          "X =      "~~x:Repeated[_, {10}]~~
            " Y =      "~~y:Repeated[_, {10}]~~
            " Z =      "~~z:Repeated[_, {10}]:>
              {x, y, z}
          },
        1
        ];
    dipoles=
      First/@StringCases[dipz,
        "Dipole moment       "~~n:Repeated[_, {13}]~~" Debye(s)
             DMX       "~~x:Repeated[_, {13}]~~
             " DMXEFC       "~~xef:Repeated[_, {13}]~~"
             DMY       "~~y:Repeated[_, {13}]~~
             " DMYEFC       "~~yef:Repeated[_, {13}]~~"
             DMZ       "~~z:Repeated[_, {13}]~~
             " DMZEFC       "~~zef:Repeated[_, {13}]:>
             {
               {x, y, z},
               {xef, yef, zef}
               },
      1
      ];
    Developer`ToPackedArray@{
      If[parts~MemberQ~"Centers",
        Map[Internal`StringToDouble, #]&/@centers,
        Nothing
        ],
      If[parts~MemberQ~"DipoleVectors",
        Map[Internal`StringToDouble, #[[1]]]&/@dipoles,
        Nothing
        ],
      If[parts~MemberQ~"EFCVectors",
        Map[Internal`StringToDouble, #[[2]]]&/@dipoles,
        Nothing
        ]
      }
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Tags*)



$nwccsddipolekeystart=
  " CCSD dipole moments / hartree & Debye
 ------------------------------------";


$nwccsddipolekeyend=
  "Total";


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "CCSDDipoleMoments"]:=
  iELStructLogRead[
    log,
    {{$nwccsddipolekeystart}, {$nwccsddipolekeyend}},
    nwLogReadDipoleBlock,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*DipoleCenters*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "DipoleCenters"]:=
  iELStructLogRead[
    log,
    {{$nwdipolekeystart}, {$nwdipolekeyend}},
    nwLogReadDipoleBlock[#, {"Centers"}][[1]]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*DipoleVectors*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "DipoleVectors"]:=
  iELStructLogRead[
    log,
    {{$nwdipolekeystart}, {$nwdipolekeyend}},
    nwLogReadDipoleBlock[#, {"DipoleVectors"}][[1]]&,
    ReadList
    ]


(* ::Subsubsubsection::Closed:: *)
(*DipoleEFCs*)



(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



NWChemLogRead[log_InputStream, "DipoleEFCs"]:=
  iELStructLogRead[
    log,
    {{$nwdipolekeystart}, {$nwdipolekeyend}},
    nwLogReadDipoleBlock[#, {"EFCVectors"}][[1]]&,
    ReadList
    ]


(* ::Subsubsection::Closed:: *)
(*ImportNWChemOut*)



(* ::Subsubsubsection::Closed:: *)
(*Keywords*)



$NWChemLogKeywords=
  {
    "StartDateTime",
    "AtomPositions",
    "CartesianCoordinates",
    "CartesianCoordinateVectors",
    "MullikenCharges",
    "MultipoleMoments",
    "DipoleMoments",
    "QuadrupoleMoments",
    "OctapoleMoments",
    "HexadecapoleMoments",
    "HartreeFockEnergies",
    "MP2Energies",
    "InputZMatrix",
    "InputZMatrixVariables",
    "ZMatrices",
    "ZMatrixCoordinates",
    "ZMatrixCoordinateVectors",
    "ScanTable",
    "OptimizationScan",
    "Blurb",
    "ComputerTimeElapsed",
    "EndDateTime"
    };
$NWChemLogAllKeywords=
  {
    "StartDateTime",
    "InputZMatrix",
    "ScanTable",
    "Blurb",
    "ComputerTimeElapsed",
    "EndDateTime"
    };
$NWChemLogExtraKeywords=
  {
    "ScanQuantityArray",
    "HartreeFockEnergyQuantityArray",
    "MP2EnergyQuantityArray",
    "ScanCoordinateQuantityArray",
    "CartesianCoordinateQuantityArray",
    "ZMatrixCoordinateQuantityArray",
    "MultipoleQuantityArray",
    "DipoleQuantityArray",
    "OptimizationScanQuantityArray",
    "OptimizationScanZMatrices"
    };


(* ::Subsubsubsection::Closed:: *)
(*Main*)



ImportNWChemOut//Clear


Options[ImportNWChemOut]=
  {
    "ImportedElements"->All,
    "NumberOfRecords"->All
    };
ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  k_String,
  n_:All
  ]:=
  Block[{$ElStructLogReadEOF, $ElStructLogReadListRecords=n},
    Replace[
      NWChemLogRead[file, k],
      _NWChemLogRead->Missing["UnknownKey", k]
      ]
    ];
ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  k:{__String},
  n_:All
  ]:=
  Block[{$ElStructLogReadEOF, $ElStructLogReadListRecords=n},
    AssociationMap[
      Replace[
        ImportNWChemOut[file, #],
        _NWChemLogRead->Missing["UnknownKey", #]
        ]&,
      SortBy[
        k, 
        Position[$NWChemLogKeywords, #]&
        ]
      ]
    ];
ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  ops:OptionsPattern[]
  ]:=
  ImportNWChemOut[
    file, 
    Replace[
      OptionValue["ImportedElements"],
      {
        Automatic->$NWChemLogAllKeywords,
        All->$NWChemLogKeywords
        }
      ],
    Replace[
      OptionValue["NumberOfRecords"],
      {
        Automatic->$ElStructLogReadListRecords
        }
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*ScanQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "ScanQuantityArray"
  ]:=
  With[{bits=ImportNWChemOut[file, {"InputZMatrix", "ScanTable"}]},
    If[MissingQ@bits["ScanTable"],
      bits["ScanTable"],
      With[{
        keys=First@bits["ScanTable"], 
        vals=Last@bits["ScanTable"], 
        zm=bits[["InputZMatrix", 1]],
        uc=
          QuantityMagnitude@
            UnitConvert[
              Quantity[1, "Hartrees"], 
              "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
              ]
        },
        With[
          {
            types=
              Map[
                Switch[FirstPosition[zm, #], 
                  {_, 3, ___}, "Angstroms",
                  _, "AngularDegrees"
                  ]&,
                Most@keys
                ]
            },
        Map[QuantityVariable, keys]->
          QuantityArray[
            MapAt[uc*#&, vals, {All, -1}], 
            Append[types, "Wavenumbers"]
            ]
          ]
        ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*CartesianCoordinateQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "CartesianCoordinateQuantityArray"
  ]:=
  QuantityArray[
    ImportNWChemOut[file, "CartesianCoordinates"],
    ConstantArray["Angstroms", 3]
    ];


(* ::Subsubsubsection::Closed:: *)
(*ZMatrixCoordinateQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "ZMatrixCoordinateQuantityArray"
  ]:=
  QuantityArray[
    ImportNWChemOut[file, "ZMatrixCoordinates"],
    {"Angstroms", "AngularDegrees", "AngularDegrees"}
    ];


(* ::Subsubsubsection::Closed:: *)
(*HartreeFockEnergyQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "HartreeFockEnergyQuantityArray"
  ]:=
  QuantityArray[
    UnitConvert[
      Quantity[1, "Hartrees"], 
      "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
      ]*Developer`ToPackedArray[ImportNWChemOut[file, "HartreeFockEnergies"]],
    "Wavenumbers"
    ];


(* ::Subsubsubsection::Closed:: *)
(*MP2EnergyQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "MP2EnergyQuantityArray"
  ]:=
  QuantityArray[
    QuantityMagnitude[
      UnitConvert[
        Quantity[1, "Hartrees"], 
        "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
        ]
      ]*Developer`ToPackedArray[ImportNWChemOut[file, "MP2Energies"]],
    "Wavenumbers"
    ];


(* ::Subsubsubsection::Closed:: *)
(*MutipoleQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "MutipoleQuantityArray"
  ]:=
  MapIndexed[
    QuantityArray[
      #,
      ConstantArray[
        Switch[#2[[1, 1]],
          "Dipole",
            "Debyes",
          _?(StringContainsQ["Quadrupole"]),
            "Debyes"*"Angstroms",
          "Octapole",
            "Debyes"*"Angstroms"*"Angstroms",
          "Hexadecapole",
            "Debyes"*"Angstroms"*"Angstroms"*"Angstroms"
          ],
        3
        ]
      ]&,
    ImportNWChemOut[file, "MutipoleMoments"]
    ]


(* ::Subsubsubsection::Closed:: *)
(*DipoleQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "DipoleQuantityArray"
  ]:=
  QuantityArray[
    ImportNWChemOut[file, "DipoleMoments"],
    ConstantArray["Debyes", 3]
    ];


(* ::Subsubsubsection::Closed:: *)
(*ScanDipoleSurface*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "ScanDipoleSurface"
  ]:=
  Module[
    {
      bits=
        ImportNWChemOut[file, 
          {"DipoleMoments", "InputZMatrix", "ScanTable"}
          ],
      keys,
      coords,
      zm,
      dips,
      types
      },
    If[MissingQ@bits["ScanTable"],
      bits["ScanTable"],
      keys=First@bits["ScanTable"];
      coords=Last@bits["ScanTable"];
      dips=bits["DipoleMoments"];
      zm=bits[["InputZMatrix", 1]];
      types=
        Map[
          Switch[FirstPosition[zm, #], 
            {_, 3, ___}, "Angstroms",
            _, "AngularDegrees"
            ]&,
          Most@keys
          ];
      Map[QuantityVariable, Join[keys, {"\[Mu]x", "\[Mu]y", "\[Mu]z"}]]->
        QuantityArray[
          MapThread[
            Join[#[[;;-2]], #2]&,
            {
              coords,
              dips
              }
            ],
          Join[types, ConstantArray["Debyes", 3]]
          ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*QuadrupoleQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "QuadrupoleQuantityArray"
  ]:=
  QuantityArray[
    ImportNWChemOut[file, "QuadrupoleMoments"],
    ConstantArray["Debyes"*"Angstroms", 3]
    ];


(* ::Subsubsubsection::Closed:: *)
(*OctapoleQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "OctapoleQuantityArray"
  ]:=
  QuantityArray[
    ImportNWChemOut[file, "OctapoleQuantityArray"],
    ConstantArray["Debyes"*"Angstroms"*"Angstroms", 3]
    ];


(* ::Subsubsubsection::Closed:: *)
(*OptimizationScanQuantityArray*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "OptimizationScanQuantityArray"
  ]:=
  With[{bits=ImportNWChemOut[file, {"InputZMatrix", "OptimizationScan"}]},
    If[MissingQ@bits[[2]],
      bits[[2]],
      With[{
        keys=Keys@First@bits[[2]], 
        vals=Values@bits[[2]], 
        zm=bits[[1, 1]],
        uc=
          QuantityMagnitude@
            UnitConvert[
              Quantity[1, "Hartrees"], 
              "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
              ]
        },
        With[
          {
            types=
              Map[
                Switch[FirstPosition[zm, #], 
                  {_, 3, ___}, "Angstroms",
                  _, "AngularDegrees"
                  ]&,
                Most@keys
                ]
            },
        Map[QuantityVariable, keys]->
          QuantityArray[
            MapAt[uc*#&, vals, {All, -1}], 
            Append[types, "Wavenumbers"]
            ]
          ]
        ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*OptimizationScanZMatrices*)



ImportNWChemOut[
  file:_String?FileExistsQ|_InputStream,
  "OptimizationScanZMatrices"
  ]:=
  With[{bits=ImportNWChemOut[file, {"InputZMatrix", "OptimizationScan"}]},
    If[MissingQ@bits[[2]],
      bits[[2]],
      With[{
        keys=Keys@First@bits[[2]], 
        vals=Values@bits[[2]], 
        zm=bits[[1, 1]],
        uc=
          QuantityMagnitude@
            UnitConvert[
              Quantity[1, "Hartrees"], 
              "Wavenumbers"*"PlanckConstant"*"SpeedOfLight"
              ]
        },
        With[
          {
            types=
              Map[
                Switch[FirstPosition[zm, #], 
                  {_, 3, ___}, "Angstroms",
                  _, "AngularDegrees"
                  ]&,
                Most@keys
                ]
            },
        ReplaceAll[zm/.q_Quantity:>QuantityMagnitude[q],
          Thread[keys->#]&/@
            QuantityMagnitude@
              QuantityArray[
                MapAt[uc*#&, vals, {All, -1}], 
                Append[types, "Wavenumbers"]
                ]
            ]
          ]
        ]
      ]
    ]


(* ::Subsection:: *)
(*FormattedCheckPoint Files*)



(* ::Subsubsection::Closed:: *)
(*iFormattedCheckpointRead*)



Clear[iFormattedCheckpointRead];
ImportFormattedCheckpointFile::misfmt=
  "Misformatted fchk file or failed to extract from block appropriately. \
`` isn't an appropriate line specification.";
iFormattedCheckpointRead[
  stream_InputStream, 
  keys:_?StringPattern`StringPatternQ|{__?StringPattern`StringPatternQ}|All
  ]:=
  Module[
    {
      validKeys=
        Replace[keys, 
          {
            "*"|Verbatim[__]->All,
            {p__}:>Alternatives[p]
            }
          ],
      header,
      line,
      lineParts,
      keyRaw,
      key,
      subspec,
      type,
      results=<||>
      },
      header=Internal`Bag[];
      Do[
        line=ReadList[stream, String, 1];
        (* If we've hit the end of the file we just return *)
        If[line==={}, Return[EndOfFile], line=line[[1]] ];
        (* test to see if we've read the header yet *)
        If[header=!=None,
          (* while in the header *)
          If[StringFreeQ[line, "Number of atoms"~~__~~" I "],
            (* stuff the bag *)
            Internal`StuffBag[header, line];
            Continue[],
            (* exit the header *)
            If[(validKeys===All||StringMatchQ["Header", validKeys]),
              results["Header"]=
                StringRiffle[Internal`BagPart[header, All], "\n"]
              ];
            header=None;
            ]
          ];
        (* if the line is malformatted we fail out *)
        If[StringStartsQ[line, " "],
          Message[ImportFormattedCheckpointFile::misfmt, line];
          results=Return[$Failed]
          ];
        (* All lines are whitespace separated by multiple spaces *)
        lineParts=StringSplit[line, Repeated[" ", {2, \[Infinity]}]];
        (* The key is the first element *)
        keyRaw=lineParts[[1]];
        (* We'll reformat it to be more Mathematica appropriate *)
        key=
          StringJoin@
            Map[
              With[{base=Last@StringSplit[StringTrim[#, "/"],"/"]},
                ToUpperCase@StringTake[base, 1]<>StringDrop[base, 1]
                ]&,
               StringSplit[lineParts[[1]], " "]
              ];
        If[MatchQ[lineParts[[2]], "I"|"R"|"C"|"L"],
          subspec=None,
          (* subspec is the second *)
          subspec=
            StringJoin@
              Map[
                With[{base=Last@StringSplit[StringTrim[#, "/"],"/"]},
                  ToUpperCase@StringTake[base, 1]<>StringDrop[base, 1]
                  ]&,
                 StringSplit[lineParts[[2]], " "]
                ];
          (* Shift so that the type is the second *)
          lineParts=Delete[lineParts, 2]
          ];
        (* The type is the second *)
        type=lineParts[[2]];
        (* If we've specified a subset of keys we make sure we're taking one of those *)
        If[validKeys===All||StringMatchQ[key, validKeys],
          (* Check if we're starting a block *)
          With[{res=
            If[lineParts[[3]]=="N=",
              With[{n=Floor@Internal`StringToDouble[lineParts[[4]]]},
                Switch[type,
                  "R"|"I",
                    If[n>50,
                      RawArray[
                        If[type=="R", "Real64", "Integer32"],
                        ReadList[stream, Number, n]
                        ],
                      ReadList[stream, Number, n]
                      ],
                  "C",
                    ReadList[stream, Word, n],
                  "H",
                    (* Gaussian encodes this without whitespace padding so it requires lower-level tricks *)
                    Replace[
                      With[{lines=Quotient[n, 72], extras=Mod[n, 72]},
                        Flatten[{
                          ReadList[stream,
                            ConstantArray[Character, 75],
                            Quotient[n, 72]
                            ][[All, 3;;74]],
                          ReadList[stream, 
                            ConstantArray[Character, 3+extras], 
                            1][[All, 3;;2+extras]]
                          }]
                        ],
                      {
                        "1"->True,
                        "0"->False,
                        " "->Nothing,
                        _->Indeterminate
                        },
                      1
                      ]
                  ]
                ],
              Which[
                type=="R"&&
                  StringLength[lineParts[[3]]]>4&&
                  StringTake[lineParts[[3]], {-4}]=="E",
                  Internal`StringToDouble@lineParts[[3]],
                type=="I",
                  Floor@Internal`StringToDouble[lineParts[[3]]],
                type=="R",
                  Internal`StringToDouble[lineParts[[3]]],
                type=="L",
                  Switch[lineParts[[3]], "0", False, "1", True, _, Indeterminate],
                type=="C",
                  lineParts[[3]]
                ]
              ]
            },
            If[subspec===None,
              results[key]=res,
              If[!KeyExistsQ[results, key],
                results[key]=<|subspec->res|>,
                results[key, subspec]=res
                ]
              ]
            ];,
          (* we place the break here so subspec keys aren't missed *)
          If[ListQ@keys&&Sort[keys]==Sort[Keys[results]],
            Break[]
            ];
          (* skip if necessary *)
          If[lineParts[[3]]=="N=",
            Skip[stream, 
              Number, 
              Floor@Internal`StringToDouble[lineParts[[4]]]
              ]
            ]
          ],
        {i, \[Infinity]}
        ];
      results
      ];
iFormattedCheckpointRead[
  file_String?FileExistsQ, 
  keys:_?StringPattern`StringPatternQ|All
  ]:=
  With[
    {
      strm=OpenRead@file
      },
    With[
      {
         res=
        CheckAbort[iFormattedCheckpointRead[strm, keys], $Aborted]
        },
      Close[strm];
      res
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*iFormattedCheckpointCleanResults*)



Clear[iFormattedCheckpointCleanResults];
iFormattedCheckpointCleanResults[results_Association?AssociationQ]:=
  Association@
    KeyValueMap[
      #->
        If[AssociationQ@#2,
          iFormattedCheckpointCleanResults[#2],
          Which[
            StringEndsQ[#, "Density"],
              With[{sq=Sqrt[Length[#2]]},
                If[IntegerQ@sq&&Positive[sq], 
                  RawArray[
                    Developer`RawArrayType@#2,
                    Partition[Normal@#2, sq]
                    ], 
                  #2
                  ]
                ],
            StringContainsQ[#, "Coordinates"],
              QuantityArray[
                Partition[Normal@#2, 3], 
                "BohrRadius"
                ],
            StringEndsQ[#, "Energy"|"Energies"],
              If[NumericQ@#2,
                Quantity[#2, "Hartrees"],
                QuantityArray[Normal@#2, "Hartrees"]
                ],
            True,
              #2
            ]
          ]&,
      results
      ];
iFormattedCheckpointCleanResults[_]:=$Failed


(* ::Subsubsection::Closed:: *)
(*ImportFormattedCheckpointFile*)
 


ImportFormattedCheckpointFile//Clear


Options[ImportFormattedCheckpointFile]=
  {
    "KeyPattern"->All
    };
ImportFormattedCheckpointFile[
  file:_String?FileExistsQ|_InputStream, 
  ops:OptionsPattern[]
  ]:=
  With[{res1=iFormattedCheckpointRead[file, OptionValue["KeyPattern"]]},
    If[AssociationQ@res1,
      iFormattedCheckpointCleanResults[res1],
      $Failed
      ]
    ];
ImportFormattedCheckpointFile[
  file:_String?FileExistsQ|_InputStream,
  "MolTable",
  ops:OptionsPattern[]
  ]:=
  With[
    {
      dats=
        ImportFormattedCheckpointFile[file, 
          "KeyPattern"->
            {
              "CurrentCartesianCoordinates", 
              "AtomicNumbers", 
              "IBond"
              }, 
          ops
          ]
      },
      With[
        {
          bonds=
            DeleteDuplicates@
              Flatten[
                MapIndexed[
                  Map[Sort]@Thread[{#2[[1]],DeleteCases[#, 0]}]&,
                  Partition[dats["IBond"], Length@dats["AtomicNumbers"]-1]
                  ],
                1
                ]
          },
        Join[
          {{Length@dats["AtomicNumbers"], Length@bonds}},
          Thread[
            {
              ChemDataLookup[dats["AtomicNumbers"], "Symbol"],
              QuantityMagnitude@
                UnitConvert[dats["CurrentCartesianCoordinates"], "Angstroms"]
              }
            ],
          bonds
          ]
        ]
    ];
ImportFormattedCheckpointFile[
  file:_String?FileExistsQ|_InputStream, 
  s:_?StringPattern`StringPatternQ|{__?StringPattern`StringPatternQ},
  ops:OptionsPattern[]
  ]:=
  ImportFormattedCheckpointFile[file, "KeyPattern"->s, ops];
ImportFormattedCheckpointFile[
  str:_String,
  keys___?StringPattern`StringPatternQ,
  ops:OptionsPattern[]
  ]:=
  ImportFormattedCheckpointFile[StringToStream[str], keys, ops];


End[];



