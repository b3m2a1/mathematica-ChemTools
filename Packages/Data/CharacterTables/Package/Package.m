(* ::Package:: *)

(* Autogenerated Package *)

(* ::Subsubsection::Closed:: *)
(*Parsers*)



CharacterTableParse::usage=
	"Parses raw character table data";


(* ::Subsubsection::Closed:: *)
(*Symmetry Functions*)



CharacterTableSymmetryFunctions::usage=
	"Determines the functions that describe the symmetry classes";
CharacterTableSymmetryFunctionsFormatted::usage="";


(* ::Subsubsection::Closed:: *)
(*Matrix Reps*)



CharacterTableRepresentationMatrices::usage=
	"Builds representation matrices for a given basis set";
CharacterTableRepresentationMatricesIrreducibleBlocks::usages="";
CharacterTableMatrixIrreducibleRepresentations::usage=
	"Finds the irreducible representations *in an already reduced matrix*";
CharacterTableMatrixIrreducibleRepresentationCharacters::usage="";
CharacterTableIrreducibleRepresentationData::usage="";
CharacterTableDirectProduct::usage="";
CharacterTableGenerate::usage="";


(* ::Subsubsection::Closed:: *)
(*Representations*)



CharacterTableReducibleRepresentationsList::usage=
	"";
CharacterTableReducibleRepresentationsGrid::usage=
	"Formats a grid for the reducible reps";


CharacterTableTotalRepresentation::usage=
	"Computes the total of a representation list";
CharacterTableReduceRepresentation::usage=
	"Reduces a reducible representation in a character table's irreps";


CharacterTableFormatReducedRepresentation::usage=
	"Displays an association of irreps as a sum";


CharacterTableModeRepresentations::usage=
	"Represents the translational, vibrational, and rotational irreps";


(* ::Subsubsection::Closed:: *)
(*Salcs*)



CharacterTableSymmetryAdaptedProjectionList::usage=
	"Applies a SALC-type projection"
CharacterTableSALCs::usage=
	"Generates the symmetry adapted linear \
combinations of whatever coordinates are supplied";
CharacterTableSALCModes::usage=
	"Turns SALCs into sums";
CharacterTableFormatSALCs::usage=
	"Formats SALCs for readbility";


(* ::Subsubsection::Closed:: *)
(*IrreducibleRepresentations*)



CharacterTableFindIrreducibleRepresentation::usage="";


CharacterTableActiveIrreducibleRepresentations::usage=
	"Extracts the active irreps for a type of spectroscopy";


Begin["`Private`"];


(* ::Subsection:: *)
(*CharacterTableParse*)



(* ::Subsubsection::Closed:: *)
(*URL Import*)



(*normalizeCTName[ct_]:=
	Replace[
		Capitalize@ToLowerCase@
			StringDelete[
				StringJoin@ReplaceAll[ct,Subscript|SubscriptBox\[Rule]List],
				Whitespace
				],
		HoldPattern[Capitalize[s_]]:>
			ToUpperCase[StringTake[s,1]]<>StringDrop[s,1]
		]*)


(*CharacterTableURL[ct_]:=
	Switch[ct,
		"T",
			"http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=900&option=4",
		"Th",
			"http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=901&option=4",
		"O",
			"http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=903&option=4",
		_,
			TemplateApply[
				"http://www.webqc.org/printable-symmetrypointgroup-ct-``.html",
				ToLowerCase@ct
				]
		]*)


(*CharacterTableRawData[ct_String?(StringContainsQ["/"])]:=
	If[StringStartsQ[ct, "http://www.webqc.org/"(*|"http://symmetry.jacobs-university.de"*)], 
		CharacterTableCleanRawData, 
		Identity
		]@
		Map[
			If[StringStartsQ[ct, "http://www.webqc.org/"|"http://symmetry.jacobs-university.de"],
				Map[
					StringDelete[
						StringJoin@
							System`Convert`HTMLImportDump`SymbolicXML2Text@#,
						Except["\n", Whitespace]
						]&,
					ReplaceAll[#[[3]],
						{
							XMLElement["img",{"src"\[Rule]"/pics/epsilon.gif"},{}]\[Rule]"\[CurlyEpsilon]",
							XMLElement["img",{"src"\[Rule]"/pics/sigma.gif"},{}]\[Rule]"\[Sigma]"
							}
						]
					]&,
				Identity
				],
			Cases[
						Import[ct,{"HTML","XMLObject"}],
						XMLElement["table", __],
						\[Infinity]
						][[
				Which[
					StringStartsQ[ct, "http://www.webqc.org/"],
						Sequence@@{2, 3},
					StringStartsQ[ct, "http://symmetry.jacobs-university.de"],
						Sequence@@{2, 3},
					True,
						All
					]
				]]
			];
CharacterTableRawData[ct_]:=
		CharacterTableRawData@CharacterTableURL@ct*)


(*CharacterTableCleanRawData[tdata_]:=
	Module[{
		trueTab=
			ConstantArray[None,
				Length@tdata+
					Length@Select[Rest@tdata, StringContainsQ["\n"][#[[2]]]&]
				],
		rowFillCounter=2,
		splitRow,
		boxLen=Length@tdata[[1]]
		},
		trueTab[[1]]=tdata[[1]];
		Map[
			If[StringContainsQ["\n"][#[[2]]],
				splitRow=StringSplit[#,"\n"]&/@#;
				With[{maxLen=Max@Append[Map[Length,splitRow],0]},
					Do[
						(* populate the final row *)
						trueTab[[rowFillCounter++]]=
							Map[
								(* check how many elements it has *)
								Switch[Length[#],
									maxLen,
										#[[i]],
									1,
										#[[1]]<>ToString[i],
									_,
										Null
									]&,
							Take[PadRight[splitRow, boxLen, ""], boxLen]
							],
						{i, maxLen}
						]
					],
				trueTab[[rowFillCounter++]]=
					PadRight[#, boxLen, ""]
				]&,
			Rest@tdata
			];
		trueTab
		]*)


(*If[!AssociationQ@$CharacterTables, $CharacterTables=<||>];
CharacterTableImport[ct_]:=
	With[{nm=normalizeCTName@ct},
		Lookup[$CharacterTables,nm,
			$CharacterTables[nm]=
				<|
					"PointGroup"\[Rule]nm,
					"SymmetryClasses"\[Rule]#[[1, 2;;Length[#] ]],
					"IrreducibleRepresentations"\[Rule]
						#[[2;;, 1 ]],
					"CharacterTable"->
						Map[Quiet[Check[ToExpression[#],#]]&, #[[2;;, 2;;Length[#] ]]],
					"Others"->
						AssociationThread[
							#[[1, 1+Length[#];; ]],
							Transpose@#[[2;;, 1+Length[#];; ]]
							]
					|>&@CharacterTableRawData@nm
			]
		]*)


(* ::Subsubsection::Closed:: *)
(*PG Ent*)



CharacterTablePointGroupEnt[ct_]:=
	Entity["FiniteGroup",
		{
			"CrystallographicPointGroup", 
			$pointGroupMap@
				normalizeCTName@ct
			}
		]


$CharacterTableKeys=
	{
		"PointGroup",
		"SymmetryClasses",
		"IrreducibleRepresentations",
		"CharacterTable",
		"LinearFunctions",
		"NonLinearFunctions"
		};


$pointGroupEntityMap=
	<|
		"C1"->1,"Ci"->2,"C2"->3,"Cs"->4,"C2h"->5,"D2"->6,"C2v"->7,
		"D2h"->8,"C4"->9,"S4"->10,"C4h"->11,"D4"->12,"C4v"->13,
		"D2d"->14,"D4h"->15,"C3"->16,"S6"->17,"D3"->18,"C3v"->19,
	 "D3d"->20,"C6"->21,"C3h"->22,"C6h"->23,"D6"->24,"C6v"->25,
		"D3h"->26,"D6h"->27,"T"->28,"Th"->29,"O"->30,
		"Td"->31,"Oh"->32,"Ih"->"Icosahedral"
		|>;


(* ::Subsubsection::Closed:: *)
(*Char Tab Data Import*)



charTabImportExcel[f_]:=
MapThread[
#->
Check[
DeleteCases[{"","",__,__Real?(FractionalPart[#]>0&),___}]@
Rest@SplitBy[#2,MatchQ[{""..}]][[3]],
$Failed
]&,
Rest/@
Import[f,
{"XLS",{"Sheets","Data"}}
]
]//Association;


(*Global`map=charTabImportExcel["~/Downloads/ed300281d_si_001.xls"];*)


(* ::Subsubsection::Closed:: *)
(*CharacterTableParsePointGroup*)



CharacterTableParsePointGroup[pgBase_String]:=
	With[{pg= StringDelete[pgBase, Whitespace]},
		With[{
			pgMain=
				First@
					StringReplace[StringReplace[pg,{"i"->"\[Infinity]", Whitespace->""}],
						t:LetterCharacter~~
						n:(DigitCharacter...|"\[Infinity]")~~
						modifiers___:>
						<|
							"ID"->StringDelete[pg, Whitespace],
							"Type"->t,
							"Order"->
								If[StringLength[n]>0,
									ToExpression[n],
									None
									],
							"Modifier"->modifiers
							|>
						]
				},
			Append[pgMain,
				"Formatted"->
				Style[
					With[{
							t=pgMain["Type"],
							o=pgMain["Order"],
							m=pgMain["Modifier"]
							},
						If[o=!=None||StringLength[m]>0,
							Subscript[t,
								Row@{Replace[o,None:>Sequence@@{}],m}
								],
							t
							]
						],
					ShowStringCharacters->False
					]
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableParseSymmetryClass*)



CharacterTableParseSymmetryClass//Clear


CharacterTableParseSymmetryClass[cl_String]:=
	With[{
			coreData=
				First@
					StringReplace[StringDelete[#, Whitespace],
						{
							StartOfString~~(counts:DigitCharacter...)~~t:Except[DigitCharacter]~~
								n:(DigitCharacter...|"\[Infinity]")~~
									modifiers___~~EndOfString:>
							<|
							"Type"->t,
							"ID"->#,
							"Order"->
								If[StringLength@n>0,
									ToExpression@
										If[StringLength@n>1&&StringTake[n, {-1}]=!="0",
											StringTake[n,{1, -2}],
											n
											],
									1
									],
							"Degree"->
								If[StringLength@n>1&&StringTake[n, {-1}]=!="0",
									ToExpression@StringTake[n,{-1}],
									1
									],
							"Count"->
								If[StringLength@counts>0,
									ToExpression[counts],
									1
									],
							"Orientation"->
								If[StringStartsQ[modifiers, ("h"|"v"|"d")],
									StringTake[modifiers, {1}],
									""
									],
							"Modifier"->
								If[StringMatchQ[modifiers,"(=*"],
									"",
									If[StringStartsQ[modifiers, ("h"|"v"|"d")],
										StringTake[modifiers, {2,-1}],
										modifiers
										]
									]
							|>
							}
						]
			},
		Append[coreData,
			"Formatted"->
				Style[
					Row@{
						coreData["Count"]*
						Replace[
							{
								Replace[coreData["Orientation"],
									""->coreData["Order"]
									],
								coreData["Degree"]
								},
							{
								{1,1}:>coreData["Type"],
								{1,n_}:>Superscript[coreData["Type"],n],
								{n_,1}:>Subscript[coreData["Type"],n],
								{n_,m_}:>Superscript[Subscript[coreData["Type"],n],m]
								}
							],
						coreData["Modifier"]
						},
					ShowStringCharacters->False
					]
			]
		]&@StringDelete[cl, Whitespace];
CharacterTableParseSymmetryClass~SetAttributes~Listable


(* ::Subsubsection::Closed:: *)
(*CharacterTableParseIrreducibleRepresentation*)



CharacterTableParseIrreducibleRepresentation//Clear


iCharacterTableParseIrreducibleRepresentation[ir_String]:=
		With[{
				coreData=
					First@
						StringReplace[#,
							{
								t:Except[DigitCharacter]~~
								index:(DigitCharacter...|"\[Infinity]")~~
								parity:"g"|"u"|""~~
								modifiers___:>
								<|
									"ID"->#,
									"Type"->t,
									"Index"->
									If[StringLength@index>0,
										ToExpression@index,
										0
										],
									"Parity"->parity,
									"Modifier"->modifiers
									|>
								}
							]
				},
			Append[coreData,
				"Formatted"->
					Style[
						Row@{
							Replace[
								{
									coreData["Index"],
									coreData["Parity"]
									},
								{
									{0,""}:>coreData["Type"],
									{0,n_}:>Subscript[coreData["Type"],n],
									{n_,0}:>Subscript[coreData["Type"],n],
									{n_,m_}:>Subscript[coreData["Type"],Row@{n,m}]
									}
								],
							coreData["Modifier"]
							},
						ShowStringCharacters->False,
						StripOnInput->False
						]
				]
			]&@StringDelete[ir, Whitespace];
CharacterTableParseIrreducibleRepresentation[s_String]:=
	Module[
		{
			split=
				StringTrim/@
					StringSplit[
						StringReplace[s, "-"~~k:Except[DigitCharacter]:>"-1"<>k],
						"+"
						]
			},
		split=
			Replace[
				StringSplit[split, 
					StartOfString~~n:NumberString:>ToExpression@n
					],
				{i_}:>{1, i},
				1
				];
		split=
			Replace[split,
				{n_, i_String}:>
					{n, iCharacterTableParseIrreducibleRepresentation[i]},
				1
				];
		If[Length[split]==1&&split[[1,1]]===1,
			split[[1,2]],
			Replace[split, {1, i_}:>i, 1]
			]
		];
CharacterTableParseIrreducibleRepresentation~SetAttributes~Listable


(* ::Subsubsection::Closed:: *)
(*CharacterTableParseTable*)



CharacterTableParseTable[pgData_Association, 
	ct:{__List}, 
	cl_List
	]:=
	Quiet@
		Map[
			Map[
				If[StringQ@#,
					Replace[
						With[{clean=
							FixedPoint[
								StringReplace[{
										"\.bd"->"(1/2)",
										"\[CurlyEpsilon]":>TemplateApply["Exp[2*Pi*I/``]",pgData["Order"]],
										"*"->"\[Conjugate]",
										"cos"~~arg:Except["+"]..:>
											"Cos["<>arg<>"]",
										"\[CapitalPhi]"->"\[FormalCapitalPhi]"
										}],
								#
								]
							},
							Check[
								ToExpression@clean,
								Echo[clean]
								]
							],
						r_?NumberQ:>IntegerPart[r]
						],
					If[NumberQ[#],
						IntegerPart@#,
						#
						]
					]&
				],
			 ct[[2;;, 4;;UpTo[3+Length@ cl]]]
			];


CharacterTableParseLinearFunctions[ct:{__List}, cl_List]:=
	Map[
		DeleteCases[Null]@
		Map[
			Replace[{
				l:{__String}:>
					Quiet[Check[ToExpression[If[Length@l>1,l,l[[1]]]],Print[l]]]
				}]
			]@
		StringSplit[
			StringTrim[
				StringReplace[
					StringReplace[#,{
						"Rx"->"\[FormalCapitalR][\[FormalX]]",
						"Ry"->"\[FormalCapitalR][\[FormalY]]",
						"Rz"->"\[FormalCapitalR][\[FormalZ]]",
						"x"->" \[FormalX]",
						"y"->" \[FormalY]",
						"z"->" \[FormalZ]"
						}],{
					e:Except[WhitespaceCharacter|"+"|"("]~~"2":>e<>"^2"
					}],
				((Whitespace|"")~~("("|")")~~(Whitespace|""))
				],
			","
			]&
		]@
	StringCases[
		Map[
			If[Length[#]>3+Length@ cl,
				#[[3+Length@ cl+1]],
				""
				]&,
			Rest@ct
			],
		s:Shortest[("("~~__~~")")|(__~~(","|EndOfString))]:>
			StringTrim[s,","]
		]


CharacterTableParseNonlinearFunctions[ct:{__List}, cl_List]:=
	Map[
		DeleteCases[Null]@
		Map[
			Replace[{
				l:{__}:>
					Quiet[Check[ToExpression[If[Length@l>1,l,l[[1]]]],Print[l]]]
				}]
			]@
		StringSplit[
			StringTrim[
				StringReplace[
					StringReplace[#,{
						"Rx"->"\[FormalCapitalR][\[FormalX]]",
						"Ry"->"\[FormalCapitalR][\[FormalY]]",
						"Rz"->"\[FormalCapitalR][\[FormalZ]]",
						"x"->" \[FormalX]",
						"y"->" \[FormalY]",
						"z"->" \[FormalZ]"
						}],{
					e:Except[WhitespaceCharacter|"+"|"("]~~"2":>e<>"^2"
					}],
				((Whitespace|"")~~("("|")")~~(Whitespace|""))
				],
			","
			]&
		]@
	StringCases[
		Map[
			If[Length[#]>3+Length@cl+1,
				#[[3+Length@cl+2]],
				""
				]&,
			Rest@ct
			],
		s:Shortest[("("~~__~~")")|(__~~(","|EndOfString))]:>
			StringTrim[s,","]
		]


CharacterTableImportExcel[ds_Association]:=
	Map[
		Check[
			With[{
				ct=#,
				pg=#[[1,3]],
				pgData=CharacterTableParsePointGroup[#[[1,3]]],
				cl=
					TakeWhile[#[[1,4;;]],
						#=!=""&
						],
				ir=
					With[{i=#[[2;;, 3 ]]},
						ReplacePart[i,
							Map[
								#[[1]]->i[[#[[1]]-1]]&,
								Position[i,""]
								]
							]
						]
				},
				<|
				"PointGroup"->
					pgData,
				"SymmetryClasses"->
					CharacterTableParseSymmetryClass[cl],
				"IrreducibleRepresentations"->
					CharacterTableParseIrreducibleRepresentation[ir],
				"CharacterTable"->
					CharacterTableParseTable[pgData, ct, cl],
				"LinearFunctions"->
					CharacterTableLinearFunctions[ct, cl],
				"NonLinearFunctions"->
					CharacterTableNonlinearFunctions[ct, cl]
					|>
				],
			<||>
			]&,
		ds
		];


(*Global`ctabs=charTabExcelClean[Global`map];*)


(* ::Subsubsection::Closed:: *)
(*CharacterTableParse*)



$CharacterTableParseObjects=
	<|
		"PointGroup"->
			CharacterTableParsePointGroup,
		"SymmetryClass"->
			CharacterTableParseSymmetryClass,
		"IrreducibleRepresentation"->
			CharacterTableParseIrreducibleRepresentation,
		"Table"->
			CharacterTableParseTable,
		"LinearFunctions"->
			CharacterTableParseLinearFunctions,
		"NonlinearFunctions"->
			CharacterTableParseNonlinearFunctions
		|>


CharacterTableParse//Clear


CharacterTableParse[k_?(KeyMemberQ[$CharacterTableParseObjects,#]&), "Function"]:=
	$CharacterTableParseObjects[k];
CharacterTableParse[k_?(KeyMemberQ[$CharacterTableParseObjects,#]&), a__]:=
	With[{f=$CharacterTableParseObjects[k]},
		With[{r=f[a]},
			r/;Head[r]=!=f
			]
		];
CharacterTableParse[k_?(KeyMemberQ[$CharacterTableParseObjects,#]&)][a__]:=
	CharacterTableParse[k, a]


CharacterTableParse~
	PackageAddAutocompletions~
	{Keys[$CharacterTableParseObjects], {"Function"}}


(* ::Subsection:: *)
(*Irreps*)



(* ::Subsubsection::Closed:: *)
(*CharacterTableFindIrreducibleRepresentation*)



CharacterTableFindIrreducibleRepresentation[
	ct_,
	key_->crit_
	]:=
	Pick[
		CharacterTableData[ct,"IrreducibleRepresentations"],
		crit/@
			CharacterTableData[ct, key]
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableActiveIrreducibleRepresentations*)



CharacterTableActiveIrreducibleRepresentations[ct_, "Infrared"]:=
	CharacterTableFindIrreducibleRepresentation[
		ct,
		"LinearFunctions"->Function@MemberQ[#,\[FormalX]|\[FormalY]|\[FormalZ],2]
		]


CharacterTableActiveIrreducibleRepresentations[ct_, "Raman"]:=
	CharacterTableFindIrreducibleRepresentation[
		ct,
		"NonLinearFunctions"->Function[Length[Flatten[#]]>0]
		]


CharacterTableActiveIrreducibleRepresentations[ct_, "Microwave"]:=
	CharacterTableFindIrreducibleRepresentation[
		ct,
		"LinearFunctions"->Function@MemberQ[#, \[FormalCapitalR][\[FormalX]]|\[FormalCapitalR][\[FormalY]]|\[FormalCapitalR][\[FormalZ]], 2]
		]


PackageAddAutocompletions[
	CharacterTableActiveIrreducibleRepresentations,
	{None, {"Infrared", "Raman", "Microwave"}}
	]


(* ::Subsection:: *)
(*Representations*)



(* ::Subsubsection::Closed:: *)
(*CharacterTableSymmetryFunctions*)



CharacterTableSymmetryFunctions[ct_, sops_]:=
	Module[{
		rots=sops["Elements","RotationAxes"],
		rotClassOrder=
			Apply[Join,
				Association@
					Thread[
						sops["Elements","RotationAxes"][[#]]->Length[#]
						]&/@
					sops["Classes", "RotationAxes"]
				],
		rotClasses=
			Apply[Join,
				Association@
					With[{
						fns=Lookup[sops["Functions","RotationAxes"],#],
						idx=sops["Elements","RotationAxes"][[#]]
						},
						Map[#->fns&,idx]
					]&/@
					sops["Classes", "RotationAxes"]
				],
		rotClassesElements=
			Apply[Join,
				Association@
					With[{
						idx=sops["Elements","RotationAxes"][[#]]
						},
						Map[#->idx&,idx]
					]&/@
					sops["Classes", "RotationAxes"]
				],
		planes=sops["Elements", "SymmetryPlanes"],
		planeClassOrder=
			Apply[Join,
				Association@
					Thread[
						sops["Elements","SymmetryPlanes"][[#]]->Length[#]
						]&/@
					sops["Classes", "SymmetryPlanes"]
				],
		planeClasses=
			Apply[Join,
				Association@
					With[{
						fns=Lookup[sops["Functions","SymmetryPlanes"],#],
						idx=sops["Elements","SymmetryPlanes"][[#]]
						},
						Map[#->fns&,idx]
					]&/@
					sops["Classes", "SymmetryPlanes"]
				],
		planeClassesElements=
			Apply[Join,
				Association@
					With[{
						idx=sops["Elements","SymmetryPlanes"][[#]]
						},
						Map[#->idx&,idx]
					]&/@
					sops["Classes", "SymmetryPlanes"]
				],
		screws=sops["Elements", "ScrewAxes"],
		screwClassOrder=
			Apply[Join,
				Association@
					Thread[
						sops["Elements","ScrewAxes"][[#]]->Length[#]
						]&/@
					sops["Classes", "ScrewAxes"]
				],
		screwClasses=
			Apply[Join,
				Association@
					With[{
						fns=Lookup[sops["Functions","ScrewAxes"],#],
						idx=sops["Elements","ScrewAxes"][[#]]
						},
						Map[#->fns&,idx]
					]&/@
				sops["Classes", "ScrewAxes"]
				],
		screwClassesElements=
			Apply[Join,
				Association@
					With[{
						idx=sops["Elements","ScrewAxes"][[#]]
						},
						Map[#->idx&,idx]
					]&/@
					sops["Classes", "ScrewAxes"]
				],
		center=sops["Elements", "Center"],
		elemListing=
			<|
				"RotationAxes"->{},
				"SymmetryPlanes"->{},
				"ScrewAxes"->{}
				|>,
		primaryAxis,
		secondaryAxis,
		ind,
		cur
		},
		rots=
			First/@SortBy[MapIndexed[#->First@#2&, rots],
				Last@FirstPosition[sops["Classes", "RotationAxes"], #[[2]]]&
				];
		planes=
			First/@SortBy[MapIndexed[#->First@#2&, planes],
				Last@FirstPosition[sops["Classes", "SymmetryPlanes"], #[[2]]]&
				];
		screws=
			First/@SortBy[MapIndexed[#->First@#2&, screws],
				Last@FirstPosition[sops["Classes", "ScrewAxes"], #[[2]]]&
				];
		primaryAxis=
			Normalize[
				MaximalBy[
					MaximalBy[rots, First][[All, 2]],
					#[[3]]&
					][[1]]-center
				];
		secondaryAxis=
			SelectFirst[
				Map[#-center&, SortBy[rots, First][[All,2]]],
				.4<(Mod[VectorAngle[#, primaryAxis], \[Pi]]/\[Pi])<.6&
				];
		If[!ListQ@secondaryAxis,
			secondaryAxis=
				SelectFirst[
					Map[
						Cross[#[[1]]-center, #[[2]]-center]&,
						planes
						],
					.1<(Mod[VectorAngle[#, primaryAxis], \[Pi]]/\[Pi])<.9&
					];
			If[!ListQ@secondaryAxis,
				secondaryAxis=
					SelectFirst[
						Map[#-center&, SortBy[rots, First][[All,2]]],
						.1<(Mod[VectorAngle[#, primaryAxis], \[Pi]]/\[Pi])<.9&
						];
				If[!ListQ@secondaryAxis,
					secondaryAxis=
						Cross[primaryAxis, {1, 0, 0}];
					If[Norm[secondaryAxis]<.1, 
						secondaryAxis=
							Cross[primaryAxis, {0, 1, 0}]
						]
					],
				secondaryAxis-=Projection[secondaryAxis, primaryAxis]
				]
			];
		secondaryAxis=Normalize[secondaryAxis];
		AssociationMap[
			Switch[#["Type"],
				"E",
					<|
						"Functions"->{ScalingTransform[{1, 1, 1}, center]},
						"Element"->None
						|>,
				"i",
					<|
						"Functions"->{ScalingTransform[{-1, -1, -1}, center]},
						"Element"->center
						|>,
				"C",
						ind=
							With[{c=#["Count"]},
								FirstPosition[
									rots,
									{
										#["Order"]*#["Degree"], 
										Which[
											StringContainsQ[#["Modifier"],"x"],
												{_?(Abs[#]>.001&), __?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"y"],
												{_?(Abs[#]<.001&),_?(Abs[#]>.001&),_?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"z"],
												{__?(Abs[#]<.001&),_?(Abs[#]>.001&)},
											True,
												_
											]
										}?(rotClassOrder[#]===c&), 
									{$Failed}
									][[1]]
								];
						If[ind===$Failed,
							Replace[
								FirstCase[
									With[{c=#["Count"]},
										Reverse@
											SortBy[sops["Elements", "RotationAxes"], 
												Abs[#["Order"]-c]&
												]
										],
									{
										o_/;Mod[o, #["Order"]*#["Degree"] ]==0,
										Which[
											StringContainsQ[#["Modifier"],"x"],
												{_?(Abs[#]>.001&), __?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"y"],
												{_?(Abs[#]<.001&),_?(Abs[#]>.001&),_?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"z"],
												{__?(Abs[#]<.001&),_?(Abs[#]>.001&)},
											True,
												_
											]
										}, 
									$Failed
									],
								r:{_,_}:>
									With[{els=rotClassesElements@r},
										If[els[[1,1]]==#["Order"]*#["Degree"],
											<|
												"Functions"->rotClasses[els[[1]]],
												"Element"->els
												|>,
											With[{o=#["Order"], d=#["Degree"]},
												<|
													"Functions"->
														Map[
																RotationTransform[
																	2.\[Pi]/(o*d),
																	#[[2]],
																	center
																	]&, 
																els
																],
													"Element"->
														Map[{o, #[[2]]}&, els]
													|>
												]
											]
										]
								],
							cur=
								<|
									"Functions"->rotClasses[rots[[ind]]],
									"Element"->First@rotClassesElements@rots[[ind]]
									|>;
							rots=DeleteCases[rots,Alternatives@@rotClassesElements@rots[[ind]]];
							cur
							],
				"\[Sigma]",
						Switch[{#["Orientation"], #["Modifier"]},
							{_, _?(StringContainsQ["xy"])},
								ind=
									With[{c=#["Count"]},
										FirstPosition[
											planes,
											{Repeated[{_,_,_?(Abs[#]<.0001&)}, {2}]}?(planeClassOrder[#]===c&),
											{1}
											][[1]]
										],
							{_, _?(StringContainsQ["xz"])},
								ind=
									With[{c=#["Count"]},
										FirstPosition[
											planes,	
											{Repeated[{_,_?(Abs[#]<.0001&),_}, {2}]}?(planeClassOrder[#]===c&),
											{1}
											][[1]]
										],
							{_, _?(StringContainsQ["yz"])},
								ind=
									With[{c=#["Count"]},
										FirstPosition[
											planes,
											{Repeated[{_?(Abs[#]<.0001&),_,_}, {2}]}?(planeClassOrder[#]===c&),
											{1}
											][[1]]
										],
							{"h", _},
								ind=
									With[{c=#["Count"]},
										FirstPosition[
											planes,
											{pt1:{_,_,_}, pt2_}/;(
												planeClassOrder[{pt1, pt2}]===c&&
												With[{
													n=Norm[primaryAxis],
													v=Cross[pt1-center, pt2-center]
													},
													Abs[primaryAxis.v/(n*Norm[v])]
													]/2.\[Pi]
												)>.8,
											{1}
											][[1]]
										],
							_,
								ind=
									FirstPosition[
										With[{c=#["Count"]},
											Select[planes, planeClassOrder[#]===c&]
											],	
										{{_,_,_}, _},
										{1}
										][[1]]
							];
						cur=
							<|
								"Functions"->planeClasses[planes[[ind]]],
								"Element"->First@planeClassesElements@planes[[ind]]
								|>;
						planes=DeleteCases[planes,Alternatives@@planeClassesElements@planes[[ind]]];
						cur,
				"S",
					ind=
						With[{c=#["Count"]},
							FirstPosition[
								screws,
								{
									#["Order"]*#["Degree"], 
									Which[
										StringContainsQ[#["Modifier"],"x"],
											{_?(Abs[#]>.001&), __?(Abs[#]<.001&)},
										StringContainsQ[#["Modifier"],"y"],
											{_?(Abs[#]<.001&),_?(Abs[#]>.001&),_?(Abs[#]<.001&)},
										StringContainsQ[#["Modifier"],"z"],
											{__?(Abs[#]<.001&),_?(Abs[#]>.001&)},
										True,
											_
										]
									}?(screwClassOrder[#]===c&), 
								{$Failed}
								][[1]]
							];
						If[ind===$Failed,
							Replace[
								FirstCase[Reverse@SortBy[sops["Elements", "ScrewAxes"], #["Order"]],
									{
										o_/;Mod[o, #["Order"]*#["Degree"] ]==0,
										Which[
											StringContainsQ[#["Modifier"],"x"],
												{_?(Abs[#]>.001&), __?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"y"],
												{_?(Abs[#]<.001&),_?(Abs[#]>.001&),_?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"z"],
												{__?(Abs[#]<.001&),_?(Abs[#]>.001&)},
											True,
												_
											]
										}, 
									$Failed
									],
								r:{_,_}:>
									With[{els=screwClassesElements@r},
										If[els[[1,1]]==#["Order"]*#["Degree"],
											<|
												"Functions"->screwClasses[els[[1]]],
												"Element"->els
												|>,
											With[{o=#["Order"], d=#["Degree"]},
												<|
													"Functions"->
														Map[
															Simplify@Composition[
																RotationTransform[
																	2.\[Pi]/(o*d),
																	#[[2]],
																	center
																	],
																ReflectionTransform[
																	#[[2]],
																	center
																	]
																]&, els],
													"Element"->
														Map[{o, #[[2]]}&, els]
													|>
												]
											]
										]
								],
							cur=
								<|
									"Functions"->screwClasses[screws[[ind]]],
									"Element"->First@screwClassesElements@screws[[ind]]
									|>;
							screws=DeleteCases[screws, Alternatives@@screwClassesElements@screws[[ind]]];
							cur
							]
				]&,
			ct["SymmetryClasses"]
			]//Prepend[
						#,
						"SourceElements"->
							<|
								"Center"->sops["Elements", "Center"], 
								"PrincipalAxes"->
									{
										secondaryAxis,
										Normalize@Cross[primaryAxis, secondaryAxis],
										primaryAxis
										}
								|>
						]& 
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableSymmetryFunctionsFormatted*)



CharacterTableSymmetryFunctionsFormatted[symFs_]:=
	Dataset@
		Map[Replace[{{l_}:>l, l_List:>MatrixForm[l]}]]@
		KeyMap[Key["Formatted"]]@
		KeyDrop[symFs, {"SourceElements"}]


(* ::Subsubsection::Closed:: *)
(*charTabRepLinearSolve*)



charTabRepLinearSolve[mx_,
	b_,
	pick_,
	i_
	]:=
	Which[
		b==mx[[i]],
			ReplacePart[ConstantArray[0,Length[mx]], i->1],
		AnyTrue[mx, Norm[b-#]<.05&],
			Normalize[Boole[Norm[b-#]<.05]&/@mx],
		AnyTrue[mx, Norm[b+#]<.05&],
			Normalize[-Boole[Norm[b+#]<.05]&/@mx],
		True,
			ReplacePart[
				ConstantArray[0, Length[mx]],
				Thread[
					Position[pick, True][[All, 1]]->
						Quiet@
							Check[
								LinearSolve[Transpose@Pick[mx, pick], b],
								LeastSquares[Transpose@Pick[mx, pick], b]
								]
					]
				]
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableRepresentationMatrices*)



$charTableDOrbitalRep=
	{
		<|
			"Points"->{{1,0,0}, {0, 1, 0},{-1, 0, 0}, {0, -1, 0}},
			"Direction"->Apply[Cross[#,#2]&]
			|>,(* dx2-y2 *)
		<|
			"Points"->{{0,0,1}, {1,1,0},{0,0,-1}},
			(*I'm making this multi-dimensional to dinstinguish it from a p-oribtal*)
			"Direction"->Function[{1,1,Abs[#[[1,3]]]}]
			|> (* dz2 *),
		<|
			"Points"->{{1,1,0}, {1,- 1, 0},{-1,-1,0}, {-1, 1, 0}},
			"Direction"->Apply[Cross[#,#2]&]
			|> (* dxy *),
		<|
			"Points"->{{1,0,1}, {1,0, -1},{-1,0,-1}, {-1,0, 1}},
			"Direction"->Apply[Cross[#,#2]&]
			|> (* dxz *),
		<|
			"Points"->{{0,1,1}, {0,1, -1},{0,-1,-1}, {0,-1, 1}},
			"Direction"->Apply[Cross[#,#2]&]
			|> (* dyz *)
		};
$charTablePOrbitalRep=
	Map[
		<|
			"Points"->{#},
			"Direction"->First
			|>&,
		IdentityMatrix[3]
		];


CharacterTableRepresentationMatrix[
	fn_,
	center_,
	sourceElement_,
	coords_
	]:=
	With[
		{
			axisAlign=
				FirstCase[Lookup[coords, "AxisAlign", None],
					_List,
					None
					],
			shift=
				TrueQ@
					FirstCase[Lookup[coords, "CenterShift", False],
						True|False,
						False
						],
			pts=
				MapThread[
					Replace[#, 
						Except[_List]:>
							#2["Points"]
						]&,
					{
						Lookup[coords, "TestPoints"],
						coords
						}
					],
			dirs=
				Lookup[coords, "Direction"]
			},
		With[
			{
				newPts=
					If[ListQ@axisAlign,
						charTableAxisSysToElementTransform[
							center, 
							axisAlign, 
							sourceElement
							][If[shift, Map[#+center&, pts], pts]],
						If[shift, Map[#+center&, pts], pts]
						]
				},
			With[
				{
					oldDirs=
						MapThread[
							#2@#&,
							{
								newPts,
								dirs
								}
							],
					newDirs=
						MapThread[
							#2@Map[fn, #]&,
							{
								newPts,
								dirs
								}
							],
					dimensions=
						Length/@newPts
					},
			MapIndexed[
				With[{d=dimensions[[ #2[[1]] ]], i=#2[[1]]},
					charTabRepLinearSolve[
						oldDirs,
						#,
						MatchQ[d]/@dimensions,
						i
						]
					]&,
				newDirs
				]
			]
		]
	];


CharacterTableRepresentationMatrices[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:charTableRepListCoordVecPat
	]:=
	Map[
		CharacterTableRepresentationMatrix[
			#["Functions"][[1]],
			mapping["SourceElements", "Center"],
			#["Element"],
			coords
			]&,
		KeyDrop[mapping, {"SourceElements"}]
		]


CharacterTableRepresentationMatrices[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	"POrbitals"
	]:=
	CharacterTableRepresentationMatrices[
		mapping,
		Map[
			Join[
				<|
					"AxisAlign"->{0,0,1},
					"CenterShift"->True
					|>,
				#
				]&,
			$charTablePOrbitalRep
			]
		];
CharacterTableRepresentationMatrices[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	"DOrbitals"
	]:=
	CharacterTableRepresentationMatrices[
		mapping,
		Map[
			Join[
				<|
					"AxisAlign"->{0,0,1},
					"CenterShift"->True
					|>,
				#
				]&,
			$charTableDOrbitalRep
			]
		];


(* ::Subsubsection::Closed:: *)
(*CharacterTableRepresentationMatricesIrreducibleBlocks*)



CharacterTableRepresentationMatricesIrreducibleBlocks[mxes_]:=
	ConnectedComponents@*WeightedAdjacencyGraph@*ReplaceAll[0->\[Infinity]]/@mxes//
		Flatten[#, 1]&//SortBy[Length]//Reverse//
			DeleteDuplicatesBy[First]//DeleteDuplicatesBy[Last]//SortBy[First]


(* ::Subsubsection::Closed:: *)
(*CharacterTableMatrixIrreducibleRepresentations*)



(* ::Text:: *)
(*We\[CloseCurlyQuote]ll do this via a Graph because it just makes life easy*)



CharacterTableMatrixIrreducibleRepresentations//Clear


CharacterTableMatrixIrreducibleRepresentations[mxes:{__List}]:=
	With[
		{
			blocks=
				CharacterTableRepresentationMatricesIrreducibleBlocks[mxes]
				},
		Table[
			Map[mx[[#, #]]&, blocks],
			{mx, mxes}
			]
		];
CharacterTableMatrixIrreducibleRepresentations[els_Association]:=
	AssociationThread[
		Keys[els],
		CharacterTableMatrixIrreducibleRepresentations[Values[els]]
		]


CharacterTableMatrixIrreducibleRepresentationCharacters[els_Association]:=
	Map[Tr]/@CharacterTableMatrixIrreducibleRepresentations[els]


(* ::Subsubsection::Closed:: *)
(*CharacterTableIrreducibleRepresentationData*)



characterTableFormatIrrep[base_]:=
	With[
		{
			assoc=
				Join[
					<|
						"Parity"->"",
						"Modifier"->"",
						"Index"->""
						|>,
					base
					]
				},
		Join[
			<|
				"ID"->assoc["Type"]<>ToString@assoc["Index"]<>assoc["Parity"]<>assoc["Modifier"]
				|>,
			assoc,
			<|
				"Formatted"->
						Style[
								Row@{
									Replace[
										{
											assoc["Index"],
											assoc["Parity"]
											},
										{
											{0,""}:>assoc["Type"],
											{0,n_}:>Subscript[assoc["Type"],n],
											{n_,0}:>Subscript[assoc["Type"],n],
											{n_,m_}:>Subscript[assoc["Type"],Row@{n,m}]
											}
										],
									assoc["Modifier"]
									},
								ShowStringCharacters->False,
								StripOnInput->False
								]
				|>
			]
		]


CharacterTableIrreducibleRepresentationData[
	dim_,
	symClasses_,
	chars_
	]:=
	With[
		{
			principleAxis=
				First@
					MaximalBy[Select[symClasses, #["Type"]=="C"&], #["Order"]&]
			},
		Reap[
			"Type"->"A"//Sow;
			MapThread[	
				Function[
					If[#==principleAxis,
						Which[#2==1, "Type"->"A"//Sow, #2==-1, "Type"->"B"//Sow]
						];
					If[
						(#["Type"]=="C"&&#["Order"]==2&&#["Modifier"]!="")||
							(#["Type"]=="\[Sigma]"&&#["Modifier"]=="d"),
						Which[
							#2==1,
								"Index"->1//Sow,
							#2==-1,
								"Index"->2//Sow
							]
						];
					If[#["Type"]=="i",
						Which[
							#2==1,
								"Parity"->"g"//Sow,
							#2==-1,
								"Parity"->"u"//Sow
							]
						];
					If[(#["Type"]=="\[Sigma]"&&#["Modifier"]=="h"),
						Which[
							#2==1,
								"Modifier"->"'"//Sow,
							#2==-1,
								"Modifier"->"''"//Sow
							]
						]
					],
				{
					symClasses,
					Sign@chars
					}
				];
			Switch[dim,
				2,
					"Type"->"E"//Sow,
				3,
					"Type"->"T"//Sow,
				4,
					"Type"->"G"//Sow,
				5,
					"Type"->"H"//Sow
				]
			][[2]]//Flatten//Association//characterTableFormatIrrep
		]


(* ::Subsubsection::Closed:: *)
(*characterTableIrrepOrdering*)



characterTableIrrepOrdering[irreps_]:=
	Ordering[
		Switch[#["Type"],
			"A",
				0,
			"B",
				10,
			"E",
				20,
			"T",
				30,
			_,	
				0
			]+
		Switch[#["Index"],
			1,
				0,
			2,
				1,
			_,	
				0
			]+
		Switch[#["Parity"],
			"g",
				0,
			"u",
				100,
			_,	
				0
			]+
		Switch[#["Modifier"],
			"'",
				0,
			"''",
				1000,
			_,	
				0
			]&/@irreps
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableGenerate*)



CharacterTableGenerate[mxes_Association]:=
	Module[
		{
			reps=CharacterTableMatrixIrreducibleRepresentations@mxes,
			symClasses,
			chars,
			irreps,
			order
			},
		symClasses=Keys[reps];
		chars=Transpose@Map[Map@Tr]@Values@reps;
		irreps=
			MapThread[
				CharacterTableIrreducibleRepresentationData[
					#,
					symClasses,
					#2
					]&,
				{
					#[[All, 1]],
					#[[All, 2]]
					}&@
				DeleteDuplicatesBy[
					Thread@
						{
							Length/@reps[[1]],
							chars
							},
					Last
					]
				];
		order=characterTableIrrepOrdering@irreps;
		CharacterTable@
			<|
					"PointGroup"-><|"Formatted"->"??"|>,
					"CharacterTable"->DeleteDuplicates[chars][[order]],
					"SymmetryClasses"->symClasses,
					"IrreducibleRepresentations"->irreps[[order]]
					|>
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableReducibleRepresentationsList*)



(* ::Text:: *)
(*
Need a method to handle the problem of building a representation for a collection of coordinates, P,
with a collection of symmetry elements, S

We just need a matrix that represents S... 
i.e. find some A such that A.P = S(P) where S(P) = ( S(p1), S(p2), S(p3), ...), where S(p1) is represented as a coefficient vector in P
*)



CharacterTableReducibleRepresentationsList//Clear


charTableRepListCoordVecPat=
	{KeyValuePattern[{
		"Points"|"TestPoints"->_List,
		"Direction"->_
		}]..};
charTableRepListCoordPat=
	{{_?NumericQ,_,_}..}|Automatic;


charTableAxisSysToElementTransform//Clear


charTableAxisSysToElementTransform[
	center_,
	ax:{_?NumericQ, _, _},
	{n_Integer, l_List}
	]:=
	With[{v1=l-center, a=ax},
		If[Abs[Normalize[v1].a]>.9,
			Identity,
			RotationTransform[{v1, a}]
			]
		];
charTableAxisSysToElementTransform[
	center_,
	{ax1:{_, _, _}, ax2:{_, _, _}},
	{n_Integer, l_List}
	]:=
	With[
		{
			t1=
				charTableAxisSysToElementTransform[center, ax1, l]
			},
		t1
		];
charTableAxisSysToElementTransform[
	center_,
	ax:{_?NumericQ, _, _},
	{pt1_List, pt2_List}
	]:=
	With[{v1=Cross[pt1-center, pt2-center], a=ax},
		If[Abs[Normalize[v1].a]>.9,
			Identity,
			RotationTransform[{v1, a}]
			]
		];
charTableAxisSysToElementTransform[
	center_,
	{ax1:{_, _, _}, ax2:{_, _, _}},
	l:{pt1_List, pt2_List}
	]:=
	With[
		{
			t1=
				charTableAxisSysToElementTransform[center, ax1, l]
			},
		Simplify@Composition[
			Quiet@Check[
				RotationTransform[{
					t1@ax2, 
					pt1
					}],
				RotationTransform[{
					t1@ax2, 
					pt2
					}]
				],
			t1
			]
		];
charTableAxisSysToElementTransform[
	center_,
	ax1:{_?NumericQ, _, _},
	l:{pt1_List, pt2_List, pt3_List}
	]:=
	With[{v1=pt3, a=ax1},
		If[Abs[Normalize[v1].a]>.9,
			Identity,
			RotationTransform[{v1, a}]
			]
		];
charTableAxisSysToElementTransform[
	center_,
	{ ax1:{_?NumericQ, _, _}, ax2:{_?NumericQ, _, _}},
	l:{pt1_List, pt2_List, pt3_List}
	]:=
	With[
		{
			t1=
				charTableAxisSysToElementTransform[center, ax1, l]
			},
		Simplify@
			Composition[
				RotationTransform[{
					t1@ax2, 
					pt2
					}],
				t1
				]
		];
charTableAxisSysToElementTransform[
	center_,
	{ ax1:{_?NumericQ, _, _}, ax2:{_?NumericQ, _, _}, ax3:{_?NumericQ, _, _}},
	l:{pt1_List, pt2_List, pt3_List}
	]:=
	With[
		{
			t1=
				charTableAxisSysToElementTransform[center, {ax1, ax2}, l]
			},
		Simplify@
			Composition[
				RotationTransform[{
					t1@ax3, 
					pt1
					}],
				t1
				]
		];
charTableAxisSysToElementTransform[___]:=Identity


charTableRepCharacter[
	center_,
	corePt_, 
	testPts_,
	dirF_,
	op_
	]:=
	With[
		{
			oldpt=corePt,
			olddir=dirF@testPts,
			newpt=op[corePt],
			newdir=dirF[op/@testPts],
			cutOff=.1*Norm[corePt-center]
			},
			Which[
				(* Point moved *)
				Not[
					And@@
						MapThread[
							#2-cutOff<=#<=#2+cutOff&,
							{newpt,oldpt}
							]
					],
					0,
				(* Norm is 0 so we can't project *)
				Norm[newdir]*Norm[olddir]==0,
					If[Norm[newdir]+Norm[olddir]<.1,
						1,
						0
						],
				True,
					newdir.olddir/(Norm[newdir]*Norm[olddir])
				]
		]


CharacterTableReducibleRepresentationsList[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coordsAndVecs:charTableRepListCoordVecPat
	]:=
	GroupBy[First->Last]@Flatten@
		MapIndexed[
			With[
				{
					primax=
						mapping["SourceElements", "PrincipalAxes"],
					anc=
						Lookup[#, "AnchorPoint",
							Mean@#["Points"]
							],
					test=
						Lookup[#, "TestPoints",
							#["Points"]
							], 
					i=#2[[1]],
					dir=#["Direction"],
					axisAlign=Lookup[#, "AxisAlign", None],
					shift=Lookup[#, "CenterShift", False],
					center=mapping["SourceElements", "Center"]
					},
					Lookup[#, "Label", anc]->
						Table[
							With[
								{
									testTrue=
										If[ListQ@axisAlign,
											charTableAxisSysToElementTransform[
												center, 
												primax, 
												m["Element"]
												][If[TrueQ@shift, Map[#+center&, test], test]],
											If[TrueQ@shift, Map[#+center&, test], test]
											]
									},
								charTableRepCharacter[
									center,
									anc,
									testTrue,
									dir,
									m["Functions"][[1]]
									]
								],
							{m, Values@KeyDrop[mapping, {"SourceElements"}]}
							]
				]&,
			coordsAndVecs
			];


charTableCoordPat={({_?NumericQ, _, _}|{{_?NumericQ, _, _}..})..};


CharacterTableReducibleRepresentationsList[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:{{_,_,_}..},
	Optional["Cartesian", "Cartesian"]
	]:=
	CharacterTableReducibleRepresentationsList[
		mapping,
		Flatten@Table[
			Map[
				<|
					"AnchorPoint"->c,
					"TestPoints"->{#},
					"Direction"->First,
					"AxisAlign"->{{0,0,1}, {0, 1, 0}},
					"CenterShift"->True
					|>&,
				IdentityMatrix[3]
				],
			{c, coords}
			]
		];
CharacterTableReducibleRepresentationsList[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:{{_,_,_}..},
	"POrbitals"
	]:=
	CharacterTableReducibleRepresentationsList[
		mapping,
		Flatten@Table[
			Map[
				<|
					"AnchorPoint"->c,
					"TestPoints"->#["Points"],
					"Direction"->#["Direction"],
					"AxisAlign"->{0,0,1},
					"CenterShift"->True
					|>&,
				$charTablePOrbitalRep
				],
			{c, coords}
			]
		];
CharacterTableReducibleRepresentationsList[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:{{_,_,_}..},
	"DOrbitals"
	]:=
	CharacterTableReducibleRepresentationsList[
		mapping,
		Flatten@Table[
			Map[
				<|
					"AnchorPoint"->c,
					"TestPoints"->#["Points"],
					"Direction"->#["Direction"],
					"AxisAlign"->{0,0,1},
					"CenterShift"->True
					|>&,
				$charTableDOrbitalRep
				],
			{c, coords}
			]
		];
CharacterTableReducibleRepresentationsList[
	ct_, 
	sops_Association?(KeyMemberQ["Elements"]),
	coords:{{_,_,_}..},
	which:"Cartesian"|"POrbitals"|"DOrbitals":"Cartesian"
	]:=
	CharacterTableReducibleRepresentationsList[
		CharacterTableSymmetryFunctions[ct, sops],
		coords,
		which
		];
CharacterTableReducibleRepresentationsList[
	ct_, 
	sops_Association?(KeyMemberQ["Elements"]),
	coordsAndVecs:charTableRepListCoordVecPat
	]:=
	CharacterTableReducibleRepresentationsList[
		CharacterTableSymmetryFunctions[ct, sops],
		coordsAndVecs
		];
CharacterTableReducibleRepresentationsList[
	args__,
	coords_Association?(KeyMemberQ["Coordinates"]),
	which:("Stretches"|"Bends"|{("Stretches"|"Bends")..}):
		{"Stretches", "Bends"}
	]:=
	With[{
		bleh=
			Join@@
				MapThread[
					With[{type=#2},
						Map[
							<|
								"AnchorPoint"->Mean[#],
								"TestPoints"->#,
								"Direction"->ChemUtilsVibrationalCoordinateFunction[type]
								|>&,
							#
							]
						]&,
					{
						Lookup[coords["Coordinates"], Flatten@List@which],
						Flatten@List@which
						}
					]
			},
		If[Length@bleh>0,
			CharacterTableReducibleRepresentationsList[args,bleh],
			{}
			]
		];


(* ::Subsubsection::Closed:: *)
(*CharacterTableReducibleRepresentationsGrid*)



CharacterTableReducibleRepresentationsGrid//Clear


charTableLabListPat=
	{(Except[_List|_Association]|{Except[_?NumericQ]..})..}


charTableDefaultLabels={{"x","y","z"}};


CharacterTableReducibleRepresentationsGrid[
	ct_,
	gamma_Association?(AllTrue[ListQ]@*Keys),
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	With[{grid=
		Panel@
			With[{
				core=
					MapIndexed[
						With[
							{
								l=#, 
								num=ToString@First@#2,
								labs=labels[[Mod[#2[[1]], Length[labels], 1]]]
								},
							MapThread[
								Prepend[#,
									If[StringQ@#2, Subscript[#2,num], #2]
									]&,
								{
									l,
									Take[
										Flatten@ConstantArray[labs, Length@l],
										Length@l
										]
									}]
							]&,
						Values@KeyDrop[gamma, Key@{"Grid"}]
						]
				},
				Style[
					Grid[
						Prepend[
							Flatten[core,1],
							Prepend[ct["SymmetryClasses"][[All,"Formatted"]], ""]
							]
						],
					ShowStringCharacters->False
					]
				]
		},
	Interpretation[
		grid,
		Append[gamma, {"Grid"}->grid]
		]
	];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coordAndVecs:charTableRepListCoordVecPat,
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			fmapping,
			coordAndVecs
			],
		labels
		];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:{{Repeated[_?NumericQ, {3}]}..},
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			fmapping,
			coords
			],
		labels
		];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	symOps_Association?(KeyMemberQ["Elements"]),
	coordAndVecs:charTableRepListCoordVecPat,
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			CharacterTableSymmetryFunctions[ct, symOps],
			coordAndVecs
			],
		labels
		];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	symOps_Association?(KeyMemberQ["Elements"]),
	coords:{{___?NumericQ}..},
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			CharacterTableSymmetryFunctions[ct, symOps],
			coords
			],
		labels
		];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	a___,
	coords_Association?(KeyMemberQ["Coordinates"]),
	which:("Stretches"|"Bends"|{("Stretches"|"Bends")..}):
		{"Stretches", "Bends"},
	labels:charTableLabListPat:{{"r","\[Theta]","\[CurlyPhi]"}}
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			a,
			coords,
			which
			],
		labels
		];


(* ::Subsubsection::Closed:: *)
(*CharacterTableTotalRepresentation*)



CharacterTableTotalRepresentation//Clear


CharacterTableTotalRepresentation[
	gamma_Association
	]:=
	Round[Transpose[Join@@Values[gamma]]//Map[Total]];
CharacterTableTotalRepresentation[
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coordVecs:charTableRepListCoordVecPat
	]:=
	With[{r=CharacterTableReducibleRepresentationsList[fmapping, coordVecs]},
		If[Length@r>0,
			CharacterTableTotalRepresentation@r,
			{}
			]
		];
CharacterTableTotalRepresentation[
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords_List
	]:=
	CharacterTableTotalRepresentation@
		CharacterTableReducibleRepresentationsList[fmapping, coords];
CharacterTableTotalRepresentation[
	a__,
	coords_Association?(KeyMemberQ["Coordinates"]),
	which:("Stretches"|"Bends"|{("Stretches"|"Bends")..}):
		{"Stretches", "Bends"}
	]:=
	CharacterTableTotalRepresentation@
		CharacterTableReducibleRepresentationsList[a, coords, which];
CharacterTableTotalRepresentation[
	ct_,
	symOps_Association?(KeyMemberQ["Elements"]),
	b__
	]:=
	CharacterTableTotalRepresentation[
		CharacterTableSymmetryFunctions[ct, symOps],
		b
		];


(* ::Subsubsection::Closed:: *)
(*CharacterTableReduceRepresentation*)



CharacterTableReduceRepresentation//Clear


CharacterTableReduceRepresentationCoefficients[
	ctRows_List,
	symmClassCounts_,
	red_
	]:=
	(1/Total[symmClassCounts])*
		Map[
			Total@
				MapThread[
					Times,
					{
						symmClassCounts,
						red,
						#
						}
					]&,
			ctRows
			];


CharacterTableReduceRepresentation[
	characterRows_List,
	symmClassCounts_List,
	rep:{__Integer}
	]:=
	CharacterTableReduceRepresentationCoefficients[
		characterRows,
		symmClassCounts,
		rep
		];
CharacterTableReduceRepresentation[ct_CharacterTable, rep:{__Integer}]:=
	With[
		{
			characterRows=
				CharacterTableData[ct, "CharacterTable"],
			symmClassCounts=
				Lookup[CharacterTableData[ct, "SymmetryClasses"], "Count"],
			irreps=
				CharacterTableData[ct,"IrreducibleRepresentations"]
			},
		AssociationThread[
			irreps,
			CharacterTableReduceRepresentationCoefficients[
				characterRows,
				symmClassCounts,
				rep
				]
			]
		];
CharacterTableReduceRepresentation[ct_CharacterTable, {}]:={};
CharacterTableReduceRepresentation[s_String, rep:{___Integer}]:=
	CharacterTableReduceRepresentation[CharacterTableData[s], rep];
CharacterTableReduceRepresentation[ct_][rep:{___Integer}]:=
	CharacterTableReduceRepresentation[ct, rep];


(* ::Subsubsection::Closed:: *)
(*CharacterTableDirectProduct*)



CharacterTableDirectProduct[ct_, irs:{ir1_, irs2__}]:=
	With[{
		reps=
			Map[
				CharacterTableData[ct, {"IrreducibleRepresentation",#}, "Vector"]&,
				irs
				]},
		Times@@reps//CharacterTableReduceRepresentation[ct]
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableModeRepresentations*)



CharacterTableModeRepresentations[
	ct_,
	totalNuclearRep_Association
	]:=
	Module[
		{
			translations,
			rotations,
			vibrations
			},
		translations=
			Counts[
				Join@@
					Map[
						Pick[
							Keys@totalNuclearRep, 
							MemberQ[#]/@
								CharacterTableData[ct,"LinearFunctions"]
							]&,
						Join[
							{\[FormalX], \[FormalY], \[FormalZ]},
							Subsets[{\[FormalX], \[FormalY], \[FormalZ]}, {2, 3}]
							]
					]
				];
		rotations=
			Counts[
				Join@@
					Map[
						Pick[
							Keys@totalNuclearRep, 
							MemberQ[#]/@
								CharacterTableData[ct,"LinearFunctions"]
							]&,
						Join[
							{\[FormalCapitalR][\[FormalX]], \[FormalCapitalR][\[FormalY]], \[FormalCapitalR][\[FormalZ]]},
							Subsets[{\[FormalCapitalR][\[FormalX]], \[FormalCapitalR][\[FormalY]], \[FormalCapitalR][\[FormalZ]]}, {2,3}]
							]
					]
				];
		vibrations=
			Association@
				KeyValueMap[
					#->
						(#2 - ( Lookup[translations, #, 0] + Lookup[rotations, #, 0] ))&,
					totalNuclearRep
					];
		<|
			"Translations"->	
				translations,
			"Rotations"->
				rotations,
			"Vibrations"->
				vibrations
			|>
		];
CharacterTableModeRepresentations[
	ct_,
	redRep:{__Integer}
	]:=
	CharacterTableModeRepresentations[ct,
		CharacterTableReduceRepresentation[
			ct,
			redRep
			]
		];
CharacterTableModeRepresentations[
	ct_,
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords_List
	]:=
	CharacterTableModeRepresentations[ct,
		CharacterTableReduceRepresentation[
			ct,
			CharacterTableTotalRepresentation[
				fmapping,
				coords
				]
			]
		];
CharacterTableModeRepresentations[
	ct_,
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coordVecs:charTableRepListCoordVecPat
	]:=
	CharacterTableModeRepresentations[ct,
		CharacterTableReduceRepresentation[
			ct,
			CharacterTableTotalRepresentation[
				fmapping,
				coordVecs
				]
			]
		];


(* ::Subsection:: *)
(*SALCs*)



(* ::Subsubsection::Closed:: *)
(*SymmetryAdaptedProjection*)



charTabIrrepDims=
	<|
		"A"->1,
		"B"->1,
		"E"->2,
		"T"->3
		|>;


CharacterTableSymmetryAdaptedProjectionList//Clear


$CharacterTableSALCRounding=.1


CharacterTableSymmetryAdaptedProjectionList[
	center_,
	symmetryFunctions_List,
	irrepRow_List,
	irrepDim_Integer,
	vec:{Repeated[_?NumericQ,{3}]},
	coords:{Repeated[{Repeated[_?NumericQ,{3}]},{1,\[Infinity]}]}
	]:=
	MapThread[
		If[ListQ@#,
			Sequence@@(#2*Through[#@(vec)]),
			#2*(#[vec])
			]&,
		{
			Take[symmetryFunctions, UpTo[Length[irrepRow]]],
			irrepRow
			}
		];


CharacterTableSymmetryAdaptedProjectionList[
	ct_CharacterTable,
	repsToTry:_String|{__String}|All,
	sMapping_Association,
	vec:{Repeated[_?NumericQ,{3}]},
	coords:{Repeated[{Repeated[_?NumericQ,{3}]},{1,\[Infinity]}]}
	]:=
	With[
		{
			irrepPos=
				If[repsToTry===All,
					All,
					Position[
						CharacterTableData[ct, "IrreducibleRepresentations"],
						_Association?(StringMatchQ[Alternatives@@Flatten@{repsToTry}]@*Key["ID"]),
						{1}
						][[All,1]]
					],
			irreps=
				CharacterTableData[ct, "IrreducibleRepresentations"],
			cTab=
				CharacterTableData[ct, "CharacterTable"],
			symmetryFunctions=
				Flatten@Lookup[
					Lookup[
						sMapping,
						CharacterTableData[ct, "SymmetryClasses"]
						],
					"Functions"
					]
			},
		MapThread[
			CharacterTableSymmetryAdaptedProjectionList[
				sMapping["SourceElements", "Center"],
				symmetryFunctions,
				#2,
				charTabIrrepDims[#["Type"]],
				vec,
				coords
				]&,
			{
				irreps[[irrepPos]],
				cTab[[irrepPos]]
				}
			]
		];
CharacterTableSymmetryAdaptedProjectionList[
	ct_CharacterTable,
	repsToTry:_String|{__String}|All,
	sMapping_Association,
	coords:{
		Repeated[{Repeated[_?NumericQ,{3}]},{1,\[Infinity]}]
		}
	]:=
	Map[
		CharacterTableSymmetryAdaptedProjectionList[
			ct,
			repsToTry,
			sMapping,
			#,
			coords
			]&,
		coords
		]


(* ::Subsubsection::Closed:: *)
(*SALCs*)



charTableSalcCoordsPat=
	{(_->{_,_,_})..};


salcsCommonReplacements=
	ReplaceAll@
		Table[
			With[{r=r},
				num_?(NumericQ[#]&&FractionalPart[#/r]<.0001&):>
					IntegerPart[num/r]*r
				],
			{
				r,
					1/DeleteCases[Map[Sqrt, Range[100]], _Integer]
				}
			]


CharacterTableSALCs//Clear


CharacterTableSALCs[
	ct_CharacterTable,
	repsToTry:_String|{__String}|All:All,
	sMapping_Association,
	testCoords:({{_,_,_}..}|Automatic):Automatic,
	coords:charTableSalcCoordsPat
	]:=
	With[
		{
			irreps=
				Map[
					CharacterTableSymmetryAdaptedProjectionList[
						ct,
						repsToTry,
						sMapping,
						#,
						coords[[All,2]]
						]&,
					Replace[testCoords,
						Automatic:>coords[[All,2]]
						]
					]//Transpose,
			coordSys=	
				coords[[All,2]],
			coordVars=
				coords[[All,1]]
			},
		Association@
			MapThread[
				#2->
					Replace[{i_}:>i]@
					Map[
						Dot[coordVars, #]&,
						DeleteDuplicates[
							MapIndexed[
								salcsCommonReplacements@
								Rationalize@
								Normalize@
								Round[
									Total@
										With[{lists=#, ind=#2[[1]]},
											Map[
												charTabRepLinearSolve[
													coordSys,
													#,
													ConstantArray[True, Length[coordSys]],
													ind
													]&,
												lists
												]
											],
									.001
									]&,
								#
								],
							#==-#2||#==#2&
							]
						]&,
				{
					irreps,
					If[repsToTry===All,
						CharacterTableData[ct, "IrreducibleRepresentations"],
						Select[
							CharacterTableData[ct, "IrreducibleRepresentations"],
							StringMatchQ[Alternatives@@Flatten@{repsToTry}]@*Key["ID"]
							]
						]
					}
				]
		];
CharacterTableSALCs[
	ct_CharacterTable,
	repsToTry:_String|{__String}|All:All,
	sMapping_Association,
	coords_Association?(KeyMemberQ["Coordinates"]),
	which:("Stretches"|"Bends"|{("Stretches"|"Bends")..}):
		{"Stretches", "Bends"}
	]:=
	DeleteCases[None]@
		AssociationMap[
			With[{crds=
				With[{type=Switch[#, "Stretches", \[FormalR], "Bends", \[FormalTheta], "Wags", \[FormalCurlyPhi]]},
						MapIndexed[
							type[#2[[1]]]->#&,
							Mean/@coords["Coordinates", #]
							]
						]
				},
				If[Length@crds>0,
					CharacterTableSALCs[
						ct,
						repsToTry,
						sMapping,
						crds
						],
					None
					]
				]&,
			DeleteDuplicates@Flatten@{which}
			]


(* ::Subsubsection::Closed:: *)
(*SALCModes*)



CharacterTableSALCModes[salcs_]:=
	AssociationThread[
		If[KeyMemberQ[salcs, "Stretches"],
			Keys@salcs["Stretches"],
			Keys@salcs
			],
		If[KeyMemberQ[salcs, "Stretches"],
			Plus@@@Transpose@Values@
				Map[
					Map[Replace[{l_,___}:>l]]@*Values,
					salcs
					],
			Map[
				Replace[{l_,___}:>l],
				Values@salcs
				]
			]
		]


(* ::Subsection:: *)
(*Formatting*)



CharacterTableFormatReducedRepresentation[irrepAssoc_]:=
	Interpretation[
		Total@KeyValueMap[#["Formatted"]*#2&, irrepAssoc],
		irrepAssoc
		]


charTableFormalDemapping=
	<|
		\[FormalR]->"r",\[FormalTheta]->"\[Theta]",\[FormalCurlyPhi]->"\[CurlyPhi]",
		\[FormalS]->"s",\[FormalP]->"p",\[FormalD]->"d",
		\[FormalSigma]->"\[Sigma]",\[FormalPi]->"\[Pi]",\[FormalDelta]->"\[Delta]",
		\[FormalX]->"x",\[FormalY]->"y",\[FormalZ]->"z"
		|>


CharacterTableFormatSALCs[salcs_, irrepSelection_:All]:=
	With[
		{
			realSalcs=
				salcs/.{
				(k:Alternatives@@Keys[charTableFormalDemapping])[i_Integer]:>
					Style[Subscript[charTableFormalDemapping[k],i],
						ShowStringCharacters->False
						]
				}
			},
		If[KeyMemberQ[salcs, "Stretches"],
			Map[
				If[ListQ@irrepSelection,
					AssociationThread[
						Lookup[irrepSelection,"Formatted"],
						Map[MatrixForm]@Lookup[#,irrepSelection]
						],
					Map[Map[MatrixForm]@*KeyMap[Key@"Formatted"]]@salcs
					]&,
				realSalcs
				],
			If[ListQ@irrepSelection,
				AssociationThread[
					Lookup[irrepSelection,"Formatted"],
					Map[MatrixForm]@Lookup[realSalcs,irrepSelection]
					],
				Map[MatrixForm]@*KeyMap[Key@"Formatted"]@realSalcs
				]
			]
		]//Dataset


End[];



