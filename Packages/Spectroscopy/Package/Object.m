(* ::Package:: *)

(* Autogenerated Package *)

$SpectrumPropertyCache::usage=
  "Expression store for cached spectrum computation";
ChemSpectrumQ::usage=
  "Tests whether an object is a ChemSpectrum";
ChemSpectrumBuild::usage=
  "Creates the true ChemSpectrum object";
ChemSpectrumCopy::usage=
  "Copies a ChemSpectrum object and preserves its metadata/cache data";


ChemSpectrumModify::usage=
  "Creates a copy of the spectrum with modified parameters";
ChemSpectrumTransform::usage=
  "Applies a transformation to the spectrum data and returns a modifed spectrum";


Begin["`Private`"];


(* ::Subsection:: *)
(*Constructor*)



(* ::Subsubsection::Closed:: *)
(*ChemSpectrumQ*)



validateSpectrum[d_Association]:=
  AllTrue[{"Version"}, KeyExistsQ[d, #]&]&&
    AllTrue[{"Frequencies", "Intensities"}, Developer`PackedArrayQ@d[#]&]&&
      Length@d["Frequencies"]==Length@d["Intensities"];
ChemSpectrumQ[a_Association]:=
  validateSpectrum@a;
ChemSpectrumQ[spec_ChemSpectrum]:=
  validateSpectrum@InterfaceAssociation[ChemSpectrum, spec]


(* ::Subsubsection::Closed:: *)
(*continuousSpectrumQ*)



continuousSpectrumQ[spec_]:=
  spec["Mode"]==="Continuous"


(* ::Subsubsection::Closed:: *)
(*spectrumListQ*)



spectrumListQ[{a_List, b_List}]:=
  Length[a]===Length[b]//TrueQ;
spectrumListQ[d:{__List}]:=
  With[{dim=Dimensions[d]},
    Length[dim]==2&&dim[[-1]]==2
    ]//TrueQ;
spectrumListQ[__]:=
  False


(* ::Subsubsection::Closed:: *)
(*getSpectrumList*)



getSpectrumList[d_List]:=
  Module[
    {
      m=d
      },
    If[Length@Dimensions@m!=2,
        specError@
          "Spectral data must be a list of frequencies and intensities"
        ];
      m=Developer`ToPackedArray@m;
      If[!Developer`PackedArrayQ@m, m=Developer`ToPackedArray@N@m];
      If[!Developer`PackedArrayQ@m,
        specError@
          "Spectral data must be real-valued numeric"
        ];
      If[Last@Dimensions[m]==2, m=Transpose@m];
      m
    ]


(* ::Subsubsection::Closed:: *)
(*ChemSpectrumBuild*)



ChemSpectrumBuild//Clear


iChemSpectrumBuild[
  {freq_, ints_}, 
  meta_:Automatic,
  version_:Automatic,
  units_:Automatic
  ]:=
  Module[
    {a},
    a=
      <|
        "Frequencies"->Developer`ToPackedArray@freq,
        "Intensities"->Developer`ToPackedArray@ints,
        "Units"->Replace[units, Automatic->None],
        "MetaInfomation"->Replace[meta, Automatic-><||>]
        |>;
    validateSpectrum[a];
    a
    ];
iChemSpectrumBuild[
  l_List?spectrumListQ, 
  meta_:Automatic,
  version_:Automatic,
  units_:Automatic
  ]:=
  (
    iChemSpectrumBuild[
      Transpose@l,
      meta,
      version,
      units
      ]
    );
iChemSpectrumBuild[a_Association]:=
  reformatSpectrumObject[a];
ChemSpectrumBuild[e__]:=
  iChemSpectrumBuild[e];


(* ::Subsubsection::Closed:: *)
(*specError*)



specError[msg_, pars___]:=
  PackageRaiseException[Automatic,
    msg,
    pars
    ]


(* ::Subsubsection::Closed:: *)
(*ConstructChemSpectrumObject*)



ConstructChemSpectrumObject[d_List, meta_]:=
  ChemSpectrum[getSpectrumList[d], meta]


(* ::Subsubsection::Closed:: *)
(*reformatSpectrumObject*)



reformatSpectrumObject[a_Association]:=
    Module[
      {
        freq,
        int
        },
      freq=Lookup[a, "Frequencies", specError@"No frequencies provides"];
      If[Length@Dimensions@freq!=1, 
        specError@"Frequency data not a list of real numbers"
        ];
      freq=Developer`ToPackedArray@freq;
      If[!Developer`PackedArrayQ@freq, 
        specError@
          "Frequency data must be real-valued numeric"
        ];
      int=Lookup[a, "Intensities", specError@"No intensities provides"];
      If[Length@Dimensions@freq!=1, 
        specError@"Intensity data not a list of real numbers"
        ];
      int=Developer`ToPackedArray@int;
      If[!Developer`PackedArrayQ@int, 
        specError@
          "Intensity data must be real-valued numeric"
        ];
      Join[
        a,
        <|
          "Frequencies"->freq,
          "Intensities"->int
          |>
        ]
      ]


(* ::Subsection:: *)
(*Object Stuff*)



(* ::Text:: *)
(*
	Need to maintain a list of properties *not* to copy...
*)



(* ::Subsubsection::Closed:: *)
(*Copy*)



ChemSpectrumCopy[spec_, test:Except[_ChemSpectrum]:(True&)]:=
  With[{copy=ChemSpectrumBuild[Normal@spec]},
    ChemSpectrumCopy[spec, copy, test];
    copy
    ];
ChemSpectrumCopy[
  spec1_, 
  spec2_, 
  keyTest_:(True&)
  ]:=
  (
    InterfaceCopyProperties[spec1, spec2, keyTest];
    spec2
    )


(* ::Subsection:: *)
(*Modify*)



(* ::Subsubsection::Closed:: *)
(*Modify*)



(* ::Text:: *)
(*
	Modifies some part of a ChemSpectrum
*)



getModdedAss[
  spec_,
  specL:(_List?spectrumListQ)|Automatic:Automatic, 
  attrs:_?OptionQ|_?AssociationQ:<||>
  ]:=
  Module[
    {
      abase = InterfaceAssociation[ChemSpectrum, spec],
      pl=specL,
      meta,
      sp2
      },
    If[specL===Automatic,
      pl={spec["Frequencies"], spec["Intensities"]},
      pl=specL
      ];
    meta=Merge[
      {
        KeyDrop[
          abase, 
          {"Frequencies", "Intensities"}
          ],
        attrs
        },
      Last
      ];
    Merge[
      {
        abase,
        <|
          "Frequencies"->specL[[1]],
          "Intensities"->specL[[2]],
          "MetaInformation"->meta
          |>
        },
      If[AssociationQ@#[[1]],
        Merge[#, Last],
        Last[#]
        ]&
      ]
    ]


ChemSpectrumModify[
  spec_, 
  specL:_List?spectrumListQ|Automatic:Automatic, 
  attrs:_?OptionQ|_?AssociationQ:<||>
  ]:=
  InterfaceModify[
    ChemSpectrum,
    spec,
    getModdedAss[spec, specL, attrs]&
    ]


(* ::Subsubsection::Closed:: *)
(*Transform*)



ChemSpectrumTransform[spec_, fn_]:=
  ChemSpectrumModify[spec, 
    fn[{spec["Frequencies"], spec["Intensities"]}]
    ]


End[];



