(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ImportGaussianJob::usage=
	"Imports data from a Gaussian job";


ImportFormattedCheckpointFile::usage=
	"Imports results from an FChk file"


Begin["`Private`"];


(* ::Subsection:: *)
(*GaussianJob*)



iGaussianReadLink0[link0Block_]:=
	StringSplit[StringTrim@link0Block, "%"|Whitespace];


iGaussianReadDirectives[directives_]:=
	StringSplit[StringTrim@directives, "#"|Whitespace];


iGaussianJobReadChargeAndMultiplicity[mult_]:=
	Map[
		If[StringMatchQ[#, NumberString], ToExpression[#], #]&,
		StringTrim@StringSplit[mult, ","|" "]
		];
iGaussianJobReadAtoms[atoms_]:=
	ImportString[atoms, "Table"];
iGaussianJobReadVariables[vars_]:=
	Map[StringSplit, StringSplit[vars, "\n"]];
iGaussianJobReadConstants[consts_]:=
	Map[StringSplit, StringSplit[consts, "\n"]];
iGaussianJobReadBonds[bonds_]:=
	ImportString[bonds, "Table"];


iGaussianJobReadSystem[systemSpec_]:=
	Module[
		{
			specText,
			mults,
			atoms,
			vars,
			consts,
			bonds
			},
		{mults, specText}=StringSplit[systemSpec, "\n", 2];
		atoms=
			First@
				StringCases[specText,
					Repeated[
						(Whitespace|"")~~LetterCharacter~~Except["\n"|":"]..~~("\n"|EndOfString)
						]
					];
		specText=StringTrim[specText, atoms];
		vars=
			StringCases[specText,
				StartOfLine~~Except["\n"]..~~":"~~(Whitespace|"")~~"\n"~~
					varBlock:
						Repeated[
							(Whitespace|"")~~LetterCharacter~~Except["\n"|":"]..~~("\n"|EndOfString)
							]:>varBlock
				];
		Which[
			Length@vars>1, 
				consts=vars[[2]];
				vars=vars[[1]],
			Length@vars==1,
				vars=vars[[1]];
				consts="",
			True,
				vars="";
				consts="";
			];
		bonds=
			Replace[
				StringCases[
					specText,
					Repeated[
						(Whitespace|"")~~DigitCharacter~~Except["\n"|":"]..~~("\n"|EndOfString)
						]
					],
				{
					{}->"",
					{e_, ___}:>e
					}
				];
		<|
			"MultiplicityAndCharge"->
				iGaussianJobReadChargeAndMultiplicity@mults,
			"Atoms"->
				iGaussianJobReadAtoms@atoms,
			"Variables"->
				iGaussianJobReadVariables@vars,
			"Constants"->
				iGaussianJobReadConstants@consts,
			"Bonds"->
				iGaussianJobReadBonds@bonds
			|>
		]


iGaussianJobRead[cleanText_]:=
	With[{baseSplit=StringSplit[cleanText, "\n".., 4]},
		<|
			"Header"->
				<|
					"Link0"->iGaussianReadLink0@baseSplit[[1]],
					"Directives"->iGaussianReadDirectives@baseSplit[[2]],
					"Description"->StringTrim@baseSplit[[3]]
					|>,
			"System"->
				iGaussianJobReadSystem@baseSplit[[4]]
			|>
		];
iGaussianJobRead1[fullText_]:=
	iGaussianJobRead@
		StringTrim@
			StringDelete[fullText, "!"~~Except["\n"]..];


ImportGaussianJob[file:_String?FileExistsQ|_InputStream]:=
	ImportGaussianJob[ReadString@file];
ImportGaussianJob[str_String?(Not@*FileExistsQ)]:=
	iGaussianJobRead1[str];


(* ::Subsection:: *)
(*FormattedCheckPoint Files*)



Clear[iFormattedCheckpointRead];
ImportFormattedCheckpointFile::misfmt=
	"Misformatted fchk file or failed to extract from block appropriately. `` isn't an appropriate line specification.";
iFormattedCheckpointRead[
	stream_InputStream, 
	keys:_?StringPattern`StringPatternQ|All
	]:=
	Module[
		{
			header,
			line,
			lineParts,
			keyRaw,
			key,
			type,
			results=<||>
				},
			header=ReadList[stream,String, 2];
			Do[
				line=ReadList[stream, String, 1];
				(* If we've hit the end of the file we just return *)
				If[line==={}, Return[EndOfFile], line=line[[1]] ];
				(* If we've specified a subset of keys we make sure we're taking one of those *)
				If[StringStartsQ[line, " "],
					Message[ImportFormattedCheckpointFile::misfmt, line];
					results=Return[$Failed]
					];
				(* All lines are whitespace separated by multiple spaces *)
				lineParts=StringSplit[line, Repeated[" ", {2, \[Infinity]}]];
				(* The key is the first element *)
				keyRaw=lineParts[[1]];
				(* We'll reformat it to be more Mathematica appropriate *)
				key=
				StringJoin@
				Map[
					With[{base=Last@StringSplit[StringTrim[#, "/"],"/"]},
						ToUpperCase@StringTake[base, 1]<>StringDrop[base, 1]
						]&,
					 StringSplit[lineParts[[1]], " "]
					];
				If[keys=!=All&&!StringMatchQ[key, keys],Continue[]];
				(* The type is the second *)
				type=lineParts[[2]];
				(* Check if we're starting a block *)
				results[key]=
				If[lineParts[[3]]=="N=",
					Developer`ToPackedArray@
					ReadList[stream, Number, 
						ToExpression[lineParts[[4]]]
						],
					ToExpression@
					If[type=="R"&&
							StringLength[lineParts[[3]]]>4&&
							StringTake[lineParts[[3]], {-4}]=="E",
						StringReplacePart[lineParts[[3]], "*10^", {-4, -4}],
						lineParts[[3]]
						]
					],
				{i, \[Infinity]}
				];
			results
			];
iFormattedCheckpointRead[
	file_String?FileExistsQ, 
	keys:_?StringPattern`StringPatternQ|All
	]:=
	With[
		{
			strm=OpenRead@file
			},
		With[
			{
				 res=
				CheckAbort[iFormattedCheckpointRead[strm, keys], $Aborted]
				},
			Close[strm];
			res
			]
		];


Clear[iFormattedCheckpointCleanResults];
iFormattedCheckpointCleanResults[results_]:=
	Association@
		KeyValueMap[
			#->
			Which[
				StringEndsQ[#, "Density"],
					With[{sq=Sqrt[Length[#2]]},
						If[IntegerQ@sq&&Positive[sq], Partition[#2, sq], #2]
						],
				StringContainsQ[#, "Coordinates"],
					QuantityArray[Partition[#2, 3], "BohrRadius"],
				StringEndsQ[#, "Energy"],
					Quantity[#2, "Hartrees"],
				True,
					#2
				]&,
			results
			];


Options[ImportFormattedCheckpointFile]=
	{
		"KeyPattern"->All
		};
ImportFormattedCheckpointFile[
	file:_String?FileExistsQ|_InputStream, 
	ops:OptionsPattern[]
	]:=
	With[{res1=iFormattedCheckpointRead[file, OptionValue["KeyPattern"]]},
		If[AssociationQ@res1,
			iFormattedCheckpointCleanResults[res1],
			$Failed
			]
		];
ImportFormattedCheckpointFile[
	str:_String ,
	ops:OptionsPattern[]
	]:=
	ImportFormattedCheckpointFile[StringToStream[str], ops];


(* ::Subsection:: *)
(*Register*)



(*Map[
	ImportExport`RegisterImport[
		#,
		ImportGaussianJob
		]&,
	{"GJF", "GaussianJob"}
	]*)


(*Map[
	ImportExport`RegisterImport[
		#,
		ImportFormattedCheckpointFile,
		"FunctionChannels"->{"Streams"}
		]&,
	{"FCHK", "FormattedCheckpoint"}
	]*)


End[];



