(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



$ChemicalSystems::usage="List of valid systems";
$ChemDefaultSystem::usage="Default chemical system";
CreateChemicalSystem::usage="Creates a ChemSystem object";
ChemObject::usage="General head for object";
ChemMethod::usage=
	"Inert head that specifies a method should be constructed";
ChemProperty::usage=
	"Inert head that specifies a method should be called";
$ChemObjects::usage=
	"Register of name->function|association pairs for defaulting new objects";


ChemAdd::usage="Adds an object to the system";
ChemCopy::usage="Copies an object in a system";
ChemDeepCopy::usage="Copies an object and anything it references";
ChemRemove::usage="Removes a system";


ChemApply::usage="Applies a function to an object's definitions";
ChemReplaceAll::usage="Applies replace all to an object's definitions";


ChemMerge::usage=
	"Merges the current object definitions with a new set";
ChemJoin::usage=
	"Uses Join to create a composite object of the objects and associations provided";


ChemAssociation::usage=
	"Gets the object association for an object";
ChemGet::usage="Gets a property of a system or object";
ChemGetRecursive::usage=
	"Recursively applies ChemGet and returns the total accumulated list";
ChemSet::usage="Sets a property of a system or object";
ChemSetDelayed::usage="Sets a property of a system or object delayed";
ChemThreadSet::usage=
	"A threaded version of ChemSet for vectors";
ChemThreadSetDelayed::usage=
	"A threaded version of ChemSetDelayed for vectors";
ChemUnset::usage=
	"Unsets a property of a system or object";


ChemMutate::usage=
	"Changes a property based on the current value";
ChemIncrement::usage=
	"Increments a property using either an user specified or automatic increment function";
ChemDecrement::usage=
	"Decrements a property using either an user specified or automatic decrement function";
ChemAppendTo::usage="Special form of ChemIncrement";
ChemDeleteFrom::usage="Special form of ChemDecrement";


ChemClear::usage="Clears systems matching a string pattern";


$ChemStoreBase::usage=
	"The object base for ChemStores";
$ChemStores::usage=
	"The current ChemStores";
$ChemCloudStore::usage=
	"The object base for cloud objects";
$ChemLocalStore::usage=
	"The object base for local objects";


ChemStore::usage=
	"A cached ChemObject";
ChemStores::usage=
	"A listing of ChemStores in a given location";
ChemSave::usage=
	"Saves an object or System to a ChemCacheObject";
ChemLoad::usage=
	"Reloads an object from a ChemCacheObject";


ChemAddReference::usage=
	"Adds references to an object";
ChemRemoveReference::usage=
	"Removes a reference to an object";
ChemReferences::usage=
	"Gets the references of an object";
ChemRecursiveReferences::usage=
	"Gets the total reference structure";
ChemRemoveRecursive::usage=
	"Removes a total reference structure";
ChemObjectQ::usage="Checks whether an object is really an object";
ChemInstanceQ::usage=
	"Checks whether an object is an instance of a type";


ChemSelect::usage=
	"Applies Select or Pick to an object";


CreateAtom::usage=
	"Creates an atom";
AtomMove::usage=
	"Moves an atom";
AtomRotate::usage=
	"Rotates an atom around a point or vector";
AtomTransform::usage=
	"Applies a tranform to the position of an atom";


AtomIsotopeQ::usage="Checks whether an atom is an isotope or not";


AtomBondedQ::usage="Checks whether a bond exists to another atom";
AtomCanBondQ::usage="Checks that a bond can be formed between two atoms";
AtomAddBond::usage="Adds a bond object to an atom's bond list";
AtomRemoveBond::usage="Removes a bond object from an atom's bond list";
AtomCreateBond::usage="Creates a bond to another atom";
AtomGetBonds::usage="Gets bonds to atoms matching a pattern";
AtomBreakBond::usage="Breaks a bond to another atom";


AtomColor::usage="Gets an atom color";
AtomPartialCharge::usage="Gets an atom partial charge";
AtomValenceChoices::usage=
	"Gets the multiple valence states and atom can be in";
AtomValence::usage="Gets an atom valence";
AtomHybridization::usage="Gets an atoms hybridization state";


AtomGraph::usage=
	"Generates a graph of the atoms and their connections";
AtomGraphScan::usage=
	"Scans an AtomGraph";


AtomGraphic::usage="Gets a 2D atom graphics object";
AtomGraphic3D::usage="Gets a 3D atom graphics object";


CreateBond::usage=
	"Creates a bond";


BondCanFormQ::usage="";
BondFormedQ::usage="";
BondForm::usage="Creates a bond";
BondBreak::usage="Breaks a bond";


BondCenter::usage=
	"Gets the raw bond center";
BondCenterOfMass::usage=
	"Gets the bond COM";
BondMove::usage=
	"Moves a bond";
BondRotate::usage=
	"Rotates a bond";
BondNormal::usage=
	"Comuptes the normal to a bond-point plane";
BondTransform::usage=
	"Applies a transform to a bond";
BondRotationTransform::usage=
	"Returns a RotationTransform on the bond axis";


BondPolarization::usage="Gets bond polarization";
BondVector::usage="Gets a bond vector";
BondDeviation::usage="Gets a bond's deviation from its standard distance";


BondColors::usage=
	"Returns the colors for a bond";
BondGraphic::usage="Gets a 2D bond graphics object";
BondGraphic3D::usage="Gets a 3D bond graphics object";


CreateAtomset::usage="Creates an atom set";


AtomsetAddAtom::usage="Adds an atom to an atomset";
AtomsetRemoveAtom::usage="Removes an atom from an atomset";
AtomsetGetAtoms::usage="Gets atoms matching a property";


AtomsetJoin::usage=
	"Creates a new atomset from a collection of atomsets";


AtomsetEmpiricalFormula::usage=
	"Pulls the empirical formula for the atomset";


AtomsetElementPositions::usage=
	"Returns element position pairs for all the atoms";
AtomsetNeighborMap::usage=
	"Returns a map of an atom and its neighbors";
AtomsetMolTable::usage=
	"Returns a mol table form of the atomset";


AtomsetSubstituteAtom::usage=
	"Substitutes in a new atom for an old one";


AtomsetBondsIndexed::usage=
	"Returns an {i1, i2, type} matrix";
AtomsetBonds::usage=
	"Returns the bonds an {i, j} -> b association"; 
AtomsetBondLengths::usage=
	"Returns the indices and length for each bond in the atomset";
AtomsetBondVectors::usage=
	"Returns the indices and bond vector for each bond";
AtomsetMeanBondLengths::usage="Returns the mean bond length by atom type";


AtomsetNormalizeBonds::usage=
	"Normalizes bonds against the standard lookup table";


AtomsetBounds::usage=
	"Applies CoordinateBounds to atomset";
AtomsetMassPositions::usage=
	"Returns mass position pairs for all the atoms";
AtomsetCenter::usage="Returns the center of the atomset";
AtomsetCenterOfMass::usage="Gets the center of pass of the Atomset";
AtomsetMove::usage="Moves an atom set";
AtomsetTransform::usage="Applies a matrix mult or transformation to the atoms";
AtomsetRotate::usage="Rotates an atom set";
AtomsetRotationTransform::usage=
	"Returns a rotation transform on an atom set";
AtomsetAxisAlign::usage=
	"Aligns the atomset along a pair of axis specs";
AtomsetAlign::usage=
	"Aligns the atomset with another atomset";


AtomsetInertialTensor::usage="Returns the inertial tensor of the atomset";
AtomsetInertialEigensystem::usage="Returns the eigensystem of the atomset";
AtomsetInertialSystem::usage="Returns inertial system of atomset";
AtomsetPrincipalAxes::usage=
	"Returns the principal axes of the system with sizes equal to the moments";


AtomsetSymmetryElements::usage=
	"Finds the symmetry elements of the specified atoms in the atomset";
AtomsetInertialSymmetry::usage=
	"Finds the symmetry elements of the atomset relating to the inertial axes";
AtomsetPointGroup::usage=
	"Guesses the atomset point group";


AtomsetVdWSurface::usage="Returns a mesh of the Van der Waals surface of the atomset";
AtomsetVdWVolume::usage="Returns the Van der Waals volume of the atomset";


AtomsetCompile::usage=
	"Macro to generate function over the atoms in an atomset";
AtomsetPointCompile::usage=
	"Version of AtomsetCompile with Point as the first argument";


AtomsetPartialCharges::usage=
	"Calculates the Gasteiger partial charges";
AtomsetElectricPotential::usage=
	"Uses the partial charges to generate an esp function";


AtomsetElectricPotentialMap::usage=
	"Plots the electric potential on the VdW surface";


AtomsetOrbitals::usage=
	"Calculates orbitals for an atomset";
AtomsetOrbitalsPlot::usage=
	"Plots orbitals as DensityPlot3D";


AtomsetEnergyScan::usage=
	"Scans atomset energy with molecules in different positions";


(*AtomsetPolarMoment::usage="Returns a polarization gradient vector";
AtomsetPolarCenter::usage=
	"Uses FixedPoint to follow the polarization vectors";
AtomsetPolarMomentPlot::usage=
	"Uses compiled PolarMoment to generate a ChemSurfacePlot";
AtomsetPolarization::usage=
	"Returns the vector from the center of an atomset to its polar center";*)


AtomsetGraph::usage="Returns the graph of the atomset";
AtomsetGraphScan::usage=
	"Applies a BFS or DFS scan to atomset";
AtomsetConnectedComponents::usage=
	"Returns the collection of connected components for the atomset";


AtomsetRings::usage=
	"Returns the collection of rings for the atomset";
AtomsetConjugatedSystems::usage=
	"Returns the collection of conjugated systems for the atomset";
AtomsetAromaticRings::usage=
	"Returns the collection of aromatic rings for the atomset";
AtomsetAromaticQ::usage=
	"Checks whether an atom or collection of atoms are aromatic";


AtomsetAtomMemberQ::usage=
	"Checks whether an atom or collection of atoms are of a certain type";


AtomsetGraphic::usage="Gets a 2D atom set graphics object";
AtomsetGraphic3D::usage="Gets a 3D bond graphics object";


(*CreateChemset::usage="Creates a chem object set";*)


(*ChemsetGraphic::usage="Gets a 2D atom set graphics object";
ChemsetGraphic3D::usage="Gets a 3D bond graphics object";*)


AtomsetWrapper::usage=
	"A wrapper that acts like an atomset that creates and deletes itself";


$ChemFormatObjects::usage="A switch for whether to format objects or not";


ChemMove::usage=
	"Generalizes \[Star]Move operations";
ChemRotate::usage=
	"Generalizes \[Star]Rotate operations";
ChemTransform::usage=
	"Generalizes \[Star]Transform operations";


ChemView::usage="Views a ChemObject";
ChemViewList::usage=
	"ChemView / Manipulate combo";


ChemSurface::usage="Generates a surface from a graphic or ChemObject";
ChemSurfacePlot::usage="Plots a function on a surface";


ChemAnimate::usage=
	"Animates a command and view expression. 
Just ListAnimate / Table / Interpretation joined";
ChemSaveAnimation::usage=
	"Exports a set of frames to a file";


ChemImportString::usage=
	"Imports a chemical structure or structures from a string";
ChemImport::usage=
	"Routes imports to ChemImportString";


ChemEvaluate::usage=
	"An evaluation tag for ChemCompile";
ChemCompile::usage=
	"Compiles a function replacing the ChemTools` scope";
$ChemCompilePoint::usage=
	"The point used in ChemPointCompile";
$ChemCompileObject::usage=
	"The object using in ChemPointCompile";
ChemPointCompile::usage=
	"Compiles a function using a coordinate as the default argument";


Begin["`Private`"];


(* Load the symbolic python package *)
ToPython;


chemSys=ChemObject[_]?ChemObjectQ;
chemSysV={chemSys..};
chemObj=ChemObject[_,_]?ChemObjectQ;
chemObjV={chemObj..};
chemObjAll=(chemObj|chemObjV);
chemThings=(chemObj|chemSys);
chemVecs=(chemObjV|chemSysV);
chemThingsAll=(chemObj|chemObjV|chemSys|chemSysV);
chemOptionsPatternBase=(_Rule|_RuleDelayed)...;
chemOptionsPattern=
	chemOptionsPatternBase|{chemOptionsPatternBase}|{{chemOptionsPatternBase}..}


Get/@FileNames["*.m",PackageFilePath["Packages","ObjectCore_"]]


If[MatchQ[$ChemFormatObjects,Except[True|False]],$ChemFormatObjects=True];


Format[o_ChemObject/;($ChemFormatObjects&&ChemObjectQ@o)]:=
	With[{properties=Normal@o},
		RawBoxes@BoxForm`ArrangeSummaryBox[
			"ChemObject",
			o,
			Replace[
				If[MissingQ@ChemGet[o,"Graphics3D"],
					None,
					ChemView[o,ImageSize->{28,28}]
					],{
				g_Graphics3D:>
					Graphics[{
						Inset[g]
						},
						ImageSize->{32,32},
						Frame->True,
						FrameTicks->False,
						Background->GrayLevel[.95],
						FrameStyle->GrayLevel[.8]
						],
				_->None
				}],
			{
				BoxForm`MakeSummaryItem[{"Type: ",
					("ObjectType"/.properties)},StandardForm]
				},
			Append[
				Replace[
					Take[
						Normal@
							KeySortBy[Switch[#,"ObjectReferences",1,_,0]&]@
							KeyDrop[properties,{"ObjectType","ObjectKey"}],
						UpTo[3]],
					(Rule|RuleDelayed)[key_,prop_]:>
						BoxForm`MakeSummaryItem[{
							TemplateApply["``: ",key],
							Short[prop/.{
								ChemObject[s_,k_]:>
									StringJoin@StringSplit[k,"-"->"-"][[;;-11]],
								ChemObject[s_]:>
									StringJoin@StringSplit[s,"-"->"-"][[;;-11]]
								},1]
							},StandardForm],
					1
					],
				If[Length@properties>5,
					"\[Ellipsis]",
					Nothing
					]
				],
			StandardForm
			]
		];


Format[m:ChemMethod[f_]/;$ChemFormatObjects]:=
	RawBoxes@BoxForm`ArrangeSummaryBox[
		"ChemMethod",
		m,
		None,
		{
			BoxForm`MakeSummaryItem[{"Type: ","Bound Method"},StandardForm]
			},
		{
			BoxForm`MakeSummaryItem[{"Function",f},StandardForm]
			},
		StandardForm
		];


Format[m:ChemProperty[f_]]/;$ChemFormatObjects:=
	RawBoxes@BoxForm`ArrangeSummaryBox[
		"ChemProperty",
		m,
		None,
		{
			BoxForm`MakeSummaryItem[{"Type: ","Bound Property"},StandardForm]
			},
		{
			BoxForm`MakeSummaryItem[{"Function",f},StandardForm]
			},
		StandardForm
		]


Format[AtomsetWrapper[a_?validAtomsetWrapperQ]]:=
	RawBoxes@BoxForm`ArrangeSummaryBox[
		"AtomsetWrapper",
		AtomsetWrapper[a],
		None,
		{
			BoxForm`MakeSummaryItem[{"Atom Count: ",Length@a["Atoms"]},StandardForm],
			BoxForm`MakeSummaryItem[{"Bond Count: ",Length@a["Bonds"]},StandardForm]
			},
		{
			BoxForm`MakeSummaryItem[{"Atoms:",a["Atoms"]},StandardForm],
			BoxForm`MakeSummaryItem[{"Bonds: ",a["Bonds"]},StandardForm]
			},
		StandardForm
		];	


manyObj=chemObjAll|{chemObjAll..};


ChemGetApply[obj:manyObj,prop_,args___]:=
	With[{attrs=
		Block[{$ChemFormatMethods=True},
			ChemGet[Flatten@obj,prop]
			]
		},
		If[ListQ@attrs,
			Through[Map[Apply,attrs][{args}]],
			attrs[args]
			]
		];


ChemMove[obj:manyObj,pt_,mode:"Set"|"Add":"Add"]:=
	(ChemGetApply[obj,"Move",pt,mode];);
ChemMove[pt_,mode:"Set"|"Add":"Add"][obj:manyObj]:=
	ChemMove[obj,pt,mode];


ChemRotate[obj:manyObj,theta_,axis_:{0.,0.,1.},pt_:{0.,0.,0.}]:=
	(ChemGetApply[obj,"Rotate",
		theta,axis,pt];);
ChemRotate[theta_,axis_:{0.,0.,1.},pt_:{0.,0.,0.}][obj:manyObj]:=
	ChemRotate[obj,theta,axis,pt];


ChemTransform[obj:manyObj,transf_]:=
	(ChemGetApply[obj,"Transform",transf];);
ChemTransform[transf_][obj:manyObj]:=
	ChemTransform[obj,transf];


ChemView[obj:manyObj,mode:"2D"|"3D":"3D",
	directives:(Except[_String|_Rule|_RuleDelayed])...,
	ops:OptionsPattern[]]:=
	Switch[mode,
		"2D",
			Graphics[{
				directives,
				ChemGetApply[obj,"Graphic",
					FilterRules[{ops},
						Except[Alternatives@@Map[First,Options@Graphics]]
						]
					]
				},
				FilterRules[
					{ops},
					Options@Graphics
					]
				],
		"3D",
			Graphics3D[{
				directives,
				ChemGetApply[obj,"Graphic3D",
					FilterRules[{ops},
						Except[Alternatives@@Map[First,Options@Graphics3D]]
						]
					]
				},
				FilterRules[
					{ops,"Lighting"->"Neutral",Boxed->False},
					Options@Graphics3D
					]
				]
		];


ChemView[obj:manyObj,"Atoms",a___]:=
	ChemView[obj,"3D",
		a,
		"AtomicRadius"->.15,
		"BondThickness"->0
		];
ChemView[obj:manyObj,"Bonds",a___]:=
	ChemView[obj,"3D",
		a,
		"AtomicRadius"->0.,
		"BondThickness"->.1
		];
ChemView[obj:manyObj,"SpaceFilling",a___]:=
	ChemView[obj,"3D",
		a,
		"RadiusScaling"->1,
		"AtomicRadius"->Automatic
		];
ChemView[obj:manyObj,"TraditionalForm",a___]:=
	ChemView[obj,"3D",
		Specularity[White,100],
		a
		];
ChemView[obj:manyObj,"Tube",a___]:=
	ChemView[obj,"3D",
		Specularity[White,100],
		a,
		"AtomicRadius"->.15,
		"BondThickness"->.15,
		"DoubleBondSeparation"->None,
		"TripleBondSeparation"->None
		];
ChemView[obj:manyObj,"Line",a___]:=
	ChemView[obj,"3D",
		Specularity[White,100],
		a,
		"AtomicRadius"->.01,
		"BondThickness"->.01,
		"DoubleBondSeparation"->None,
		"TripleBondSeparation"->None
		];


ChemView[s:(_String|_Integer|{(_String|_Integer)..}),a___]:=
	Replace[ChemImport@s,
		c:chemObjAll:>
			With[{g=ChemView[c,a]},
				ChemRemoveRecursive@c;
				g
				]
		];	


ChemViewList[l_List,ops___]:=
	With[{
		len=Length@l,
		barSize=Rasterize[Slider[],"RasterSize"],
		bW=25
		},
		Manipulate[
			ChemView[l[[i]],ops],
			Framed[
				Grid[
					{
						{
							Button[
								Style["\[LeftTriangleBar]",Gray],
								i=1,
								Appearance->"AbuttingRight"(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,Last@barSize}*)],
							Button[
								Style["\[LeftTriangle]",Gray],
								i=Max@{i-1,1},
								Appearance->"AbuttingLeftRight"(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,Last@barSize}*)],
							Framed[
								Control@{{i,1,""},1,Length@l,1,
									ControlType->Manipulator},
								FrameMargins->{{0,10},{-1,-1}},
								FrameStyle->Directive[Thin,GrayLevel[.9]]
								],
							Button[
								Style["\[RightTriangle]",Gray],
								i=Min@{i+1,len},
								Appearance->"AbuttingLeftRight"(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,Last@barSize}*)],
							Button[
								Style["\[RightTriangleBar]",Gray],
								i=len,
								Appearance->"AbuttingLeft",
								FrameMargins->{{0,3},{-1,0}}(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,.5}*)]
							}
						},
					Spacings->0,
					Alignment->Top
					],
				RoundingRadius->5,
				FrameMargins->{{-2,-2},{-3,-2}},
				Background->White,
				FrameStyle->GrayLevel[.9]
				]
			]
		];


Options[ChemSurface]=
	Join[
		Options[BoundaryDiscretizeRegion],
		Options[DiscretizeGraphics]
		];
ChemSurface[g_Graphics3D,ops:OptionsPattern[]]:=
	With[{c=Cases[g,_Sphere,\[Infinity]]/.Sphere->Ball},
		If[Length@c>0,
			BoundaryDiscretizeRegion[
				RegionUnion@@c,
				FilterRules[{ops},
					Options@BoundaryDiscretizeRegion
					],
				PlotTheme->"SmoothShading"
				],
			DiscretizeGraphics[g,
				FilterRules[{ops},
					Options@DiscretizeGraphics
					],
				PlotTheme->"SmoothShading"
				]
			]
		];
ChemSurface[obj:chemObj,ops:OptionsPattern[]]:=
	ChemSurface@ChemView[obj,"SpaceFilling"];


(*Options[ChemSurfacePlot]={
	Function\[Rule]Compile[{{p,_Real,1}},Norm@p],
	InterpolatingFunction\[Rule]Compile[{{c,_Real,1}},Mean@c],
	ColorFunction\[Rule](Hue[1-.8*#]&),
	ColorFunctionScaling\[Rule]True
	};
ChemSurfacePlot[
	surface_?RegionQ,
	ops:OptionsPattern[]
	]:=
	With[{
		coordinateFunction=OptionValue@Function,
		interpolationFunction=OptionValue@InterpolatingFunction,
		colorFunction=OptionValue@ColorFunction,
		csScaling=TrueQ[OptionValue@ColorFunctionScaling]
		},
	Block[{
		csPlotCoordinateValues=coordinateFunction/@MeshCoordinates@surface,
		csPlotMinMax,csPlotMin,csPlotDiff,
		csPlotCellStyling},
		csPlotMinMax=MinMax@csPlotCoordinateValues;
		csPlotMin=First@csPlotMinMax;
		csPlotDiff=Abs@First@Differences@csPlotMinMax;
		csPlotCoordinateValues=
			Association@
				If[csScaling,
					If[csPlotDiff==0,
						MapIndexed[First@#2\[Rule].5&,
							csPlotCoordinateValues],
						MapIndexed[First@#2\[Rule](#-csPlotMin)/csPlotDiff&,
							csPlotCoordinateValues]
						],
					MapIndexed[First@#2\[Rule]#&,csPlotCoordinateValues]
					];
		csPlotCellStyling=
			With[{cf=
				colorFunction/.HoldPattern@ColorData[a__]\[RuleDelayed]
					RuleCondition[ColorData[a],True]},
			MapIndexed[
				Style[{2,First@#2},
					cf@interpolationFunction[First@#/.csPlotCoordinateValues]
					]&,
				MeshCells[surface,2]
				]
			];
		HighlightMesh[surface,
			csPlotCellStyling,
			PlotTheme\[Rule]"SmoothShading"
			]
		]
	];
ChemSurfacePlot[system_String,id_,f_,
	a___
	]:=
	With[{
		s=ChemSurface[system,id],
		ops=
			Sequence@@
				Normal@
					With[{op=Association@{
						ColorFunction\[Rule]({ColorData["TemperatureMap"]@#,Opacity[.65]}&),
						a
						}},
						If[FreeQ[op[ColorFunction],_Opacity],
							With[{cf=op[ColorFunction]},
								Append[op,ColorFunction\[Rule](Flatten@{cf@#,Opacity[.65]}&)]
								],
							op
							]
						]
			},
		Replace[
			ChemSurfacePlot[s,
				If[FreeQ[Hold[f],Point],
					f,
					AtomsetPointCompile[system,id,
						f
						]
					],
				ops
				],
			p:Except[_ChemSurfacePlot]:>
				Show[
					p,
					ChemView[system,id]
					]
			]
		];
ChemSurfacePlot[ChemObject[system_,id_],a__]:=
	ChemSurfacePlot[system,id,a];
ChemSurfacePlot~SetAttributes~HoldRest;*)


Options[ChemSurfacePlot]=
	Join[
		Options@SliceDensityPlot3D,
		Options@ChemSurface,{
		Quiet->True
		}];
ChemSurfacePlot[
	function_,
	surface_?RegionQ,
	ops:OptionsPattern[]
	]:=
	With[{m=MinMax@MeshCoordinates@surface},
		With[{
			drops=
				Sequence@@
					FilterRules[{ops,
						ColorFunction->ColorData["TemperatureMap"],
						Boxed->False,
						Axes->False
						},
					Options@SliceDensityPlot3D]
			},
			With[{h=
				Hold@
					SliceDensityPlot3D[function@{x,y,z},surface,
						{x,First@m,Last@m},
						{y,First@m,Last@m},
						{z,First@m,Last@m},
						drops
						]
				},
				If[OptionValue@Quiet//TrueQ,
					Quiet[ReleaseHold@h,CompiledFunction::cfta],
					ReleaseHold@h
					]
				]
			]
		];
ChemSurfacePlot[f_,
	obj_?ChemObjectQ,
	ops:OptionsPattern[]]:=
	With[{
		s=
		ChemSurface[obj,
			FilterRules[{ops},Options@ChemSurface]],
		opacity=
			Lookup[
				FilterRules[{ops},
					Opacity],
				Opacity,
				.85]
			},
		With[{
			pf=
				If[FreeQ[Hold[f],$ChemCompilePoint|$ChemCompileObject],
					f,
					Replace[Unevaluated[f],{
						c_ChemPointCompile:>
							c[obj],
						_:>
							Replace[ChemPointCompile[f],{
								c:Except[_CompiledFunction]:>
									c[obj]
								}]
						}]
					],
			pops=
				Sequence@@
					Replace[
						FilterRules[
							{
								ops,
								ColorFunction->ColorData["TemperatureMap"]
								},
							Options@ChemSurfacePlot],
						(ColorFunction->v_):>
							With[{cfOld=Replace[v,{_String|_Integer:>ColorData[v]}]},
								ColorFunction->
									(Directive[
										cfOld@#,
										Opacity[opacity]
										]&)
								],
						1]
			},
			Replace[
				ChemSurfacePlot[pf,s,pops],
				p:Except[_ChemSurfacePlot]:>
					Show[p,ChemView[obj]]
				]
			]
		];
ChemSurfacePlot~SetAttributes~HoldFirst;


chemAnimationTime=
	(_Times?(MatchQ[_Integer])|_Integer|_List|\[Infinity]);
chemAnimationObjs=
	manyObj|_Symbol?(MatchQ[manyObj])|
		{((_Symbol?(MatchQ[chemObjAll]))|manyObj)..};


ChemAnimate//ClearAll;
Options[ChemAnimate]=
	Join[
		Options@ListAnimate,{
		Prolog->{},
		Epilog->{},
		"AnimationTime"->10.,
		"ChemViewOptions"->{}
		}];
ChemAnimate[
	cmd_,
	steps:chemAnimationTime:10,
	ops:OptionsPattern[]]:=
	With[{
		frames=
			Join[
				Flatten@{OptionValue@Prolog},
				If[MatchQ[steps,_Integer|\[Infinity]],{cmd},{}],
				With[{
					start=Now,
					anmQ=
						Quantity[
							Replace[OptionValue@"AnimationTime",Except[_?NumericQ]->0],
							"Seconds"]
						},
					If[steps===\[Infinity],
						Reap[
							While[Now-start<anmQ,
								Sow@cmd
								]
							][[2,1]],
						Table[
							If[Now-start<anmQ,
								cmd,
								Nothing
								],
							steps
							]
						]
					],
				Flatten@{OptionValue@Epilog}
				]},
		Interpretation[
			ListAnimate[frames,
				FilterRules[{ops},Options@ListAnimate]],
			frames
			]
		];
ChemAnimate[
	obj:chemAnimationObjs,
	mutate_,
	steps:chemAnimationTime:10,
	ops:OptionsPattern[]]:=
	With[{cvops=
		Sequence@@
			Flatten@{OptionValue@"ChemViewOptions"}
			},
		ChemAnimate[
			mutate@obj;
			ChemView[obj,cvops],
			steps,
			ops,
			Prolog->{ChemView[obj,cvops]}
			]
		];
SyntaxInformation[ChemAnimate]=
	{
		"ArgumentsPattern"->{_,_.,_.,OptionsPattern[]},
		"LocalVariables"->{Table,{2,3}}
		};
ChemAnimate~SetAttributes~HoldAll;


ChemSaveAnimation[file_,
	frames_List|Interpretation[_,frames_List],
	ops:OptionsPattern[]]:=
	With[{images=
		Rasterize[#,"Image",FilterRules[{ops},Options@Rasterize]]&/@
			frames
			},
		With[{dims=ImageDimensions@First@images},
   	 Export[file,
   	 	ImageResize[ColorConvert[#, "RGB"], dims] & /@ images,
   	 	ops
   	 	]
    	]
    ]


ZMatrixStringPattern1=
	((StartOfLine|Whitespace)~~LetterCharacter..~~(Whitespace|EndOfLine));
ZMatrixStringPattern2=
	((StartOfLine|Whitespace)~~LetterCharacter..~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~(Whitespace|EndOfLine));
ZMatrixStringPattern3=
	((StartOfLine|Whitespace)~~LetterCharacter..~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~(Whitespace|EndOfLine));
ZMatrixStringPattern4=
	((StartOfLine|Whitespace)~~LetterCharacter..~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~(Whitespace|EndOfLine));


ChemDataZMatrixStringPattern=
	ZMatrixStringPattern1|
	(ZMatrixStringPattern1~~ZMatrixStringPattern2)|
	(ZMatrixStringPattern1~~ZMatrixStringPattern2~~ZMatrixStringPattern3)|
	(ZMatrixStringPattern1~~ZMatrixStringPattern2~~
		ZMatrixStringPattern3~~(ZMatrixStringPattern4..));


MolTableLineStringPattern1=
	(StartOfLine|Whitespace)~~LetterCharacter..~~
		Whitespace~~NumberString~~
		Whitespace~~NumberString~~
		Whitespace~~NumberString;
MolTableLineStringPattern2=
	(
		(StartOfLine|Whitespace)~~NumberString~~
		Whitespace?(Not@*StringContainsQ["\n"])~~NumberString~~
		Whitespace?(Not@*StringContainsQ["\n"])~~NumberString~~
		Whitespace?(Not@*StringContainsQ["\n"])~~LetterCharacter..~~
		Except["\n"]..
		);


ChemDataMolTableStringPattern=
	(
		((MolTableLineStringPattern1~~(Whitespace|"")~~EndOfLine)..)|
		((MolTableLineStringPattern2~~(Whitespace|"")~~EndOfLine)..)
		);


BondLineStringPattern=
	(
		(StartOfLine|Whitespace)~~DigitCharacter..~~
			Whitespace~~DigitCharacter..~~(Except["\n"]...)
		);


ChemDataBondBlockStringPattern=
	(BondLineStringPattern~~EndOfLine)..;


chemImportZMatrix[table_]:=
	With[{chunks=
		SequenceCases[SplitBy[table,MatchQ@{_String,___}],
			s:{ {{_String,___},___},{{_Integer,___},___} }|{{{_String,___},___}}:>
				Join@@s
			]},
		Table[
			With[{
				a=ChemUtilsGenerateMolTable@Cases[t,{_String,___}],
				b=Cases[t,{_Integer,_Integer,_Integer}|{_Integer,_Integer}]
				},
				Join[
					{{Length@a,Length@b}},
					a,
					b
					]
				],
			{t,chunks}
			]
		];


chemImportMolTable[string_String]:=
	chemImportMolTableString/@
		Select[
			StringSplit[string,
				"$$$$"
				],
			StringContainsQ["V2000"|"V3000"]
			];
chemImportMolTable[l_List]:=
	chemImportMolTableList/@
		DeleteCases[{"$$$$"}]@
			Split[
				l,
				MatchQ[{"$$$$"}]
				];


chemMolImportAtoms[stringChunks:{__String}]:=
	With[{chunks=
		StringTake[stringChunks,{
			{1,10},(*Positions*)
			{11,20},
			{21,30},
			{31,34}(*Element*)(*
			{34,-1}(*Rest*)*)
			}]
		},
		{
			StringTrim@#[[4]],
			ToExpression@Take[#,3]
			(*,
			ImportString[#[[5]],"Table"]*)
			}&/@chunks
		];
chemMolImportBonds[stringChunks:{__String}]:=
	With[{chunks=
		StringTake[stringChunks,{
			{1,3},
			{4,6},
			{7,9}(*,
			{10,-1}*)
			}]
		},
		ToExpression@chunks[[All,;;3]]
		];
basicDigitPattern=
	(
		("  "~~DigitCharacter)|
		(" "~~DigitCharacter)|
		DigitCharacter
		);
chemImportMolTableString[s_String]:=
	With[{blockChunks=
		Join[
			StringCases[
				s,{
				StartOfString~~id:(Except["\n"]..):>
					{"Props","ID"->id},
				StartOfString~~(Except["\n"]..)~~"\n"~~
					"  "~~name:(Except["\n"]..):>
					{"Props","IDTag"->name},
				(StartOfLine~~nums:((basicDigitPattern)~~
					(Except["\n"]..))~~("V2000"|"V3000")):>
					{"Numbers",ToExpression@StringTake[nums,{{1,3},{4,6}}]},
				(
					"> <"~~prop:Except[">"]..~~">"~~val:Except["<"]..~~"\n\n":>	
						RuleCondition[
							{"Props",
								StringJoin@
									(
										(
											Switch[#,
												(*
										Replace isn't capturing the variable appropriately here for 
										who knows what reason
										*)
												"pubchem",
													Nothing,
												"id",
													"ID",
												"rmsd",
													"RMSD",
												"cid",
													"CID",
												"mmff94",
													"MMFF94",
												"sid",
													"SID",
												_,
													ToUpperCase[StringTake[#,1]]<>
														StringTake[#,{2,-1}]
												]
											)&/@ToLowerCase@StringSplit[prop,"_"]
										)->
										Replace[
											DeleteCases[{}]@ImportString[val,"Table"],{
											{{i_}}:>i,
											l:{{_}..}:>Flatten[l]
											}]
									},
							True
							]
					)
				}],
			StringCases[
				StringSplit[s,
					(StartOfLine~~((basicDigitPattern)~~
						(Except["\n"]..))~~("V2000"|"V3000"))|
					"M "
					][[2]],{
				l:(StartOfLine~~("  -"|"   ")~~Except["\n"]..~~"\n"):>
					If[StringLength@l>=30,
						{"Atoms",l},
						l
						],
				l:(
					StartOfLine~~(
						("  "~~DigitCharacter)|
						(" "~~DigitCharacter)|
						DigitCharacter
						)~~Except["\n"]..~~"\n"):>
						If[StringLength@l>=9,
							{"Bonds",l},
							l
							]
				}]
			]},
			With[{data=KeySort@GroupBy[blockChunks,First->Last]},
				{
					Join[
						data["Numbers"],
						chemMolImportAtoms[data["Atoms"]],
						chemMolImportBonds[data["Bonds"]]
						],
					data["Props"]
					}
				]
		];


ChemImport::molst="Unable to find beginning of MolTable block";
chemImportMolTableList[table_List]:=
	Block[{$atomBondCount={\[Infinity],\[Infinity]}},
		Replace[
			Reap[
				Replace[table,{
					{atomCount_,bondCount_,___,"V2000"|"V3000"}:>
						With[{ab=
							If[atomCount>999,
								FromDigits/@
									Partition[IntegerDigits@atomCount,UpTo[3]],
								{atomCount,bondCount}
								]
							},
							Sow@"START";
							Sow@ab
							],
					{crd1_Real,crd2_Real,crd3_Real,elm_String,massDifference_,
						charge_,hCount_,stereoFlag_,hCount2_,__,
						aMap_,invRet_,exactChg_}:>
						Sow@{elm,{crd1,crd2,crd3}},
					{atom1_Integer,atom2_Integer,bondType_Integer,otherShit___}:>
						Sow@
							If[atom1>999,
								Append[
									With[{try1=
										FromDigits/@
											Partition[IntegerDigits@atom1,UpTo[3]]
										},
										If[AnyTrue[try1,#>First@$atomBondCount&],
											FromDigits@*Reverse/@
												Partition[Reverse@IntegerDigits@atom1,
													UpTo[3]]
											]
										],
									atom2
									],
								{atom1,atom2,bondType}
								],
					{"M","END"}:>
						Sow@"END",
					{">",s_String?(StringMatchQ["<*>"])}:>
						Sow["PROP"->s],
					e_:>Sow@e
					},
					1]
				][[2]],
				{
					e:Except[{{___,"START",___}}]:>(
						Print@e;
						Message[ChemImport::molst];
						$Failed
						),
					e_:>(parseMolTable@First@e)
					}
				]
		];


parseMolTable[atomList:{___,"START",__}]:=
	SequenceCases[atomList,
		{
			id_:None,
			idTag_:None,
			___,
			"START",bits:Shortest@__,"END",p___}:>
			{
				{
					bits
					},
				Join[
					{
						"ID"->id,
						"IDTag"->idTag
						},
					Map[Last@First@#->Rest[#]]&/@
						Block[{flag=True},
							Split[{p},
								Function[
									If[MatchQ[#,"PROP"->_],
										flag=Not@flag
										];
									flag
									]
								]
							]
					]
				}	
		];


getElemColors[]:=
	Replace[
		$elemsByColor,
		Except[_Association]:>
			($elemsByColor=
				DeleteCases[
					AssociationMap[
						ElementData[#,"IconColor"]&,
						ChemTools`Private`$ChemElements//Keys
						],
					$Failed
					]
				)
		];
elemByColor[c_]:=
	With[{elems=getElemColors[]},
		SelectFirst[
			Keys@elems,
			Replace[elems[#],{
				ec_?ColorQ:>
					(ColorDistance[ec,c]<.1),
				_->False
				}]||
			Replace[ColorData["Atoms"][#],{
				ec_?ColorQ:>
					(ColorDistance[ec,c]<.1),
				_->False
				}]&,
			"X"
			]
		];


graphics3DGetAtoms[{color_,crds__}]:=
	With[{e=elemByColor@color},
		Map[{e,#}&,{crds}]
		];


graphics3DGetBonds[{origCrds_,atomCrds_}]:=
	With[{bondCrds=Replace[origCrds,(l_List->_):>l,1]},
		With[{pairs=
			DeleteDuplicatesBy[Sort]@*Join@@
				Replace[bondCrds,{
					{
						a_?(Norm[First@Nearest[atomCrds,#]-#<.1]&),
						b_?(Norm[First@Nearest[atomCrds,#]-#<.1]&)
						}:>
						With[{
							a1=First@Nearest[atomCrds,a,1],
							a2=First@Nearest[atomCrds,b,1]
							},
							If[a1==a2,
								Nothing,
								{{a1,a2}}
								]
							],
					{a_,b_}:>
						Join[
							Cases[bondCrds,
								{a,i:Except[b]}|{i:Except[b],a}:>{b,i}
								],
							Cases[bondCrds,
								{i:Except[a],b}|{b,i:Except[a]}:>{a,i}
								]
							]
						},
					1]
				},
			(*Append[#,1]&/@*)
				Select[
					pairs,
					AllTrue[#,MemberQ[atomCrds,#]&]&
					]
			]
		];


graphicsComplexImport[gc_]:=
	With[{
		coords=First@gc,
		objs=Cases[gc[[2]],_RGBColor|_Sphere|_Ball|_Cylinder,\[Infinity]]},
		With[{
			balls=
				SequenceCases[objs,
					{_RGBColor,(_Sphere|_Ball)..},
					\[Infinity]],
			sticks=
				SequenceCases[objs,
					{_RGBColor,(_Cylinder)..},
					\[Infinity]
					]
			},
			With[{
				atoms=
					Join@@Map[
							graphics3DGetAtoms@*
								ReplaceAll[ (Sphere|Ball)[p_,___]:>p ],
							balls
							]},
				{
					atoms,
					graphics3DGetBonds@{
						Cases[sticks,
							Cylinder[{i_Integer,j_Integer},___]:>
								{i,j}
							,\[Infinity]],
						Last/@atoms
						}
					}/.i_Integer:>coords[[i]]
				]
			]
		];


graphicsImportSpheresBallsAndCylinders[objs_]:=
	With[{objSet=
		Cases[objs,_RGBColor|_Sphere|_Ball|_Cylinder,\[Infinity]]
		},
		With[{
			balls=
				SequenceCases[objSet,
					{_RGBColor,(_Sphere|_Ball)..},
					\[Infinity]],
			sticks=
				Cases[
					ReplaceAll[objSet,
						l:{___,_Cylinder,___}:>
							SplitBy[l,
								MatchQ[_Cylinder]
								]
						],{
					Except[_Cylinder]...,
					c:__Cylinder|{__Cylinder},
					Except[_Cylinder]...
					}:>
						Flatten@{c},\[Infinity]]
			},
			With[{
					atoms=
						Join@@Map[
								graphics3DGetAtoms@*
									ReplaceAll[ (Sphere|Ball)[p_,___]:>p ],
								balls
								]},
					{
						atoms,
						graphics3DGetBonds@{
							Map[
								FirstCase[#,
									p:{{__?NumericQ},{__?NumericQ}}:>
										(p),
									Nothing,
									\[Infinity]
									]&,
								sticks
								],
							Last/@atoms
							}
						}
					]
				]
			];


chemImportGraphics3D[data_Graphics3D]:=
	With[{as=
		Replace[FirstCase[data,_GraphicsComplex,None,\[Infinity]],{
			None:>
				graphicsImportSpheresBallsAndCylinders@data,
			gc_:>
				graphicsComplexImport@gc
			}]
		},
		List@
			Join[
				With[{m=
					Replace[
						Replace[(Norm@*Subtract@@@Last@as),{
							{}->0,
							m:{__}:>Mean@m
							}],
						i_?(#>0&):>
							Floor@Log10@i
						]},
						If[m>0,
							Map[{First@#,Last@#/10^m}&,First@as],
							First@as
							]
					],
				With[{aps=Last/@First@as},
					Sort@
						Map[
							First@First@Position[aps,#]&,
							Last@as,
							{2}]
					]
				]
		];


(*chemImportGraph[data_Graph]:=
	With[{
		nodes=VertexList@data,
		c=Options[data,VertexStyle],
		w=Normal@WeightedAdjacencyGraph@data},
		Vertex coordinates would have to be explicitly specified, though.
		
		];*)


chemImport[
	system:_String|ChemObject[_]|Automatic:Automatic,
	atomSets_List
	]:=
	With[{sys=Replace[system,Automatic:>$ChemDefaultSystem]},
		Replace[
			CreateAtomset[sys,#]&/@atomSets//Flatten,{
			{}->None,
			{a_}:>a
			}]
		];


ChemImport::noobj=
	"Unable to construct ChemObject check input file or contact me";
ChemImportString[
	system:chemSys|Automatic:Automatic,
	string_String,
	format:"MolTable"|"ZMatrix"]:=
	Switch[format,
		"MolTable",
			chemImport[system,
				chemImportMolTable@string],
		"ZMatrix",
			chemImport[system,
				chemImportZMatrix@ImportString[string,"Table"]]
		];
ChemImportString[
	system:chemSys|Automatic:Automatic,
	string_String,
	Optional[Automatic,Automatic]]:=
	With[{attempts=
		If[StringContainsQ[string,"V2000"|"V3000"],
			{"MolTable","ZMatrix"},
			{"ZMatrix","MolTable"}
			]
		},
		Replace[
			ChemImportString[system,string,First@attempts],{
			Except[_ChemObject|{__ChemObject}]:>
				Replace[
					Quiet@
						ChemImportString[system,string,Last@attempts],
					e:Except[_ChemObject|{__ChemObject}]:>(
						Message[ChemImport::noobj];
						$Failed
						)
					]
			}]
		]


ChemImport[
	system:chemSys|Automatic:Automatic,
	file:_File|_String?FileExistsQ,
	format:"MolTable"|"ZMatrix"|Automatic:Automatic]:=
	With[{form=
		Replace[format,
			Automatic:>
				Switch[FileExtension@file,
					"mol"|"sdf",
						"MolTable",
					"gjf",
						"ZMatrix",
					_,
						Automatic
					]
				]
			},
		ChemImportString[system,Import[file,"Text"],form]
		];


ChemImport[
	system:chemSys|Automatic:Automatic,
	file:_URL|_String?(URLParse[#]["Scheme"]=!=None&),
	format:"MolTable"|"ZMatrix"|Automatic:Automatic]:=
	With[{f=URLDownload@file},
		If[FileExistsQ@f,
			ChemImport[system,f,format],
			$Failed
			]
		];	


ChemImport::no3d=
	"No 3D structure found for identifier ``. Attempting to use a 2D structure instead";
ChemImport::nostr=
	"No structure found for identifier ``";
ChemImport[
	system:chemSys|Automatic:Automatic,
	structure:
		_PubChemCompound|
		_PubChemSubstance|
		_Integer|
		Entity["Chemical",_]|
		_String?(
			Not@FileExistsQ@#&&
			Not@StringContainsQ[#,"\n"|$PathnameSeparator]
			&),
	format:"MolTable"|"ZMatrix"|Automatic:Automatic]:=
	Replace[
		Replace[
			Quiet[ChemDataLookup[structure,"SDFFiles"],ServiceExecute::serrormsg],
			$Failed:>(
				Message[ChemImport::no3d, structure];
				ChemDataLookup[structure,"2DStructures",
					"Overwrite"->True]
				)
			],{
		mol_String:>
			ChemImportString[system,mol,"MolTable"],
		mols:{__String}:>
			Map[ChemImportString[system,#,"MolTable"]&,mols],
		_:>(Message[ChemImport::nostr,structure];$Failed)
		}];


ChemImport[
	system:chemSys|Automatic:Automatic,
	data_Graphics3D
	]:=
	chemImport[system,chemImportGraphics3D@data];


(*ChemImport[
	system:chemSys|Automatic:Automatic,
	data_Graph
	]:=
	chemImport[system,chemImportGraph@data];*)


$ChemImportableTypes=
	(
		_Graphics3D|_String|_Integer|Entity["Chemical",_]|
		_File|_URL|
		_PubChemCompound|_PubChemSubstance
		);


ChemImport[system:chemSys|Automatic:Automatic,
	data:{$ChemImportableTypes..}
	]:=
	ChemImport[system,#]&/@data;


ChemImport[
	system:chemSys|Automatic:Automatic,
	s_Symbol?(Not@*MatchQ[$ChemImportableTypes|{$ChemImportableTypes..}])
	]:=
	(s=ChemImport[system,SymbolName[Unevaluated[s]]]);
ChemImport[system:chemSys|Automatic:Automatic,
	s_?(MatchQ[$ChemImportableTypes|{$ChemImportableTypes..}]),
	o___
	]:=
	ChemImport[system,s,o];
ChemImport[
	a___
	]/;!TrueQ[$ChemImportInImport]:=
	Block[{$ChemImportInImport=True},
		With[{l={a}},
			ChemImport@@l
			]
		]


ChemImport~SetAttributes~HoldFirst;


ChemEvaluate[expr_]:=
	Evaluate[expr];


ChemCompile[spec:{{_,_Blank,___}...},
	code_,
	ops___
	]:=
	With[{expr=
		Hold[code]/.{
			HoldPattern@Map[
				s:(_Symbol?ChemToolsSym)|(_Symbol?ChemToolsSym[___]),
				a__]:>
				RuleCondition[Map[s,a],
					True
					],
			s_Symbol?ChemToolsSym[
				args___
				]:>
				RuleCondition[
					s[args],
					True
					],
			s_Symbol?ChemToolsSym[
				op___
				][args___]:>
				RuleCondition[
					s[op][args],
					True
					]
			}//.{
				c:ChemObject[_,_]?ChemObjectQ:>
					RuleCondition[
						Replace[ChemAssociation[c],
							Except[_Association]:><||>
							],
						True],
				s:(_Symbol?ChemSymObjectQ):>
					RuleCondition[
						Replace[ChemAssociation[c],
							Except[_Association]:><||>
							],
						True]
				}
			},
			Replace[expr,
				Hold@e_:>
					Compile[spec,e,ops]
				]
		];
ChemCompile~SetAttributes~HoldAll;


ChemPointCompile[
	expr_?(Function[Null,FreeQ[Hold[#],$ChemCompileObject],HoldFirst]),
	ops___]:=
	ChemCompile[
		{{$ChemCompilePoint,_Real,1}},
		expr,
		ops
		];
HoldPattern[ChemPointCompile[expr_,ops___][obj_]]:=
	Replace[Hold[expr]/.($ChemCompileObject->obj),
		Hold[e_]:>
			ChemPointCompile[e,ops]
		];
ChemPointCompile~SetAttributes~HoldFirst;


End[];



