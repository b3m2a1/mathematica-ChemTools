(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Subsection:: *)
(*Management*)



$ChemDVRManager::usage="Manager interface for ChemDVR things";
ChemDVRDirectory::usage="Directory finder";
ChemDVRFile::usage="Simple combination of FileNameJoin and ChemDVRDirectory";
ChemDVRPotentials::usage="Lists all matching files in ChemDVRDirectory[\"PotentialEnergy\"]";
$ChemDVRPotentials::usage="Alias for ChemDVRPotentials[\"*@.@*\"]";


PackageScopeBlock[
	ChemDVRDefaultFormatGrid::usage="";
	ChemDVRDefaultNamedPotential::usage="";
	ChemDVRDefaultPotentialEnergy::usage="";
	ChemDVRDefaultWavefunctions::usage="";
	ChemDVRDefaultPlot::usage="";
	ChemDVRDefaultGridWavefunctions::usage="";
	ChemDVRDefaultInterpolatingWavefunctions::usage="";
	ChemDVRDefaultExpectationValues::usage="";
	ChemDVRDefaultOperatorMatrix::usage="";
	ChemDVRDirectProductGrid::usage=
		"Creates a direct product grid from two grid functions";
	ChemDVRDirectProductKineticEnergy::usage=
		"Creates a direct product grid from two grid functions";,
	$Context
	];


ChemDVRCreate::usage="OOP constructor for a ChemDVR";
ChemDVRObject::usage="General object wrapper for ChemDVR stuff";
ChemDVRGet::usage="Gets an attribute for a ChemDVR instance";
ChemDVRSet::usage="Sets an attribute for a ChemDVR instance";
ChemDVRAssociation::usage="Returns the base association for the instance";


ChemDVRSave::usage="Saves various ChemDVR components";
ChemDVRClear::usage="Clears saved ChemDVR components";


ChemDVRClass::usage="Template interface for a ChemDVR";
ChemDVRClasses::usage="Lists the available classes";
ChemDVRNewClass::usage="Opens up a template notebook for a new class";


ChemDVRBegin::usage="Wrapper for all BeginPackage stuff";
ChemDVREnd::usage="Wrapper for all EndPackage stuff";
$ChemDVRLoaded::usage="The set of packages loaded already";
ChemDVRNeeds::usage="Needs type loader for stuff";
ChemDVRReload::usage="Reloads a ChemDVR file";


(* ::Subsection:: *)
(*Usage*)



ChemDVRDimension::usage=
	"Returns the dimension of a ChemDVR object";
ChemDVROptions::usage=
	"Returns the options associated with a particular DVR step";
ChemDVRGrid::usage=
	"Returns the grid used in ChemDVR calculations";
ChemDVRKineticEnergy::usage=
	"Returns the kinetic energy used in ChemDVR calculations";
ChemDVRPotentialEnergy::usage=
	"Returns the potential energy used in ChemDVR calculations";
ChemDVRWavefunctions::usage=
	"Returns the wavefunctions computed in ChemDVR calculations";
ChemDVRGridWavefunctions::usage=
	"Returns the wavefunction imposed on the grid";
ChemDVRInterpolatingWavefunctions::usage=
	"Returns the wavefunctions interpolating over a grid";
ChemDVRExpectationValues::usage=
	"Returns the expectation values of a set of functions";
ChemDVROperatorMatrix::usage=
	"Returns the cross-state expectation matrix of a set of states->function specs";
ChemDVRView::usage="Displays the wavefunctions from a ChemDVR run";
ChemDVRRun::usage="General form ChemDVR runner";


ChemDVRNotebook::usage="Opens a notebook for playing with a single ChemDVR instance";


Begin["`Private`"];


(* ::Subsection:: *)
(*Management*)



(* ::Subsubsection::Closed:: *)
(*KeyWords*)



$dvroot="Root";
$dvalt="ExtraDirs";
$dvrinst="Instances";
$dvrke="KineticEnergy";
$dvrpe="PotentialEnergy";
$dvrwf="Wavefunctions";
$dvrgr="Grid";
$dvrgrwf="GridWavefunctions";
$dvrintwf="InterpolatingWavefunctions";
$dvrexv="ExpectationValues";
$dvrexm="OperatorMatrix";
$dvrvw="View";


(* ::Subsubsection::Closed:: *)
(*Manager*)



If[!MatchQ[$ChemDVRManager,_Association],
	$ChemDVRManager=
		<|
			"Directories"->
				<|
					$dvroot->ChemExtensionDir["DVR"],
					$dvalt->
						Map[
							FileNameJoin[{#, "DVR"}]&,
							{$ChemExtensionsApp, $ChemExtensionsDev}
							],
					"Classes"->"Classes",
					$dvrinst->$dvrinst,
					$dvrpe->$dvrpe,
					$dvrke->$dvrke,
					$dvrwf->$dvrwf
					|>,
			"Objects"->
				<|
					|>,
			"Settings"->
				<|
					"Load"<>$dvrke->False,
					"Save"<>$dvrke->False,
					"Load"<>$dvrpe->False,
					"Save"<>$dvrpe->False,
					"Load"<>$dvrwf->False,
					"Save"<>$dvrwf->False
					|>
			|>
	];


(* ::Subsubsection::Closed:: *)
(*Directory*)



$ChemDVRRoot:=
	$ChemDVRManager["Directories", $dvroot];
$ChemDVRPath:=
	Prepend[
		$ChemDVRManager["Directories", $dvalt],
		$ChemDVRRoot
		]


Options[ChemDVRDirectory]=
	{
		"Root":>$ChemDVRRoot,
		"Path":>$ChemDVRPath
		};
ChemDVRDirectory[
	dSpec_?(KeyMemberQ[$ChemDVRManager["Directories"],#]&),
	alt:True|False:False,
	ops:OptionsPattern[]
	]:=
	With[{d=$ChemDVRManager["Directories", dSpec]},
		If[!alt,
			If[Not@DirectoryQ@ExpandFileName@d,
				(
					If[Not@DirectoryQ@#,
						CreateDirectory[#, CreateIntermediateDirectories->True]
						];
					#
					)&@
						FileNameJoin@{OptionValue["Root"], dSpec},
				d
				],
			FileNameJoin@{#,dSpec}&/@
				OptionValue["Path"]
			]
		];


(* ::Subsubsection::Closed:: *)
(*File*)



ChemDVRFile//Clear


Options[ChemDVRFile]=
	Options@ChemDVRDirectory;
ChemDVRFile[
	dSpec_String?(KeyMemberQ[$ChemDVRManager["Directories"],#]&),
	fspec__String,
	o:OptionsPattern[]
	]:=
	With[
		{
			ops=
				FileNameJoin@{#,fspec}&/@
					ChemDVRDirectory[dSpec, True, o]
			},
		SelectFirst[ops, FileExistsQ, Last@ops]
		];
ChemDVRFile[
	dSpec_String?(KeyMemberQ[$ChemDVRManager["Directories"],#]&),
	ChemDVRObject[uuid_]
	]:=
	ChemDVRFile[
		dSpec,
		uuid<>If[MatchQ[dSpec,$dvrke|$dvrpe|$dvrwf],".mx",".m"]
		]
ChemDVRFile[ChemDVRObject[uuid_]]:=
	ChemDVRFile[$dvrinst,uuid<>".m"];


(* ::Subsubsection::Closed:: *)
(*Potentials*)



ChemDVRPotentials[
	pat:_?StringPattern`StringPatternQ:"*@.@*",
	nameTake:True|False:True
	]:=
	If[nameTake,Map@FileNameTake,Identity]@
		FileNames[pat,ChemDVRDirectory[$dvrpe]];


(* ::Subsubsection::Closed:: *)
(*Create*)



ChemDVRCreate::norng="No range function provided";
ChemDVRCreate::nogrid="No grid function provided";
ChemDVRCreate::noke="No kinetic energy function provided";
ChemDVRCreate::nope="No potential energy function provided";
ChemDVRCreate::novw="No view function provided";
ChemDVRCreate[a_Association]:=
	Block[{dvrAssoc=a},
		If[KeyMemberQ[a,"Class"],
			ChemDVRClass@a["Class"]];
		If[!KeyMemberQ[dvrAssoc,"UUID"],
			dvrAssoc["UUID"]=CreateUUID["ChemDVR-"]
			];
		If[!KeyMemberQ[dvrAssoc,"Name"],
			dvrAssoc["Name"]="ChemDVR Instance"
			];
		MapThread[
			If[!KeyMemberQ[dvrAssoc,#],
				Replace[#2,Hold[m_]:>
					Message[m]];
				dvrAssoc[#]=None;
				]&,{
			{"Range", $dvrgr, $dvrke},
			Thread@
				Hold[
					{
						ChemDVRCreate::norng,ChemDVRCreate::nogrid,
						ChemDVRCreate::noke
						}
					]
			}];
		If[!KeyMemberQ[dvrAssoc,"Points"],
			dvrAssoc["Points"]=
				ConstantArray[10,Length@dvrAssoc["Range"]]
			];
		If[!KeyMemberQ[dvrAssoc, $dvrpe],
			dvrAssoc[$dvrpe]=
				ChemDVRDefaultPotentialEnergy
			];
		If[!KeyMemberQ[dvrAssoc, $dvrwf],
			dvrAssoc[$dvrwf]=
				ChemDVRDefaultWavefunctions
			];
		If[!KeyMemberQ[dvrAssoc, $dvrvw],
			dvrAssoc[$dvrvw]=
				ChemDVRDefaultPlot
			];
		If[!KeyMemberQ[dvrAssoc, $dvrgrwf],
			dvrAssoc[$dvrgrwf]=
				ChemDVRDefaultGridWavefunctions
			];
		If[!KeyMemberQ[dvrAssoc, $dvrintwf],
			dvrAssoc[$dvrintwf]=
				ChemDVRDefaultInterpolatingWavefunctions
			];
		If[!KeyMemberQ[dvrAssoc, $dvrexv],
			dvrAssoc[$dvrexv]=
				ChemDVRDefaultExpectationValues
			];
		If[!KeyMemberQ[dvrAssoc, $dvrexm],
			dvrAssoc[$dvrexm]=
				ChemDVRDefaultOperatorMatrix
			];
		If[!KeyMemberQ[dvrAssoc,"FormatGrid"],
			dvrAssoc["FormatGrid"]=
				ChemDVRDefaultFormatGrid
			];
		$ChemDVRManager["Objects",dvrAssoc["UUID"]]=
			dvrAssoc;
		ChemDVRObject[dvrAssoc["UUID"]]
		];


ChemDVRCreate::nodvr="No ChemDVR found at ``";
ChemDVRCreate[dvr_String?FileExistsQ]:=
	With[{a=Get@dvr},
		If[AssociationQ@a,
			ChemDVRCreate@a,
			Message[ChemDVRCreate::nodvr,dvr];
			$Failed
			]
		];
ChemDVRCreate[dvr_String?(Not@*FileExistsQ)]:=
	With[{f=ChemDVRFile[$dvrinst,StringTrim[dvr,".m"]<>".m"]},	
		If[FileExistsQ@f,
			ChemDVRCreate@f,
			Message[ChemDVRCreate::nodvr,f]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Save*)



ChemDVRSave//Clear


Options[ChemDVRSave]=
	Options@ChemDVRFile;
ChemDVRSave[
	$dvrinst,
	name_String,
	a_Association,
	o:OptionsPattern[]
	]:=
	Block[{$ContextPath={"System`"}},
		Export[ChemDVRFile[$dvrinst, name, o],a]
		];
ChemDVRSave[
	prop:$dvrke|$dvrpe|$dvrwf, 
	name_String, 
	mx_List?MatrixQ,
	o:OptionsPattern[]
	]:=
	Export[	
		ChemDVRFile[prop, name, o],
		mx
		];


ChemDVRSave[
	Optional[$dvrinst,$dvrinst],
	ChemDVRObject[uuid_],
	o:OptionsPattern[]
	]:=
	ChemDVRSave[
		$dvrinst,
		uuid<>".m",
		$ChemDVRManager["Objects",uuid],
		o
		];
ChemDVRSave[
	prop:$dvrke|$dvrpe|$dvrwf, 
	ChemDVRObject[uuid_],
	mx_List?MatrixQ,
	o:OptionsPattern[]
	]:=
	ChemDVRSave[
		prop,
		uuid<>".mx",
		mx,
		o
		];


(* ::Subsubsection::Closed:: *)
(*Clear*)



Options[ChemDVRClear]=
	Options@ChemDVRFile;
ChemDVRClear[prop:$dvrinst|$dvrke|$dvrpe|$dvrwf, name_String,
	ops:OptionsPattern[]
	]:=
	Quiet@DeleteFile@ChemDVRFile[prop,name, ops];


ChemDVRClear[
	prop:$dvrinst|$dvrke|$dvrpe|$dvrwf,$dvrinst,
	ChemDVRObject[uuid_],
	ops:OptionsPattern[]
	]:=
	ChemDVRClear[prop,
		uuid<>".m",
		ops
		];


(* ::Subsection:: *)
(*Defaults*)



(* ::Subsubsection::Closed:: *)
(*FormatGrid*)



ChemDVRDefaultFormatGrid[grid_,points_,___]:=
	grid;


(* ::Subsubsection::Closed:: *)
(*DefaultGridPointList*)



Options[ChemDVRDefaultGridPointList]=
	{
		"GridPrepFunction"->Identity
		};
ChemDVRDefaultGridPointList[grid_, o:OptionsPattern[]]:=
	With[{dims=Dimensions[grid]},
		If[Depth@grid<=3,
			OptionValue["GridPrepFunction"]@grid,
			Flatten[
				OptionValue["GridPrepFunction"]@grid,
				Depth[grid]-3
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*WavefunctionSelection*)



Options[ChemDVRDefaultWavefunctionSelection]=
	{
		"WavefunctionSelection"->All
		};
ChemDVRDefaultWavefunctionSelection[wfs_, 
	sel:Except[_?OptionQ], ops:OptionsPattern[]]:=
	If[sel=!=All,
		wfs[[All, 
			Replace[sel,
				i_Integer:>Range[i]
				]
			]],
		wfs
		];
ChemDVRDefaultWavefunctionSelection[wfs_, ops:OptionsPattern[]]:=
	ChemDVRDefaultWavefunctionSelection[wfs,
		OptionValue["WavefunctionSelection"]
		]


(* ::Subsubsection::Closed:: *)
(*NamedPotential*)



ChemDVRObject::nonpot="Named potential `` unknown";


ChemDVRDefaultNamedPotential//Clear


(* ::Subsubsubsection::Closed:: *)
(*HarmonicOscillator*)



ChemDVRDefaultNamedPotential["HarmonicOscillator", ops___?OptionQ]:=
	With[
		{
			k=Lookup[{ops}, "ForceConstant", 1/2],
			re=Lookup[{ops}, "EquilibriumBondLength", 0]
			},
		Norm[k*(#-re)^2]&
		];


(* ::Subsubsubsection::Closed:: *)
(*MorseOscillator*)



ChemDVRDefaultNamedPotential["MorseOscillator", ops___?OptionQ]:=
	With[
		{
			de=Lookup[{ops}, "DissociationEnergy", 1],
			a=Lookup[{ops}, "\[Alpha]", 1],
			re=Lookup[{ops}, "EquilibriumBondLength", 0]
			},
		Norm[(de*(1-Exp[-a*(#-re)])^2)]&
		];


(* ::Subsubsubsection::Closed:: *)
(*HinderedRotor*)



ChemDVRDefaultNamedPotential["HinderedRotor", ops___?OptionQ]:=
	With[
		{
			w=Lookup[{ops}, "WellNumber", 3],
			d=Lookup[{ops}, "WellDepth", 5.]
			},
		Norm[d*Cos[w/2*#]]&
		];


(* ::Subsubsubsection::Closed:: *)
(*Fallback*)



ChemDVRDefaultNamedPotential[name_String, ops___?OptionQ]:=
	If[FileExistsQ[name]||MemberQ[ChemDVRPotentials[], name],
		name,
		With[
			{
				pe=PhysicalSystemData[name, "PotentialEnergy"],
				crds=PhysicalSystemData[name, "Coordinates"],
				vars=PhysicalSystemData[name, "Variables"]
				},
			If[MissingQ@pe||MissingQ@crds,
				Message[ChemDVRObject::nonpot, name];
				Throw[$Failed],
				With[
					{
						potExpr=
							pe/.
								Join[
									MapIndexed[
										Sequence@@
											{#->Apply[Slot, #2], #[___]->Apply[Slot, #2]}&,
										crds
										], 
									Flatten@
										Join[
											{ops}, 
											Replace[
												Flatten@{ops},
												(s_String->v_):>
													Sequence@@{
														QuantityVariable[_, s]->v, 
														QuantityVariable[s, _]->v
														},
												1
												]
											],
									Thread[vars->1]
									]
							},
					Function[potExpr]
					]
				]
			]
		];
ChemDVRDefaultNamedPotential[e___]:=
	(Message[ChemDVRObject::nonpot, {e}];Throw[$Failed])


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultPotentialEnergy*)



ChemDVRObject::badpot=
	"Potential function `` didn't return a numerical vector over the gridpoints"; 


Options[ChemDVRDefaultPotentialEnergy]=
	Join[
		{
			"PotentialFunction"->Automatic,
			Function->Automatic
			},
		Options@ChemDVRDefaultGridPointList
		];
ChemDVRDefaultPotentialEnergy[grid_, ops___?OptionQ]:=
	With[
		{
			pf=
				Replace[
					Lookup[Flatten@{ops}, "PotentialFunction", 
						Lookup[Options[ChemDVRDefaultPotentialEnergy], "PotentialFunction"]
						],
					{
						s_String:>
							ChemDVRDefaultNamedPotential[s, ops],
						{s_String, op___?OptionQ}:>
							ChemDVRDefaultNamedPotential[s, op],
						Except[_Function|_Symbol?(Length[DownValues[#]>0]&)]:>
							Replace[
								Lookup[Flatten@{ops}, Function, 
									Lookup[Options[ChemDVRDefaultPotentialEnergy], Function]
									],
								Automatic:>ChemDVRDefaultNamedPotential[]
								]
						}
					],
			gp=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{ops},
						Options@ChemDVRDefaultGridPointList
						]
					]
				},
		With[
			{
				gpVec=
					Replace[pf@gp, Except[_List]:>Map[pf, gp]]
				},
			If[!VectorQ@gpVec,
				Message[ChemDVRObject::badpot, pf];
				Throw[$Failed],
				SparseArray[Band[{1, 1}]->gpVec]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultWavefunctions*)



Options[ChemDVRDefaultWavefunctions]=
	Join[
		Options@Eigensystem,
		{
			"NumberOfWavefunctions"->Automatic,
			"CorrectPhase"->True,
			"SortEnergies"->True
			}
		];
ChemDVRDefaultWavefunctions[T_,V_,ops:OptionsPattern[]]:=
	Module[
		{
			ham=T+V,
			nwfs=OptionValue["NumberOfWavefunctions"],
			sort=OptionValue["SortEnergies"]=!=False,
			rephase=OptionValue["CorrectPhase"]=!=False,
			wfns,
			phase
			},
		wfns=
				If[sort, #[[{1,2},Ordering[First@#]]], #]&@
					Eigensystem[
						ham,
						Replace[nwfs,
							{
								Automatic:>
									If[Head@ham===SparseArray, 
										-Abs[Min@{Max@{Length@ham/10, 20}, Length@ham, 25}],
										Sequence@@{}
										],
								i_Integer:>-i,
								_:>Sequence@@{}
								}
							],
						Method->
							Replace[OptionValue[Method], 
								Automatic:>
									If[Head@ham===SparseArray, 
										Automatic,
										"FEAST"
										]
								],
						FilterRules[
							FilterRules[{ops},Alternatives@@Keys@Options@Eigensystem],
							Except[Method]
							]
						];
		If[rephase,
			phase=Sign@wfns[[2, Ordering[First@wfns][[1]]]];
			{First@wfns,phase*#&/@Last@wfns},
			wfns
			]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultGridWavefunctions*)



Options[ChemDVRDefaultGridWavefunctions]=
	Join[
		{
			"ReturnEnergies"->False
			},
		Options[ChemDVRDefaultWavefunctionSelection],
		Options[ChemDVRDefaultGridPointList]
		];
ChemDVRDefaultGridWavefunctions[grid_,wfs_, o:OptionsPattern[]]:=
	With[
		{
			coreGridPoints=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{o}, Options@ChemDVRDefaultGridPointList]
					],
			wfns=
				ChemDVRDefaultWavefunctionSelection[
					wfs,
					FilterRules[{o}, Options[ChemDVRDefaultWavefunctionSelection]]
					],
			retE=TrueQ@OptionValue["ReturnEnergies"]
			},
		If[retE, 
			MapThread[
				#->Thread[{coreGridPoints,#2}]&,
				wfns
				],
			Map[Thread[{coreGridPoints,#}]&, wfns[[2]]]
			]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultInterpolatingWavefunctions*)



Options[ChemDVRDefaultInterpolatingWavefunctions]=
	Options@ChemDVRDefaultGridWavefunctions;
ChemDVRDefaultInterpolatingWavefunctions[
	grid_,
	wfs_,
	ops:OptionsPattern[]
	]:=
	With[
		{
			coreGridPoints=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
					],
			wfns=
				ChemDVRDefaultWavefunctionSelection[
					wfs,
					FilterRules[{ops}, Options[ChemDVRDefaultWavefunctionSelection]]
					],
			retE=TrueQ@OptionValue["ReturnEnergies"]
			},
		If[retE, 
			MapThread[
				#->Interpolation@MapThread[Flatten@*List,{coreGridPoints,#2}]&,
				wfns
				],
			Map[Interpolation@MapThread[Flatten@*List,{coreGridPoints, #}]&, wfns[[2]]]
			]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultExpectationValues*)



(* ::Subsubsubsection::Closed:: *)
(*chemDVRCalcExpectationValue*)



chemDVRCalcExpectationValueVec[func_, grid_]:=
	Replace[func@grid, 
		Except[_List?(Length[#]==Length@grid&)]:>Map[func, grid]
		];
chemDVRCalcExpectationValueVec[func_, grid_, wf_]:=
	Replace[func[grid, wf], 
		Except[_List?(Length[#]==Length@grid&)]:>
			MapThread[func, {grid, wf}]
		];
chemDVRCalcExpectationValue[func_Function, grid_, wfL_, wfR_]:=
	wfL.
		If[MemberQ[func, Slot[2], \[Infinity]],
			chemDVRCalcExpectationValueVec[func, grid, wfR],
			wfR*chemDVRCalcExpectationValueVec[func, grid]
			];
chemDVRCalcExpectationValue[func:Except[_Function], grid_, wfL_, wfR_]:=
	wfL.Replace[chemDVRCalcExpectationValueVec[func, grid, wfR],
		{__func}:>wfR*chemDVRCalcExpectationValueVec[func, grid]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultExpectationValues*)



Options[ChemDVRDefaultExpectationValues]=
	Options@ChemDVRDefaultGridWavefunctions;
ChemDVRDefaultExpectationValues[
	grid_,
	wfs_,
	evs_,
	ops:OptionsPattern[]
	]:=
	With[
		{
			coreGridPoints=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{ops}, Options[ChemDVRDefaultGridPointList]]
					],
			exfns=
				Flatten@List@evs,
			wfns=
				ChemDVRDefaultWavefunctionSelection[
					wfs,
					FilterRules[{ops}, Options[ChemDVRDefaultWavefunctionSelection]]
					],
			retE=
				TrueQ@OptionValue["ReturnEnergies"]
			},
		If[retE, 
			wfns[[1]]->#&,
			Identity
			]@
				If[Not@ListQ@evs, Map[First], Identity]@
					Table[
						Map[
							chemDVRCalcExpectationValue[#, coreGridPoints, wf, wf]&,
							exfns
							],
						{wf, wfns[[2]]}
						]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultOperatorMatrix*)



Options[ChemDVRDefaultOperatorMatrix]=
	Options@ChemDVRDefaultExpectationValues;
ChemDVRDefaultOperatorMatrix[
	grid_,
	wfs_,
	evs_,
	ops:OptionsPattern[]
	]:=
	Module[
		{
			coreGridPoints=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{ops}, Options[ChemDVRDefaultGridPointList]]
					],
			exfns=
				Flatten@List@evs,
			sels,
			wfns,
			retE=
				TrueQ@OptionValue["ReturnEnergies"]
			},
		{sels, exfns}=
			Transpose@
				Replace[exfns,
					{
						(sel_->fn_):>
							{sel, fn},
						fn_:>
							{OptionValue["WavefunctionSelection"], fn}
						},
					1
					];
		wfns=
			Map[ChemDVRDefaultWavefunctionSelection[wfs, #]&, sels];
		If[Length@sels==1, First, Identity]@
			MapThread[
				Block[
					{mx, eSet=#[[1]], wfSet=#[[2]], exFs=#2},
					If[retE, 
						Array[
							{eSet[[#]], eSet[[#2]]}&,
							{Length@wfSet, Length@wfSet}
							]->#&,
						Identity
						]@
					Table[
						With[{i=i, j=j, gr=coreGridPoints, wfL=wfSet[[i]], wfR=wfSet[[j]]},
							If[Not@ListQ@exFs,
								chemDVRCalcExpectationValue[
									exFs, 
									gr, 
									wfL, wfR
									],
								Map[
									chemDVRCalcExpectationValue[
										#, 
										gr, 
										wfL, wfR
										]&,
									exFs
									]
								]
							],
						{i, Length@wfSet},
						{j, Length@wfSet}
						]
					]&,
				{
					wfns,
					exfns
					}
				]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultPlot*)



(* ::Subsubsubsection::Closed:: *)
(*$ChemDVRDefaultPlotOptions*)



$ChemDVRDefaultPlotOptions=
	DeleteDuplicatesBy[First]@
		Join[
			{
				"ShowEnergy"->True,
				"ShowPotential"->True,
				"PotentialStyle"->Automatic,
				"WavefunctionClipping"->10^-5,
				"WavefunctionScaling"->Scaled[.5],
				"WavefunctionShifting"->None,
				"WavefunctionRescaling"->None,
				"PotentialRescaling"->None,
				"PlotProbabilityDensity"->False,
				"PlotDisplayMode"->Manipulate,
				"PlotFunction"->Automatic,
				"CoordinateTransformation"->None,
				"PlotListStyle"->Automatic
				},
			Options[ChemDVRDefaultGridPointList],
			Options[ChemDVRDefaultWavefunctionSelection]
			]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotOptionValue*)



ChemDVRDefaultPlotOptionValue[opName_, ops_, f_:None, default_:Automatic]:=
	Lookup[Flatten@{ops}, opName,
		Lookup[Options[f], opName, 
			Lookup[$ChemDVRDefaultPlotOptions, opName, default]
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotGetShiftedScaledWavefunctions*)



ChemDVRDefaultPlotGetShiftedScaledWavefunctions//Clear


(* ::Subsubsubsubsection::Closed:: *)
(*chemDVRDefaultPlotWavefunctionRescalingFunction*)



chemDVRDefaultPlotWavefunctionRescalingFunction//Clear;
chemDVRDefaultPlotWavefunctionRescalingFunction[
	{min_?NumericQ, max_?NumericQ},
	_
	]:=
	Map[Rescale[#, MinMax[#], {min, max}]&];
chemDVRDefaultPlotWavefunctionRescalingFunction[
	Scaled[mm:{_?NumericQ, _?NumericQ}],
	pot_
	]:=
	With[{pmm=mm*MinMax[pot]},
		Map[Rescale[#, MinMax[#], pmm]&]
		];
chemDVRDefaultPlotWavefunctionRescalingFunction[
	Scaled[n_?NumericQ],
	pot_
	]:=
	chemDVRDefaultPlotWavefunctionRescalingFunction[
		Scaled[{0, n}],
		pot
		];
chemDVRDefaultPlotWavefunctionRescalingFunction[___]:=
	Identity


(* ::Subsubsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotGetShiftedScaledWavefunctions*)



ChemDVRDefaultPlotGetShiftedScaledWavefunctions[
	psi_,
	pot_,
	shift_,
	scale_,
	rescale_
	]:=
	With[
		{
			rescalePsi=
				chemDVRDefaultPlotWavefunctionRescalingFunction[rescale, pot][psi],
			shiftFactor=
				Replace[shift,
					Scaled[s_?NumericQ]:>
						s*Max@Abs[pot]
					],
			scaleFactor=
				Replace[scale,
					Scaled[s_?NumericQ]:>
						s*Max@Abs[pot]
					]
			},
		If[NumericQ@shiftFactor,
			If[NumericQ@scaleFactor, scaleFactor*shiftFactor, shiftFactor]+#,
			#
			]&@
			If[NumericQ@scaleFactor, 
				With[{maxPsi=Max[Abs[psi]]},
					MapThread[
						With[{minPsi=First@MinimalBy[#, Abs]},
							#2-scaleFactor*minPsi/maxPsi
							]&,
						{
							rescalePsi,
							scaleFactor*rescalePsi/maxPsi
							}
						]
					],
				rescalePsi
				]
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotGetClippedWavefunctionSpec*)



ChemDVRDefaultPlotGetClippedWavefunctionSpec[
	psi_,
	clip_?NumericQ
	]:=
	Map[#>=clip&, Abs[psi]]; 
ChemDVRDefaultPlotGetClippedWavefunctionSpec[
	psi_,
	Scaled[clip_?NumericQ]
	]:=
	ChemDVRDefaultPlotGetClippedWavefunctionSpec[
		psi,
		Rescale[clip, {0, 1}, MinMax[Abs@psi]]
		];
ChemDVRDefaultPlotGetClippedWavefunctionSpec[
	psi_,
	_
	]:=
	ConstantArray[True, Length@psi];


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotGetPlotPoints*)



(* ::Subsubsubsubsection::Closed:: *)
(*Imp*)



iChemDVRDefaultPlotGetPlotPoints[
	sel_,
	pot_,
	grid_,
	scaling_,
	shifting_,
	rescaling_,
	clip:_Scaled|_?NumericQ
	]:=
	With[
		{
			scaledPsi=
				ChemDVRDefaultPlotGetShiftedScaledWavefunctions[
					sel, pot, 
					shifting, scaling, rescaling
					]
			},
		MapThread[
			With[
				{
					pspec=ChemDVRDefaultPlotGetClippedWavefunctionSpec[#, clip]
					},
				MapThread[
					Flatten@*List,
					{
						Pick[grid, pspec], 
						Pick[#2, pspec]
						}
					]
				]&,
			{
				sel,
				scaledPsi
				}
			]
		];
iChemDVRDefaultPlotGetPlotPoints[
	sel_,
	pot_,
	grid_,
	scaling_,
	shifting_,
	rescaling_,
	clip:Except[_?NumericQ]
	]:=
	With[
		{
			scaledPsi=
				ChemDVRDefaultPlotGetShiftedScaledWavefunctions[
					sel, pot, 
					shifting, scaling, rescaling
					]
			},
		Map[
			MapThread[Flatten@*List, {grid, #}]&,
			scaledPsi
			]
		]


(* ::Subsubsubsubsection::Closed:: *)
(*potResc*)



chemDVRDefaultPlotPotentialRescalingFunction[potResc_]:=
	Replace[potResc, 
		{
			{_?NumericQ, _?NumericQ}:>
				Function@Rescale[#, MinMax[#], potResc],
			Scaled[s:{_?NumericQ, _?NumericQ}]:>
				Function@
					With[{mm=MinMax[#]},
						Rescale[#, mm, s*mm]
						],
			Offset[
				off:_?NumericQ,
				scl:{_?NumericQ, _?NumericQ}
				]:>
				Function[
					off+Rescale[#, MinMax[#], scl]
					],
			Offset[
				off:_?NumericQ,
				Scaled[scl:{_?NumericQ, _?NumericQ}]
				]:>
				Function@
					With[{mm=MinMax[#]},
						off+If[scl=={1, 1}, #, Rescale[#, mm, scl*mm]]
						],
			Offset[
				Scaled[off:_?NumericQ],
				scl:{_?NumericQ, _?NumericQ}
				]:>
				Function@
					With[{mm=MinMax[#]},
						(off*First[mm])+Rescale[#, mm, scl*mm]
						],
			Offset[
				Scaled[off:_?NumericQ],
				Scaled[scl:{_?NumericQ, _?NumericQ}]
				]:>
				Function@
					With[{mm=MinMax[#]},
						(off*First[mm])+If[scl=={1, 1}, #, Rescale[#, mm, scl*mm]]
						],
			_->Identity
			}
		]


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



Options[ChemDVRDefaultPlotGetPlotPoints]=
	$ChemDVRDefaultPlotOptions;
ChemDVRDefaultPlotGetPlotPoints[
	gridpoints_,
	psi_,
	pot_,
	showPot_,
	showEng_,
	transf_,
	ops:OptionsPattern[]
	]:=
	With[
		{
			scaling=
				OptionValue["WavefunctionScaling"],
			rescaling=
				OptionValue["WavefunctionRescaling"],
			clipping=
				OptionValue["WavefunctionClipping"],
			shift=
				OptionValue["WavefunctionShifting"],
			potResc=
				OptionValue["PotentialRescaling"],
			wfnsel=
				ChemDVRDefaultWavefunctionSelection[
					psi, 
					FilterRules[{ops}, 
						Options@ChemDVRDefaultWavefunctionSelection
						]
					],
			sqr=
				TrueQ["PlotProbabilityDensity"],
			gps=
				If[transf===None, 
					gridpoints, 
					Map[
						Replace[transf,
							chart_Rule:>
								Function[
									Evaluate@
										CoordinateTransform[chart, 
											Slot/@Range[Length[gridpoints[[1]]]]
											]
									]
							],
						gridpoints
						]
					]
				},
		{
			If[TrueQ@showEng,
				wfnsel[[1]],
				None
				],
			iChemDVRDefaultPlotGetPlotPoints[
				If[sqr, wfnsel[[2]]^2, wfnsel[[2]]],
				If[showPot, pot, {1}],
				gps,
				scaling,
				shift,
				rescaling,
				clipping
				],
			If[TrueQ@showPot,
				MapThread[
					Flatten@*List,
					{
						gps,
						chemDVRDefaultPlotPotentialRescalingFunction[potResc]@
							Normal@
								If[pot//MatrixQ,
									Diagonal@pot,
									pot
									]
						}
					],
				None
				]
			}
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotPotential*)



ChemDVRDefaultPlotPotential[
	func_Symbol, pot_, ops:OptionsPattern[]
	]:=
	With[
		{
			potStyle=
				ChemDVRDefaultPlotOptionValue[
					"PotentialStyle",
					{ops},
					func,
					Automatic
					]
			},
		func[
			pot,
			Evaluate@
				FilterRules[
					Flatten@{
						PlotStyle->
							Replace[potStyle,
								Automatic:>
									{
										If[Length@pot[[1]]===2,
											Directive[Dashed, Gray],
											Directive[Opacity[.5], Gray]
											]
										}
								],
						ops
						},
					Options@func
					]
			]
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotResolvePlotStyle*)



ChemDVRDefaultPlotResolvePlotStyle[
	func_, solNum_, ops_
	]:=
	Module[
		{
			cf=
				Replace[
					{
						s:_String|{_String, __}:>ColorData[s],
						Automatic:>ColorData[97]
						}
					]@
					ChemDVRDefaultPlotOptionValue[
						"PlotListStyle", 
						{ops}, 
						func, 
						Lookup[
							Charting`ResolvePlotTheme[Automatic, func],
							"DefaultColorFunction",
							Lookup[
								Lookup[
									Charting`ResolvePlotTheme[Automatic, func], 
									Method,
									{"DefaultPlotStyle"->Automatic}
									],
								"DefaultPlotStyle",
								Automatic
								]
							]
						]
			},
			With[
				{
					ci=
						MatchQ[cf, HoldPattern[ColorDataFunction[_, "Indexed", __]]]
					},
				Function[
					Which[
						ListQ@cf,
							cf[[Mod[#, Length[cf], 1]]],
						ci,
							cf@#,
						True,
							cf@Rescale[#, {1, solNum}]
						]
					]
				]
			]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotManipulateSolutions*)



ChemDVRDefaultPlotManipulateSolutions[
	func_Symbol, energies_, solns_, pot_,
 ops:OptionsPattern[]
 ]:=
	With[
		{
			potPlot=
				If[pot=!=None, ChemDVRDefaultPlotPotential[func, pot, ops], None],
			ps=
				ChemDVRDefaultPlotResolvePlotStyle[func, Length@solns, {ops}]
			},
		Manipulate[
			Replace[
				func[solns[[i]],
					Evaluate@
						FilterRules[
							{
								ops,
								PlotStyle->
									ps[i]
								},
							Options@func
							]
					],
				{
					Except[_Graphics|_Graphics3D]:>
						Failure["DVR Viewer",
							"Couldn't view solutions for plotting function ``"~~TemplateApply~~func
							],
					g:_Graphics|_Graphics3D:>
						Function[
							If[energies=!=None,
								Legended[#,
									Placed[
										Row@{Subscript["E", i],": ", energies[[i]] },
										After
										]
									],
								#
								]
							]@If[pot=!=None, Show[g, potPlot], g]
					}
				],
			{{i, 1, "\[Psi]"}, 1, Length@solns, 1}
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotListSolutions*)



ChemDVRDefaultPlotListSolutions[
	func_Symbol, energies_, solns_, pot_,
 ops:OptionsPattern[]
 ]:=
	With[
		{
			potPlot=
				If[pot=!=None, ChemDVRDefaultPlotPotential[func, pot, ops], None],
			ps=
				ChemDVRDefaultPlotResolvePlotStyle[func, Length@solns, {ops}]
			},
		Table[
			Replace[
				func[solns[[i]],
					Evaluate@
						FilterRules[
							{
								ops,
								PlotStyle->ps[i]
								},
							Options@func
							]
					],
				{
					Except[_Graphics|_Graphics3D]:>
						Failure["DVR Viewer",
							"Couldn't view solutions for plotting function ``"~~TemplateApply~~func
							],
					g:_Graphics|_Graphics3D:>
						Function[
							If[energies=!=None,
								Legended[#,
									Placed[
										Row@{Subscript["E", i],": ", energies[[i]] },
										After
										]
									],
								#
								]
							]@If[pot=!=None, Show[g, potPlot], g]
					}
				],
			{i, 1, Length@solns}
			]
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotShowSolutions*)



ChemDVRDefaultPlotShowSolutions[
	func_Symbol, energies_, solns_, pot_,
	ops:OptionsPattern[]
	]:=
	With[
		{
			ps=
				ChemDVRDefaultPlotResolvePlotStyle[func, Length@solns, {ops}]
			},
		Show[
			If[pot=!=None, 
				ChemDVRDefaultPlotPotential[func, pot, ops], 
				{}
				],
			MapIndexed[
				Replace[
					func[#,
						Evaluate@
							FilterRules[
								{
									ops,
									PlotStyle->
											ps@#2[[1]]
									},
								Options@func
								]
						],
					{
						Except[_Graphics|_Graphics3D]:>
							Nothing
						}
					]&,
				solns
				]
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotSolutions*)



ChemDVRDefaultPlotSolutions[
	func_Symbol, energies_, solns_, pot_,
 ops:OptionsPattern[]
 ]:=
	Switch[
		ChemDVRDefaultPlotOptionValue[
			"PlotDisplayMode",
			{ops},
			func
			],
		Manipulate|"Manipulate",
			ChemDVRDefaultPlotManipulateSolutions[
				func, energies, solns, pot, 
				ops
				],
		Show|"Show",
			ChemDVRDefaultPlotShowSolutions[
				func, energies, solns, pot, 
				ops
				],
		_,
			ChemDVRDefaultPlotListSolutions[
				func, energies, solns, pot, 
				ops
				]
		];
ChemDVRDefaultPlotSolutions[
	func_, energies_, solns_, pot_,
 ops:OptionsPattern[]
 ]:=
 Module[{plotFun},
 	plotFun[e___]:=func[e];
 	ChemDVRDefaultPlotSolutions[func, energies, solns, pot, ops]
 	] 


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotBasic*)



ChemDVRDefaultPlotBasic[
	solutions_, grid_, potentialMatrix_, 
	headFunc_Symbol, defaultFunc:Except[_?OptionQ],
	ops:OptionsPattern[]
	]:=
	Module[
		{
			params=
				ChemDVRDefaultPlotGetPlotPoints[
					grid,
					solutions, 
					potentialMatrix,
					TrueQ@
						ChemDVRDefaultPlotOptionValue["ShowPotential",
							{ops},
							headFunc,
							False
							],
					TrueQ@
						ChemDVRDefaultPlotOptionValue["ShowEnergy",
							{ops}, 
							headFunc,
							False
							],
					ChemDVRDefaultPlotOptionValue["CoordinateTransformation",
						{ops}, 
						headFunc,
						None
						],
					FilterRules[{ops},
						Options@ChemDVRDefaultPlotGetPlotPoints
						]
					]
			},
		ChemDVRDefaultPlotSolutions[
			Replace[
				ChemDVRDefaultPlotOptionValue["PlotFunction",
					{ops}, 
					headFunc,
					False
					],
				Automatic->defaultFunc
				],
			Sequence@@params,
			ops,
			PlotRange->
				Append[
					ConstantArray[Automatic, 
						Length[params[[2, 1, 1]]]-1
						],
					MinMax@params[[2, All, All, -1]]
					],
			PlotRangePadding->
				Append[
					ConstantArray[
						{Scaled[.05],Scaled[.05]}, 
						Length[params[[2, 1, 1]]]-1
						],
					{Scaled[.15], Scaled[.15]}
					]
			]
	];


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotCartesian1D*)



Options[ChemDVRDefaultPlotCartesian1D]=
	Join[
		$ChemDVRDefaultPlotOptions,
		{
			AxesOrigin->{0,0},
			PlotRange->Automatic
			},
		FilterRules[Options[ListLinePlot],
			Except[AxesOrigin|PlotRange]
			]
		];
ChemDVRDefaultPlotCartesian1D[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, grid, potentialMatrix,
		ChemDVRDefaultPlotCartesian1D, ListLinePlot,
		ops
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotCartesian2D*)



Options[ChemDVRDefaultPlotCartesian2D]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[ListPlot3D]
		];
ChemDVRDefaultPlotCartesian2D[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, grid, potentialMatrix,
		ChemDVRDefaultPlotCartesian2D, ListPlot3D,
		ops
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotCartesian3D*)



Options[ChemDVRDefaultPlotCartesian3D]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[ContourPlot3D]
		];
ChemDVRDefaultPlotCartesian3D[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, grid, potentialMatrix,
		ChemDVRDefaultPlotCartesian3D, ContourPlot3D,
		ops
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotAngular*)



Options[ChemDVRDefaultPlotAngular]=
	DeleteDuplicatesBy[First]@
		Join[
			{
				"WavefunctionShifting"->1,
				"PotentialRescaling"->
					Offset[Scaled[-1.5], Scaled[{1, 1}]],
				Joined->True
				},
			$ChemDVRDefaultPlotOptions,
			Options[ListPolarPlot]
			];
ChemDVRDefaultPlotAngular[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, grid, potentialMatrix,
		ChemDVRDefaultPlotAngular, ListPolarPlot,
		ops,
		"WavefunctionShifting"->1,
		"PotentialRescaling"->Offset[Scaled[-1.5], Scaled[{1, 1}]],
		Joined->True,
		PlotRange->All
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotAngular3D*)



iChemDVRDefaultPlotAngular3D//Clear
Options[iChemDVRDefaultPlotAngular3D]=
	Options[ListPointPlot3D];
iChemDVRDefaultPlotAngular3D[pts_, ops:OptionsPattern[]]:=
	ReplaceAll[
		ListPointPlot3D[pts,
			Evaluate@FilterRules[{ops}, Options[ListPointPlot3D]]
			],
		{a___, p_Point, b___}:>
			{AbsoluteThickness[2], a, Line@@Insert[p, p[[1, 1]], {1, -1}], b}
		];


Options[ChemDVRDefaultPlotAngular3D]=
	DeleteDuplicatesBy[First]@
		Join[
			$ChemDVRDefaultPlotOptions,
			Options[ListPointPlot3D]
			];
ChemDVRDefaultPlotAngular3D[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, grid, potentialMatrix,
		ChemDVRDefaultPlotAngular3D, iChemDVRDefaultPlotAngular3D,
		ops,
		"CoordinateTransformation"->
			({Cos[#], Sin[#]}&)
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotPolar*)



Options[ChemDVRDefaultPlotPolar]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[ListPlot3D]
		];
ChemDVRDefaultPlotPolar[
	solutions_,
	gridpoints_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, gridpoints, potentialMatrix,
		ChemDVRDefaultPlotPolar, ListPlot3D,
		ops,
		"CoordinateTransformation"->
			("Polar" -> "Cartesian"),
		RegionMemberFunction->
			RegionMember[
				Annulus[
					{0, 0}, 
					MinMax[gridpoints[[All, 1]]],
					MinMax[gridpoints[[All, 2]]]
					]
				]
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotShell*)



Options[ChemDVRDefaultPlotShell]=
	DeleteDuplicatesBy[First]@
		Join[
			{
				"WavefunctionShifting"->1
				},
			$ChemDVRDefaultPlotOptions,
			Options[ListSurfacePlot3D]
			];
ChemDVRDefaultPlotShell[
	solutions_,
	gridpoints_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, gridpoints, potentialMatrix,
		ChemDVRDefaultPlotShell, ListSurfacePlot3D,
		ops,
		"CoordinateTransformation"->
			("Spherical" -> "Cartesian"),
		"WavefunctionShifting"->1
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotSpherical*)



Options[ChemDVRDefaultPlotSpherical]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[ContourPlot3D]
		];
ChemDVRDefaultPlotSpherical[
	solutions_,
	gridpoints_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, gridpoints, potentialMatrix,
		ChemDVRDefaultPlotSpherical, ContourPlot3D,
		ops,
		"CoordinateTransformation"->
			("Spherical" -> "Cartesian")
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotDensity2D*)



Options[ChemDVRDefaultPlotDensity2D]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[ListDensityPlot]
		];
ChemDVRDefaultPlotDensity2D[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, grid, potentialMatrix,
		ChemDVRDefaultPlotDensity2D, ListDensityPlot,
		ops
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotDensity3D*)



Options[ChemDVRDefaultPlotDensity3D]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[ListDensityPlot3D]
		];
ChemDVRDefaultPlotDensity3D[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, grid, potentialMatrix,
		ChemDVRDefaultPlotDensity3D, ListDensityPlot3D,
		ops
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotPolarDensity*)



Options[ChemDVRDefaultPlotPolarDensity]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[DensityPlot]
		];
ChemDVRDefaultPlotPolarDensity[
	solutions_,
	gridpoints_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, gridpoints, potentialMatrix,
		ChemDVRDefaultPlotPolarDensity, DensityPlot,
		ops,
		"CoordinateTransformation"->
			("Polar" -> "Cartesian"),
		RegionMemberFunction->
			RegionMember[
				Annulus[
					{0, 0}, 
					MinMax[gridpoints[[All, 1]]],
					MinMax[gridpoints[[All, 2]]]
					]
				]
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotSphericalDensity*)



Options[ChemDVRDefaultPlotSphericalDensity]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[DensityPlot3D]
		];
ChemDVRDefaultPlotSphericalDensity[
	solutions_,
	gridpoints_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, gridpoints, potentialMatrix,
		ChemDVRDefaultPlotSphericalDensity, DensityPlot3D,
		ops,
		"CoordinateTransformation"->
			("Spherical" -> "Cartesian")
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotContour2D*)



Options[ChemDVRDefaultPlotContour2D]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[ListContourPlot]
		];
ChemDVRDefaultPlotContour2D[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, grid, potentialMatrix,
		ChemDVRDefaultPlotContour2D, ListContourPlot,
		ops
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotContour3D*)



Options[ChemDVRDefaultPlotContour3D]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[ListContourPlot3D]
		];
ChemDVRDefaultPlotContour3D[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, grid, potentialMatrix,
		ChemDVRDefaultPlotContour3D, ListContourPlot3D,
		ops
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlotPolarContour*)



Options[ChemDVRDefaultPlotPolarContour]=
	Join[
		$ChemDVRDefaultPlotOptions,
		Options[ContourPlot]
		];
ChemDVRDefaultPlotPolarContour[
	solutions_,
	gridpoints_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultPlotBasic[
		solutions, gridpoints, potentialMatrix,
		ChemDVRDefaultPlotPolarContour, ContourPlot,
		ops,
		"CoordinateTransformation"->
			("Polar" -> "Cartesian"),
		RegionMemberFunction->
			RegionMember[
				Annulus[
					{0, 0}, 
					MinMax[gridpoints[[All, 1]]],
					MinMax[gridpoints[[All, 2]]]
					]
				]
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPlot*)



ChemDVRRun::nosup="PlotMode `` is unsupported";


Options[ChemDVRDefaultPlot]=
	Join[
		{
			"PlotMode"->Automatic
			},
		$ChemDVRDefaultPlotOptions
		];
ChemDVRDefaultPlot[
	solutions_,
	grid_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	Catch@
	Module[
		{
			gridpoints,
			func,
			pmode,
			gridranges
			},
		pmode=
			ChemDVRDefaultPlotOptionValue[
				"PlotMode",
				{ops},
				ChemDVRDefaultPlot,
				Automatic
				];
		func=
			Switch[pmode,
				{"Cartesian", 1},
					ChemDVRDefaultPlotCartesian1D,
				{"Cartesian", 2},
					ChemDVRDefaultPlotCartesian2D,
				{"Cartesian", 3},
					ChemDVRDefaultPlotCartesian3D,
				"Cartesian",
					gridpoints=
						ChemDVRDefaultGridPointList[grid, 
							FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
							];
					{"Cartesian", Length@gridpoints[[1]]},
				{"Density", 2},
					ChemDVRDefaultPlotDensity2D,
				{"Density", 3},
					ChemDVRDefaultPlotDensity3D,
				{"Density", "Polar"},
					ChemDVRDefaultPlotPolarDensity,
				{"Density", "Spherical"},
					ChemDVRDefaultPlotSphericalDensity,
				"Density",
					gridpoints=
						ChemDVRDefaultGridPointList[grid, 
							FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
							];
					{"Density", Length@gridpoints[[1]]},
				{"Contour", 2},
					ChemDVRDefaultPlotContour2D,
				{"Contour", 3},
					ChemDVRDefaultPlotContour3D,
				{"Contour", "Polar"},
					ChemDVRDefaultPlotPolarContour,
				{"Contour", "Spherical"},
					ChemDVRDefaultPlotSpherical,
				"Contour",
					gridpoints=
						ChemDVRDefaultGridPointList[grid, 
							FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
							];
					{"Contour", Length@gridpoints[[1]]},
				"Angular",
					ChemDVRDefaultPlotAngular,
				"Angular3D",
					ChemDVRDefaultPlotAngular3D,
				"Polar",
					ChemDVRDefaultPlotPolar,
				"Shell",
					ChemDVRDefaultPlotShell,
				"Spherical",
					ChemDVRDefaultPlotSpherical,
				Automatic,
					gridpoints=
						ChemDVRDefaultGridPointList[grid, 
							FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
							];
					gridranges=
						If[Length@gridpoints[[1]]==0,
							{MinMax@gridpoints},
							MinMax/@Transpose[gridpoints]
							];
					Switch[gridranges,
						{{_, _}?(#[[2]]+#[[1]]==2\[Pi]&)},
							"Angular",
						{
							{_, _}?(#[[2]]+#[[1]]==2\[Pi]&), 
							{_, _}?(#[[2]]+#[[1]]==\[Pi]&)
							},
							"Shell",
						{
							{_, _},
							{_, _}?(#[[2]]+#[[1]]==2\[Pi]&)
							},
							"Polar",
						{
							{_, _},
							{_, _}?(#[[2]]+#[[1]]==2\[Pi]&), 
							{_, _}?(#[[2]]+#[[1]]==\[Pi]&)
							},
							"Spherical",
						_,
							{"Cartesian", Length@gridranges}
						],
				_,
					Message[
						ChemDVRRun::nosup,
						pmode
						];
					Throw[$Failed]
				];
		If[StringQ@func||ListQ@func,
			ChemDVRDefaultPlot[
				solutions,
				grid,
				potentialMatrix,
				"PlotMode"->func,
				ops
				],
			If[!ListQ@gridpoints, 
				gridpoints=
					ChemDVRDefaultGridPointList[grid, 
						FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
						]
				];
			func[
				solutions,
				gridpoints,
				potentialMatrix,
				ops
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDirectProductKineticEnergy*)



(* ::Subsubsubsection::Closed:: *)
(*Imp*)



(* ::Subsubsubsubsection::Closed:: *)
(*dvrKGetValues*)



If[Length@OwnValues[dvrKGetValues]==0,
	dvrKGetValues := 
		dvrKGetValues=
			Compile[
				{
					{k1row, _Real, 1}, {blockvals, _Real, 2}, 
					{diagidx, _Integer, 1}, {i, _Integer}
					},
		   Block[{A},
		    A =
		    	Join[
			      Table[
								Compile`GetElement[k1row, k], 
								{l, 1, Dimensions[blockvals][[1]]}, 
								{k, 1, i}
								],
			      blockvals,
			      Table[
								Compile`GetElement[k1row, k], 
								{l, 1, Dimensions[blockvals][[1]]}, 
								{k, i + 2, Length[k1row]}
								],
			      2
			      ];
		    Do[
					A[[k, Compile`GetElement[diagidx, k] + i]] += 
						Compile`GetElement[k1row, i + 1], 
					{k, 1, Length[blockvals]}
					];
		    A
		    ],
		   RuntimeAttributes -> {Listable},
		   Parallelization -> True,
		   CompilationTarget -> "C",
		   RuntimeOptions -> "Speed"
		   ]
	]


(* ::Subsubsubsubsection::Closed:: *)
(*dvrKGetColumnIndices*)



If[Length@OwnValues[dvrKGetColumnIndices]==0,
	dvrKGetColumnIndices := 
		dvrKGetColumnIndices=
			Compile[{
		    {blockci, _Integer, 3}, {diagci, _Integer, 
		     3}, {m, _Integer}, {n, _Integer}, {i, _Integer}
		    },
		   If[i > 0,
		    If[i < m - 1,
		     Join[
						diagci[[All, 1 ;; i]], 
						blockci + i n, 
						diagci[[All, i + 1 ;; m - 1]] + (n), 
						2
						],
		     Join[
						diagci[[All, 1 ;; i]], 
						blockci + i n, 
						2
						]
		     ],
		    Join[
		    	blockci + i n, 
		    	diagci[[All, i + 1 ;; m - 1]] + (n), 
		    	2
		    	]
		    ],
		   RuntimeAttributes -> {Listable},
		   Parallelization -> True,
		   CompilationTarget -> "C",
		   RuntimeOptions -> "Speed"
		   ]
	];


(* ::Subsubsubsubsection::Closed:: *)
(*dvrKToSparseArray*)



dvrKToSparseArrayData[b_?MatrixQ] := {
  Partition[SparseArray[b]["ColumnIndices"], Dimensions[b][[2]]],
  b,
  Dimensions[b][[2]],
  Range[Dimensions[b][[2]]]
  }

dvrKToSparseArray[X_] := 
 With[{d1 = Dimensions[X[[1]]][[1]], d2 = Dimensions[X[[1]]][[2]]},
  SparseArray @@ {Automatic, {d1, d1}, 0,
    {1, {Range[0, d1 d2, d2], Flatten[X[[1]], 1]}, Flatten[X[[2]]]}}
  ]


(* ::Subsubsubsubsection::Closed:: *)
(*dvrKIteration*)



dvrKIteration[X_, a_] := With[{
   m = Length[a],
   blockci = X[[1]],
   blockvals = X[[2]],
   n = X[[3]],
   diagidx = X[[4]]
   },
  With[{ran = Range[0, m - 1]},
   {
    Join @@ 
    	dvrKGetColumnIndices[blockci, 
    		Transpose[Partition[Partition[Range[(m - 1) n], 1], n]], 
    		m, 
    		n, 
    		ran
    		],
    Join @@ dvrKGetValues[a, blockvals, diagidx, ran],
    m n,
    Join @@ Outer[Plus, ran, diagidx]
    }
   ]
  ]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDirectProductKineticEnergy*)



ChemDVRDirectProductKineticEnergy[keMats:{__List}]:=
	dvrKToSparseArray[
		Fold[dvrKIteration, 
			dvrKToSparseArrayData[keMats[[1]]], 
			Rest[keMats]
			]
		]


(* ::Subsection:: *)
(*ChemDVRObject*)



chemDVRValidQ[uuid_String]:=
	KeyMemberQ[$ChemDVRManager["Objects"],uuid];
chemDVRValidQ[ChemDVRObject[uuid_]]:=
	chemDVRValidQ[uuid];
chemDVRValidQ[___]:=False;
dvrObjPattern=ChemDVRObject[uuid_?chemDVRValidQ]


dvrOpsLookup[ops___,key_,default_]:=
	Lookup[Flatten@Normal@{ops},key,default]
dvrOpsLookup~SetAttributes~HoldAll;


(* ::Subsubsection::Closed:: *)
(*Reloading*)



ChemDVRObject[a_Association]:=
	ChemDVRCreate[a];


ChemDVRObject[uuid_String?(
	Not@KeyMemberQ[$ChemDVRManager["Objects"],#]&&
		FileExistsQ@ChemDVRFile[$dvrinst,#<>".m"]
	&)]:=
	ChemDVRCreate[uuid]


(* ::Subsubsection::Closed:: *)
(*Association*)



ChemDVRAssociation[obj:dvrObjPattern]:=
	$ChemDVRManager["Objects",First@obj];


(* ::Subsubsection::Closed:: *)
(*Get*)



ChemDVRGet[obj:dvrObjPattern,attribute_]:=
	Lookup[$ChemDVRManager["Objects",First@obj],attribute];
ChemDVRGet[obj:dvrObjPattern,attribute_,default_]:=
	Lookup[$ChemDVRManager["Objects",First@obj],attribute,default];


ChemDVRGet[obj:ChemDVRClass[a_Association],attribute_]:=
	Lookup[a,attribute];
ChemDVRGet[obj:ChemDVRClass[a_Association],attribute_,default_]:=
	Lookup[a,attribute,default];


PackageAddAutocompletions[
	ChemDVRGet,
	{
		None,
		{
			$dvrgr,
			$dvrke,$dvrpe,
			$dvrwf,$dvrgrwf,
			$dvrintwf,$dvrexv,
			$dvrexm,$dvrvw
			}
		}
	]


(* ::Subsubsection::Closed:: *)
(*Mutate*)



ChemDVRMutate//ClearAll
ChemDVRMutate~SetAttributes~HoldAll;
With[{obPat=dvrObjPattern},
	ChemDVRMutate[(obj:obPat)[at___], fn_, args___]:=
		With[{k=First@obj},
			fn[
				$ChemDVRManager["Objects", k, at],
				args
				]
			];
	ChemDVRMutate[(obj:obPat)[[at___]], fn_, args___]:=
		With[{k=First@obj},
			fn[
				$ChemDVRManager[["Objects", k, at]],
				args
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Set*)



ChemDVRSet//Clear


ChemDVRSet[obj:dvrObjPattern, attribute__, value_]:=
	ChemDVRMutate[
		obj[attribute],
		Set,
		value
		]


(* ::Subsubsection::Closed:: *)
(*Options*)



ChemDVROptions[obj:dvrObjPattern, method_String]:=
	Options@ChemDVRGet[obj, method];
ChemDVROptions[obj:dvrObjPattern, methods:{__String}]:=
	AssociationMap[ChemDVROptions[obj,#]&, methods];
ChemDVROptions[obj:dvrObjPattern, Optional[All, All]]:=
	ChemDVROptions[obj, 
		{$dvrgr, $dvrke, "PotentialEnergy", $dvrwf, "View"}
		]


PackageAddAutocompletions[
	ChemDVROptions,
	{
		None,
		{
			$dvrgr,
			$dvrke, $dvrpe, $dvrwf,
			$dvrvw
			}
		}
	]


(* ::Subsubsection::Closed:: *)
(*Dimension*)



ChemDVRDimension[obj:dvrObjPattern]:=
	Length@ChemDVRGet[obj,"Range"];


(* ::Subsubsection::Closed:: *)
(*Grid*)



ChemDVRGrid[obj:dvrObjPattern,ops:OptionsPattern[]]:=
	Block[{
		RunRange=None,
		RunPoints=None
		},
		RunRange=dvrOpsLookup[ops,"Range",None];
		If[MatchQ[RunRange,{{_?NumericQ,_?NumericQ}..}],
			ChemDVRSet[obj,"Range",RunRange]];
		RunPoints=dvrOpsLookup[ops,"Points",None];
		If[MatchQ[RunPoints,{__?NumericQ}],
			ChemDVRSet[obj,"Points",RunPoints]
			];
		ChemDVRGet[obj,"FormatGrid",(#&)][
			ChemDVRGet[obj,$dvrgr][
				ChemDVRGet[obj,"Points"],ChemDVRGet[obj,"Range"],
				Sequence@@FilterRules[{ops},Options@ChemDVRGet[obj,$dvrgr]]
				],
			ChemDVRGet[obj,"Points"]
			]
		];


(* ::Subsubsection::Closed:: *)
(*KineticEnergy*)



dvrCalcKE[obj_,ops___]:=
	With[{g=dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]]},
		ChemDVRGet[obj,$dvrke][g,Sequence@@FilterRules[{ops},Options@ChemDVRGet[obj,$dvrke]]]
		]


ChemDVRKineticEnergy[obj:dvrObjPattern,ops:OptionsPattern[]]:=
	With[{dvrke=ChemDVRGet[obj,$dvrke]},
		If[StringQ@dvrke,
			If[FileExistsQ@dvrke,Import@dvrke,Import@ChemDVRFile[$dvrke,dvrke]],
			With[{tryLoad=
				TrueQ@dvrOpsLookup[ops,"Load"<>$dvrke,
						dvrOpsLookup[ops,"Load",
							$ChemDVRManager["Settings","Load"<>$dvrke]]
						]},
				If[tryLoad,
					If[FileExistsQ@ChemDVRFile[$dvrke,obj],
						Import@ChemDVRFile[$dvrke,obj],
						ChemDVRKineticEnergy[obj,
							"Load"<>$dvrke->False,
							"Load"->False,
							ops
							]
						],
					With[{ke=dvrCalcKE[obj,ops]},
						If[MatrixQ[ke],
							If[TrueQ@dvrOpsLookup[ops,"Save"<>$dvrke,
									dvrOpsLookup[ops,"Save",
										$ChemDVRManager["Settings","Save"<>$dvrke]]
									],
								ChemDVRSave[$dvrke,obj,ke]
								]
							];
						ke
						]
					]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*PotentialEnergy*)



dvrCalcPE[obj_,ops___]:=
	With[{g=dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]]},
		ChemDVRGet[obj,$dvrpe][g,
			Sequence@@FilterRules[{ops},Options@ChemDVRGet[obj,$dvrpe]]
			]
		]


dvrLoadPotential[obj_,file_,ops___]:=
	DiagonalMatrix@
		Flatten[
			dvrImportAlignPotential[
				obj,
				With[{
					gBase=dvrOpsLookup[ops, $dvrgr,ChemDVRGrid[obj,ops]],
					dim=ChemDVRDimension[obj]
					},
					If[Dimensions[gBase[[1]]][[dim]]=!=dim,
						SelectFirst[
							gBase,
							With[{d2=Dimensions[#[[1]]]},
								Length[d2]>=dim&&d2[[dim]]===dim
								]&,
							Throw[$Failed]
							],
						gBase
						]
					],
				file,
				FilterRules[{ops},Options@dvrImportAlignPotential]
				]
			]


ChemDVRPotentialEnergy[obj:dvrObjPattern,ops:OptionsPattern[]]:=
	With[{dvrpe=dvrOpsLookup[ops,$dvrpe,ChemDVRGet[obj,$dvrpe]]},
		If[StringQ@dvrpe,
			If[FileExistsQ@dvrpe,
				dvrLoadPotential[obj,dvrpe,ops],
				dvrLoadPotential[obj,ChemDVRFile[$dvrpe, dvrpe],ops]
				],
			With[{tryLoad=
				TrueQ@dvrOpsLookup[ops,"Load"<>$dvrpe,
						dvrOpsLookup[ops,"Load",
							$ChemDVRManager["Settings","Load"<>$dvrpe]]
						]},
				If[tryLoad,
					If[FileExistsQ@ChemDVRFile[$dvrpe,obj],
						dvrLoadPotential[obj,ChemDVRFile[$dvrpe,obj],ops],
						ChemDVRPotentialEnergy[obj,
							"Load"<>$dvrpe->False,
							"Load"->False,
							ops]
						],
					With[{pe=dvrCalcPE[obj,ops]},
						If[MatrixQ[pe],
							If[TrueQ@dvrOpsLookup[ops,"Save"<>$dvrpe,
									dvrOpsLookup[ops,"Save",
										$ChemDVRManager["Settings","Save"<>$dvrpe]]
									],
								ChemDVRSave[$dvrpe,obj,pe]
								]
							];
						pe
						]
					]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*GridPotential*)



dvrImportPotential[obj_,grid:{_List,___}]:=
	With[{
		g=
			Select[Flatten[grid,Depth[grid]-3],AllTrue[NumericQ]]
			},
		Thread[{g[[All,;;-2]],g[[All,-1]]}]
		];
dvrImportPotential[obj_,vals:{_?NumericQ,___}]:=
	With[{
		grid=If[Length[#]==2&&MatrixQ@#[[2]],#[[1]],#]&@ChemDVRGrid[obj]
		},
		Thread[{Flatten[grid,Depth[grid]-3],vals}]
		]


dvrImportPotential[obj_,file_String?FileExistsQ]:=
	With[{
			res=
			dvrImportPotential[
				obj,
				Import[file]
				]
			},
		res/;AllTrue[res,ListQ]
		]


Options[dvrAlignPotential]=
	{
		Tolerance->.01,
		"GridPotentialPrepFunction"->Identity
		};
dvrAlignPotential[
	grid:Except[_?OptionQ],
	peInput:Except[_?OptionQ],
	ops:OptionsPattern[]
	]:=
	With[{peGrid=
			Replace[OptionValue["GridPotentialPrepFunction"]@peInput,
				Except[_List]:>peInput
				]},
		Dimensions[grid];
		With[{
			d1=Depth[grid],
			d2=Depth[peGrid],
			tol=OptionValue[Tolerance]
			},
			If[d1<d2,Throw[$Failed]];
			With[{
					points1=
						Map[grid[[Sequence@@#]]->#&, 
							Position[grid,{__?NumericQ}]
							],
					points2=
						If[Last@Dimensions[peGrid]===2,
							peGrid[[All,1]],
							Most/@peGrid
							]
					},
				If[Length[points1]=!=Length[points2],
					With[{interpf=Interpolation[peGrid]},
						ReplacePart[
							grid,
							Thread@
								Rule[Last/@points1,
									Quiet[
										interpf@@@Map[First,points1],
										InterpolatingFunction::dmval
										]
									]
							]
						],
					(*
					Find the nearest point to the points
						(issues with duplicates may arise, but only for ill-aligned data )
					Replace the grid points with the potential values
					
					*)
					Block[{
						nearestChoices=points1,
						nearestValues=points2,
						nearestFound={}
						},
						While[
							nearestFound=
								{
									nearestFound,
									DeleteDuplicates@
										AssociationThread[
											nearestValues->
												Map[First, Nearest[nearestChoices, nearestValues]]
											]
									};
							nearestChoices=
								DeleteCases[nearestChoices,
									_->(Alternatives@@Values@Last[nearestFound])
									];
							nearestValues=
								DeleteCases[nearestValues,
									Alternatives@@Keys@Last[nearestFound]
									];
							Length[nearestValues]>0
							];
						nearestFound=Apply[Join, Map[Values, Flatten[nearestFound]]];
						ReplacePart[
							grid,
							Thread[
								nearestFound->
								peGrid[[All,2]]
								]
							]
						]
					]
				]
			]
		]


Options[dvrImportAlignPotential]=Options[dvrAlignPotential];
dvrImportAlignPotential[obj_,grid_,pot:Except[_?OptionQ],
	ops:OptionsPattern[]
	]:=
	With[{p=dvrImportPotential[obj,pot]},
		dvrAlignPotential[grid,p,ops]
		]


(* ::Subsubsection::Closed:: *)
(*Wavefunctions*)



dvrCalcWFs[obj_,ops___]:=
	With[{
		ke=
			dvrOpsLookup[ops,$dvrke,ChemDVRKineticEnergy[obj,ops]],
		pe=
			dvrOpsLookup[ops,"PotentialEnergy",ChemDVRPotentialEnergy[obj,ops]],
		wf=ChemDVRGet[obj,$dvrwf]
		},
		wf[ke,pe,
			Sequence@@FilterRules[{ops},
			Options@wf]
			]
		];


ChemDVRWavefunctions[obj:dvrObjPattern,ops:OptionsPattern[]]:=
	With[{tryLoad=
		TrueQ@dvrOpsLookup[ops,"Load"<>$dvrwf,
			dvrOpsLookup[ops,"Load",
				$ChemDVRManager["Settings","Load"<>$dvrwf]]
			]},
		If[tryLoad,
			If[FileExistsQ@ChemDVRFile[$dvrwf,obj],
				Import@ChemDVRFile[$dvrwf,obj],
				ChemDVRWavefunctions[obj,
					"Load"<>$dvrwf->False,
					"Load"->False,
					ops
					]
				],
			With[{wf=dvrCalcWFs[obj,ops]},
				If[Length@wf==2&&MatrixQ[Last@wf,NumericQ],
					If[TrueQ@dvrOpsLookup[ops,"Save"<>$dvrwf,
							dvrOpsLookup[ops,"Save",
								$ChemDVRManager["Settings","Save"<>$dvrwf]]
							],
						ChemDVRSave[$dvrwf,obj,wf]
						]
					];
				wf
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*GridWavefunctions*)



ChemDVRGridWavefunctions[obj:dvrObjPattern,ops:OptionsPattern[]]:=
	With[{gridwf=ChemDVRGet[obj,$dvrgrwf]},
		gridwf[
			dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]],
			dvrOpsLookup[ops,
				$dvrwf,
				ChemDVRWavefunctions[obj,ops]
				],
			FilterRules[{ops},
				Options@gridwf
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*InterpolatingWavefunctions*)



ChemDVRInterpolatingWavefunctions[obj:dvrObjPattern,ops:OptionsPattern[]]:=
	With[{interpf=ChemDVRGet[obj, $dvrintwf]},
		interpf[
			dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]],
			dvrOpsLookup[ops,
				$dvrwf,
				ChemDVRWavefunctions[obj,ops]
				],
			FilterRules[{ops},
				Options@interpf
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*ExpectationValues*)



ChemDVRExpectationValues[
	obj:dvrObjPattern, 
	efuns:Except[_?OptionQ], 
	ops:OptionsPattern[]
	]:=
	With[{exFun=ChemDVRGet[obj, $dvrexv]},
		exFun[
			dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
			dvrOpsLookup[ops,
				$dvrwf,
				ChemDVRWavefunctions[obj,ops]
				],
			efuns,
			FilterRules[{ops},
				Options@exFun
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*OperatorMatrix*)



ChemDVROperatorMatrix[
	obj:dvrObjPattern, 
	efuns:Except[_?OptionQ], 
	ops:OptionsPattern[]
	]:=
	With[{exFun=ChemDVRGet[obj, $dvrexm]},
		exFun[
			dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
			dvrOpsLookup[ops,
				$dvrwf,
				ChemDVRWavefunctions[obj,ops]
				],
			efuns,
			FilterRules[{ops},
				Options@exFun
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*View*)



ChemDVRView[obj:dvrObjPattern,ops:OptionsPattern[]]:=
	With[{g=
		dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]]},
		With[{pe=
			dvrOpsLookup[ops,"PotentialEnergy",
				ChemDVRPotentialEnergy[obj,$dvrgr->g,ops]]},
			With[{wfs=
				dvrOpsLookup[ops,
					$dvrwf,
					ChemDVRWavefunctions[obj,
						$dvrgr->g,
						"PotentialEnergy"->pe,
						ops
						]
					]},
					ChemDVRGet[obj,"View"][wfs,g,pe,
						{ops}
						]
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*Run*)



ChemDVRRun::badops="Options `` aren't valid for ChemDVRRun (OptionQ failed)"


iChemDVRGetRuntimeOptions[key_]:=
	Sequence@@
		dvrOpsLookup[
			{RunRuntimeOptions}, 
			key<>"Options",
			{RunRuntimeOptions}
			]


iChemDVRRunGridWavefunctions[obj_]:=
	ChemDVRGridWavefunctions[obj,
		$dvrwf->RunWavefunctions,
		$dvrgr->RunGrid,
		iChemDVRGetRuntimeOptions[$dvrgrwf]
		];
iChemDVRRunInterpolatingWavefunctions[obj_]:=
	ChemDVRInterpolatingWavefunctions[obj,
		$dvrwf->RunWavefunctions,
		$dvrgr->RunGrid,
		iChemDVRGetRuntimeOptions[$dvrintwf]
		];
iChemDVRRunExpectationValues[obj_]:=
	ChemDVRExpectationValues[obj,
		Replace[
			Rest@RunEndPoint,
			{
				{f:Except[_List]}:>f,
				e_:>Flatten[e]
				}
			],
		$dvrwf->RunWavefunctions,
		$dvrgr->RunGrid,
		iChemDVRGetRuntimeOptions[$dvrexv]
		];
iChemDVRRunOperatorMatrix[obj_]:=
	ChemDVROperatorMatrix[obj,
		Replace[
			Rest@RunEndPoint,
			{
				{f:Except[_List]}:>f,
				e_:>Flatten[e]
				}
			],
		$dvrwf->RunWavefunctions,
		$dvrgr->RunGrid,
		iChemDVRGetRuntimeOptions[$dvrexm]
		]


iChemDVRRun[obj:dvrObjPattern,ops:OptionsPattern[]]:=
	Block[{
		RunObject=obj,
		RunRuntimeOptions=
			Sequence@@
				Normal@
					Merge[
						{
							ops,
							ChemDVRGet[obj, "RuntimeOptions", {}],
							ChemDVRGet[obj, "Defaults", {}]
							},
						First
						],
		RunCheckPoint=None,
		RunEndPoint,
		RunRange=None,
		RunPoints=None,
		RunGrid=None,
		RunKineticEnergy=None,
		RunPotentialEnergy=None,
		RunWavefunctions=None
		},
		
		If[!OptionQ[{RunRuntimeOptions}], 
			Message[ChemDVRRun::badops, RunRuntimeOptions];
			Throw[$Failed]
			];
		RunEndPoint=dvrOpsLookup[RunRuntimeOptions, Return, "View"];
		If[dvrOpsLookup[RunRuntimeOptions, "Save", False],
			ChemDVRSave@obj
			];
		(*---------- Grid ---------*)
		RunGrid=dvrOpsLookup[RunRuntimeOptions, $dvrgr, None];
		If[RunGrid===None,
			RunGrid=
				ChemDVRGrid[obj,
					iChemDVRGetRuntimeOptions[$dvrgr]
					]
			];
		If[RunEndPoint===$dvrgr, Return@RunGrid];
		RunCheckPoint=$dvrgr;
		(*---------- Kinetic Energy ---------*)
		If[RunEndPoint=!=$dvrpe&&
			!ListQ@dvrOpsLookup[RunRuntimeOptions, $dvrwf, None],
			RunKineticEnergy=
				dvrOpsLookup[RunRuntimeOptions, $dvrke, None];
			If[RunKineticEnergy===None,
				RunKineticEnergy=
					ChemDVRKineticEnergy[obj,
						$dvrgr->RunGrid,
						iChemDVRGetRuntimeOptions[$dvrke]
						]
				];
			];
		If[RunEndPoint===$dvrke, Return@RunKineticEnergy];
		RunCheckPoint=$dvrke;
		(*---------- Potential Energy ---------*)
		RunPotentialEnergy=
			dvrOpsLookup[RunRuntimeOptions, $dvrpe, None];
		If[RunPotentialEnergy===None,
			RunPotentialEnergy=
				ChemDVRPotentialEnergy[obj,
					$dvrgr->RunGrid,
					iChemDVRGetRuntimeOptions[$dvrpe]
					]
				];
		If[RunEndPoint===$dvrpe,Return@RunPotentialEnergy];
		RunCheckPoint=$dvrpe;
		(*---------- Wavefunctions ---------*)
		RunWavefunctions=
			dvrOpsLookup[RunRuntimeOptions, $dvrwf, None];
		If[RunWavefunctions===None,
			With[{ke=RunKineticEnergy, pe=RunPotentialEnergy},
			RunWavefunctions=
				ChemDVRWavefunctions[obj,
					$dvrke->ke,
					$dvrpe->pe,
					iChemDVRGetRuntimeOptions[$dvrwf]
					];
				]
			];
		If[RunEndPoint===$dvrwf,
			Return@RunWavefunctions
			];
		RunCheckPoint=$dvrwf;
		
		Switch[RunEndPoint,
			{
				(
					$dvrgr|$dvrke|$dvrpe|$dvrwf|
						$dvrgrwf|$dvrintwf|{$dvrexv, __}|{$dvrexm, __})..
				},
				Replace[
					Replace[
						DeleteDuplicates@RunEndPoint,
						{
							$dvrgr:>($dvrgr->RunGrid),
							$dvrke:>($dvrke->RunKineticEnergy),
							$dvrpe:>($dvrpe->RunPotentialEnergy),
							$dvrwf:>($dvrwf->RunWavefunctions),
							$dvrgrwf:>
								($dvrgrwf->iChemDVRRunGridWavefunctions[obj]),
							$dvrintwf:>
								($dvrintwf->iChemDVRRunInterpolatingWavefunctions[obj]),
							{$dvrexv, __}:>
								($dvrexv->iChemDVRRunExpectationValues[obj]),
							{$dvrexm, __}:>
								($dvrexm->iChemDVRRunOperatorMatrix[obj])
							},
						1
						],
				o:{__Rule}:>Association[o]
				],
			$dvrgrwf,
				(*----------  Wavefunction Grid ---------*)
				iChemDVRRunGridWavefunctions[obj],
			$dvrintwf,
				(*----------  InterpolatingWavefunctions ---------*)
				iChemDVRRunInterpolatingWavefunctions[obj],
			{$dvrexv, __},
				(*----------  ExpectationValues ---------*)
				iChemDVRRunExpectationValues[obj],
			{$dvrexm, __},
				(*----------  Operator Matrix ---------*)
				iChemDVRRunOperatorMatrix[obj],
			"FullResults",
				If[ListQ@RunWavefunctions,
					<|
						"Grid"->
							If[ListQ@RunGrid, 
								RawArray["Real64", RunGrid],
								RunGrid
								],
						"PotentialEnergy"->
							If[ListQ@RunPotentialEnergy, 
								RawArray["Real64", RunPotentialEnergy],
								RunPotentialEnergy
								],
						"KineticEnergy"->
							If[ListQ@RunKineticEnergy, 
								RawArray["Real64", RunKineticEnergy],
								RunKineticEnergy
								],
						"Energies"->
							If[ListQ@RunWavefunctions, 
								RawArray["Real64", RunWavefunctions[[1]]],
								RunWavefunctions[[1]]
								],
						"Wavefunctions"->
							If[ListQ@RunWavefunctions, 
								RawArray["Real64", RunWavefunctions[[2]]],
								RunWavefunctions[[2]]
								]
						|>
					],
			_,
				(*---------- View ---------*)
				ChemDVRView[obj,
					$dvrwf->RunWavefunctions,
					$dvrpe->RunPotentialEnergy,
					$dvrgr->RunGrid,
					iChemDVRGetRuntimeOptions[$dvrvw]
					]
			]
		];


ChemDVRRun[obj:dvrObjPattern,ops:OptionsPattern[]]:=
	Catch@With[{m=If[$Notebooks,dvrOpsLookup[ops,Monitor,False],False]},
		Switch[m,
			Automatic|True,	
				With[{start=Now,clock=Unique@"clock$"},
					Monitor[iChemDVRRun[obj,ops],
						With[{p=
							Replace[
								Position[
									{$dvrgr,$dvrke,$dvrpe,$dvrwf},
									RunCheckPoint
									],{
								{{i_}}:>i,
								_->-1
								}]},
							Panel@Grid[{
								{"Time Elapsed:",
									If[p<4,
										Row@{Dynamic[clock;Round[Now-start,.02]],
											Invisible@Pane[Animator[Dynamic@clock,{0,1,.1},1],{5,5}]},
										Now-start
										]},
								{"Grid:",If[p<1,"\[EmptySquare]","\[CheckmarkedBox]"]},
								{"Kinetic Energy:",If[p<2,"\[EmptySquare]","\[CheckmarkedBox]"]},
								{"Potential Energy:",If[p<3,"\[EmptySquare]","\[CheckmarkedBox]"]},
								{"Wavefunctions:",If[p<4,"\[EmptySquare]","\[CheckmarkedBox]"]}
								},
								Alignment->Left
								]
							]
						]
					],
			_Function,
				Monitor[iChemDVRRun[obj,ops],m@RunCheckPoint],
			_,
				iChemDVRRun[obj,ops]
			]
		];
(*ChemDVRRun[obj:dvrObjPattern,
	ret:
		$dvrke|$dvrpe|$dvrwf|
			$dvrgr|$dvrgrwf|$dvrintwf,
	ops:OptionsPattern[]
	]:=
	ChemDVRRun[
		obj,
		Return\[Rule]ret,
		ops
		]*)


(*PackageAddAutocompletions[
	ChemDVRRun,
	{
		None,
		{
			$dvrke, $dvrpe, $dvrwf,
			$dvrgr, $dvrgrwf, $dvrintwf
			}
		}
	]*)


(* ::Subsubsection::Closed:: *)
(*Notebook*)



ChemDVRNotebook//Clear


Options[ChemDVRNotebook]=
	Join[
		{
			"SaveObject"->True
			},
		Options@Notebook
		];
ChemDVRNotebook[
	obj:dvrObjPattern,
	ops:OptionsPattern[]
	]:=
	With[
		{
			so=OptionValue["SaveObject"]
			},
		If[so,
			ChemDVRSave@obj
			];
		CreateDocument@
			Notebook[
				First@
					Get[PackageFilePath["Resources", "Templates", "DVRNotebook.nb"]],
				FilterRules[
					{
						ops,
						WindowTitle->ChemDVRGet[obj,"UUID"]
						},
					Options@Notebook
					]
				]
		]


(* ::Subsubsection::Closed:: *)
(*OOP Interface*)



(* ::Subsubsubsection::Closed:: *)
(*Call*)



$dvrBasicKeys=
	$dvrgr|$dvrpe|$dvrke|
		$dvrwf|$dvrgrwf|$dvrintwf|"FullResults"


ChemDVRObject[uuid_?chemDVRValidQ][a___?OptionQ]:=
	ChemDVRRun[ChemDVRObject[uuid],a];
(obj:_ChemDVRObject?chemDVRValidQ)[k:$dvrBasicKeys, args___?OptionQ]:=
	ChemDVRRun[obj, Return->k, args];
(obj:_ChemDVRObject?chemDVRValidQ)[k:$dvrexv|$dvrexm, 
		efuns:Except[_?OptionQ], args___?OptionQ]:=
	ChemDVRRun[obj, Return->{k, efuns}, args];
(obj:_ChemDVRObject?chemDVRValidQ)["Properties"]:=
	Keys@ChemDVRAssociation[obj];
(obj:_ChemDVRObject?chemDVRValidQ)["Association"]:=
	Keys@ChemDVRAssociation[obj];
(obj:_ChemDVRObject?chemDVRValidQ)[k:Except[_?OptionQ]..]:=
	ChemDVRGet[obj, k];
ChemDVRObject/:
	(obj:_ChemDVRObject?chemDVRValidQ)[[k:Except[_?OptionQ]..]]:=
		ChemDVRGet[obj, k];


(* ::Subsubsubsection::Closed:: *)
(*Mutate*)



ChemDVRObjMutate//ClearAll;
ChemDVRObjMutate~SetAttributes~HoldAllComplete;
$ChemDVROneArgMutators=
	Set|SetDelayed|TimesBy|DivideBy|AddTo|SubtractFrom|
		PrependTo|AppendTo|AssociateTo|KeyDropFrom;
$ChemDVRBaseNoArgMutators=
	Increment|Decrement;
ChemDVRObject/:(m:Set|SetDelayed)[
	obj_ChemDVRObject?chemDVRValidQ[k:Except[_?OptionQ]..],
	v_]:=
	ChemDVRMutate[obj[k], m, v];
With[{oneArgs=$ChemDVROneArgMutators, noArg=$ChemDVRNoArgMutators},
	ChemDVRObjMutate[
		(m:oneArgs)[
			(obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[k:Except[_?OptionQ]..],
			a_
			]
		]:=
		With[{o=obj},
			ChemDVRMutate[o[k], m, a]
			];
	ChemDVRObjMutate[
		(m:oneArgs)[
			(obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[[k:Except[_?OptionQ]..]],
			a_
			]
		]:=
		With[{o=obj},
			ChemDVRMutate[o[[k]], m, a]
			];
	ChemDVRObjMutate[
		(m:noArg)[
			(obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[k:Except[_?OptionQ]..]
			]
		]:=
		With[{o=obj},
			ChemDVRMutate[o[k], m]
			];
	ChemDVRObjMutate[
		(m:noArg)[
			(obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[[k:Except[_?OptionQ]..]]
			]
		]:=
		With[{o=obj},
			ChemDVRMutate[o[[k]], m]
			];
		];


Language`SetMutationHandler[ChemDVRObject, ChemDVRObjMutate]


(* ::Subsubsection::Closed:: *)
(*Formatting*)



$dvrimg=
	Graphics[First@#,
		{
			ImageSize->{28,28},
			AspectRatio->Full,
			Method->{"ShrinkWrap"->True}
			}
		]&@Graphics[{{}, GraphicsComplex[CompressedData["
1:eJyNlX9U1FUaxkcG0URwgOGHlAZEQo2CRDJSxL3ZGmKKYGAJJ8QfC5qQiBUh
GiCT0KqkOFPEGgrrUVNEMcWxjn2vpSuBBexqWMjuRIMiooiASqAG973v3X/X
g4fz5Z577/u+93mej/eyNQv/aqNSqWqH/4/8zju9/O2kbg+mV46qftk9imz/
cuQvHqz+sG15eI8j2WXarUlpd2fpEdNX72z2JAf4Bne2d5zHUK2NH6lJaxn+
cWN+ppYvcj4MJmcXDzy2dpEbc7I0r1AtpKRxtvtb7za5soDyxlm6Ua+R1qAZ
RzPnubJZi7+3n6hdRLomva7OPq9llmL1H+U/LyV/DO/+cJaW9RjtrLEbUond
3aLhilxY4riOWkvW+8S5rXLIMNOFLXeyjM7fnEe8fqpbUPiVMyv/Ke1GgM0W
Evh1R8WWAGeWbLyeMLjdSML2jZzgxCIzCyZd6S0jc4p9I4t9ndjh9bmF+bb7
yfBlIy2yic9FfT2/8yhZMTyNEk8NW+Xvs7Roh5lYRq7TTWAzrg5+cKn8DBn5
It6OjM6urjDa/EA8hrub7e7Afrzw1KG4gibC23MYzzwOVv67K+Iymesw0qE9
61sxdfqGMgtZ2e43MiLWqX/MJiH7Ksnn8x/Lkha9s3vQ4ZaY9xhm3hlQ+MKv
veQEn68da/2c7lPdGBDzHM3O5rxWqDWr6C0+P1v2Q+/WdR3Ro+kYPi81uz7e
kpXQMo7CfGzYGHWCOcysoTCPUSxUa7ZuLtbSN3j/KnYn98FLZ9QTKfT7SImq
OZlw0XEy1fL+HiieM8+X7b3sTefwfgYVVcNbzc/2+NJcXv99pXVu9iFNpD89
yuu9qxzLflJXdVFHrby+PmXlDS+lzBAo6rmjhNdZAx5WBNFYfv9t5cql/2xL
ywumGn7fTSXoXKpuU8wM+gE/v0OxSZxc9J6dnlr4eVZlndORtuSdM+mbfL9F
mVcYcGXgRqio57Jypi9x2oDti5Ty9UYlxPecpucifjPl6X+o59fEhlGV+JfZ
sDykISeM5sI6SRbrSbCfNIj9e+B8cqofzod1C/n0Y7hfNZnXR/qdoT6op4N8
tgTq94L+iPJP6A/qv03im6F/f5gPOVQP87kN8yPWmzA/BvMlxzfCfMX8ybZ5
MP9oeB+S0QjvA/p8QKJD4f064H1JnBneF+5XUdMmeH8K+qDfuYI+fEE/1McW
9CP0RRc6gr66QX/Usx/0J/RJ7fJAn2bQL239O+hX6JsaTKBvA+if2i8G/Qt/
0NUzwR/Qjz1NTAb/CH/RpyvBXxPBf7StDvwn/EmNL4M/reBfur8d/Cv8TU95
g7+hfw0dCAT/z4V8oD5bIB/CIT9o2XuQH9MhX6i2FPIF5uNMQ8yQP1rIJ6pp
+S/Pp7GQX/RqwzWeXyLf6G+XRvN8A/9q6dsE8s8C+UgbJ0M+XoT8pC5l/+L5
KfKVakJbeL7CfN3oGmMbz9+DkM80K13H87kM8puW+KTw/Bb5TtfdieT5DvP3
oMcy7vH8Rx6cDPvojVGWWMmDHZccz7sULZU82HrymmndlDTJg+Om1JZSa6bk
QXeKOUYfly95cHlsVVtgW5HkQeXvhqvzF5dIHvxlzdyzpjsVkgc6h5i2I56H
JQ+6/Lwz9BNqJA8mxS5paMphkgeblzxz3xBfK3nQnt/yyolvmiQPTtU4pIev
/0XyYEOz/9IahzbJgwNJxhcWhF2XPFg1ffvBcyt6JA8ineP/tmbvPcmD/vrV
335S9Ujy4GyXfpuhy5YiD1K1xzSlYfYUebBsj1+1PtOJIg8K1K1ZMRo3ijxI
HzKETMh4nCIPNs55uDX3Ry+KPOg6tCorLtyXIg9Mae2urw75od/Y+rStGVdu
6SQPNqYpG0/1BkoeBL9Zr5vfHSR5EOWaXud7OljyoHRPnTl69gzJg86oV4w/
p4T8jwdTU3d12eolDyblLE/JeRQieTDL54vm+yRE8qA/Xr/W/uTzkgefPrl3
amjSc5IHjjU77LYXBEgeVIw3vXyie4rkwb3oae7n856QPCj2rHrRuFYtecA2
VWtKvdQMedBneKn24etPMOTBYLJPWeh3UxjywD6ix//IhACGPPg8vKpvU2MQ
Qx7UJzZWXysKZsiDkGUXdnZOeZ4hD26KdeTBb2I/8mBInI888F0J9yMPnAug
PuRB/GaoH3nQ5w79IQ+WiP6RB/vEfJAHU8X8kAcHxHyRB71i/siDKPE+yIMI
8X7Ig2zxvsgDjwXw/siD00IfyINkoR/kQYTQF/IgX+gPeRAn9Ik8iBX6RR4c
FPpGHlChf+TBzUHwB/LAU/gHeaAS/kIeNLqA/5AHlcKfyINdF8C/yIPfhb+R
B2eE/5EHnyyDfEAe5P8K+YE8aPoG8gV5sN8A+YM8cBH5hDwYtxDyC3lQ7wb5
hjzwG4rm+Yc8KImBfEQeRJdAfiIPEs2Heb4iD9pdIH+RB2vfX83zGXlQXWXl
+Y08ePX4eJ7vyIPCojye/9Ny7GPvPuxU0BdF8E3wG3mB37j//13/E/+FsGQ=

"], {{{}, {RGBColor[0.21020243862087418`, 0.47802869583858715`, 0.802198107305176], Opacity[0.25], EdgeForm[None], GraphicsGroup[Polygon[{{1, 199, 200, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2}}]]}, {RGBColor[0., 0.5478609782372904, 0.4891696614045123], Opacity[0.25], EdgeForm[None], GraphicsGroup[Polygon[{{196, 195, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152}}]]}, {RGBColor[0., 0.5478609782372904, 0.4891696614045123], Opacity[0.25], EdgeForm[None], GraphicsGroup[Polygon[{{196, 198, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153}, {98, 197, 195, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99}}]]}, {}, {}, {}, {}, {}, {}}, {{}, {}, {RGBColor[0.21020243862087418`, 0.47802869583858715`, 0.802198107305176], PointSize[0.01388888888888889], Thickness[Tiny], Line[{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97}]}, {RGBColor[0., 0.5478609782372904, 0.4891696614045123], PointSize[0.01388888888888889], Thickness[Tiny], Line[{98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 195, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 196, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194}]}}}], {}, {}, {{}, {}}, {{}, {}}}, PlotStyle -> {Directive[RGBColor[0.21020243862087418`, 0.47802869583858715`, 0.802198107305176], Thickness[Tiny]], Directive[RGBColor[0., 0.5478609782372904, 0.4891696614045123], Thickness[Tiny]]}, Filling -> {1 -> {Axis, Directive[RGBColor[0.21020243862087418`, 0.47802869583858715`, 0.802198107305176], Opacity[0.25]]}, 2 -> {Axis, Directive[RGBColor[0., 0.5478609782372904, 0.4891696614045123], Opacity[0.25]]}}, AspectRatio -> GoldenRatio^(-1), Axes -> None, AxesLabel -> {None, None}, AxesOrigin -> {0, 0}, DisplayFunction -> Identity, Frame -> {{False, False}, {False, False}}, FrameLabel -> {{None, None}, {None, None}}, FrameTicks -> {{Automatic, Automatic}, {Automatic, Automatic}}, GridLines -> {None, None}, GridLinesStyle -> Directive[GrayLevel[0.5, 0.4]], ImagePadding -> All, Method -> {"ShrinkWrap" -> True}, PlotRange -> Automatic, PlotRangeClipping -> True, PlotRangePadding -> {{Scaled[0.02], Scaled[0.02]}, {0, 0}}, Ticks -> {Automatic, Automatic}];


Format[obj:dvrObjPattern?chemDVRValidQ]:=
	RawBoxes@
		BoxForm`ArrangeSummaryBox[
			"ChemDVRObject",
			obj,
			Replace[ChemDVRGet[obj,"Icon"],_Missing->$dvrimg],
				{
					BoxForm`MakeSummaryItem[{"Name: ",ChemDVRGet[obj,"Name"]},StandardForm],
					BoxForm`MakeSummaryItem[{"UUID: ",ChemDVRGet[obj,"UUID"]},StandardForm]
					},
			Block[{$ContextPath={"System`"}},
				Map[
					BoxForm`MakeSummaryItem[{Row@{#,": "},ChemDVRGet[obj,#]},StandardForm]&,{
						"Range",
						"Points",
						$dvrgr,
						$dvrke,
						$dvrpe,
						$dvrwf
					}]
				],
			StandardForm
			];
		


(* ::Subsection:: *)
(*ChemDVRClass*)



(* ::Subsubsection::Closed:: *)
(*ChemDVRClass*)



ChemDVRClasses[pat_:"*"]:=
	Map[
		FileBaseName,
		Join@@
			Map[
				FileNames[
					If[StringQ@pat,StringTrim[pat,".m"],pat]~~".m",
					#
					]&,
				ChemDVRDirectory["Classes", True]
				]
		];


PackageAddAutocompletions[
	"ChemDVRClass",
	List@ChemDVRClasses[]
	];


(* ::Subsubsection::Closed:: *)
(*Loading*)



ChemDVRClass::noclass="No class template found at ``";
ChemDVRClass[f_String?(FileExistsQ)]:=
	With[{a=
		If[ExpandFileName[f]==
				ExpandFileName@ChemDVRFile["Classes",FileNameTake@f],
			ChemDVRNeeds@FileBaseName@f,
			ChemDVRNeeds@f
			]},
		If[AssociationQ@a,
			If[ExpandFileName[f]==
					ExpandFileName@ChemDVRFile["Classes",FileNameTake@f],
				ChemDVRClass[Append[a,"Class"->FileBaseName@f]],
				ChemDVRClass[a]
				],
			Message[ChemDVRClass::noclass,f];$Failed
			]
		];
ChemDVRClass[f_String?(Not@*FileExistsQ)]:=
	(If[FileExistsQ@#,
			ChemDVRClass@#,
			Message[ChemDVRClass::noclass,#];$Failed])&@
		ChemDVRFile["Classes",StringTrim[f,".m"]<>".m"];


(* ::Subsubsection::Closed:: *)
(*Instantiation*)



ChemDVRClass[a_Association][ops___Rule]:=
	ChemDVRCreate[Join[a,<|ops|>]];
ChemDVRClass[a_Association][range:{{_?NumericQ,_?NumericQ}..}]:=
	ChemDVRClass[a]["Range"->range];
ChemDVRClass[a_Association][points:{__Integer?Positive}]:=
	ChemDVRClass[a]["Points"->points];
ChemDVRClass[a_Association][
	points:{__Integer?Positive},
	range:{{_?NumericQ,_?NumericQ}..}]:=
	ChemDVRClass[a]["Points"->points,"Range"->range];
ChemDVRClass[a_Association][
	range:{{_?NumericQ,_?NumericQ}..},
	points:{__Integer?Positive}
	]:=
	ChemDVRClass[a][points,range]


(* ::Subsubsection::Closed:: *)
(*Template*)



$ChemDVRClassTemplate=
	With[{sn=ToBoxes@Placeholder["Name"]},
	Notebook[{
		Cell[
			TextData@{Cell[BoxData@ToBoxes@Placeholder["LongName"]]," ","DVR"}, 
			"CodeSection"],
		Cell[TextData@{Cell[BoxData@ToBoxes@Placeholder["Description"]]},"Text"],
		Cell[BoxData@"ChemDVRBegin[];","InputSection"];
		Cell[
			BoxData@{
				RowBox[{
					RowBox[{RowBox[{sn,"FormatGrid"}],"::","usage"}],"=","\"\""}],"\n",
				RowBox[{
					RowBox[{RowBox[{sn,$dvrgr}],"::","usage"}],"=","\"\""}],"\n",
				RowBox[{
					RowBox[{RowBox[{sn,$dvrke}],"::","usage"}],"=","\"\""}],"\n",
				RowBox[{
					RowBox[{RowBox[{sn,"PotentialEnegy"}],"::","usage"}],"=","\"\""}],"\n",
				RowBox[{
					RowBox[{RowBox[{sn,$dvrwf}],"::","usage"}],"=","\"\""}],"\n",
				RowBox[{
					RowBox[{RowBox[{sn,"View"}],"::","usage"}],"=","\"\""}]
				},
				"CodeInput"],
		Cell[BoxData@RowBox[{RowBox[{"Begin","[","\"`Private`\"","]"}],";"}],
			"InputSection"],
		Cell["Grid Formatting Function", "CodeSubsubsection"],
		Cell[
			"This function should take a grid and the grid points used to generate the grid.",
			 "Text"],
		Cell[BoxData@
			RowBox[{
				RowBox[{RowBox[{sn,"FormatGrid"}],"[",RowBox[{"grid_",",","points_"}],"]"}],
				":=","\n\t",
				ToBoxes@Placeholder["FormatGrid Function"]}],
			"CodeInput"
			],
		Cell["Grid Function", "CodeSubsubsection"],
		Cell[
			"This function should take the number of grid points for each coordinate",
			 "Text"],
		Cell[BoxData@
			RowBox[{
				RowBox[{RowBox[{sn,$dvrgr}],"[",RowBox[{"points_",",","range_"}],"]"}],
				":=","\n\t",
				ToBoxes@Placeholder["Grid Function"]}],
			"CodeInput"
			],
		Cell["Kinetic Energy Function", "CodeSubsubsection"],
		Cell[
			"This should take the grid generated previously",
			 "Text"],
		Cell[BoxData@
			RowBox[{
				RowBox[{RowBox[{sn,$dvrke}],"[",RowBox[{"grid_"}],"]"}],
				":=","\n\t",
				ToBoxes@Placeholder["KineticEnergy Function"]}],
			"CodeInput"
			],
		Cell["Potential Energy Function", "CodeSubsubsection"],
		Cell[
			"This should take the grid generated previously",
			 "Text"],
		Cell[BoxData@
			RowBox[{
				RowBox[{RowBox[{sn,$dvrpe}],"[",RowBox[{"grid_"}],"]"}],
				":=","\n\t",
				ToBoxes@Placeholder["PotentialEnergy Function"]}],
			"CodeInput"
			],
		Cell["Wavefunctions Function", "CodeSubsubsection"],
		Cell[
			"This should take the kinetic and potential energies generated previously",
			 "Text"],
		Cell[BoxData@
			RowBox[{
				RowBox[{RowBox[{sn,$dvrwf}],"[",RowBox[{"T_","V_"}],"]"}],
				":=","\n\t",
				ToBoxes@Placeholder["Wavefunctions Function"]}],
			"CodeInput"
			],
		Cell["View Function", "CodeSubsubsection"],
		Cell[
			"This should take the wavefunctions, grid and potential energies",
			 "Text"],
		Cell[BoxData@
			RowBox[{
				RowBox[{RowBox[{sn,"View"}],"[",RowBox[{"wfs_","grid_","V_"}],"]"}],
				":=","\n\t",
				ToBoxes@Placeholder["View Function"]}],
			"CodeInput"
			],
		Cell[BoxData@RowBox[{RowBox[{"End","[","]"}],";"}],
			"InputSection"],
		Cell[
			BoxData@RowBox[{"<|","\n","\t",
				RowBox[{
					RowBox[{"\"Name\"","\[Rule]",RowBox@{"\"",ToBoxes@Placeholder["Name"],"\""}}],
						",","\n","\t",
					RowBox[{"\"Dimension\"","\[Rule]",ToBoxes@Placeholder["Dimension"]}],
						",","\n","\t",
					RowBox[{"\"FormatGrid\"","->",RowBox[{sn,"FormatGrid"}]}],
						",","\n","\t",
					RowBox[{"\"Grid\"","->",RowBox[{sn,$dvrgr}]}],
						",","\n","\t",
					RowBox[{"\"KineticEnergy\"","->",RowBox[{sn,$dvrke}]}],
						",","\n","\t",
					RowBox[{"\"PotentialEnergy\"","->",RowBox[{sn,$dvrpe}]}],
						",","\n","\t",
					RowBox[{"\"Wavefunctions\"","->",RowBox[{sn,$dvrwf}]}],
						",","\n","\t",
					RowBox[{"\"View\"","->",RowBox[{sn,"View"}]}]}],
					"\n","\t","|>"}],
			"CodeInput"
			],
		Cell[BoxData@"ChemDVREnd[];","InputSection"],
		Cell["","SectionSeparator"]
		},
		StyleDefinitions->
			FrontEnd`FileName[{"ChemTools","Private"},"NewDVRClass.nb"]
		]
		];


(* ::Subsubsection::Closed:: *)
(*New*)



Options[ChemDVRNewClass]={
	"LongName"->None,
	"Description"->None,
	"Name"->None,
	"Dimension"->None
	};
ChemDVRNewClass[ops:OptionsPattern[]]:=
	With[{
		name=
			Replace[OptionValue["Name"],
				s_String:>StringTrim[StringReplace[s,Except[WordCharacter]->""],"DVR"]<>
					"DVR"
				],
		ln=Replace[OptionValue["LongName"],None->OptionValue["Name"]],
		desc=OptionValue["Description"],
		dim=OptionValue["Dimension"]
		},
		With[{reps=
			{
				If[name===None,
					Nothing,
					Sequence@@{
						RowBox@{ToBoxes@Placeholder["Name"],s_}:>
							(name<>s),
						RowBox@{s1_,ToBoxes@Placeholder["Name"],s2_}:>
							s1<>name<>s2
						}
					],
				If[ln===None,
					Nothing,
					ToBoxes@Placeholder["LongName"]->ln
					],
				If[desc===None,
					Nothing,
					ToBoxes@Placeholder["Description"]->desc
					],
				If[dim===None,
					Nothing,
					ToBoxes@Placeholder["Dimension"]->dim
					]
				}
			},
			CreateDocument@
				If[Length@reps===0,
					$ChemDVRClassTemplate,
					If[name===None,
						ReplaceAll[$ChemDVRClassTemplate,reps],
						Append[ReplaceAll[$ChemDVRClassTemplate,reps],
							"WindowTitle"->name
							]
						]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Begin*)



ChemDVRBegin[context_:""]:=
	If[$Context=!=Context[ChemDVRBegin],
		BeginPackage[Context[ChemDVRBegin]];
		AppendTo[$ContextPath, Context[ChemDVRDefaultWavefunctions]]
		];


(* ::Subsubsection::Closed:: *)
(*End*)



ChemDVREnd[]:=
	If[$Context===Context[ChemDVRBegin],
		EndPackage[]
		];


(* ::Subsubsection::Closed:: *)
(*Needs*)



If[Not@AssociationQ@$ChemDVRLoaded,
	$ChemDVRLoaded=<|
		
		|>
	];


chemDVRGet[f_String?(FileExistsQ)]:=
	Replace[Get@f,
		{
			c_Association:>
				Set[$ChemDVRLoaded[f],
					Append[c,"File"->f]
					],
			_->$Failed
			}];


ChemDVRNeeds[f_String?(FileExistsQ)]:=
	Lookup[$ChemDVRLoaded,f,
		chemDVRGet[f]
		];
ChemDVRNeeds[f_String?(Not@*FileExistsQ)]:=
	Lookup[$ChemDVRLoaded,f,
		Lookup[$ChemDVRLoaded,ChemDVRFile["Classes",StringTrim[f,".m"]<>".m"],
			chemDVRGet@ChemDVRFile["Classes",StringTrim[f,".m"]<>".m"]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Reload*)



ChemDVRReload[s_String]:=(
	If[KeyMemberQ[$ChemDVRLoaded,s],
		$ChemDVRLoaded[s]=.,
		$ChemDVRLoaded[ChemDVRFile["Classes",StringTrim[s,".m"]<>".m"]]=.
		];
	ChemDVRNeeds@s
	);


PackageAddAutocompletions[
	"ChemDVRReload",
	List@ChemDVRClasses[]
	];


(* ::Subsubsection::Closed:: *)
(*Formatting*)



$dvrclassimg=
	Graphics[
		{
			Inset[
				Graphics[
					First@#/._Opacity->Opacity[.1],
					{
						ImageSize->{28,28},
						AspectRatio->Full,
						Method->{"ShrinkWrap"->True},
						PlotRange->{{-3,3},{-0,20}}
						}
					]
				],
			Inset[
				Graphics[
					{
						GrayLevel[.2],
						First@#2
						},
					{
						ImageSize->{28,28},
						AspectRatio->Full,
						Method->{"ShrinkWrap"->True}
						}
					]
				]
			},
		Background->GrayLevel[.95],
		FrameStyle->GrayLevel[.8],
		Frame->True,
		FrameTicks->False,
		ImageSize->{32,32}
		]&[$dvrimg,Graphics[{FilledCurve[Line[CompressedData["
1:eJxN2HmUjlUYAPCPKESLZA2p7Eu2SNkqRFkiZUnJUimyRCkqS7utVWTLvu+M
GWPGNjPGjNlnrNG+bySihN73zM85/XG/3/ne8533ufd7nvfe994q/Yd1G1ow
Eom0Dz5Co4J2qEAksoXRjOFWxnIb4xjP7dzBndzF3UxgIpO4h8ncyxSmch/T
mM4MZjKL2cxhLvO4P/AgD3A/85jLHGYzi5nMYDrTuI+pTOFeJnNP4IHAJCYy
gbu5izu5g9sZzzhuYyy3MobR3MIobuYmbuQGruc6ruUaruYqrgw8GLiCy7mM
S7mEi7mIC7mA8/kp53Eu53A2Z/ETzuQMfszp/Igf8gO+z/f4buChwGmcyimc
zEl8h2/zLb7JN/g6X+NETuB4juOrfIUvcyzH8CW+yNF8gc9zVODhwJF8jiM4
nMM4lM9yCAfzGT7NQXyKT/IJDuQA9mc/Ps6+fIyPsg8fYW/2CjwS2JM9+DAf
Ync+yG7sygfYhZ3ZiR15P+9jB7bnvWzHtmzDe3g372JrtmLLwM8CW7A57+Qd
bMbb2ZRNeBsbsxEbsgHr81bWY13WYW3WYk3WYHVWY1Xewpt5U+DRwCq8kZVZ
iRV5AyuwPMuxLMuwNK9nKV7HkryW1/BqXsUSLM4rWYxFWYRXBB4LvJyFWYiX
sSALMMKLkXwv8Dz/5Tn+w795lmf4F0/zFP/kSf7BEzzO3/kbfw3a50H7hT/z
J/7IH/g9v+O3/IZf8yt+yS94qR3jUX7GIzzMQzzIA9zPPOaKkeN7thhZYmSJ
kS1Gthg5YuSIkStGrhh5/2uXruUw22+zmOkeGUx37zTuEzNVH1K4V9+SuUef
k5hoLAncbYy7uNPYd3C7/z2ecfKxjbHytFXeYhgtn1sYJc+buSmSn/+N3BDJ
r4v1XBfJr5e1XBPJr6PVXBXJr6+Vkfx6Cw3rb0Ukvx5Df3f9OE/wD57knzzF
0/yLZ3iWf/MfnuO/PM8LvMjw+Q0twIK8jIVYmJcznC/C8RZhURbjlSzOEryK
V/MaXsuSvI6leD1LswzLshzLswJvYEVWYmWG83eYvyq8iTfzFlZlNVZnDdZk
LdZmHdZlPd7K+mzAhmzExryNTdiUt7MZw/U1rMs72Zwt2JKt2Jp38W7ewzZs
y3a8l+3ZgffxfnZkJ3ZmFz7AruzG8H0nfM668yE+zB7syV7szUfYh4/yMfbl
4+zH/hzAgXyCT/IpDuLTfIaDOYTh+2g4fwzlMA7nCD7HkRzF5/kCR/NFvsQx
HMuX+Qpf5TiO5wRO5Gt8nW8w3B+E8+FbfJvvcBIncwqnchrf5Xt8nx/wQ37E
6fyYMziTn3AWZ3MO53Iew/1aOL/P5wIu5CIu5hIu5TIu5wqu5Cqu5hqu5Tqu
5wZu5CZuZhS3MJoxDPfT4boVy22MYzy3cwd3chd3M4GJTOIeJnMvU5jKfUxj
OjOYySxmMzzfCNfhXOZxP8PzkXC9Ds9LLp0b/QdyegDz
"]]], FilledCurve[Line[CompressedData["
1:eJxN12W3VVUUBuAFUhICUoL0Renu7hYR2PvQ3SghZdChNAapoDTSgv4Ru7u7
W1H3Gvth6Ic5ng933BNrve88YzeYsXj0ouIhhKvFQoi2yHw2m+bZPJNNs2yu
8DKf5iVe5AWe5zme5ZlsmmbzFE/zFE/yBI/zGI/yCJ/kEzzMQ3ycj/EgD3A/
93Ev9/DRbJpk8wgf5kPczV3cyR3czm3cyi18kA9wMzdxIzdwPddxLddk0zib
1VzF+3kf7+U9XMkVXM5lXMq7uYSLuYgLeRfv5ALO57xsbs1mLudwNmdxJmdw
OqdxKqdwMidxIidwPMdxLAtMmXAMR2dzSzajeAdH8naO4G0czmEcyiEczEEc
yAHsz37syz7szV7smU2jbHqwO7uxK7uwMzuxIzuwPduxLduwNVuxJVuwOZux
KZswZqHIGRf5DkX+VvS/acgGrM96rMs6rM2bWYs1eRNrsDqrsSqr8EafoTIr
sSJvYAWWZzmW5fUsw9IsxZIswetYnMUY+E/I/ZtX+VfIz+pP/sHf+Rt/5S/8
mT/xR/7A7/kdv+U3/Nr7f8UvQ35+X4T8Tj8P+R1/FvI7j8YMfBryTERjRj4J
eWaiMUMf+z2Kxox9FPLMRWMGPwx5JqMxox+EPLPRmOH3Q57paMz4eyHPfDR2
4N2Qd+KdkHckGjvzdsg7FI2deivkHYvGzr0Z8g5GYyffCHlHo7Gzr4e8w9HY
6ddC3vFo7PyrId8B0bgTXgn5jojGnfFyyHfISyHfKdG4Y14M+c6Jxh30Qsh3
UjTuqOdDvrOicYc9F/KdFk1Z8PeC/yt4vYL3KXj/gs9T8DkLPn/qe6W+b+oc
UueTOrfUeabOOXXuqftI3VPq/lL3mrrvVA5S+UjlJpWnVL5SeUvlL5XHVD4T
eU3kN5HnRL4TeU/kP9GHRD8SfUn0J9GnRL8SfUv0L9HHRD8TfU30N9HnaHHG
vsf7KsGSLMXSLMPrWZblWJ4VeAMrshIr80ZWYVVWY3XWYNyfMV81WYs3szbr
sC7rsT4bsCGL2KjYf7+50Wu/wY3ZhE3ZjM3Zgi0Zd0XsRWu2YVu2Y3t2YEd2
Ymd2YVd2Y3f2YE/2Ym/2YV/2Y9wVsccDOJCDOJhDOJTDOJy3cQRv50hem1Ec
zTFMmLLAsRzH8V5zAidyEidzCqdyGqdzBmdyFmdzDudyHudzAe/kXVzIRc5g
MZfwbi7lMi7nCq7kPbyX9/F+ruJqruFaruN6buBGbuJmd/cAH+QWbuU2bucO
7uQu7uZDfJiP8FHu4V7u434e4EHG56mYtcd5iIf5BJ/kER7lMR7nCZ7kKZ7m
UzzDszzH87zAi7zE+LwaO3KZVxifb2OH4vPuUA7hYA7iQA5gf/ZjX/Zhb/Zi
T/Zgd3ZjV3ZhZ3ZiR3Zge7ZjW7Zha7ZiS157vv8X4eR7WA==
"]]], FilledCurve[Line[CompressedData["
1:eJxV3HV8VVe2AODTTmemU5lO3acydXekAgR3J7i7JPhNCCE4F3d3h1JKKS3u
rnVXqLuN63us5ru/ee+P+/vITXLvOXuvtfbOWYd7Q9vcejlnJkly3jlJEl50
+vHT6ceFpx8/8gd+z+/4Lb/h1/yKX/ILfs7P+Ck/4cf8iKd4kh/yA77P9/gu
3+HbfItv8g2+ztf4Kl/hy3yJL/IFnuBxHuNRHuFhHuJBHuB+7uNe7uFu7uJO
7uB2buNWbuFmbuJGPs/nuIHPcj2f4To+zbV8imv4JFdzFVdyBZdzGZdyCRdz
ERdyAedzHudyDmdzFmdyBqdzGqdyCidzEidyAsdzHMdyDEczzVEcyREczmEc
yiEczCIOYiEHsoADmM88ptif/diXfdibvdiTucxhD3ZnN3ZlF3ZmJ3ZkB7Zn
O7ZlG7ZmK7ZkCzZnMzZlEzZmNhuxIRuwPuuxLuuwNmuxJmuwOquxKquwMiux
IiuwPLNYjmVZhk/wcT7GR1mapViSJfgIH+ZDfJAP8H7ex3t5D+/mXbwzKV4/
7jj9uPj04/bTj0tOP247/biUl/FyXsEreRWv5jW8lr/ndbyeN/BG/oE38Wbe
wluZedzOO3gn7+LdvIf38j7ezwf4IEuYz5IsxdJ8lI/xcT7BMizLcsw8yrMC
K7ISK7MKq7Iaq7MGa7IWa7MO67Ie67MBG7IRs9mYTdiUzdicLdiSrdiabdiW
7dieHdiRndiZXdiV3didPZjDXPZkL/ZmH/ZlP/ZninnM5wAWcCALOYhFHMwh
HMphHM4RHMlRTHM0x3Asx3E8J3AiJ3Eyp3Aqp3E6Z3AmZ3E253Au53E+F3Ah
F3Exl3Apl3E5VzD2HJEjqxh7kgqsyEqszCqsymqszhqsyVqszTqsy3qszwZs
yEbMZmM2YVM2Y3O2YEu2Ymu2YVu2Y3t2YEd2Ymd2YVd2Y3f2YA5z2ZO92Jt9
2Jf92J8p5jGfA1jAgSzkIBZxMIdwKIdxOEdwJCNXIk4iV1ZyBZdzGZdyCRdz
ERdyAedzHudyDmdzFmdyBqdzGqdyCidzEidyAsdzHMdyDEcz8xjFkRzB4RzG
oRzCwSziIBZyIAs4gPnMY4r92Y992Ye92Ys9mcsc9mB3dmNXdmFndmJHdmB7
tmNbtmFrtmJLtmBzNmNTNmFjZrMRG7IB67Me67IOa7MWa7IGq7Maq7IKK7MS
K7ICyyf/XVPCcizLMnyCj/MxPsrSLMWSLMFH+DBjrxqxGfurkRzB4RzGoRzC
wSziIBZyIAs4gPnMY4r92Y992Ye92Ys9mcsc9mB3dmNXdmFndmJHdmB7tmNb
tmFrtmJLtmBzNmNTNmFjZrMRG7IB67Me67IOa7MWa7IGq7Maq7IKK7MSIzYj
LiI2I04iNiNusjx/m+dv83xYgiVZiqX5KB/j43yCZViW5ZjF8qzAiqzEyqzC
qqzG6qzBmqzF2qzDuqzH+mzAhmzEbDZmEzZlMzZnC7ZkK7ZmG7ZlO7ZnB3Zk
J3ZmF3ZlN3ZnD+Ywlz3Zi73Zh33Zj/2ZYh7zOYAFHMhCDmIRB3MIh3IYh3ME
R3IU0xzNMRzLcRzPCZzISZzMKZzKaZzOGZzJWZzNOZzLeZzPBVzIRVzMJVzK
ZVzOFVzJVVzNJ7mGT3Etn+Y6PsP1fJYb+Byf50Zu4mZu4VZu43bu4E7u4m7u
4V7u434e4EEe4mEe4VEe43Ge4At8kS/xZb7CV/kaX+cbfJNv8W2+w3f5Ht/n
B/yQJ3mKH/FjfsJP+Rk/5xf8kl/xa37Db/kdv+cP/JE/8Y/8E//Mv/Cv/Bv/
zn/wn/wX/83/8H+YnFHsGTyTv+BZ/CV/xV/zbP6G5/Bcnsfz+VtewN/xQl7E
i3kJL+VlvJxX8Epexat5Da/l73kdr+cNvJF/4E28mbfwVt7G23kH7+RdvJv3
8F7ex/v5AB/kQ3yYj7AES7IUS/NRPsbH+QTLsCzLMYvlWYEVWYmVWYVVWY3V
WYM1WYu1WYd1WY/12YAN2YjZbMwmbMpmbM4WbMlWbM02bMt2bM8O7MhO7Mwu
7Mpu7M4ezGEue7IXe7MP+7If+zPFPOZzAAs4kIUcxCIO5hAO5TAO5wiO5Cim
OZpjOJbjOJ4TOJGTOJlTOJXTOJ0zOJOzOJtzOJfzOJ8LuJCLuJhLuJTLuJwr
uJKruJpPcg2f4lo+zXV8huv5LDfwOT7PjdzEzdzCrdzG7dzBndzF3dzDvdzH
/TzAgzzEwzzCozzG4zzBF/giX+LLfIWv8jW+zjf4Jt/i23yH7/I9vs8P+CFP
8hQ/4sf8hJ/yM37OL/glv+LX/IbfnlHco/mO359R3KsJ7+RdvJv38F7ex/v5
AB/kQ3yYj7AES7IUS/NRPsbH+QTLsCzLMYvlWYEVWYmVWYVVWY3VWYM1WYu1
WYd1WY/12YAN2YjZbMwmbMpmbM4WbMlWbM02bMt2bM8O7MhO7Mwu7Mpu7M4e
zGEue7KXfOrD3sw835O5zGEPdmc3dmUXdmYndmQHtmc7tmUbtmYrtmQLNmcz
NmUTNmY2G7EhG7A+67Eu67A2a7Ema7A6q7Eqq7AyK7EiI86Pi/tjPCofjvAw
D/EgD3A/93Ev93A3d3End3A7t3Ert3AzN3Ejn+dz3MBnuZ7PcB2f5lo+xTV8
kqu5iiu5gsu5jEu5hIu5iAu5gPM5j3M5h7M5izM5g9M5jVM5hZM5iRM5geM5
jmM5hqOZ5iiO5AgO5zAO5RAOZhEHsZADWcABzGceU+zPfuzLPuzNXuzJXOaw
B7uzG7uyCzuzEzuyA9uzHduyDVuzFVuyBZuzGZuyiXxsLE+z5W22PM6W19ny
PFveh9VYnTVYk7VYm3VYl/VYnw3YkI2YzcZswqZsxuZswZZsxdZsw7Zsx/bs
wI7sxM7swq7sxu7swRzmsid7sTf7sC/7sT9TzGM+B7CAA1nIQSziYA7hUA7j
cI7gSHExSpykxU1aHKXFVVqcpcVdWhymxWVanKbFbVocp8V1WpynxX1aHqTl
RVqepOVNWh6l5VVanqXlXVoepuVlWp6m5W1aHqfldVqeh/2ZYh7zOYAFHMhC
DmIRB3MIh3IYh3MER3IU0xzNMRzLcRzPCZzISZzMKZzKaZzOGZzJWZzNOZzL
eZzPBVzIRVzMJVzKZVzOFVzJVVzNJ7mGT3Etn+Y6PsP1fJYb+Byf50Zu4mZu
4VZu43bu4E7u4m7u4V7u434e4EEe4mEe4VEe43GekKcn5O0JeXxCXp+Q5yfk
fTiEg1nEQSzkQBZwAPOZxxT7sx+jrsU+vDf7MPN8P/ZninnM5wAWcCALOYhF
HMwhHMphHM4RHMlRTHM0x3Asx3E8J3AiJ3Eyp3Aqp3E6Z3AmZ3E253Au53E+
F3AhF3Exl3Apl3E5V3AlV3E1n+QaPsW1fJrr+AzX81lu4HOMXk38nR+9mm8Z
1wGiZ/M14zpB9G6+ZFxHiB7O54zrDNHL+ZRxHSJ6Oh8zrlNEb+cU4zpG9Hg+
ZFzniF7P+4zrINHzeZdxnWR3UnzdJIzrKHuS4usqYVxniV5QXHeJXtBrjOsy
0RN6hXHdJnpDL/HFM4p7RC8w8uWQvA4jzw8nxXkfRh2I3tFhRp2IHtJBRh2J
XtJ+Rp2JntJeRh2K3tJuRp2KHtNORh2LXlPUteg1bWPUveg5bWHUxeg9bWLU
zehBPc+oq9GL2sCou9GTWs+oy9GbWseo29GjWsuo69GrWsOo+9GzWs1YF6J3
tZKxbkQPazljXYle1lLGuhM9rViHoqe1iLFORW9rAWMdO5kUr2thrHOnkuJ1
L4x1MHpesxjrZPS+ZjDW0eiBTWOss9ELm8JYh6MnNomxTkdvbAJjHf8iKV7X
w1jno1c2hrEPiJ5Z7AuiZzaKsW+I3tkIxr4iemjDGPuO6KUNYexLoqdWxNi3
RG+tkLGviR5bAWPfE722fOYx5fspv5fyeinvk/L+KceVcrwp55FyXinnmzIO
KeOTMm4p45kyzinjnzIvKfOVMo8p85sy7ylxkBIfKXGTEk8pcZYSfylxmRKv
KXGcEt8pcZ+SDyl5kpI/KfmUkmcp+ZeSlyn5mpLHKfkdHuJBHuB+7uNe7uFu
7uJO7uB2buNWbjGfm30d9Tb2wVGH+7Gv5/uwt5/vxZ5eJ9fr5rCH9+vObo6j
K7s4vs7s5Lg7soPzac92zrMt2zj/1mxlXFqyhfFqzmbGsSmbGN/GzDbujdjQ
fDQwP/VZz7zVZR3zWZu1zHNN1jD/1VlNXFRlFfFSmZXEUUVWEF/lmSXuyrGs
eCzDJ8Tp43xM/D4qnkuzlDgvyRLi/xE+LC8e4oPy5QHeL4/u473y6x7eLe/u
4p3y8Q7eLk9v463y9xbeLK9vYvSZTyXFfefI/xsYfemoC9cx+tZRL65l9LWj
jlzN6HtHfbmS0RePunM5o28e9ehSRl896tTFjL77z//vkdGXj7p2AaNvH/Xu
fEZfP+rguYy+f9THuA8g6uXZjPsEoo7+inEfQdTXsxj3GUTdPZNnMPH9xO8l
Xi/xPon3TRxP4jgTx584r8T5JsYhMT6JcUuMZ2KcE+OfmJfEPCXmLzGviflO
xEEiPhJxk4inRJwl4i8Rl4l4TcRxIq4T8Z7Ig0R+JPImkU+JPEvkXyIvE/ma
yONEfoeHeJAHuJ/7uJd7uJu7uJM7uJ3buJVbzOdmX0edjftONjLt+bSfS4uD
8Bc8i7/kr/hrns3f8Byey/N4Pn/LC/g7XsiLeDEv4aW8jJfzCl7Jq3g1r+G1
/D2v4/W8gTfyD7yJN/MW3srbeDvv4J28i3fzHt7L+3g/H+CDfIgP8xGWYEmW
YmlGXR7FkRzB4RzGoRzCwSziIBZyIAs4gPnMY4r92Y992Ye92Ys9mcsc9mB3
dmNXdmFndmJHdmB7tmNbtmFrtmJLtmBzNmNTNmFjZrMRG7IB67Me67IOa7MW
a7IGq7Maq7IKK7MSK7KCOCkvbsqLoyxxlSXOssRdljjMEpdZ4jRL3GaJ4yxx
nSXOs8R9ljzIkhdZ8iRL3mTJoyx5lSXPsuRdljzMkpdZ8jRL3mbJ4yx5nSXP
w2t5Da/mVbySV/ByXsZLeQkv5kW8kL/jBfwtz+d5PJfn8Dc8m7/mr/hLnsVf
8EyewYRR18P/8N/8F//Jf/Dv/Bv/yr/wz/wT/8if+CN/4Pf8jt/yG37Nr/gl
v+Dn/Iyf8hN+zI94iif5IT/g+3yP7/Idvs23+Cbf4Ot8ja/yFb7Ml/giX+AJ
HucxHuURHmbsESIfY48QeRp7hIqsxMqswqqsxuqswZqsxdqsw7qsx/pswIZs
xGw2ZhM2ZTM2Zwu2ZCu2Zhu2ZTu2Zwd2ZCd2Zhd2ZTd2Zw/mMJc92Yu92Yd9
2Y/9mWIe8zmABRzIQg5iEQdzCIdyGIdzBGMdj7iIdT3i5Ofr+TzCozzG4zzB
F/giX+LLfIWv8jW+zjf4Jt/i23yH7/I9vs8P+CFP8hQ/4sf8hJ/yM37OL/gl
v+LX/Ibf8jt+zx/4I3/iH/kn/pl/4V/5N/6d/+A/+S/+m//5P270/CY/t8nv
bfY6m73uFu+zxftudRxbHdc2x7nNcW93Htud1w7nucN57zQOu4zLLuO027jt
No57jOse47zXuO81D/vMyz7ztN+87TePB8zrAfMcsfshIw4iht9nxEnE8ruM
OIqYfpsRZxHbbzLiMGI84jJi/DVG3Easv8KI64j5l/iiR+bfJ3zvOI/5naM8
4rUO85D3OMgD3ns/9zmmvdzjWHdzl3PYyR3Obbtz3catxmALNxubTdxozJ7n
c8ZyA581xuv5jLFfx6fNyVo+Za7W8ElzuJqrzO1KRm8n5nw5o/cTsbCUS5Li
GFmcFMfMIkYvKWJpAaPXFDE2j9GLitibw+hVRUzOYvSyIlZnMHpdEcPTGL2w
iO0p/LlXluidJcW9tMiFCYxeW+TIOEYvLnJnDEcn/60JmRqRqRmZGpKpKZka
k6k5mRqUqUmZGpWpWZkalqlpmRqXqXmZGpipiZkaeTL5/zU0U1MzNTZTczM1
OFOTMzU6U7MzNTxT0zM1PlPzM2tAZk3IrBGZNSOzhmTWlMwak1lzMmtQZk3K
rFGZNSuzhh3kAe7nPu7lHu7mLu7kDm7nNm7lFvO52deRS7GWRi6N9PUIDvdz
wzjU7w/hYK9bxEHer5ADHUcBBzi+fOY57hT7O59+7Os8+7C38+/FnsYl1zjl
sIfx687MXiizN+pivDuzk3noyA7mpz3bmbe2bGM+W7OVeW7J2OvF/Dfnz/eY
Ju4xTYr3ihEvjRl7yYijRoy9ZsRX7D0j3uoz9qYRh3UZe9eIz9qMvW3EbU3G
3jfiuTpjbxxxXpVVkuL4r8zYW0deVGTsvSNfyif//Rsh8qgcyybF+VWGca92
5N3jjHu5Ix/j3u7Iz9KMe78jb0sy7g0/mRTfKx7GveOR5w8x7i2P/H+Ace95
1IX7GPemR724h3HvetSRuxj3tkd9uYNx73vm/86F8TlGUY9u4c1JcZ26ifE5
SFG/bkyK69kNvD4prnPXMT5XKerftYzPXYq6eDXjc5miXl7J+NymqKOXMz7X
KerrpYzPfYq6ezEznyv4v0iNm28=
"]]]}, ImageSize -> {52.1640625, Automatic}]];


Format[ChemDVRClass[a_Association]]:=
	RawBoxes@
		BoxForm`ArrangeSummaryBox[
			"ChemDVRClass",
			Lookup[a,"Icon",ChemDVRClass@a],
			$dvrclassimg,
				{
					BoxForm`MakeSummaryItem[{"Name: ",Lookup[a,"Name"]},StandardForm]
					},
			KeyValueMap[
				BoxForm`MakeSummaryItem[{Row@{#,": "},#2},StandardForm]&,
					KeySelect[a,MatchQ[Except["Name"]]]
				],
			StandardForm
			];


End[];



