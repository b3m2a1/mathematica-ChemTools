(* ::Package:: *)

(* Autogenerated Package *)

ChemDVRDefaultPrepareHamiltonian::usage=
ChemDVRDefaultWavefunctions::usage="";
ChemDVRDefaultGridWavefunctions::usage="";
ChemDVRDefaultInterpolatingWavefunctions::usage="";
ChemDVRDefaultExpectationValues::usage="";
ChemDVRDefaultOperatorMatrix::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*WavefunctionSelection*)



chemDVRScaledWavefunctionSpan[s_, len_]:=
	Which[
		s>=1, 
			Sequence@@{},
		s==0,
			Sequence@@{},
		s<0,
			Ceiling[s*len];;,
		True,
			;;Floor[s*len] 
		]


Options[ChemDVRDefaultWavefunctionSelection]=
	{
		"WavefunctionSelection"->All
		};
ChemDVRDefaultWavefunctionSelection[wfs_, 
	sel:Except[_?OptionQ], ops:OptionsPattern[]]:=
	If[sel=!=All,
		wfs[[All, 
			Replace[sel,
				{
					i_Integer?Positive:>
						If[i>Length@wfs[[1]], All, ;;i],
					i_Integer?Negative:>
						If[-i>Length@wfs[[1]], All, i;;],
					Scaled[s_?NumericQ]:>
						chemDVRScaledWavefunctionSpan[s, Length@wfs[[1]]],
					Scaled[{min_?NumericQ, max_?NumericQ}]:>
						With[{minMax=Sort@{min, max}},
							Replace[
								{
									chemDVRScaledWavefunctionSpan[minMax[[1]], Length@wfs[[1]]],
									chemDVRScaledWavefunctionSpan[minMax[[2]], Length@wfs[[1]]]
									},
								{
									{}:>
										Sequence@@{},
									{M_;;, ;;m_}|
										{m_;;, M_;;}|
										{;;m_, ;;M_}:>m;;M,
									{e_}:>e
									}
								]
							]
					}
				]
			]],
		wfs
		];
ChemDVRDefaultWavefunctionSelection[wfs_, ops:OptionsPattern[]]:=
	ChemDVRDefaultWavefunctionSelection[wfs,
		OptionValue["WavefunctionSelection"]
		]


(* ::Subsection:: *)
(*ChemDVRDefaultPrepareHamiltonian*)



Options[ChemDVRDefaultPrepareHamiltonian]=
	{
		"ValidateHamiltonian"->True,
		"PruningEnergy"->None,
		"HamiltonianRounding"->None
		};
ChemDVRDefaultPrepareHamiltonian[T_, V_, ops:OptionsPattern[]]:=
	Module[
		{
			prune=OptionValue["PruningEnergy"],
			vDiag,
			prunePos,
			fullLen,
			round=OptionValue["HamiltonianRounding"],
			keMat=ReleaseHold@T,
			peMat=ReleaseHold@V,
			ham,
			validate=OptionValue["ValidateHamiltonian"]=!=False,
			hermCut
			},
		If[!SquareMatrixQ[keMat]||
			(validate&&!MatrixQ[keMat, NumericQ]),
			PackageRaiseException[
				Automatic,
				"The kinetic energy is not a square numerical matrix"
				]
			];
		If[!SquareMatrixQ[peMat]||
			(validate&&!MatrixQ[peMat, NumericQ]),
			PackageRaiseException[
				Automatic,
				"The potential energy is not a square numerical matrix"
				]
			];
		ham=keMat+peMat;
		fullLen=Length@ham;
		If[!SquareMatrixQ[ham]||
			(validate&&!MatrixQ[ham, NumericQ]),
			PackageRaiseException[
				Automatic,
				"The Hamiltonian is not a square numerical matrix"
				]
			]; 
		If[NumericQ@prune||MatchQ[prune, Scaled[_?NumericQ]],
			vDiag=Normal@Diagonal[ReleaseHold@V];
			prune=
				Replace[prune, 
					{
						i_?NumericQ:>Rescale[i, MinMax@vDiag],
						Scaled[s_]:>s
						}
					];
			vDiag=Rescale[vDiag];
			prunePos=Flatten@Position[vDiag, _?(#>prune&), 1];
			ham=
				ham[[
					Complement[Range[Length@ham], prunePos], 
					Complement[Range[Length@ham], prunePos]
					]];
			];
		If[round>1, round=10^-round];
		If[NumericQ@round, ham=Round[ham, N@round]];
		If[validate&&!HermitianMatrixQ@ham, 
			If[HermitianMatrixQ[ham, Tolerance->10^-7],
				hermCut=
					SelectFirst[
						Range[
							Floor@$MachinePrecision,
							7,
							-1
							],
						HermitianMatrixQ[ham, Tolerance->10^-#]&
						];
				PackageRaiseException[
					Automatic,
					"Hamiltonian isn't Hermitian. \
Numerical instability may have introduced lack of hermiticity. \
Try passing \"HamiltonianRounding\"->``.",
					With[{c=hermCut}, HoldForm[10^-c]]
					],
				PackageRaiseException@
					"Hamiltonian is neither Hermitian nor approximately Hermitian"
				]
			]; 
		{ham, {If[ListQ@prunePos, prunePos, {}], fullLen}}
		]


(* ::Subsection:: *)
(*ChemDVRDefaultWavefunctions*)



Options[ChemDVRDefaultWavefunctions]=
	Join[
		Options@Eigensystem,
		{
			"NumberOfWavefunctions"->Automatic,
			"CorrectPhase"->True,
			"SortEnergies"->True,
			"WavefunctionEigensolver"->Eigensystem,
			"PreadjustHamiltonian"->True
			},
		Options[ChemDVRDefaultPrepareHamiltonian]
		];
ChemDVRDefaultWavefunctions[T_, V_, ops:OptionsPattern[]]:=
	Module[
		{
			useFlags,
			ham,
			wfnSel,
			hamAdj,
			hamDiag,
			hamDiagMax,
			rowSums,
			rowBounds,
			rowMin,
			rowShift,
			hamEigMax,
			nwfs=OptionValue["NumberOfWavefunctions"],
			sort=OptionValue["SortEnergies"]=!=False,
			rephase=OptionValue["CorrectPhase"]=!=False,
			wfns,
			phase,
			solver=
				Replace[OptionValue["WavefunctionEigensolver"],
					Eigenvectors->Eigensystem
					],
			origLen,
			prunePos,
			prunePosOrder,
			hamPruned
			},
		Internal`WithLocalSettings[
			useFlags=
				Fold[
					Lookup,
					SystemOptions["LinearAlgebraOptions"->"UseMatrixPropertyFlags"],
					{"LinearAlgebraOptions", "UseMatrixPropertyFlags"}
					];
			SetSystemOptions["LinearAlgebraOptions"->"UseMatrixPropertyFlags"->True],
			{ham, {prunePos, origLen}}=
				ChemDVRDefaultPrepareHamiltonian[T, V, 
					FilterRules[{ops}, Options[ChemDVRDefaultPrepareHamiltonian]]
					];
			hamPruned=Length@prunePos>0;
			If[hamPruned,
				(*
				Will need to reconstruct the wavefunctions to resample the grid properly
				The first entries will be the pruned positions.
				The last entries will be fill.
				Need to resort so that the fill is in the right spot.
				*) 
				prunePosOrder=
					Ordering@Join[Complement[Range[origLen], prunePos], prunePos]
				];
			wfnSel=
				Replace[nwfs,
					{
						Automatic:>
							If[Head@ham===SparseArray, 
								-Abs[Max@{Min@{Floor[Length@ham/10], 25}, 3}],
								If[solver===Eigenvalues,
									-Abs[Max@{Min@{Floor[Length@ham/10], 25}, 3}],
									Sequence@@{}
									]
								],
						i_Integer:>
							-i,
						_:>Sequence@@{}
						}
					];
			hamAdj=Length@{wfnSel}>0&&TrueQ@OptionValue["PreadjustHamiltonian"];
			If[hamAdj, wfnSel=-wfnSel];
			If[hamAdj||hamPruned,
				(*
				If things are pruned I want the maximum possible eigenvalue to return by Gerschgorin--
					this is what I'll give for all the pruned positions
				*)
				hamDiag=Diagonal[ham];
				hamDiagMax=Max[hamDiag];
				rowBounds=2*Abs[hamDiag]-rowSums;
				hamEigMax=Max@hamDiag+Max@Abs@rowBounds;
				];
			If[hamAdj,
				(*
				I force all eigenvalues to be negative then pick the largest ones. This is faster with the 
				Arnoldi algorithm.
				
				By Gerschgorin's theorm this means I need to push the diagonal large enough
					such that all of the eigenvalue disks are wholly negative
				*)
				hamDiag-=hamDiagMax;
				rowSums=Total@*Abs/@ham; (* Compute row sums*)
				rowBounds=2*Abs[hamDiag]-rowSums; (* Compute diagonal - disk radius *)
				rowMin=Min@rowBounds; (* Pick largest displacement in negative sense *)
				rowShift=-(2*Abs[rowMin]+hamDiagMax); (* Shift by twice this to force no intersections with zero*)
				ham=ham+SparseArray[Band[{1,1}]->rowShift, {Length@ham, Length@ham}]
				];
			wfns=
				Re@
					solver[
						ham,
						wfnSel,
						Method->
							Replace[OptionValue[Method], 
								Automatic:>
									If[Head@ham===SparseArray, 
										"Arnoldi",
										"FEAST"
										]
								],
						FilterRules[
							FilterRules[{ops},Alternatives@@Keys@Options@Eigensystem],
							Except[Method]
							]
						];
			Which[
				NumericQ@wfns[[1]],
					(* just energies, so just return them *)
					If[sort, Sort, Identity]@
						If[hamPruned, 
							If[wfnSel===All,
								Join[
									#, 
									ConstantArray[hamEigMax, Echo@Length@prunePos]
									],
								#
								]&,
							Identity
							]@
						If[TrueQ[NumericQ@rowShift],
							wfns-rowShift,
							wfns
							],
				Length@wfns==2,
					(* full eigensystem *)
					wfns=
						If[sort, #[[{1,2}, Ordering[First@#]]], #]&@
							If[hamPruned, 
								{
									If[wfnSel===All,
										Join[
											#[[1]], 
											ConstantArray[hamEigMax, Length@prunePos]
											],
										#[[1]]
										],
									Join[
										#, 
										ConstantArray[0., Length@prunePos]
										][[prunePosOrder]]&/@#[[2]]
									}&, 
								Identity
								]@
							If[TrueQ[NumericQ@rowShift],
								{
										#[[1]]-rowShift, 
										#[[2]]
										},
								#
								]&@wfns;
					If[rephase,
						phase=Sign@wfns[[2, Ordering[First@wfns][[1]]]];
						{First@wfns, phase*#&/@Last@wfns},
						wfns
						],
				True,
					wfns
				],
			SetSystemOptions["LinearAlgebraOptions"->"UseMatrixPropertyFlags"->useFlags]
			]
		];


(* ::Subsection:: *)
(*ChemDVRDefaultGridWavefunctions*)



Options[ChemDVRDefaultGridWavefunctions]=
	Join[
		{
			"ReturnEnergies"->False,
			"PruningEnergy"->None
			},
		Options[ChemDVRDefaultWavefunctionSelection],
		Options[ChemDVRDefaultGridPointList]
		];
ChemDVRDefaultGridWavefunctions[
	grid_, 
	wfs_,
	V_,
	o:OptionsPattern[]
	]:=
	With[
		{
			coreGridPoints=
				ChemDVRDefaultPruneGridPoints[
					ChemDVRDefaultGridPointList[grid, 
						FilterRules[{o}, Options@ChemDVRDefaultGridPointList]
						],
					V,
					OptionValue["PruningEnergy"]
					],
			wfns=
				ChemDVRDefaultWavefunctionSelection[
					ReleaseHold@wfs,
					FilterRules[{o}, Options[ChemDVRDefaultWavefunctionSelection]]
					],
			retE=TrueQ@OptionValue["ReturnEnergies"]
			},
		If[retE, 
			MapThread[
				#->Thread[{coreGridPoints,#2}]&,
				wfns
				],
			Map[Thread[{coreGridPoints,#}]&, wfns[[2]]]
			]
		];


(* ::Subsection:: *)
(*ChemDVRDefaultInterpolatingWavefunctions*)



Options[ChemDVRDefaultInterpolatingWavefunctions]=
	Options@ChemDVRDefaultGridWavefunctions;
ChemDVRDefaultInterpolatingWavefunctions[
	grid_,
	wfs_,
	V_,
	ops:OptionsPattern[]
	]:=
	With[
		{
			coreGridPoints=
				ChemDVRDefaultPruneGridPoints[
					ChemDVRDefaultGridPointList[grid, 
						FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
						],
					V,
					OptionValue["PruningEnergy"]
					],
			wfns=
				ChemDVRDefaultWavefunctionSelection[
					ReleaseHold@wfs,
					FilterRules[{ops}, Options[ChemDVRDefaultWavefunctionSelection]]
					],
			retE=TrueQ@OptionValue["ReturnEnergies"]
			},
		If[retE, 
			MapThread[
				#->Interpolation@MapThread[Flatten@*List,{coreGridPoints,#2}]&,
				wfns
				],
			Map[Interpolation@MapThread[Flatten@*List,{coreGridPoints, #}]&, wfns[[2]]]
			]
		];


(* ::Subsection:: *)
(*Expectations*)



(* ::Subsection:: *)
(*ChemDVRDefaultExpectationValues*)



(* ::Subsubsection::Closed:: *)
(*chemDVRCalcExpectationValue*)



chemDVRCalcExpectationValueVec[func_, grid_]:=
	Replace[func@grid, 
		Except[_List?(Length[#]==Length@grid&)]:>Map[func, grid]
		];
chemDVRCalcExpectationValueVec[func_, grid_, wf_]:=
	Replace[func[grid, wf], 
		Except[_List?(Length[#]==Length@grid&)]:>
			MapThread[func, {grid, wf}]
		];
chemDVRCalcExpectationValue[func_Function, grid_, wfL_, wfR_]:=
	wfL.
		If[MemberQ[func, Slot[2], \[Infinity]],
			chemDVRCalcExpectationValueVec[func, grid, wfR],
			wfR*chemDVRCalcExpectationValueVec[func, grid]
			];
chemDVRCalcExpectationValue[func:Except[_Function], grid_, wfL_, wfR_]:=
	wfL.Replace[chemDVRCalcExpectationValueVec[func, grid, wfR],
		{__func}:>wfR*chemDVRCalcExpectationValueVec[func, grid]
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultExpectationValues*)



Options[ChemDVRDefaultExpectationValues]=
	Options@ChemDVRDefaultGridWavefunctions;
ChemDVRDefaultExpectationValues[
	grid_,
	wfs_,
	evs_,
	V:_?SquareMatrixQ|Hold[_?SquareMatrixQ],
	ops:OptionsPattern[]
	]:=
	With[
		{
			coreGridPoints=
				ChemDVRDefaultPruneGridPoints[
					ChemDVRDefaultGridPointList[grid, 
						FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
						],
					V,
					OptionValue["PruningEnergy"]
					],
			exfns=
				Flatten@List@evs,
			wfns=
				ChemDVRDefaultWavefunctionSelection[
					ReleaseHold@wfs,
					FilterRules[{ops}, Options[ChemDVRDefaultWavefunctionSelection]]
					],
			retE=
				TrueQ@OptionValue["ReturnEnergies"]
			},
		If[retE, 
			wfns[[1]]->#&,
			Identity
			]@
				If[Not@ListQ@evs, Map[First], Identity]@
					Table[
						Map[
							chemDVRCalcExpectationValue[#, coreGridPoints, wf, wf]&,
							exfns
							],
						{wf, wfns[[2]]}
						]
		];


(* ::Subsection:: *)
(*ChemDVRDefaultOperatorMatrix*)



Options[ChemDVRDefaultOperatorMatrix]=
	Options@ChemDVRDefaultExpectationValues;
ChemDVRDefaultOperatorMatrix[
	grid_,
	wfs_,
	evs_,
	V:_?SquareMatrixQ|Hold[_?SquareMatrixQ],
	ops:OptionsPattern[]
	]:=
	Module[
		{
			coreGridPoints=
				ChemDVRDefaultPruneGridPoints[
					ChemDVRDefaultGridPointList[grid, 
						FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
						],
					V,
					OptionValue["PruningEnergy"]
					],
			exfns=
				Flatten@List@evs,
			sels,
			wfns=ReleaseHold@wfs,
			retE=
				TrueQ@OptionValue["ReturnEnergies"]
			},
		{sels, exfns}=
			Transpose@
				Replace[exfns,
					{
						(sel_->fn_):>
							{sel, fn},
						fn_:>
							{OptionValue["WavefunctionSelection"], fn}
						},
					1
					];
		wfns=
			Map[ChemDVRDefaultWavefunctionSelection[wfns, #]&, sels];
		If[Length@sels==1, First, Identity]@
			MapThread[
				Block[
					{mx, eSet=#[[1]], wfSet=#[[2]], exFs=#2},
					If[retE, 
						Array[
							{eSet[[#]], eSet[[#2]]}&,
							{Length@wfSet, Length@wfSet}
							]->#&,
						Identity
						]@
					Table[
						With[{i=i, j=j, gr=coreGridPoints, wfL=wfSet[[i]], wfR=wfSet[[j]]},
							If[Not@ListQ@exFs,
								chemDVRCalcExpectationValue[
									exFs, 
									gr, 
									wfL, wfR
									],
								Map[
									chemDVRCalcExpectationValue[
										#, 
										gr, 
										wfL, wfR
										]&,
									exFs
									]
								]
							],
						{i, Length@wfSet},
						{j, Length@wfSet}
						]
					]&,
				{
					wfns,
					exfns
					}
				]
		];


End[];



