(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemDVRDefaultFormatGrid::usage="";
ChemDVRDefaultGrid::usage=
	"Default DVR grid function";
ChemDVRDefaultNamedGrid::usage="";
ChemDVRDirectProductGrid::usage=
	"Creates a direct product grid from two grid functions";
ChemDVRDirectProductKineticEnergy::usage=
	"Creates a direct product ke from two ke functions";
ChemDVRKroneckerProductKineticEnergy::usage=
	"Calculates the kinetic energy as a Kronecker product";
ChemDVRDefaultKineticEnergy::usage=
	"Calculates the kinetic energy as a product of kes"
ChemDVRDefaultNamedPotential::usage="";
ChemDVRDefaultPotentialEnergy::usage="";
ChemDVRDefaultGridPotentialEnergy::usage="";
ChemDVRDefaultPrepareHamiltonian::usage=
ChemDVRDefaultWavefunctions::usage="";
ChemDVRDefaultGridWavefunctions::usage="";
ChemDVRDefaultInterpolatingWavefunctions::usage="";
ChemDVRDefaultExpectationValues::usage="";
ChemDVRDefaultOperatorMatrix::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*Grids*)



(* ::Subsubsection::Closed:: *)
(*FormatGrid*)



ChemDVRDefaultFormatGrid[grid_,points_,___]:=
	grid;


(* ::Subsubsection::Closed:: *)
(*DefaultGridPointList*)



Options[ChemDVRDefaultGridPointList]=
	{
		"GridPrepFunction"->Identity
		};
ChemDVRDefaultGridPointList[grid_, o:OptionsPattern[]]:=
	With[{dims=Dimensions[grid]},
		If[Depth@grid<=3,
			OptionValue["GridPrepFunction"]@grid,
			Flatten[
				OptionValue["GridPrepFunction"]@grid,
				Depth[grid]-3
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDirectProductGrid*)



(* ::Text:: *)
(*Alas this is best implemented procedurally owing to lack of FoldTuple*)



chemDVRComputeGrid[fn_, pt_, reg_, opts:OptionsPattern[]]:=
	fn[pt, reg, FilterRules[{opts}, Options[fn]]]


ChemDVRDirectProductGrid[{grids__}]:=
		Outer[List, grids];
ChemDVRDirectProductGrid[
	fns_,
	pts_,
	regions_,
	opts:OptionsPattern[]
	]:=
	ChemDVRDirectProductGrid@
		MapThread[
			#[#2, #3, FilterRules[{opts}, Options[#]]]&,
			{
				fns,
				pts,
				regions
				}
			]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultGrid*)



(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultNamedGrid*)



(* ::Subsubsubsubsection::Closed:: *)
(*RegularSubdivision*)



ChemDVRDefaultNamedGrid[
	"RegularSubdivision", 
	pt_Integer, {min_, max_}
	]:=
	Subdivide@@Flatten@{min, max, pt-1};


(* ::Subsubsubsubsection::Closed:: *)
(*InteriorSubdivision*)



ChemDVRDefaultNamedGrid[
	"InteriorSubdivision", 
	pt_Integer, {min_, max_}
	]:=
	((max-min)/(pt+1)*Range[pt])+min;


(* ::Subsubsubsubsection::Closed:: *)
(*AzimuthalSubdivision*)



ChemDVRDefaultNamedGrid[
	"AzimuthalSubdivision", 
	pt_Integer, {min_, max_}
	]:=
	DeleteDuplicatesBy[Mod[#,2\[Pi]]&]@
		ChemDVRDefaultNamedGrid[
			"RegularSubdivision", 
			pt, {min, max}
			]


(* ::Subsubsubsubsection::Closed:: *)
(*PolarSubdivision*)



ChemDVRDefaultNamedGrid[
	"PolarSubdivision", 
	pt_Integer, {min_, max_}
	]:=
	DeleteDuplicatesBy[Mod[#, \[Pi]]&]@
		ChemDVRDefaultNamedGrid[
			"RegularSubdivision", 
			pt, {min, max}
			]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultGrid*)



(* ::Text:: *)
(*

	TODO: 
		include default grids; 
		allow for easy specification in DVR template files;
		handle NonCommutativeMultiply for direct product grids;
		handle arbitrary op matrix el func for determining change of basis;

*)



ChemDVRRun::grdimfn=
	"Dimensions of grid (``) and number of grid types (``) don't match";
ChemDVRRun::ungrid=
	"\"GridType\" `` not known";


Options[ChemDVRDefaultGrid]=
	{
		"GridType"->"RegularSubdivision"
		};
ChemDVRDefaultGrid[
	pts_,
	regions_,
	ops:OptionsPattern[]
	]:=
	With[
		{
			gfs=
				Replace[OptionValue["GridType"],
					{
						k:_Cross|_NonCommutativeMultiply|_(Inactive[CircleTimes]):>List@@k,
						{s_, n_Integer}:>ConstantArray[s, n],
						s_?AtomQ:>ConstantArray[s, Length@pts]
						}
					]
			},
		If[Length@Flatten[{gfs}, 1]=!=Length@pts, 
			Message[ChemDVRRun::grdimfn, Length@pts, Length@Flatten[{gfs}, 1]];
			Throw[$Failed]
			];
		MapThread[
			Switch[#,
				_String,
					Replace[ChemDVRDefaultNamedGrid[#, #2, #3],
						ChemDVRDefaultNamedGrid[s_, __]:>
							(
								Message[ChemDVRRun::ungrid, s];
								Throw[$Failed]
								)
						],
				_,
					#[#2, #3]
				]&,
			{
				gfs,
				pts,
				regions
				}
			]//
			Replace[
				{
					{l_}:>l,
					l:{__}:>ChemDVRDirectProductGrid[l]
					}
				]
		]


(* ::Subsection:: *)
(*PotentialEnergy*)



(* ::Subsubsection::Closed:: *)
(*NamedPotential*)



ChemDVRObject::nonpot="Named potential `` unknown";


ChemDVRDefaultNamedPotential//Clear


(* ::Subsubsubsection::Closed:: *)
(*HarmonicOscillator*)



ChemDVRDefaultNamedPotential["HarmonicOscillator", ops___?OptionQ]:=
	With[
		{
			k=Lookup[{ops}, "ForceConstant", 1/2],
			re=Lookup[{ops}, "EquilibriumBondLength", 0]
			},
		With[{basic=k*(#-re)^2},
			If[Length@basic>1,
				Total[basic],
				basic
				]
			]&
		];


(* ::Subsubsubsection::Closed:: *)
(*MorseOscillator*)



ChemDVRDefaultNamedPotential["MorseOscillator", ops___?OptionQ]:=
	With[
		{
			de=Lookup[{ops}, "DissociationEnergy", 10],
			a=Lookup[{ops}, "WellWidth", 1],
			re=Lookup[{ops}, "EquilibriumBondLength", 0]
			},
		With[{basic=(de*(1-Exp[-(1/a)*(#-re)])^2)},
			If[Length@basic>1,
				Total[basic],
				basic
				]
			]&
		];


(* ::Subsubsubsection::Closed:: *)
(*MultiWellPolynomial*)



ChemDVRDefaultNamedPotential["MultiWellPolynomial", ops___?OptionQ]:=
	Module[
		{
			pos=Lookup[{ops}, "TurningPoints", {-1, 1}],
			dep=Lookup[{ops}, "Depth", 5],
			min=Lookup[{ops}, "Minimum", 0],
			mainPol,
			minValPos,
			minPos,
			minVal,
			minDiff
			},
		If[EvenQ@Length@pos,
			pos=Riffle[pos, MovingAverage[pos, 2]]
			];
		mainPol=Integrate[Product[\[FormalX]p-t, {t, pos}], \[FormalX]p];
		minValPos={\[FormalI]pol, mainPol}/.MapIndexed[{\[FormalX]p->#, \[FormalI]pol->#2[[1]]}&, pos];
		{minPos, minVal}=
			First@MinimalBy[minValPos[[Range[1, Length@pos, 2]]], Last];
		minDiff=
			Min@{
				If[minPos>1,
					minValPos[[minPos-1, 2]]-minVal,
					\[Infinity]
					],
				If[minPos<Length@pos,
					minValPos[[minPos+1, 2]]-minVal,
					\[Infinity]
					]
				};
		If[minDiff>0, 
			dep=dep/minDiff,
			dep=1
			];
		With[{expr=dep(mainPol/.\[FormalX]p->#)-(dep*minVal-min)},
			With[{basic=expr},
				If[Length@basic>1,
					Total[basic],
					basic
					]
				]&
			]
		];


(* ::Subsubsubsection::Closed:: *)
(*HinderedRotor*)



ChemDVRDefaultNamedPotential["HinderedRotor", ops___?OptionQ]:=
	With[
		{
			w=Lookup[{ops}, "WellNumber", 3],
			d=Lookup[{ops}, "WellDepth", 5.]
			},
		With[{basic=d*Cos[w/2*#]},
			If[Length@basic>1,
				Total[basic],
				basic
				]
			]&
		];


(* ::Subsubsubsection::Closed:: *)
(*Fallback*)



ChemDVRDefaultNamedPotential[name_String, ops___?OptionQ]:=
	If[FileExistsQ[name]||MemberQ[ChemDVRPotentials[], name],
		name,
		With[
			{
				pe=PhysicalSystemData[name, "PotentialEnergy"],
				crds=PhysicalSystemData[name, "Coordinates"],
				vars=PhysicalSystemData[name, "Variables"]
				},
			If[MissingQ@pe||MissingQ@crds,
				Message[ChemDVRObject::nonpot, name];
				Throw[$Failed],
				With[
					{
						potExpr=
							pe/.
								Join[
									MapIndexed[
										Sequence@@
											{#->Apply[Slot, #2], #[___]->Apply[Slot, #2]}&,
										crds
										], 
									Flatten@
										Join[
											{ops}, 
											Replace[
												Flatten@{ops},
												(s_String->v_):>
													Sequence@@{
														QuantityVariable[_, s]->v, 
														QuantityVariable[s, _]->v
														},
												1
												]
											],
									Thread[vars->1]
									]
							},
					Function[potExpr]
					]
				]
			]
		];
ChemDVRDefaultNamedPotential[e___]:=
	(Message[ChemDVRObject::nonpot, {e}];Throw[$Failed])


(* ::Subsubsection::Closed:: *)
(*GridBasedPotential*)



dvrImportPotential[obj_,grid:{_List,___}]:=
	With[{
		g=
			Select[Flatten[grid,Depth[grid]-3],AllTrue[NumericQ]]
			},
		Thread[{g[[All,;;-2]],g[[All,-1]]}]
		];
dvrImportPotential[obj_,vals:{_?NumericQ,___}]:=
	With[{
		grid=If[Length[#]==2&&MatrixQ@#[[2]],#[[1]],#]&@ChemDVRGrid[obj]
		},
		Thread[{Flatten[grid,Depth[grid]-3],vals}]
		]


dvrImportPotential[obj_,file_String?FileExistsQ]:=
	With[{
			res=
			dvrImportPotential[
				obj,
				Import[file]
				]
			},
		res/;AllTrue[res,ListQ]
		]


Options[dvrAlignPotential]=
	{
		Tolerance->.01,
		"GridPotentialPrepFunction"->Identity
		};
dvrAlignPotential[
	grid:Except[_?OptionQ],
	peInput:Except[_?OptionQ],
	ops:OptionsPattern[]
	]:=
	With[{peGrid=
			Replace[OptionValue["GridPotentialPrepFunction"]@peInput,
				Except[_List]:>peInput
				]},
		Dimensions[grid];
		With[{
			d1=Depth[grid],
			d2=Depth[peGrid],
			tol=OptionValue[Tolerance]
			},
			If[d1<d2,Throw[$Failed]];
			With[{
					points1=
						Map[grid[[Sequence@@#]]->#&, 
							Position[grid,{__?NumericQ}]
							],
					points2=
						If[Last@Dimensions[peGrid]===2,
							peGrid[[All,1]],
							Most/@peGrid
							]
					},
				If[Length[points1]=!=Length[points2],
					With[{interpf=Interpolation[peGrid]},
						ReplacePart[
							grid,
							Thread@
								Rule[Last/@points1,
									Quiet[
										interpf@@@Map[First,points1],
										InterpolatingFunction::dmval
										]
									]
							]
						],
					(*
					Find the nearest point to the points
						(issues with duplicates may arise, but only for ill-aligned data )
					Replace the grid points with the potential values
					
					*)
					Block[{
						nearestChoices=points1,
						nearestValues=points2,
						nearestFound={}
						},
						While[
							nearestFound=
								{
									nearestFound,
									DeleteDuplicates@
										AssociationThread[
											nearestValues->
												Map[First, Nearest[nearestChoices, nearestValues]]
											]
									};
							nearestChoices=
								DeleteCases[nearestChoices,
									_->(Alternatives@@Values@Last[nearestFound])
									];
							nearestValues=
								DeleteCases[nearestValues,
									Alternatives@@Keys@Last[nearestFound]
									];
							Length[nearestValues]>0
							];
						nearestFound=Apply[Join, Map[Values, Flatten[nearestFound]]];
						ReplacePart[
							grid,
							Thread[
								nearestFound->
								peGrid[[All,2]]
								]
							]
						]
					]
				]
			]
		]


Options[dvrImportAlignPotential]=Options[dvrAlignPotential];
dvrImportAlignPotential[obj_,grid_,pot:Except[_?OptionQ],
	ops:OptionsPattern[]
	]:=
	With[{p=dvrImportPotential[obj,pot]},
		dvrAlignPotential[grid,p,ops]
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultPotentialEnergy*)



ChemDVRObject::badpot=
	"Potential function `` didn't return a numerical vector over the gridpoints"; 


(* ::Subsubsubsection::Closed:: *)
(*iChemDVRDefaultPotentialFunction*)



(* ::Text:: *)
(*
	
	Need good symbolic representation for a direct product of potential functions, which can also work for the grid and for the kinetic energy too.

*)



iChemDVRDefaultPotentialFunction//Clear


iChemDVRDefaultPotentialFunction[s_String, ops___]:=
	ChemDVRDefaultNamedPotential[s, ops];
iChemDVRDefaultPotentialFunction[
	{s_String, op___?OptionQ},
	___
	]:=
	ChemDVRDefaultNamedPotential[s, op];
iChemDVRDefaultPotentialFunction[
	{s_, n_Integer}, 
	ops___
	]:=
	iChemDVRDefaultPotentialFunction[
		NonCommutativeMultiply@@ConstantArray[s, n],
		ops
		];
iChemDVRDefaultPotentialFunction[
	(NonCommutativeMultiply|List|Cross)[a:Repeated[Except[_?OptionQ].., {2, \[Infinity]}]], 
	ops___
	]:=
	Function[
		Evaluate@
			MapIndexed[#[Slot@@#2]&, 
				iChemDVRDefaultPotentialFunction[#, ops]&/@{a}
				]
		]/.Slot[n_]:>#[[n]];
iChemDVRDefaultPotentialFunction[
	(NonCommutativeMultiply|List|Cross)[a:Except[_?OptionQ]], 
	ops___
	]:=
	iChemDVRDefaultPotentialFunction[a, ops];
iChemDVRDefaultPotentialFunction[e_, ___]:=
	e


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPotentialEnergyElementFunction*)



Options[ChemDVRDefaultPotentialEnergyElementFunction]=
	{
		"PotentialFunction"->Automatic,
		Function->Automatic
		};
ChemDVRDefaultPotentialEnergyElementFunction[ops:OptionsPattern[]]:=
	Replace[
		iChemDVRDefaultPotentialFunction[
			Lookup[Flatten@{ops}, "PotentialFunction", 
				Lookup[
					Options[ChemDVRDefaultPotentialEnergyElementFunction], 
					"PotentialFunction"
					]
				]
			],
		Except[
			_Function|_InterpolatingFunction|
			_CompiledFunction|_Symbol?(Length[DownValues[#]>0]&)
			]:>
			iChemDVRDefaultPotentialFunction[
				Lookup[Flatten@{ops}, Function, 
					Lookup[
						Options[ChemDVRDefaultPotentialEnergyElementFunction], 
						Function
						]
					]
				]
		]


(* ::Subsubsubsection::Closed:: *)
(*iChemDVRPotentialEnergy*)



iChemDVRPotentialEnergy[gridpoints_, function_]:=
	With[
		{
			gpVec=
				Replace[Quiet@function@gridpoints, 
					Except[_List?(Length[#]==Length[gridpoints]&)]:>Map[function, gridpoints]]
			},
		If[!VectorQ@gpVec,
			Message[ChemDVRObject::badpot, function];
			Throw[$Failed],
			SparseArray[Band[{1, 1}]->gpVec]
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPotentialEnergy*)



Options[ChemDVRDefaultPotentialEnergy]=
	Join[
		Options[ChemDVRDefaultPotentialEnergyElementFunction],
		Options@ChemDVRDefaultGridPointList
		];
ChemDVRDefaultPotentialEnergy[grid_, ops___?OptionQ]:=
	With[
		{
			pf=
				Replace[Function[e_List]:>Function[Total[e]]]@
					ChemDVRDefaultPotentialEnergyElementFunction[ops],
			gp=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{ops},
						Options@ChemDVRDefaultGridPointList
						]
					]
				},
		iChemDVRPotentialEnergy[gp, pf]
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultGridPotentialEnergy*)



Options[ChemDVRDefaultGridPotentialEnergy]=
	Options[ChemDVRDefaultGridPointList];
ChemDVRDefaultGridPotentialEnergy[
	grid:_List, 
	pe:{Except[_List], ___},
	ops:OptionsPattern[]
	]:=
	MapThread[
		Flatten@*List,
		{
			ChemDVRDefaultGridPointList[grid, ops],
			pe
			}
		];
ChemDVRDefaultGridPotentialEnergy[
	grid:_List, 
	pe:_SparseArray|_List?(SquareMatrixQ),
	ops:OptionsPattern[]
	]:=
	ChemDVRDefaultGridPotentialEnergy[
		grid,
		Normal@Diagonal@pe,
		ops
		]


(* ::Subsection:: *)
(*KineticEnergy*)



(* ::Subsubsection::Closed:: *)
(*ChemDVRKroeneckerProductKineticEnergy*)



(* ::Text:: *)
(*Many, many, many thanks to Henrik Schumacher for this wonderful implementation:
	https://mathematica.stackexchange.com/a/165953/38205*)



(* ::Subsubsubsection::Closed:: *)
(*Imp*)



(* ::Subsubsubsubsection::Closed:: *)
(*dvrKGetValues*)



If[Length@OwnValues[dvrKGetValues]==0,
	dvrKGetValues := 
		dvrKGetValues=
			Compile[
				{
					{k1row, _Real, 1}, {blockvals, _Real, 2}, 
					{diagidx, _Integer, 1}, {i, _Integer}
					},
		   Block[{A},
		    A =
		    	Join[
			      Table[
								Compile`GetElement[k1row, k], 
								{l, 1, Dimensions[blockvals][[1]]}, 
								{k, 1, i}
								],
			      blockvals,
			      Table[
								Compile`GetElement[k1row, k], 
								{l, 1, Dimensions[blockvals][[1]]}, 
								{k, i + 2, Length[k1row]}
								],
			      2
			      ];
		    Do[
					A[[k, Compile`GetElement[diagidx, k] + i]] += 
						Compile`GetElement[k1row, i + 1], 
					{k, 1, Length[blockvals]}
					];
		    A
		    ],
		   RuntimeAttributes -> {Listable},
		   Parallelization -> True,
		   CompilationTarget -> "C",
		   RuntimeOptions -> "Speed"
		   ]
	]


(* ::Subsubsubsubsection::Closed:: *)
(*dvrKGetColumnIndices*)



If[Length@OwnValues[dvrKGetColumnIndices]==0,
	dvrKGetColumnIndices := 
		dvrKGetColumnIndices=
			Compile[{
		    {blockci, _Integer, 3}, {diagci, _Integer, 
		     3}, {m, _Integer}, {n, _Integer}, {i, _Integer}
		    },
		   If[i > 0,
		    If[i < m - 1,
		     Join[
						diagci[[All, 1 ;; i]], 
						blockci + i n, 
						diagci[[All, i + 1 ;; m - 1]] + (n), 
						2
						],
		     Join[
						diagci[[All, 1 ;; i]], 
						blockci + i n, 
						2
						]
		     ],
		    Join[
		    	blockci + i n, 
		    	diagci[[All, i + 1 ;; m - 1]] + (n), 
		    	2
		    	]
		    ],
		   RuntimeAttributes -> {Listable},
		   Parallelization -> True,
		   CompilationTarget -> "C",
		   RuntimeOptions -> "Speed"
		   ]
	];


(* ::Subsubsubsubsection::Closed:: *)
(*dvrKToSparseArray*)



dvrKToSparseArrayData[b_?MatrixQ] := {
  Partition[SparseArray[b]["ColumnIndices"], Dimensions[b][[2]]],
  b,
  Dimensions[b][[2]],
  Range[Dimensions[b][[2]]]
  }

dvrKToSparseArray[X_] := 
 With[{d1 = Dimensions[X[[1]]][[1]], d2 = Dimensions[X[[1]]][[2]]},
  SparseArray @@ {Automatic, {d1, d1}, 0,
    {1, {Range[0, d1 d2, d2], Flatten[X[[1]], 1]}, Flatten[X[[2]]]}}
  ]


(* ::Subsubsubsubsection::Closed:: *)
(*dvrKIteration*)



dvrKIteration[X_, a_] := With[{
   m = Length[a],
   blockci = X[[1]],
   blockvals = X[[2]],
   n = X[[3]],
   diagidx = X[[4]]
   },
  With[{ran = Range[0, m - 1]},
   {
    Join @@ 
    	dvrKGetColumnIndices[blockci, 
    		Transpose[Partition[Partition[Range[(m - 1) n], 1], n]], 
    		m, 
    		n, 
    		ran
    		],
    Join @@ dvrKGetValues[a, blockvals, diagidx, ran],
    m n,
    Join @@ Outer[Plus, ran, diagidx]
    }
   ]
  ]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDirectProductKineticEnergy*)



ChemDVRKroeneckerProductKineticEnergy[keMats:{__List}]:=
	dvrKToSparseArray[
		Fold[dvrKIteration, 
			dvrKToSparseArrayData[keMats[[1]]], 
			Rest[keMats]
			]
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDirectProductKineticEnergy*)



chemDVRKeOptValue[k_, opts_, fns_]:=
	Lookup[opts, k,
		Lookup[Merge[Options/@fns, First], k,
			Lookup[Options[ChemDVRDirectProductKineticEnergy], k]
			]
		];


Options[ChemDVRDirectProductKineticEnergy]=
	Join[
		{
			"Masses"->Automatic,
			"HBars"->Automatic,
			"ScalingFactors"->Automatic,
			Precision->MachinePrecision
			},
		Options[ChemDVRDefaultGridPointList]
		];
ChemDVRDirectProductKineticEnergy[
	fns_,
	grid_,
	opts:OptionsPattern[]
	]:=
	With[
		{
			subgrids=
				Map[
					DeleteDuplicates, 
					Transpose@
						ChemDVRDefaultGridpointList[grid, 
							FilterRules[{opts}, Options[ChemDVRDefaultGridpointList]]
							]
					],
			masses=
				Replace[
					chemDVRKeOptValue["Masses", Flatten@{opts}, fns],
					{
						n_?NumericQ:>ConstantArray[n, Length@fns],
						{n__?NumericQ}:>Flatten[ConstantArray[n, Length@fns]][[;;Length@fns]],
						_:>ConstantArray[1, Length@fns]
						}
					],
			hbars=
				Replace[
					chemDVRKeOptValue["HBars", Flatten@{opts}, fns],
					{
						n_?NumericQ:>ConstantArray[n, Length@fns],
						{n__?NumericQ}:>Flatten[ConstantArray[n, Length@fns]][[;;Length@fns]],
						_:>ConstantArray[1, Length@fns]
						}
					],
			sfacs=
				Replace[
					chemDVRKeOptValue["ScalingFactors", Flatten@{opts}, fns],
					{
						n_?NumericQ:>ConstantArray[n, Length@fns],
						{n__?NumericQ}:>Flatten[ConstantArray[n, Length@fns]][[;;Length@fns]],
						_:>ConstantArray[1, Length@fns]
						}
					],
			prec=
				Replace[
					chemDVRKeOptValue[Precision, Flatten@{opts}, fns],
					Except[_?NumericQ|\[Infinity]]->MachinePrecision
					]
			},
		ChemDVRKroneckerProductKineticEnergy[
			(*
				Compute the individual KEs to feed into Henriks Kronecker Product KE
			*)
			MapThread[
				With[{opt=Association@Options[fns]},
					If[KeyExistsQ[opt, "ScalingFactor"],
						Identity,
						With[{f=#5}, f*#&]
						]@
						If[KeyExistsQ[opt, Precision],
							Identity,
							N[#, prec]
							]@
							#[#2, 
								FilterRules[
									{"Mass"->#3, "HBar"->#4, "ScalingFactor"->#5, Precision->prec},
									Options[#]
									]
								]
					]&,
				{
					fns,
					subgrids,
					masses,
					hbars,
					sfacs
					}
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultKineticEnergy*)



(* ::Subsubsubsection::Closed:: *)
(*iChemDVRDefaultKineticEnergy1D*)



ChemDVRRun::badkeel=
	"Couldn't determine arguments for element function ``. \
Expected to take (i, j), (i, j, N) or (i, j, N, x[i], x[j])";


ChemDVRRun::badke=
	"Kinetic energy function returned non-numerical KE";


Options[iChemDVRDefaultKineticEnergy1D]=
	{
		"Mass"->1,
		"HBar"->1,
		"ScalingFactor"->1,
		Precision->MachinePrecision
		};
iChemDVRDefaultKineticEnergy1D[
	elementFunction_,
	gridpoints:{__?NumericQ},
	ops:OptionsPattern[]
	]:=
	Module[
		{
			gn=Length@gridpoints,
			dx=gridpoints[[2]]-gridpoints[[1]],
			hb=OptionValue["HBar"],
			m=OptionValue["Mass"],
			coeff,
			ke,
			elf=
				Replace[elementFunction,
					s_String:>iChemDVRDefaultKineticEnergyElementFunction[s]
					]
			},
		coeff=
			If[NumericQ@OptionValue["ScalingFactor"],
				OptionValue["ScalingFactor"],
				1
				]*hb^2/(2m*dx^2);
		ke=
			Which[
				Quiet@NumericQ@elf[1, 1],
					Table[coeff*elf[i, j], {i, gn}, {j, gn}],
				Quiet@NumericQ@elf[1, 1, gn],
					Table[coeff*elf[i, j, gn], {i, gn}, {j, gn}],
				Quiet@NumericQ@elf[1, 1, gn, gridpoints[[1]], gridpoints[[1]]],
					Table[
						coeff*elf[i, j, gn, gridpoints[[i]], gridpoints[[j]]], 
						{i, gn}, {j, gn}],
				True,
					Message[ChemDVRRun::badkeel, elf];
					Throw[$Failed]
				];
		If[!MatrixQ[ke, NumericQ], 
			ChemDVRRun::badke;
			Throw[$Failed]
			];
		If[OptionValue[Precision]===\[Infinity],
			ke,
			N[ke, OptionValue[Precision]]
			]
		];


(* ::Subsubsubsection::Closed:: *)
(*iChemDVRDefaultKineticEnergyElementFunction*)



iChemDVRDefaultKineticEnergyElementFunction//Clear


(* ::Subsubsubsubsection::Closed:: *)
(*ColbertMillerCartesian*)



iChemDVRDefaultKineticEnergyElementFunction["ColbertMillerCartesian"]:=
	Function[
		If[#==#2, 
			\[Pi]^2/3, 
			((-1)^(#-#2))*2/(#-#2)^2
			]
		];


(* ::Subsubsubsubsection::Closed:: *)
(*ColbertMillerRadial*)



iChemDVRDefaultKineticEnergyElementFunction["ColbertMillerRadial"]:=
	Function[
		If[#==#2, 
			\[Pi]^2/3-1/#^2,
			2/(#-#2)^2-2/(#+#2)^2
			]*((-1)^(#-#2))
		];


(* ::Subsubsubsubsection::Closed:: *)
(*ColbertMillerPolar*)



iChemDVRDefaultKineticEnergyElementFunction["ColbertMillerPolar"]:=
	Function[
		(#3/Pi)^2/2*
			If[#==#2,
				(2*#3^2+1)/3-1/(Sin[Pi*#/#3]&2),
				((-1)^(#-#2))/
					(Sin[(\[Pi]*(#-#2))/(2*#3)]^2-Sin[(\[Pi]*(#+#2))/(2*#3)]^2)
				]
		];


(* ::Subsubsubsubsection::Closed:: *)
(*MeyerAzimuthal*)



iChemDVRDefaultKineticEnergyElementFunction["MeyerAzimuthal"]:=
	Function[
		If[#==#2,
			(#3^2/2+1)*1/6,
			((-1)^(#-#2))/
				(2*Sin[(\[Pi]*(#-#2))/#3]^2)
			]
		];


(* ::Subsubsubsubsection::Closed:: *)
(*Fallback*)



iChemDVRDefaultKineticEnergyElementFunction[___]:=
	(
		Message[ChemDVRRun::nokel, "Unknown kinetic energy element function ``"];
		Throw[$Failed]
		)


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultKineticEnergyElementFunction*)



ChemDVRDefaultKineticEnergyElementFunction//Clear


Options[ChemDVRDefaultKineticEnergyElementFunction]=
	{
			"KineticEnergyElementFunction"->Automatic
			};
ChemDVRDefaultKineticEnergyElementFunction[
	ops:OptionsPattern[]
	]:=
	With[
		{
			keel=
				Replace[OptionValue["KineticEnergyElementFunction"],
					{
						k:_Cross|_NonCommutativeMultiply|_(Inactive[CircleTimes]):>List@@k,
						{s_, n_Integer}:>ConstantArray[s, n]
						}
					]
				},
		Switch[keel,
			_String,
					iChemDVRDefaultKineticEnergyElementFunction[keel],
			{_String, ___?OptionQ},
				Apply[iChemDVRDefaultKineticEnergyElementFunction, keel],
			{_, _Integer},
				Map[
					ChemDVRDefaultKineticEnergyElementFunction[
						"KineticEnergyElementFunction"->#
						]&,
					ConstantArray[keel[[1]], keel[[2]]]
					],
			{(_String|{_String, ___?OptionQ})..},
				Map[
					ChemDVRDefaultKineticEnergyElementFunction[
						"KineticEnergyElementFunction"->#
						]&,
					keel
					],
			{_},
				ChemDVRDefaultKineticEnergyElementFunction@
					First@keel,
			_,
				keel
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultKineticEnergyLists*)



Options[ChemDVRDefaultKineticEnergyLists]=
	Options[iChemDVRDefaultKineticEnergy1D];
ChemDVRDefaultKineticEnergyLists[
	gridpoints_,
	keel_, 
	ops:OptionsPattern[]
	]:=
	With[
		{
			subgrids=
				Replace[
					ChemDVRDefaultGridPointList[
						gridpoints, 
						FilterRules[{ops}, Options[ChemDVRDefaultGridPointList]]
						],
					{
						l:{__List}:>
							Map[
								DeleteDuplicates, 
								Transpose@l
								],
						l_List:>{l}
						}
					],
			masses=
				OptionValue["Mass"],
			sclFacs=
				OptionValue["ScalingFactor"],
			hb=
				OptionValue["HBar"],
			prec=
				OptionValue[Precision],
			keels=If[!ListQ@keel, {keel}, keel]
			},
		If[Length@subgrids=!=Length@keels,
			Message[ChemDVRRun::kedimx, Length@subgrids, Length@keels];
			Throw[$Failed]
			];
		MapThread[
			iChemDVRDefaultKineticEnergy1D[
				#, 
				#2, 
				FilterRules[
					{
						"Mass"->#3,
						"ScalingFactor"->#4,
						"HBar"->#5,
						Precision->#6,
						ops
						}, 
					Options[iChemDVRDefaultKineticEnergy1D]
					]
				]&,
			{
				keels,
				subgrids,
				Take[
					Flatten@ConstantArray[masses, Length@keels], 
					Length@keels
					],
				Take[
					Flatten@ConstantArray[sclFacs, Length@keels], 
					Length@keels
					],
				Take[
					Flatten@ConstantArray[hb, Length@keels], 
					Length@keels
					],
				Take[
					Flatten@ConstantArray[prec, Length@keels], 
					Length@keels
					]
				}
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultKineticEnergy*)



(* ::Text:: *)
(*
	Try to generate the kinetic energy from a kinetic energy elementfunction
*)



ChemDVRRun::kedimx=
	"Dimension of grid (``) doesn't match number of kinetic energy element\
 functions (``)";


Options[ChemDVRDefaultKineticEnergy]=
	Join[
		Options[ChemDVRDefaultKineticEnergyElementFunction],
		Options[iChemDVRDefaultKineticEnergy1D]
		];
ChemDVRDefaultKineticEnergy[
	gridpoints_,
	ops:OptionsPattern[]
	]:=
	Replace[
		ChemDVRDefaultKineticEnergyElementFunction@
			FilterRules[{ops},
				Options@ChemDVRDefaultKineticEnergyElementFunction
				],
		{
			keels_List:>
				ChemDVRKroeneckerProductKineticEnergy@
					ChemDVRDefaultKineticEnergyLists[
						gridpoints,
						keels, 
					 FilterRules[{ops},
					 	Options@ChemDVRDefaultKineticEnergyLists
						 ]
					 ],
			keel_:>
				iChemDVRDefaultKineticEnergy1D[
					keel, 
					gridpoints, 
					FilterRules[{ops}, Options[iChemDVRDefaultKineticEnergy1D]]
					]
			}
		]


(* ::Subsection:: *)
(*Wavefunctions*)



(* ::Subsubsection::Closed:: *)
(*WavefunctionSelection*)



chemDVRScaledWavefunctionSpan[s_, len_]:=
	Which[
		s>=1, 
			Sequence@@{},
		s==0,
			Sequence@@{},
		s<0,
			Ceiling[s*len];;,
		True,
			;;Floor[s*len] 
		]


Options[ChemDVRDefaultWavefunctionSelection]=
	{
		"WavefunctionSelection"->All
		};
ChemDVRDefaultWavefunctionSelection[wfs_, 
	sel:Except[_?OptionQ], ops:OptionsPattern[]]:=
	If[sel=!=All,
		wfs[[All, 
			Replace[sel,
				{
					i_Integer?Positive:>
						If[i>Length@wfs[[1]], All, ;;i],
					i_Integer?Negative:>
						If[-i>Length@wfs[[1]], All, i;;],
					Scaled[s_?NumericQ]:>
						chemDVRScaledWavefunctionSpan[s, Length@wfs[[1]]],
					Scaled[{min_?NumericQ, max_?NumericQ}]:>
						With[{minMax=Sort@{min, max}},
							Replace[
								{
									chemDVRScaledWavefunctionSpan[minMax[[1]], Length@wfs[[1]]],
									chemDVRScaledWavefunctionSpan[minMax[[2]], Length@wfs[[1]]]
									},
								{
									{}:>
										Sequence@@{},
									{M_;;, ;;m_}|
										{m_;;, M_;;}|
										{;;m_, ;;M_}:>m;;M,
									{e_}:>e
									}
								]
							]
					}
				]
			]],
		wfs
		];
ChemDVRDefaultWavefunctionSelection[wfs_, ops:OptionsPattern[]]:=
	ChemDVRDefaultWavefunctionSelection[wfs,
		OptionValue["WavefunctionSelection"]
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultPrepareHamiltonian*)



Options[ChemDVRDefaultPrepareHamiltonian]=
	{
		"ValidateHamiltonian"->True,
		"PruningEnergy"->None
		};
ChemDVRDefaultPrepareHamiltonian[T_, V_, ops:OptionsPattern[]]:=
	Module[
		{
			prune=OptionValue["PruningEnergy"],
			vDiag,
			prunePos,
			ham=T+V//ReleaseHold
			},
		If[!SquareMatrixQ[ham]||
			(OptionValue["ValidateHamiltonian"]=!=False&&!MatrixQ[ham, NumericQ]),
			Message[ChemDVRRun::badham];
			Throw[$Failed]
			]; 
		If[NumericQ@prune||MatchQ[prune, Scaled[_?NumericQ]],
			vDiag=Normal@Diagonal[ReleaseHold@V];
			prune=
				Replace[prune, 
					{
						i_?NumericQ:>Rescale[i, MinMax@vDiag],
						Scaled[s_]:>s
						}
					];
			vDiag=Rescale[vDiag];
			prunePos=Flatten@Position[vDiag, _?(#>prune&), 1];
			ham=
				ham[[
					Complement[Range[Length@ham], prunePos], 
					Complement[Range[Length@ham], prunePos]
					]];
			];
		ham
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultWavefunctions*)



ChemDVRRun::badham="The computed Hamiltonian is not a square numerical matrix";


Options[ChemDVRDefaultWavefunctions]=
	Join[
		Options@Eigensystem,
		{
			"NumberOfWavefunctions"->Automatic,
			"CorrectPhase"->True,
			"SortEnergies"->True,
			"WavefunctionEigensolver"->Eigensystem
			},
		Options[ChemDVRDefaultPrepareHamiltonian]
		];
ChemDVRDefaultWavefunctions[T_, V_, ops:OptionsPattern[]]:=
	Module[
		{
			ham,
			wfnSel,
			minMaxDiag,
			nwfs=OptionValue["NumberOfWavefunctions"],
			sort=OptionValue["SortEnergies"]=!=False,
			rephase=OptionValue["CorrectPhase"]=!=False,
			wfns,
			phase,
			solver=
				Replace[OptionValue["WavefunctionEigensolver"],
					Eigenvectors->Eigensystem
					]
			},
		ham=
			ChemDVRDefaultPrepareHamiltonian[T, V, 
				FilterRules[{ops}, Options[ChemDVRDefaultPrepareHamiltonian]]
				];
		wfnSel=
			Replace[nwfs,
				{
					Automatic:>
						If[Head@ham===SparseArray, 
							-Abs[Min@{Length@ham, 25}],
							If[solver===Eigenvalues,
								-Abs[Min@{Length@ham, 25}],
								Sequence@@{}
								]
							],
					i_Integer:>
						-i,
					_:>Sequence@@{}
					}
				];
		If[Length@{wfnSel}>0,
			minMaxDiag=MinMax@Diagonal[ham];
			If[minMaxDiag[[1]]<0&&minMaxDiag[[2]]>0,
				ham=ham-SparseArray[Band[{1,1}]->minMaxDiag[[1]], {Length@ham, Length@ham}]
				]
			];
		wfns=
			solver[
				ham,
				wfnSel,
				Method->
					Replace[OptionValue[Method], 
						Automatic:>
							If[Head@ham===SparseArray, 
								Automatic,
								"FEAST"
								]
						],
				FilterRules[
					FilterRules[{ops},Alternatives@@Keys@Options@Eigensystem],
					Except[Method]
					]
				];
		Which[
			NumericQ@wfns[[1]],
				(* just energies, so just return them *)
				If[sort, Sort, Identity]@
					If[TrueQ[Length[minMaxDiag]==2&&minMaxDiag[[1]]<0&&minMaxDiag[[2]]>0],
						wfns+minMaxDiag[[1]],
						wfns
						],
			Length@wfns==2,
				(* full eigensystem *)
				wfns=
					If[sort, #[[{1,2}, Ordering[First@#]]], #]&@
						If[TrueQ[Length[minMaxDiag]==2&&minMaxDiag[[1]]<0&&minMaxDiag[[2]]>0],
							{#[[1]]+minMaxDiag[[1]], #[[2]]},
							#
							]&@wfns;
				If[rephase,
					phase=Sign@wfns[[2, Ordering[First@wfns][[1]]]];
					{First@wfns,phase*#&/@Last@wfns},
					wfns
					],
			True,
				wfns
			]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultGridWavefunctions*)



Options[ChemDVRDefaultGridWavefunctions]=
	Join[
		{
			"ReturnEnergies"->False
			},
		Options[ChemDVRDefaultWavefunctionSelection],
		Options[ChemDVRDefaultGridPointList]
		];
ChemDVRDefaultGridWavefunctions[grid_,wfs_, o:OptionsPattern[]]:=
	With[
		{
			coreGridPoints=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{o}, Options@ChemDVRDefaultGridPointList]
					],
			wfns=
				ChemDVRDefaultWavefunctionSelection[
					ReleaseHold@wfs,
					FilterRules[{o}, Options[ChemDVRDefaultWavefunctionSelection]]
					],
			retE=TrueQ@OptionValue["ReturnEnergies"]
			},
		If[retE, 
			MapThread[
				#->Thread[{coreGridPoints,#2}]&,
				wfns
				],
			Map[Thread[{coreGridPoints,#}]&, wfns[[2]]]
			]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultInterpolatingWavefunctions*)



Options[ChemDVRDefaultInterpolatingWavefunctions]=
	Options@ChemDVRDefaultGridWavefunctions;
ChemDVRDefaultInterpolatingWavefunctions[
	grid_,
	wfs_,
	ops:OptionsPattern[]
	]:=
	With[
		{
			coreGridPoints=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{ops}, Options@ChemDVRDefaultGridPointList]
					],
			wfns=
				ChemDVRDefaultWavefunctionSelection[
					ReleaseHold@wfs,
					FilterRules[{ops}, Options[ChemDVRDefaultWavefunctionSelection]]
					],
			retE=TrueQ@OptionValue["ReturnEnergies"]
			},
		If[retE, 
			MapThread[
				#->Interpolation@MapThread[Flatten@*List,{coreGridPoints,#2}]&,
				wfns
				],
			Map[Interpolation@MapThread[Flatten@*List,{coreGridPoints, #}]&, wfns[[2]]]
			]
		];


(* ::Subsection:: *)
(*Expectations*)



(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultExpectationValues*)



(* ::Subsubsubsection::Closed:: *)
(*chemDVRCalcExpectationValue*)



chemDVRCalcExpectationValueVec[func_, grid_]:=
	Replace[func@grid, 
		Except[_List?(Length[#]==Length@grid&)]:>Map[func, grid]
		];
chemDVRCalcExpectationValueVec[func_, grid_, wf_]:=
	Replace[func[grid, wf], 
		Except[_List?(Length[#]==Length@grid&)]:>
			MapThread[func, {grid, wf}]
		];
chemDVRCalcExpectationValue[func_Function, grid_, wfL_, wfR_]:=
	wfL.
		If[MemberQ[func, Slot[2], \[Infinity]],
			chemDVRCalcExpectationValueVec[func, grid, wfR],
			wfR*chemDVRCalcExpectationValueVec[func, grid]
			];
chemDVRCalcExpectationValue[func:Except[_Function], grid_, wfL_, wfR_]:=
	wfL.Replace[chemDVRCalcExpectationValueVec[func, grid, wfR],
		{__func}:>wfR*chemDVRCalcExpectationValueVec[func, grid]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultExpectationValues*)



Options[ChemDVRDefaultExpectationValues]=
	Options@ChemDVRDefaultGridWavefunctions;
ChemDVRDefaultExpectationValues[
	grid_,
	wfs_,
	evs_,
	ops:OptionsPattern[]
	]:=
	With[
		{
			coreGridPoints=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{ops}, Options[ChemDVRDefaultGridPointList]]
					],
			exfns=
				Flatten@List@evs,
			wfns=
				ChemDVRDefaultWavefunctionSelection[
					ReleaseHold@wfs,
					FilterRules[{ops}, Options[ChemDVRDefaultWavefunctionSelection]]
					],
			retE=
				TrueQ@OptionValue["ReturnEnergies"]
			},
		If[retE, 
			wfns[[1]]->#&,
			Identity
			]@
				If[Not@ListQ@evs, Map[First], Identity]@
					Table[
						Map[
							chemDVRCalcExpectationValue[#, coreGridPoints, wf, wf]&,
							exfns
							],
						{wf, wfns[[2]]}
						]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultOperatorMatrix*)



Options[ChemDVRDefaultOperatorMatrix]=
	Options@ChemDVRDefaultExpectationValues;
ChemDVRDefaultOperatorMatrix[
	grid_,
	wfs_,
	evs_,
	ops:OptionsPattern[]
	]:=
	Module[
		{
			coreGridPoints=
				ChemDVRDefaultGridPointList[grid, 
					FilterRules[{ops}, Options[ChemDVRDefaultGridPointList]]
					],
			exfns=
				Flatten@List@evs,
			sels,
			wfns=ReleaseHold@wfs,
			retE=
				TrueQ@OptionValue["ReturnEnergies"]
			},
		{sels, exfns}=
			Transpose@
				Replace[exfns,
					{
						(sel_->fn_):>
							{sel, fn},
						fn_:>
							{OptionValue["WavefunctionSelection"], fn}
						},
					1
					];
		wfns=
			Map[ChemDVRDefaultWavefunctionSelection[wfns, #]&, sels];
		If[Length@sels==1, First, Identity]@
			MapThread[
				Block[
					{mx, eSet=#[[1]], wfSet=#[[2]], exFs=#2},
					If[retE, 
						Array[
							{eSet[[#]], eSet[[#2]]}&,
							{Length@wfSet, Length@wfSet}
							]->#&,
						Identity
						]@
					Table[
						With[{i=i, j=j, gr=coreGridPoints, wfL=wfSet[[i]], wfR=wfSet[[j]]},
							If[Not@ListQ@exFs,
								chemDVRCalcExpectationValue[
									exFs, 
									gr, 
									wfL, wfR
									],
								Map[
									chemDVRCalcExpectationValue[
										#, 
										gr, 
										wfL, wfR
										]&,
									exFs
									]
								]
							],
						{i, Length@wfSet},
						{j, Length@wfSet}
						]
					]&,
				{
					wfns,
					exfns
					}
				]
		];


(* ::Subsection:: *)
(*PotentialOptimization*)



(* ::Subsubsection::Closed:: *)
(*PotentialOptimizedGrid*)



(* ::Subsubsubsection::Closed:: *)
(*iChemDVRDefault1DPOGrid*)



iChemDVRDefault1DPOGrid//Clear


iChemDVRDefault1DPOGrid[
	grid_,
	wfs:{{_?NumericQ, ___}, {_List, ___}},
	bs_Integer
	]:=
	Module[
		{
			xmat,
			gps,
			gporder,
			chob
			},
		xmat=
			ChemDVRDefaultOperatorMatrix[
				grid,
				wfs,
				{#&},
				"WavefunctionSelection"->bs
				];
		If[!SquareMatrixQ[xmat],
			xmat=xmat[[1]]
			];
		{gps, chob}=Eigensystem[xmat];
		gporder=Ordering[Abs[gps-xmat[[1]]]];
		{gps[[gporder]], chob[[gporder]]}
		];
iChemDVRDefault1DPOGrid[
	grid_,
	ke_,
	pe_,
	bs_Integer
	]:=
	iChemDVRDefault1DPOGrid[
		grid,
		ChemDVRDefaultWavefunctions[
			ke, 
			pe, 
			"NumberOfWavefunctions"->All
			],
		bs
		]


(* ::Subsubsubsection::Closed:: *)
(*FindGridReording*)



chemDVRPOFindGridReordering[new_, old_]:=
	Module[
		{
			nearestMap=
				Thread[new->Nearest[old->"Index", new, Length@new]],
			dupeGroups
			},
		dupeGroups=GroupBy[nearestMap, First@*Last];
		KeyValueMap[
			Function[
				dupeGroups[#]=First@First@#2;
				If[Length@#2>1,
					Do[
						Do[
							If[!KeyExistsQ[dupeGroups, pos],
								dupeGroups[pos]=First@el;
								Break[]
								],
							{pos, Last@el}
							],
						{el, Rest@#}
						]
					]
				],
			dupeGroups
			];
		new/.AssociationThread[Values[dupeGroups], Keys[dupeGroups]]
		]


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultPotentialOptimize*)



(* ::Text:: *)
(*
	Iterate over the grids, optimizing each degree of freedom
	Return the transformed versions of:
		\[FilledSmallCircle] the grids
		\[FilledSmallCircle] the potentials
		\[FilledSmallCircle] the kinetic energies
		\[FilledSmallCircle] the Hamiltonians
	Let the returned elements be requested explicitly so as to minimize the overhead in this
	Also should support optimization of 1D grid from the wavefunctions
*)



ChemDVRRun::pokey=
	"`` is not a valid spec for potential optimization. Valid ones are ``";
ChemDVRRun::pono=
	"No valid specs for potential optimization requested.";


Options[ChemDVRDefaultPotentialOptimize]=
	DeleteDuplicatesBy[First]@
		Join[
			Options[ChemDVRDefaultKineticEnergy],
			Options[ChemDVRDefaultPotentialEnergy],
			{
				"OptimizedComponents"->All,
				"OptimizedCoordinates"->All,
				"OptimizedBasisSize"->Scaled[.25]
				}
			];
ChemDVRDefaultPotentialOptimize[
	grid_,
	ops:OptionsPattern[]
	]:=
	Module[
		{
			subgrids=
				Replace[
					ChemDVRDefaultGridPointList[
						grid, 
						FilterRules[{ops}, Options[ChemDVRDefaultGridPointList]]
						],
					{
						l:{__List}:>
							Map[
								DeleteDuplicates, 
								Transpose@l
								],
						l_List:>{l}
						}
					],
				coordSpec,
				grids,
				keels,
				kins,
				potFuns,
				pots,
				size,
				newGrid,
				orders,
				trans,
				optSpec,
				optParts=<||>,
				optGrids,
				optKins,
				optPots,
				optHams,
				poKeys
			},
		optSpec=
			Replace[OptionValue["OptimizedComponents"],
				All->{"Grid", "PotentialEnergy", "KineticEnergy"}
				];
		poKeys=
			{
				"Grid",
				"Transformation",
				"KineticEnergy",
				"PotentialEnergy",
				"Hamiltonian"
				};
		Replace[
			Cases[Flatten@List@optSpec,
				Except[(Alternatives@@poKeys)]
				],
			l:{__}:>
				Message[ChemDVRObject::pokey, l, poKeys]
			];
		optSpec=
			If[MemberQ[poKeys, optSpec],
				optSpec,
				Cases[Flatten@List@optSpec,
					Alternatives@@poKeys
					]
				];
		If[!MemberQ[poKeys, optSpec]&&Length@optSpec==0,
			Message[ChemDVRObject::pono];
			Throw@$Failed
			];
		coordSpec=OptionValue["OptimizedCoordinates"];
		grids=subgrids[[coordSpec]];
		keels=
			ChemDVRDefaultKineticEnergyElementFunction@
				FilterRules[
					{ops},
					Options@ChemDVRDefaultKineticEnergyElementFunction
					];
		If[Length@keels!=Length@grids,
			keels=Flatten[ConstantArray[keels, Length@grids], 1][[coordSpec]]
			];
		kins=
			ChemDVRDefaultKineticEnergyLists[
				grid,
				keels,
				FilterRules[{ops}, Options@ChemDVRDefaultKineticEnergyLists]
				];
		potFuns=
			Map[
				ChemDVRDefaultPotentialEnergyElementFunction["PotentialFunction"->#]&,
				Replace[
					OptionValue["PotentialFunction"],
					a:Except[list:{(_Function|_Symbol)...}]:>
						ConstantArray[a, Length@subgrids]
					]
				][[coordSpec]];
		If[Length@potFuns!=Length@grids,
			potFuns=Flatten[ConstantArray[potFuns, Length@grids], 1][[coordSpec]]
			];
		pots=
			MapThread[
				iChemDVRPotentialEnergy,
				{
					grids,
					potFuns
					}
				];
		size=
			Flatten[
				ConstantArray[OptionValue["OptimizedBasisSize"], Length@grids],
				1
				][[coordSpec]];
		size=
			MapThread[
				Replace[#,
					{
						i_Integer?Positive:>i,
						Scaled[i_?(0<#<1&)]:>
							Ceiling[i*Length@#2],
						_->All
						}
					]&,
				{
					size,
					grids
					}
				];
		trans=
			MapThread[
				iChemDVRDefault1DPOGrid,
				{
					grids,
					kins,
					pots,
					size
					}
				];
		{newGrid, trans}=
			{trans[[All, 1]], trans[[All, 2]]};(*
		orders=
			MapThread[
				chemDVRPOFindGridReordering,
				{
					newGrid,
					grids
					}
				];*)
		Table[
			optParts[bit]=
				Switch[bit,
					"Grid",
						newGrid,
					"Transformation",
						trans[[All, 2]],
					"KineticEnergy",
						MapThread[
							(*(Length[#]/#3)**)
								(#2.#[[;;#3, ;;#3]].Transpose[#2])&,
							{
								kins,
								trans,(*
								orders,*)
								size
								}
							],
					"PotentialEnergy",
						MapThread[
							(*(Length[#]/#3)**)
								(#2.#[[#3, ;;#3]].Transpose[#2])&,
							{
								pots,
								trans,(*
								orders,*)
								size
								}
							],
					"Hamiltonian",
						MapThread[
							(*(Length[#]/#3)**)
								(#2.#[[#3, ;;#3]].Transpose[#2])&,
							{
								kins+pots,
								trans,(*
								orders,*)
								size
								}
							]
					],
			{bit, DeleteDuplicates@Flatten@List@optSpec}
			];
		If[!ListQ@optSpec&&KeyExistsQ[optParts, optSpec],
			optParts[[optSpec]],
			optParts
			]
		]


End[];



