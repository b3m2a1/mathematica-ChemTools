(* ::Package:: *)

(* Autogenerated Package *)

$ChemDVRDefaultKineticEnergyElementFunctions::usage=
	"The set of built-in kinetic energy element functions"
ChemDVRDirectProductKineticEnergy::usage=
	"Creates a direct product ke from two ke functions";
ChemDVRKroneckerProductKineticEnergy::usage=
	"Calculates the kinetic energy as a Kronecker product";
ChemDVRDefaultKineticEnergy::usage=
	"Calculates the kinetic energy as a product of kes"


Begin["`Private`"];


(* ::Subsection:: *)
(*ChemDVRKroeneckerProductKineticEnergy*)



(* ::Text:: *)
(*Many, many, many thanks to Henrik Schumacher for this wonderful implementation:
	https://mathematica.stackexchange.com/a/165953/38205*)



(* ::Subsubsection::Closed:: *)
(*Imp*)



(* ::Subsubsubsection::Closed:: *)
(*dvrKGetValues*)



If[Length@OwnValues[dvrKGetValues]==0,
	dvrKGetValues := 
		dvrKGetValues=
			Compile[
				{
					{k1row, _Real, 1}, {blockvals, _Real, 2}, 
					{diagidx, _Integer, 1}, {i, _Integer}
					},
		   Block[{A},
		    A =
		    	Join[
			      Table[
								Compile`GetElement[k1row, k], 
								{l, 1, Dimensions[blockvals][[1]]}, 
								{k, 1, i}
								],
			      blockvals,
			      Table[
								Compile`GetElement[k1row, k], 
								{l, 1, Dimensions[blockvals][[1]]}, 
								{k, i + 2, Length[k1row]}
								],
			      2
			      ];
		    Do[
					A[[k, Compile`GetElement[diagidx, k] + i]] += 
						Compile`GetElement[k1row, i + 1], 
					{k, 1, Length[blockvals]}
					];
		    A
		    ],
		   RuntimeAttributes -> {Listable},
		   Parallelization -> True,
		   CompilationTarget -> "C",
		   RuntimeOptions -> "Speed"
		   ]
	]


(* ::Subsubsubsection::Closed:: *)
(*dvrKGetColumnIndices*)



If[Length@OwnValues[dvrKGetColumnIndices]==0,
	dvrKGetColumnIndices := 
		dvrKGetColumnIndices=
			Compile[{
		    {blockci, _Integer, 3}, {diagci, _Integer, 
		     3}, {m, _Integer}, {n, _Integer}, {i, _Integer}
		    },
		   If[i > 0,
		    If[i < m - 1,
		     Join[
						diagci[[All, 1 ;; i]], 
						blockci + i n, 
						diagci[[All, i + 1 ;; m - 1]] + (n), 
						2
						],
		     Join[
						diagci[[All, 1 ;; i]], 
						blockci + i n, 
						2
						]
		     ],
		    Join[
		    	blockci + i n, 
		    	diagci[[All, i + 1 ;; m - 1]] + (n), 
		    	2
		    	]
		    ],
		   RuntimeAttributes -> {Listable},
		   Parallelization -> True,
		   CompilationTarget -> "C",
		   RuntimeOptions -> "Speed"
		   ]
	];


(* ::Subsubsubsection::Closed:: *)
(*dvrKToSparseArray*)



dvrKToSparseArrayData[b_?MatrixQ] := {
  Partition[SparseArray[b]["ColumnIndices"], Dimensions[b][[2]]],
  b,
  Dimensions[b][[2]],
  Range[Dimensions[b][[2]]]
  }

dvrKToSparseArray[X_] := 
 With[{d1 = Dimensions[X[[1]]][[1]], d2 = Dimensions[X[[1]]][[2]]},
  SparseArray @@ {Automatic, {d1, d1}, 0,
    {1, {Range[0, d1 d2, d2], Flatten[X[[1]], 1]}, Flatten[X[[2]]]}}
  ]


(* ::Subsubsubsection::Closed:: *)
(*dvrKIteration*)



dvrKIteration[X_, a_] := With[{
   m = Length[a],
   blockci = X[[1]],
   blockvals = X[[2]],
   n = X[[3]],
   diagidx = X[[4]]
   },
  With[{ran = Range[0, m - 1]},
   {
    Join @@ 
    	dvrKGetColumnIndices[blockci, 
    		Transpose[Partition[Partition[Range[(m - 1) n], 1], n]], 
    		m, 
    		n, 
    		ran
    		],
    Join @@ dvrKGetValues[a, blockvals, diagidx, ran],
    m n,
    Join @@ Outer[Plus, ran, diagidx]
    }
   ]
  ]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDirectProductKineticEnergy*)



ChemDVRKroeneckerProductKineticEnergy[keMats:{__List}]:=
	dvrKToSparseArray[
		Fold[dvrKIteration, 
			dvrKToSparseArrayData[keMats[[1]]], 
			Rest[keMats]
			]
		]


(* ::Subsection:: *)
(*ChemDVRDirectProductKineticEnergy*)



chemDVRKeOptValue[k_, opts_, fns_]:=
	Lookup[opts, k,
		Lookup[Merge[Options/@fns, First], k,
			Lookup[Options[ChemDVRDirectProductKineticEnergy], k]
			]
		];


Options[ChemDVRDirectProductKineticEnergy]=
	Join[
		{
			"Masses"->Automatic,
			"HBars"->Automatic,
			"ScalingFactors"->Automatic,
			Precision->MachinePrecision
			},
		Options[ChemDVRDefaultGridPointList]
		];
ChemDVRDirectProductKineticEnergy[
	fns_,
	grid_,
	opts:OptionsPattern[]
	]:=
	With[
		{
			subgrids=
				Map[
					DeleteDuplicates, 
					Transpose@
						ChemDVRDefaultGridpointList[grid, 
							FilterRules[{opts}, Options[ChemDVRDefaultGridpointList]]
							]
					],
			masses=
				Replace[
					chemDVRKeOptValue["Masses", Flatten@{opts}, fns],
					{
						n_?NumericQ:>ConstantArray[n, Length@fns],
						{n__?NumericQ}:>Flatten[ConstantArray[n, Length@fns]][[;;Length@fns]],
						_:>ConstantArray[1, Length@fns]
						}
					],
			hbars=
				Replace[
					chemDVRKeOptValue["HBars", Flatten@{opts}, fns],
					{
						n_?NumericQ:>ConstantArray[n, Length@fns],
						{n__?NumericQ}:>Flatten[ConstantArray[n, Length@fns]][[;;Length@fns]],
						_:>ConstantArray[1, Length@fns]
						}
					],
			sfacs=
				Replace[
					chemDVRKeOptValue["ScalingFactors", Flatten@{opts}, fns],
					{
						n_?NumericQ:>ConstantArray[n, Length@fns],
						{n__?NumericQ}:>Flatten[ConstantArray[n, Length@fns]][[;;Length@fns]],
						_:>ConstantArray[1, Length@fns]
						}
					],
			prec=
				Replace[
					chemDVRKeOptValue[Precision, Flatten@{opts}, fns],
					Except[_?NumericQ|\[Infinity]]->MachinePrecision
					]
			},
		ChemDVRKroneckerProductKineticEnergy[
			(*
				Compute the individual KEs to feed into Henriks Kronecker Product KE
			*)
			MapThread[
				With[{opt=Association@Options[fns]},
					If[KeyExistsQ[opt, "ScalingFactor"],
						Identity,
						With[{f=#5}, f*#&]
						]@
						If[KeyExistsQ[opt, Precision],
							Identity,
							N[#, prec]
							]@
							#[#2, 
								FilterRules[
									{"Mass"->#3, "HBar"->#4, "ScalingFactor"->#5, Precision->prec},
									Options[#]
									]
								]
					]&,
				{
					fns,
					subgrids,
					masses,
					hbars,
					sfacs
					}
				]
			]
		]


(* ::Subsection:: *)
(*ChemDVRBasisSetKineticEnergy*)



(* ::Subsubsection::Closed:: *)
(*iChemDVRRecKERep*)



iChemDVRRecKERep//Clear


Options[iChemDVRRecKERep]=
	{
		"KeepExact"->Automatic,
		"EchoRepresentation"->False
		};
iChemDVRRecKERep[
	recRules:{(_Integer->_)..},
	pts_,
	___?(Not@*OptionQ),
	ops:OptionsPattern[]
	]:=
	If[OptionValue@"EchoRepresentation"//TrueQ, Echo, Identity]@
	With[{ex=TrueQ@OptionValue["KeepExact"]},
		SparseArray[
			Map[
				With[{fn=#[[2]], shift=#[[1]]},
					Band[
						If[Positive@shift, 
							{1, 1+shift},
							{1-shift, 1}
							]
						]->
							Array[
								If[!ex, N, Identity]@fn[#, #+shift]&,
								pts-Abs@#[[1]], 
								Max@{1-#[[1]], 1}
								]
					]&,
				recRules
				],
			{pts, pts}
			]
		]


(* ::Subsubsection::Closed:: *)
(*iChemDVRBSKERep*)



Options[iChemDVRBSKERep]=
	{
		"KeepExact"->Automatic
		};
iChemDVRBSKERep[
	{basisFunction_, coordinate_, coordinateFunction_, keFunc_},
	{pts_},
	{min_, max_}
	]:=
	With[
		{
			cr=coordinateFunction@coordinate, 
			keF=Replace[keFunc, Automatic:>Function[D[#, {coordinate, 2}]]],
			ex=
				Replace[OptionValue["KeepExact"], 
					Except[True|False]:>NoneTrue[{min, max}, MatchQ[_Real]]]
			},
		Table[
			If[ex,
				Integrate,
				Function[Null, Quiet[NIntegrate[##], NIntegrate::ncvb], HoldAll]
				][
				basisFunction[i, cr]*
					keF@basisFunction[j, cr],
				{coordinate, min, max}
				],
			{i, pts},
			{j, pts}
			]
		]


(* ::Subsubsection::Closed:: *)
(*iChemDVRNamedRecKE*)



(* ::Subsubsubsection::Closed:: *)
(*Legendre*)



iChemDVRNamedRecKE["Legendre"|LegendreP, pts_]=
	{
		0  -> ((1-#)#&)
		};


(* ::Subsubsubsection::Closed:: *)
(*Hermite*)



iChemDVRNamedRecKE["Hermite"|HermiteH, pts_]=
	{
		0  -> (1/2(2#-1)&),
		2  -> (-(1/2)Sqrt[#(1+#)]&),
		-2 -> (-(1/2)Sqrt[#2(1+#2)]&)
		};


(* ::Subsubsubsection::Closed:: *)
(*Chebyshev*)



iChemDVRNamedRecKE["Chebyshev"|ChebyshevT, pts_]=
	{
		0  -> (Which[#==1, 3, #==2, 1/2, True, (-1-8(#-1)-4(#-1)^2)]*1/8&),
		2  -> (If[#==1, 15/(8*Sqrt[2]), (15+16(#-1)+4(#-1)^2)*1/16]&),
		-2 -> (If[#2==1, 15/(8*Sqrt[2]), (15+16(#2-1)+4(#2-1)^2)*1/16]&)
		};


(* ::Subsubsubsection::Closed:: *)
(*Fallback*)



iChemDVRNamedRecKE[name_]:=
	PackageRaiseException[
		Automatic,
		"\"BasisSet\" reccurence `` not known",
		name
		];


(* ::Subsubsection::Closed:: *)
(*iChemDVRBasisSetKineticEnergy*)



Options[iChemDVRBasisSetKineticEnergy]=
	{
		"KeepExact"->Automatic,
		"EchoRepresentation"->False
		};
iChemDVRBasisSetKineticEnergy[
	basisDef_,
	pts_
	]:=
	Module[
		{
			rep,
			eig,
			spec=basisDef,
			ops
			},
		ops=Select[basisDef, OptionQ];
		spec=Select[basisDef, Not@*OptionQ];
		rep=
			Switch[spec,
				{_String},
					iChemDVRRecKERep[
						iChemDVRNamedRecKE[spec[[1]], pts], 
						pts, 
						ops
						],
				{(_Integer->_)..},
					iChemDVRRecKERep[spec, pts, ops],
				{_},
					iChemDVRBSKERep[
						Join[spec, {\[FormalX], Identity, Automatic}],
						pts,
						ops
						],
				{_, _Symbol},
					iChemDVRBSKERep[
						Join[spec, {Identity, Automatic}],
						pts,
						ops
						],
				{_, _Symbol, _},
					iChemDVRBSKERep[
						Append[spec, Automatic],
						pts,
						ops
						],
				{_, _Symbol, _, _},
					iChemDVRBSKERep[
						spec,
						pts,
						ops
						],
				_,
					PackageRaiseException[Automatic,
						"Couldn't process basis specification ``",
						spec
						]
				]
		]


(* ::Subsection:: *)
(*ChemDVRDefaultKineticEnergy*)



$ChemDVRDefaultKineticEnergyElementFunctions=
	{
		"ColbertMillerCartesian",
		"ColbertMillerRadial",
		"ColbertMillerAzimuthal",
		"MeyerAzimuthal",
		"SibertChebyshev"
		};


(* ::Subsubsection::Closed:: *)
(*$iChemDVRDefaultKineticEnergyOptions*)



$iChemDVRDefaultKineticEnergyOptions=
	{
		{"BasisSet", "Legendre"}->
			{
				"ScalingFactor"->1/100
				},
		"ColbertMillerPolar"->
			{
				"MeshSpacing"->1,
				"ScalingFactor"->1/100
				},
		"ColbertMillerAzimuthal"->
			{
				"MeshSpacing"->1
				},
		"MeyerAzimuthal"->
			{
				"MeshSpacing"->1
				}
		};


(* ::Subsubsection::Closed:: *)
(*iChemDVRDefaultKineticEnergy1D*)



ChemDVRRun::badkeel=
	"Couldn't determine arguments for element function ``. \
Expected to take (i, j), (i, j, N) or (i, j, N, x[i], x[j])";


ChemDVRRun::badke=
	"Kinetic energy function returned non-numerical KE";


Options[iChemDVRDefaultKineticEnergy1D]=
	{
		"Mass"->1,
		"HBar"->1,
		"ScalingFactor"->1,
		Precision->MachinePrecision,
		"MeshSpacing"->Automatic,
		"TransformationMatrix"->None,
		"IncludeCoefficient"->True
		};
iChemDVRDefaultKineticEnergy1D[
	elementFunction_,
	gridpoints:{__?NumericQ},
	ops:OptionsPattern[]
	]:=
	Module[
		{
			gn=Length@gridpoints,
			dx,
			hb=OptionValue["HBar"],
			m,
			sf,
			prec,
			coeff,
			tmat,
			ke,
			elf,
			kelfOps
			},
		(** --------------------------- Element Function --------------------------- **)
		elf=
			Replace[elementFunction,
				{
					s_String:>
						iChemDVRDefaultKineticEnergyElementFunction[s],
					{s:Except["BasisSet", _String], o___}:>
						iChemDVRDefaultKineticEnergyElementFunction[s, o]
					}
				];
		kelfOps=
			Replace[elementFunction,
				{
					k:{"BasisSet", __?(Not@*OptionQ), o___?OptionQ}:>
						Join[
							FilterRules[
								{
									o, 
									"MeshSpacing"->1
									},
								Except[Alternatives@@Keys@Options@iChemDVRBasisSetKineticEnergy]
								],
							Lookup[
								$iChemDVRDefaultKineticEnergyOptions,
								Key@Take[k, 2],
								{}
								]
							],
					{s_String, o___?OptionQ}:>
						Join[
							{o},
							Lookup[$iChemDVRDefaultKineticEnergyOptions,
								s,
								{}
								]
							],
					s_String:>
						Lookup[$iChemDVRDefaultKineticEnergyOptions,
							s,
							{}
							],
					{_, o___?OptionQ}:>
						{o},
					_->{}
					}
				];
		(** --------------------------- Parameter Setup--------------------------- **)
		m=Lookup[kelfOps, "Mass", OptionValue["Mass"]];
		dx=
			Replace[Lookup[kelfOps, "MeshSpacing", OptionValue["MeshSpacing"]],
				Automatic:>gridpoints[[2]]-gridpoints[[1]]
				];
		hb=Lookup[kelfOps, "Mass", OptionValue["HBar"]];
		sf=
			Replace[
				Lookup[kelfOps, "ScalingFactor", OptionValue["ScalingFactor"]],
				Except[_?NumericQ]->1
				];
		prec=Lookup[kelfOps, Precision, OptionValue[Precision]];
		tmat=OptionValue["TransformationMatrix"];
		If[SquareMatrixQ@tmat&&Length@tmat!=gn,
			PackageRaiseException[
				Automatic,
				"\"TransformationMatrix\" dimension (``) and grid dimension (``) don't match",
				Short@elf
				]
			];
		coeff=sf*(hb^2)/(2*m*dx^2);
		(** --------------------------- Matrix Calculation --------------------------- **)
		ke=
			Which[
				MatchQ[elf, {"BasisSet", ___}],
					sf*
						iChemDVRBasisSetKineticEnergy[
							Rest@elf,
							gn
							],
				Quiet@NumericQ@elf[1, 1],
					Table[elf[i, j], {i, gn}, {j, gn}],
				Quiet@NumericQ@elf[1, 1, gn],
					Table[elf[i, j, gn], {i, gn}, {j, gn}],
				Quiet@NumericQ@elf[1, 1, gn, gridpoints[[1]], gridpoints[[1]]],
					Table[
						elf[i, j, gn, gridpoints[[i]], gridpoints[[j]]], 
						{i, gn}, {j, gn}],
				True,
					PackageRaiseException[
						"DVRRun",
						"Couldn't determine arguments for element function ``. \
Expected to take (i, j), (i, j, N) or (i, j, N, x[i], x[j])",
						"MessageParameters"->{elf}
						]
				];
		If[!MatrixQ[ke, NumericQ], 
			PackageRaiseException[
				Automatic,
				"Kinetic energy function `` returned non-numerical KE",
				Short@elf
				]
			];
		(** --------------------------- Post Processing --------------------------- **)
		If[SquareMatrixQ@tmat,
			ke=tmat.ke.Transpose[tmat]
			];
		If[Lookup[kelfOps, "IncludeCoefficient", OptionValue["IncludeCoefficient"]], 
			ke=coeff*ke
			];
		If[prec===Infinity,
			ke,
			N[ke, prec]
			]
		];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultKineticEnergyElementFunction*)



iChemDVRDefaultKineticEnergyElementFunction//Clear


(* ::Subsubsubsection::Closed:: *)
(*ColbertMillerCartesian*)



iChemDVRDefaultKineticEnergyElementFunction[
	"ColbertMillerCartesian",
	___
	]:=
	Function[
		If[#==#2, 
			\[Pi]^2/3, 
			((-1)^(#-#2))*2/(#-#2)^2
			]
		];


(* ::Subsubsubsection::Closed:: *)
(*ColbertMillerRadial*)



iChemDVRDefaultKineticEnergyElementFunction[
	"ColbertMillerRadial",
	___
	]:=
	Function[
		If[#==#2, 
			\[Pi]^2/3-1/#^2,
			2/(#-#2)^2-2/(#+#2)^2
			]*((-1)^(#-#2))
		];


(* ::Subsubsubsection::Closed:: *)
(*ColbertMillerAzimuthal*)



iChemDVRDefaultKineticEnergyElementFunction[
	"ColbertMillerAzimuthal",
	___
	]:=
	Function[
		With[{i=#, j=#2, n2p1=#3, n=(#3-1)/2},
			(-1)^(i-j)*
				If[i==j,
					n*(n+1)/3,
					Cos[Pi*(i-j)/n2p1]/
						(2*Sin[Pi*(i-j)/n2p1]^2)
					]
				]
		];


(* ::Subsubsubsection::Closed:: *)
(*ColbertMillerPolar*)



iChemDVRDefaultKineticEnergyElementFunction[
	"ColbertMillerPolar",
	___
	]:=
	Function[
		With[{i=#, j=#2, n=#3+1},
			((-1)^(i-j))/2*
				If[i==j,
					(2*n^2+1)/3-1/(Sin[Pi*i/n]^2),
					1/(Sin[Pi*(i-j)/(2*n)]^2)-1/(Sin[Pi*(i+j)/(2*n)]^2)
					]
				]
		];


(* ::Subsubsubsection::Closed:: *)
(*MeyerAzimuthal*)



iChemDVRDefaultKineticEnergyElementFunction[
	"MeyerAzimuthal",
	___
	]:=
	Function[
		If[#==#2,
			(#3^2/2+1)*1/6,
			((-1)^(#-#2))/
				(2*Sin[(\[Pi]*(#-#2))/#3]^2)
			]
		];


(* ::Subsubsubsection::Closed:: *)
(*SibertChebyshev*)



iChemDVRDefaultKineticEnergyElementFunction[
	"SibertChebyshev",
	___
	]:=
	Function@
		With[{i=#, j=#2, n=#3/2, n2=#3},
			-(\[Pi]^2*(-1)^(i-j))/2*
				If[i==j,
					n+(n-1)*(n2-1)/3-1(Sin[\[Pi] (2i-1)/(n2)]^2),
					1/(Sin[\[Pi] (i-j)/(n2)]^2)-1/(Sin[\[Pi] (i+j-1)/(n2)]^2)
					]
			]


(* ::Subsubsubsection::Closed:: *)
(*Fallback*)



iChemDVRDefaultKineticEnergyElementFunction[e_, ___]:=
	PackageRaiseException[
		Automatic,
		"Unknown kinetic energy element function ``",
		e
		];


(* ::Subsubsubsection::Closed:: *)
(*ChemDVRDefaultKineticEnergyElementFunction*)



ChemDVRDefaultKineticEnergyElementFunction//Clear


ChemDVRRun::kedimx=
	"Dimension of grid (``) doesn't match number of kinetic energy element\
 functions (``)";


Options[ChemDVRDefaultKineticEnergyElementFunction]=
	{
			"KineticEnergyElementFunction"->Automatic
			};
ChemDVRDefaultKineticEnergyElementFunction[
	ops:OptionsPattern[]
	]:=
	With[
		{
			keel=
				Replace[OptionValue["KineticEnergyElementFunction"],
					{
						k:_Cross|_NonCommutativeMultiply|_(Inactive[CircleTimes]):>List@@k,
						{s_, n_Integer}:>ConstantArray[s, n]
						}
					]
				},
		Switch[keel,
			_String|{_String, ___?OptionQ},
				keel,
			{_, _Integer},
				Map[
					ChemDVRDefaultKineticEnergyElementFunction[
						"KineticEnergyElementFunction"->#
						]&,
					ConstantArray[keel[[1]], keel[[2]]]
					],
			{(_String|{_String, ___?OptionQ})..},
				Map[
					ChemDVRDefaultKineticEnergyElementFunction[
						"KineticEnergyElementFunction"->#
						]&,
					keel
					],
			{_},
				ChemDVRDefaultKineticEnergyElementFunction@
					First@keel,
			_,
				keel
			]
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultKineticEnergyLists*)



Options[ChemDVRDefaultKineticEnergyLists]=
	Options[iChemDVRDefaultKineticEnergy1D];
ChemDVRDefaultKineticEnergyLists[
	gridpoints_,
	keel_, 
	ops:OptionsPattern[]
	]:=
	With[
		{
			subgrids=
				Replace[gridpoints,
					Except[{{Repeated[_?NumericQ, {3, Infinity}]}..}]:>
						Replace[
							ChemDVRDefaultGridPointList[
								gridpoints, 
								FilterRules[{ops}, Options[ChemDVRDefaultGridPointList]]
								],
							{
								l:{__List}:>
									Map[
										DeleteDuplicates, 
										Transpose@l
										],
								l_List:>{l}
								}
							]
					],
			masses=OptionValue["Mass"],
			sclFacs=OptionValue["ScalingFactor"],
			hb=OptionValue["HBar"],
			prec=OptionValue[Precision],
			h=OptionValue["MeshSpacing"],
			tm=OptionValue["TransformationMatrix"],
			keels=
				Replace[If[!ListQ@keel, {keel}, keel],
					b:{"BasisSet", ___}:>{b}
					]
			},
		If[Length@subgrids=!=Length@keels,
			PackageRaiseException[
				"Dimension of grid (``) doesn't match number of KE functions (``)",
				"MessageParameters"->{Length@subgrids, Length@keels}
				]
			];
		MapThread[
			iChemDVRDefaultKineticEnergy1D[
				#, 
				#2, 
				FilterRules[
					{
						"Mass"->#3,
						"ScalingFactor"->#4,
						"HBar"->#5,
						Precision->#6,
						"MeshSpacing"->#7,
						"TransformationMatrix"->#8,
						ops
						}, 
					Options[iChemDVRDefaultKineticEnergy1D]
					]
				]&,
			{
				keels,
				subgrids,
				Take[
					Flatten@ConstantArray[masses, Length@keels], 
					Length@keels
					],
				Take[
					Flatten@ConstantArray[sclFacs, Length@keels], 
					Length@keels
					],
				Take[
					Flatten@ConstantArray[hb, Length@keels], 
					Length@keels
					],
				Take[
					Flatten@ConstantArray[prec, Length@keels], 
					Length@keels
					],
				Take[
					Flatten@ConstantArray[h, Length@keels], 
					Length@keels
					],
				Take[
					Flatten@ConstantArray[tm, Length@keels],
					Length@keels
					]
				}
			]
		]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultKineticEnergy*)



(* ::Text:: *)
(*
	Try to generate the kinetic energy from a kinetic energy element function
*)



Options[ChemDVRDefaultKineticEnergy]=
	Join[
		Options[ChemDVRDefaultKineticEnergyElementFunction],
		Options[iChemDVRDefaultKineticEnergy1D]
		];
ChemDVRDefaultKineticEnergy[
	gridpoints_,
	ops:OptionsPattern[]
	]:=
	Replace[
		ChemDVRDefaultKineticEnergyElementFunction@
			FilterRules[{ops},
				Options@ChemDVRDefaultKineticEnergyElementFunction
				],
		{
			keel:{"BasisSet", ___}:>
				iChemDVRDefaultKineticEnergy1D[
					keel, 
					gridpoints, 
					FilterRules[{ops}, Options[iChemDVRDefaultKineticEnergy1D]]
					],
			keels_List:>
				ChemDVRKroeneckerProductKineticEnergy@
					ChemDVRDefaultKineticEnergyLists[
						gridpoints,
						keels, 
					 FilterRules[{ops},
					 	Options@ChemDVRDefaultKineticEnergyLists
						 ]
					 ],
			keel_:>
				iChemDVRDefaultKineticEnergy1D[
					keel, 
					gridpoints, 
					FilterRules[{ops}, Options[iChemDVRDefaultKineticEnergy1D]]
					]
			}
		]


End[];



