(* ::Package:: *)

(* Autogenerated Package *)

ChemDVRDefaultGuessWavefunctions::usage=
  "Provides an approximation for the wavefunctions assuming no coupling";


Begin["`Private`"];


(* ::Subsection:: *)
(*ChemDVRDefaultGuessWavefunctions*)



(* ::Text:: *)
(*
	Build the kinetic energy for each DoF.
	If there\[CloseCurlyQuote]s no coupling in the potential energy (i.e. passed a list of PEs),
		build the 1D Hamiltonians of each and calculate full eigensystem
		return direct product eigenvalues and eigenvectors
	Otherwise,
		compute eigensystems of  each kinetic energy
		create direct product eigenvalues
		add on potential energies evaluated at grid points, appropriately sorted
		return these eigenvalues and direct product eigenvectors
*)



(* ::Subsubsection::Closed:: *)
(*iChemDVRGetGWGrids*)



iChemDVRGetGWGrids[grid_, ops:OptionsPattern[]]:=
  Module[{dim=Dimensions[grid], subgrids},
    subgrids=
      Replace[
        ChemDVRDefaultGridPointList[
          grid, 
          FilterRules[{ops}, Options[ChemDVRDefaultGridPointList]]
          ],
        {
          l:{{Repeated[_?NumericQ, {dim[[-1]]}]}, ___List}:>
            Map[
              DeleteDuplicates@l[[All, #]]&,
              Range[dim[[-1]]]
              ],
          l_List:>{l}
          }
        ];
    If[!MatchQ[subgrids, {Repeated[_?NumericQ, {#}]}&/@Most@dim],
      PackageRaiseException[
        Automatic,
        "Wavefunction guesser couldn't decompose grid.\
 Found subgrids of dimension ``. Expected subgrids of dimension ``.",
        Length/@subgrids,
        Most@dim
        ]
      ];
    subgrids
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRGetGWKineticEnergy*)



iChemDVRGetGWKineticEnergy[subgrids_, fullDim_, cupcrd_, ops:OptionsPattern[]]:=
  Module[
    {
      keels,
      kins
      },
    keels=
      ChemDVRDefaultKineticEnergyElementFunction@
        FilterRules[
          {ops},
          Options@ChemDVRDefaultKineticEnergyElementFunction
          ];
    If[Length@keels!=Length@cupcrd,
      If[Length@keels!=fullDim,
        keels=Flatten[{keels}, 1];
        keels=PadRight[keels, fullDim, keels];
        ];
      keels=If[Length@#==1, First, Identity]@keels[[#]]&/@cupcrd
      ];
    ChemDVRDefaultKineticEnergyLists[
      subgrids,
      keels,
      FilterRules[{ops}, Options@ChemDVRDefaultKineticEnergyLists]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRGetGWUncoupledPE*)



iChemDVRGetGWUncoupledPE[pf_, subgrids_, fullDim_, cupcrd_, ops:OptionsPattern[]]:=
  Module[
    {
      potFuns,
      p
      },
    potFuns=
      Flatten[
        {
          Replace[
            pf,
            {
              a:{_String, ___?OptionQ}:>
                ConstantArray[a, fullDim],
              a:Except[_List]:>
                ConstantArray[a, fullDim]
              }
            ]
          },
        1
        ];
    If[Length@potFuns=!=Length@cupcrd,
      potFuns=
        PadRight[potFuns, fullDim, potFuns];
      potFuns=If[Length@#==1, First, Identity]@potFuns[[#]]&/@cupcrd
      ];
    potFuns=
      Map[
        If[#=!=None,
          ChemDVRDefaultPotentialEnergyElementFunction["PotentialFunction"->#],
          #
          ]&,
        PadRight[potFuns, fullDim, potFuns]
        ];
    MapThread[
      If[#2=!=None,
        iChemDVRPotentialEnergy[##],
        None
        ]&,
      {
        subgrids,
        potFuns
        }
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRGetGWEigenSets*)



(* ::Text:: *)
(*
	Implementing this:
		https://cs.stackexchange.com/a/46945
*)



iChemDVRGetGWEigenSetsC:=
  iChemDVRGetGWEigenSetsC=
    Compile[
      {{vals, _Real, 2}, {n, _Integer}},
      Module[
        {
          dim,
          len,
          queue,
          costs,
          defel,
          tups,
          pop,
          push,
          cost,
          qels=0,
          solns=0,
          order
          },
        dim=Length@vals;
        len=Dimensions[vals][[2]];
        (* Initialize priority queue and cost vector *)
        defel=Table[-1, {$, dim}];
        queue=Table[defel, {$, n}];
        costs=Table[-1., {$, n}];
        (* Initialize solutions *)
        tups=Table[defel, {$, n}];
        (* Determine first element *)
        push=Table[1, {$, dim}];
        (* Compute cost *)
        cost=0.;
        Do[cost+=vals[[i, push[[i]]]], {i, dim}];
        (* Push onto queue *)
        ++qels;
        queue[[qels]]=push;
        costs[[qels]]=cost;
        (* Iterate *)
        pop=defel;
        Do[
          (* pop the first element, add it to the tups array *)
          pop=queue[[1]];
          tups[[++solns]]=pop;
          (* shift the queue elements back *)
          queue[[;;qels]]=queue[[2;;qels+1]];
          costs[[;;qels]]=costs[[2;;qels+1]];
          qels--;
          Do[
            (* Create new push element *)
            push=pop;
            push[[j]]+=1;
            (* Safety check that shows I've messed something up *)
            If[push[[j]]<=len,
              (* Compute cost *)
              cost=0.;
              Do[cost+=vals[[i, push[[i]]]], {i, dim}];
              (* determine where on queue would be added *)
              ++qels;
              (* allocate more queue if necessary *)
              If[qels>Length@queue,
                queue=
                Join[queue, 
                  Table[defel, {$$,2*Length@queue}]
                  ];
                costs=
                Join[costs, 
                  Table[-1., {$$,2*Length@queue}]
                  ]
                ];
              (* push onto queue *)
              queue[[qels]]=push;
              costs[[qels]]=cost;
              ];
            (* If next element would be added in later iteration, break *)
            If[pop[[j]]>1, Break[]],
            {j, dim}
            ];
          (* resort by priority *)
          order=Ordering[costs[[;;qels]]];
          queue[[;;qels]]=queue[[;;qels]][[order]];
          costs[[;;qels]]=costs[[;;qels]][[order]],
          {$, n-1}
          ];
        pop=queue[[1]];
        tups[[++solns]]=pop;
        tups
        ]
      ];


iChemDVRGetGWEigenSets[eigenvals_, n_]:=
  Module[
    {
      pos,
      sets,
      eigs,
      eigmax=Length@eigenvals*Max@eigenvals+5,
      eiglen=Length/@eigenvals//Max,
      vals
      },
    eigs=PadRight[#, eiglen, eigmax]&/@eigenvals;
    pos=iChemDVRGetGWEigenSetsC[eigs, n];
    sets=MapIndexed[eigenvals[[#2[[1]], #]]&, Transpose@pos]//Transpose;
    vals=Total/@sets;
    pos=Pick[pos, #<eigmax&/@vals];
    vals=Select[vals, #<eigmax&];
    {pos, vals}
    ]


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultGuessWavefunctions*)



$ChemDVRGuessWavefunctionsComponents=
  {
    "Grid", "Energies", "Wavefunctions",
    "CombinationIndices",
    "ComponentGrids", 
    "ComponentKineticEnergies", "ComponentPotentialEnergies",
    "ComponentWavefunctions",
    "CouplingPotential"
    };


(* ::Text:: *)
(*
	Need good way to allow some sets of coordinates to be handled via multidim DVR
*)



Options[ChemDVRDefaultGuessWavefunctions]=
  DeleteDuplicatesBy[First]@
    Join[
      Options[ChemDVRDefaultKineticEnergy],
      Options[ChemDVRDefaultPotentialEnergy],
      Options[ChemDVRDefaultWavefunctions],
      {
        "CoupledCoordinates"->None,
        "UncoupledPotentialFunctions"->Automatic,
        "GuessWavefunctionsComponents"->Automatic,
        "NumberOfCombinations"->Automatic
        }
      ];
ChemDVRDefaultGuessWavefunctions[
  grid_,
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      subgrids,
      grids,
      newgrid,
      fullDim,
      cupcrd,
      kins,
      pots,
      cuppot,
      hams,
      engs,
      wfs,
      dpengs,
      dpwfs,
      optSpec,
      potEigs,
      hamEigs,
      indices,
      numEigs,
      numCombo,
      hamEigvals,
      hamEigvecs,
      eigenvalues,
      revPotEigs,
      revEigenvalues,
      eigLBMat,
      eigUBMat,
      eigenvaluesLB,
      eigenvaluesUB,
      eigenvectors,
      comps,
      ret
      },
    (** ----------------------------------- GRIDS ----------------------------------- **)
    grids=iChemDVRGetGWGrids[grid, ops];
    fullDim=Length@grids;
    If[fullDim==1,
      PackageRaiseException@
        "Guess wavefunctions in 1D are simply DVR solutions. \
Use standard methods for these"
      ];
    (** ------------------------------- COORDINATES ------------------------------- **)
    cupcrd=
      Replace[
        OptionValue["CoupledCoordinates"],
        {
          i:{__Integer}:>
            Append[List/@Complement[Range[fullDim], i], i],
          i:{{__Integer}..}:>
            Join[List/@Complement[Range[fullDim], Flatten@i], i],
          _:>
            List/@Range[fullDim]
          }
        ];
    If[Complement[Flatten@cupcrd, Range[fullDim]]=!={},
      PackageRaiseException[
        Automatic,
        "Coordinate specification `` contains more coordinates (``) \
than in the system (``)",
        {
          OptionValue["CoupledCoordinates"],
          Length@DeleteDuplicates@Flatten@cupcrd, 
          fullDim
          }
        ]
      ];
    KeyValueMap[
      If[#2>1,
        PackageRaiseException[
          Automatic,
          "Coordinate `` shows up in coordinate specification `` more than once",
          {
            #,
            OptionValue["CoupledCoordinates"]
            }
          ]
        ]&,
      Counts[Flatten@cupcrd]
      ];
    cupcrd=SortBy[cupcrd, First];
    (** ---------------------------------- GRIDS 2 ---------------------------------- **)
    subgrids=
      Replace[grids[[#]],
        {
          {l_List}:>l,
          ls:{_List, __List}:>ChemDVRDirectProductGrid[ls]
          }
        ]&/@cupcrd;
    newgrid=
      Outer[Flatten@*List, Sequence@@subgrids];
    (** ------------------------------ KINETIC ENERGY ------------------------------ **)
    kins=iChemDVRGetGWKineticEnergy[subgrids, fullDim, cupcrd, ops];
    If[!MatchQ[kins, {__?SquareMatrixQ}],
      PackageRaiseException@
        "Couldn't generate kinetic energy matrices for wavefunction guessing"
      ];
    (** ----------------------------- POTENTIAL ENERGY----------------------------- **)
    pots=
      iChemDVRGetGWUncoupledPE[
        Replace[
          OptionValue["UncoupledPotentialFunctions"],
          Automatic:>(ConstantArray[0., Length[#]]&)
          ],
        subgrids, 
        fullDim, 
        cupcrd,
        ops
        ];
    If[!MatchQ[kins, {__?SquareMatrixQ}],
      PackageRaiseException@
        "Couldn't generate potential energy matrices for wavefunction guessing"
      ];
    (** ------------------------ COUPLED POTENTIAL ENERGY------------------------- **)
    cuppot=
      Normal@Diagonal@
        ChemDVRDefaultPotentialEnergy[
          newgrid,
          FilterRules[
            {ops},
            Options[ChemDVRDefaultPotentialEnergy]
            ]
          ];
    cuppot-=
      Flatten@
        Outer[Plus, 
          Sequence@@Map[Normal@*Diagonal, pots]
          ];
    (** ------------------------------ EIGENSYSTEMS ------------------------------ **)
    potEigs=Sort@cuppot;
    numEigs=
      Replace[OptionValue["NumberOfWavefunctions"], 
        {
          Except[_Integer?Positive]:>
            Min@{25, Times@@Map[Length, kins]},
          i_Integer?Positive:>
            Min@{i, Times@@Map[Length, kins]}
          }
        ];
    hamEigs=
      MapThread[
        ChemDVRDefaultWavefunctions[
          ##,
          "NumberOfWavefunctions"->
            Min@{numEigs, Length@#},
          FilterRules[
            {ops},
            Options[ChemDVRDefaultWavefunctions]
            ]
          ]&,
        {
          kins,
          pots
          }
        ];
    numCombo=
      Replace[
        OptionValue["NumberOfCombinations"], 
        {
          Except[_Integer?Positive]:>
            Apply[Times, Dimensions[#][[2]]&/@hamEigs],
          i_Integer?Positive:>
            Min@{i, Apply[Times, Dimensions[#][[2]]&/@hamEigs]}
          }
        ];
    (*
		hamEigs=
			With[{o=Ordering[#[[1]]]}, #[[All, o]]]&/@hamEigs;*)
    hamEigvals=hamEigs[[All, 1]];
    hamEigvecs=hamEigs[[All, 2]];
    Clear[hamEigs];
    (** --------------------------- BUILD EIGENVALUES --------------------------- **)
    (*
			Need to figure out which combinations of eigenvalues will give me the smallest n combined eigenvalues.
			Then I take direct products of the corresponding eigenvectors.
			
			Since the "tuple space" can be large, we'll do this with a compiled search function
		*)
    {indices, eigenvalues}=
      iChemDVRGetGWEigenSets[hamEigvals, numCombo];
    numEigs=Min@{numEigs, Length@eigenvalues};
    eigenvectors:=
      Map[
        Flatten@Outer[
          Times,
          Sequence@@MapIndexed[hamEigvecs[[#2[[1]], #]]&, #]
          ]&, 
        indices[[;;numEigs]]
        ];
    (*
		These come from Weyl's inequalities:
			https://en.wikipedia.org/wiki/Weyl%27s_inequality#Weyl.27s_inequality_in_matrix_theory
		in particular,
			a_j + b_k <= c_i <= a_r + b_s for all j + k - n \[GreaterEqual] i \[GreaterEqual] r + s -1
		where c_n is the smallest eigenvalue
		
		Note that the eigenvalues we have go from n-m to n, not from 1 to m
		This means our eigenvalue space is incomplete and we only have the bottom part of the matrix
		This means we can say the most about our small eigenvalues as they're the only parts where we have the
			full diagonal
		
		*)
    potEigs=Developer`ToPackedArray@N@potEigs;
    eigenvalues=Developer`ToPackedArray@eigenvalues;
    revEigenvalues=Developer`ToPackedArray@Reverse@eigenvalues;
    eigLBMat=Outer[Plus, revEigenvalues, potEigs[[;;Length[revEigenvalues]]]];
    eigUBMat=
      If[numEigs==Length@potEigs,
        eigLBMat,
        Outer[Plus, revEigenvalues, potEigs[[-Length[revEigenvalues];;]]]
        ];
    (* 
		Here we pick the diagonal in this matrix that corresponds to adding the 
			set of smallest j and k such that j + k \[GreaterEqual] i + n
			i. e. we solve so that j + k == i + n, as these will give the largest sums
		For a given i, this turns out to be simply be the ith lower diagonal
		
		Since we only have the bottom part of the matrix, we iterate on m instead of n
		*)
    eigenvaluesLB:=eigenvaluesLB=
      With[{m=Length[eigLBMat]},
        Table[
          Max@Diagonal[eigLBMat, 1-i],
          {i, m, 1, -1}
          ]
        ];
    (* 
		Here we pick the diagonal in this matrix that corresponds to adding the 
			set of largest r and s such that r + s \[LessEqual] i + 1
			i. e. we solve so that r + s == i + 1, as these will give the smallest sums
		
		Since we only have the bottom part of the matrix, we iterate on m instead of n
		*)
    eigenvaluesUB:=eigenvaluesUB=
      With[{m=Length[eigUBMat]},
          Table[
            Min@Diagonal[eigUBMat, i-1],
            {i, 1, m, 1}
            ]
        ];
    eigenvalues:=eigenvalues=
      Thread[{eigenvaluesLB[[;;numEigs]], eigenvaluesUB[[;;numEigs]]}];
    (** -------------------------- CONSTRUCT RETURN -------------------------- **)
    comps=
      Replace[
        OptionValue["GuessWavefunctionsComponents"],
        {
          All->$ChemDVRGuessWavefunctionsComponents,
          s:{__String}:>
            Replace[
              Intersection[s, $ChemDVRGuessWavefunctionsComponents],
              {}->{"Grid", "Wavefunctions"}
              ],
          Except[_String?(MemberQ[$ChemDVRGuessWavefunctionsComponents, #]&)]:>
            {"Grid", "Wavefunctions"}
          }
        ];
    ret=
      <|
        "Grid":>Outer[Flatten@*List, Sequence@@subgrids],
        "Energies":>eigenvalues,
        "Wavefunctions":>{eigenvalues, eigenvectors},
        "CombinationIndices":>indices[[;;numEigs]],
        "KineticEnergy":>
          ChemDVRKroeneckerProductKineticEnergy[kins],
        "PotentialEnergy":>
          With[{m=ChemDVRDirectProductPotentialEnergy[pots]},
            m+SparseArray[Band[{1, 1}]->cuppot]
            ],
        "ComponentGrids":>subgrids,
        "ComponentKineticEnergies":>kins,
        "ComponentPotentialEnergies":>pots,
        "CouplingPotential":>cuppot,
        "ComponentWavefunctions":>{hamEigvals, hamEigvecs}
        |>;
    If[StringQ@comps,
      ret[comps],
      AssociationThread[
        comps,
        Lookup[ret, comps]
        ]
      ]
    ]


End[];



