(* ::Package:: *)

(* Autogenerated Package *)

(* ::Text:: *)
(*
	This really needs to be reimplemented as an Interface. It\[CloseCurlyQuote]ll make it easier to store and cleaner to work with... Also no memory leaks! 
	
	For the new DVRResultsObject we\[CloseCurlyQuote]ll use that as the primary container object throughout the entire calculation. It will guide the whole process and methods should be written with the expecation of getting one of them.
*)



(* ::Subsection:: *)
(*Management*)



(* ::Subsubsection::Closed:: *)
(*File Stuff*)



ChemDVRDirectory::usage="Directory finder";
ChemDVRFile::usage=
  "Simple combination of FileNameJoin and ChemDVRDirectory";
ChemDVRPotentials::usage=
  "Lists all matching files in ChemDVRDirectory[\"PotentialEnergy\"]";
$ChemDVRPotentials::usage="Alias for ChemDVRPotentials[\"*@.@*\"]";


(* ::Subsubsection::Closed:: *)
(*Objects*)



$ChemDVRManager::usage="Manager interface for ChemDVR things";


ChemDVRCreate::usage="OOP constructor for a ChemDVR";
ChemDVRAssociation::usage="Returns the base association for the instance";


ChemDVRSave::usage="Saves various ChemDVR components";
ChemDVRClear::usage="Clears saved ChemDVR components";


(* ::Subsubsection::Closed:: *)
(*Properties*)



ChemDVRGet::usage=
  "Gets an attribute for a ChemDVR instance";
ChemDVRSet::usage=
  "Sets an attribute for a ChemDVR instance";
ChemDVROptions::usage=
  "Returns the options associated with a particular DVR step";
ChemDVRRun::usage="General form ChemDVR runner";


(* ::Subsection:: *)
(*Usage*)



ChemDVRDimension::usage=
  "Returns the dimension of a ChemDVR object";


(* ::Subsubsection::Closed:: *)
(*Methods*)



ChemDVRGrid::usage=
  "Returns the grid used in ChemDVR calculations";
ChemDVRKineticEnergy::usage=
  "Returns the kinetic energy used in ChemDVR calculations";
ChemDVRPotentialEnergy::usage=
  "Returns the potential energy used in ChemDVR calculations";
ChemDVRGridPotentialEnergy::usage=
    "Returns the potential energy used in ChemDVR calculations on the grid";
ChemDVRPotentialOptimization::usage=
  "Returns potential optimized DVR parameters";
ChemDVRGuessWavefunctions::usage=
  "Returns guess wavefunctions from uncoupled representation";
ChemDVRWavefunctions::usage=
  "Returns the wavefunctions computed in ChemDVR calculations";
ChemDVRGridWavefunctions::usage=
  "Returns the wavefunction imposed on the grid";
ChemDVRInterpolatingWavefunctions::usage=
  "Returns the wavefunctions interpolating over a grid";
ChemDVRExpectationValues::usage=
  "Returns the expectation values of a set of functions";
ChemDVROperatorMatrix::usage=
  "Returns the cross-state expectation matrix of a set of states->function specs";
ChemDVROperatorMatrixElements::usage=
  "Returns specific elements of the expectation matrix for states->function specs";
ChemDVRExtendWavefunctions::usage=
  "Extends the set of wavefunctions based on previous set";
ChemDVRView::usage="Displays the wavefunctions from a ChemDVR run";


(* ::Subsubsection::Closed:: *)
(*Interfaces*)



ChemDVRNotebook::usage=
  "Opens a notebook for playing with a single ChemDVR instance";


Begin["`Private`"];


(* ::Subsection:: *)
(*Management*)



(* ::Subsubsection::Closed:: *)
(*Key Symbols*)



$dvroot="Root";
$dvalt="ExtraDirs";
$dvrinst="Instances";
$dvrke="KineticEnergy";
$dvrpe="PotentialEnergy";
$dvrgp="GridPotentialEnergy";
$dvrpo="PotentialOptimization";
$dvrham="Hamiltonian";
$dvreng="Energies";
$dvrwf="Wavefunctions";
$dvrguwf="GuessWavefunctions";
$dvrexwf="ExtendWavefunctions";
$dvrgr="Grid";
$dvrgrwf="GridWavefunctions";
$dvrintwf="InterpolatingWavefunctions";
$dvrexv="ExpectationValues";
$dvrexm="OperatorMatrix";
$dvrexmel="OperatorMatrixElements";
$dvrfmgr="FormatGrid";
$dvrvw="View";


(* ::Subsubsection::Closed:: *)
(*Manager*)



If[!MatchQ[$ChemDVRManager,_Association],
  $ChemDVRManager=
    <|
      "Directories"->
        <|
          $dvroot->ChemExtensionDir["DVR"],
          $dvalt->
            Map[
              FileNameJoin[{#, "DVR"}]&,
              {$ChemExtensionsApp, $ChemExtensionsDev}
              ],
          "Classes"->"Classes",
          $dvrinst->$dvrinst,
          $dvrpe->$dvrpe,
          $dvrke->$dvrke,
          $dvrwf->$dvrwf
          |>,
      "Objects"->
        <|
          |>,
      "Settings"->
        <|
          "Load"<>$dvrke->False,
          "Save"<>$dvrke->False,
          "Load"<>$dvrpe->False,
          "Save"<>$dvrpe->False,
          "Load"<>$dvrwf->False,
          "Save"<>$dvrwf->False
          |>
      |>
  ];


(* ::Subsubsection::Closed:: *)
(*Directory*)



$ChemDVRRoot:=
  $ChemDVRManager["Directories", $dvroot];
$ChemDVRPath:=
  Prepend[
    $ChemDVRManager["Directories", $dvalt],
    $ChemDVRRoot
    ]


Options[ChemDVRDirectory]=
  {
    "Root":>$ChemDVRRoot,
    "Path":>$ChemDVRPath
    };
ChemDVRDirectory[
  dSpec_?(KeyMemberQ[$ChemDVRManager["Directories"],#]&),
  alt:True|False:False,
  ops:OptionsPattern[]
  ]:=
  With[{d=$ChemDVRManager["Directories", dSpec]},
    If[!alt,
      If[Not@DirectoryQ@ExpandFileName@d,
        (
          If[Not@DirectoryQ@#,
            CreateDirectory[#, CreateIntermediateDirectories->True]
            ];
          #
          )&@
            FileNameJoin@{OptionValue["Root"], dSpec},
        d
        ],
      FileNameJoin@{#,dSpec}&/@
        OptionValue["Path"]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*File*)



ChemDVRFile//Clear


Options[ChemDVRFile]=
  Options@ChemDVRDirectory;
ChemDVRFile[
  dSpec_String?(KeyMemberQ[$ChemDVRManager["Directories"],#]&),
  fspec__String,
  o:OptionsPattern[]
  ]:=
  With[
    {
      ops=
        FileNameJoin@{#,fspec}&/@
          ChemDVRDirectory[dSpec, True, o]
      },
    SelectFirst[ops, FileExistsQ, Last@ops]
    ];
ChemDVRFile[
  dSpec_String?(KeyMemberQ[$ChemDVRManager["Directories"],#]&),
  ChemDVRObject[uuid_]
  ]:=
  ChemDVRFile[
    dSpec,
    uuid<>If[MatchQ[dSpec,$dvrke|$dvrpe|$dvrwf],".mx",".m"]
    ]
ChemDVRFile[ChemDVRObject[uuid_]]:=
  ChemDVRFile[$dvrinst,uuid<>".m"];


(* ::Subsubsection::Closed:: *)
(*Potentials*)



ChemDVRPotentials[
  pat:_?StringPattern`StringPatternQ:"*@.@*",
  nameTake:True|False:True
  ]:=
  If[nameTake,Map@FileNameTake,Identity]@
    FileNames[pat,ChemDVRDirectory[$dvrpe]];


(* ::Subsubsection::Closed:: *)
(*Create*)



ChemDVRCreate::norng="No range function provided";
ChemDVRCreate::nogrid="No grid function provided";
ChemDVRCreate::noke="No kinetic energy function provided";
ChemDVRCreate::nope="No potential energy function provided";
ChemDVRCreate::novw="No view function provided";


ChemDVRCreate[a_Association]:=
  Block[{dvrAssoc=a},
    If[KeyMemberQ[a,"Class"],
      ChemDVRClass@a["Class"]];
    If[!KeyMemberQ[dvrAssoc,"UUID"],
      dvrAssoc["UUID"]=CreateUUID["ChemDVR-"]
      ];
    If[!KeyMemberQ[dvrAssoc,"Name"],
      dvrAssoc["Name"]="ChemDVR Instance"
      ];
    Map[
      If[!KeyExistsQ[dvrAssoc, #[[1]]],
        dvrAssoc[#[[1]]]=#[[2]]
        ]&,
      {
        {$dvrgr, ChemDVRDefaultGrid},
        {$dvrke, ChemDVRDefaultKineticEnergy},
        {$dvrpe, ChemDVRDefaultPotentialEnergy},
        {$dvrgp, ChemDVRDefaultGridPotentialEnergy},
        {$dvrpo, ChemDVRDefaultPotentialOptimize},
        {$dvrguwf, ChemDVRDefaultGuessWavefunctions},
        {$dvrwf, ChemDVRDefaultWavefunctions},
        {$dvrexwf, ChemDVRDefaultExtendWavefunctions},
        {$dvrvw, ChemDVRDefaultPlot},
        {$dvrgrwf, ChemDVRDefaultGridWavefunctions},
        {$dvrintwf, ChemDVRDefaultInterpolatingWavefunctions},
        {$dvrexv, ChemDVRDefaultExpectationValues},
        {$dvrexm, ChemDVRDefaultOperatorMatrix},
        {$dvrexmel, ChemDVRDefaultOperatorMatrixElements},
        {$dvrfmgr, ChemDVRDefaultFormatGrid}
        }
      ];
    $ChemDVRManager["Objects",dvrAssoc["UUID"]]=
      dvrAssoc;
    ChemDVRObject[dvrAssoc["UUID"]]
    ];


ChemDVRCreate::nodvr="No ChemDVR found at ``";
ChemDVRCreate[dvr_String?FileExistsQ]:=
  With[{a=Get@dvr},
    If[AssociationQ@a,
      ChemDVRCreate@a,
      Message[ChemDVRCreate::nodvr,dvr];
      $Failed
      ]
    ];
ChemDVRCreate[dvr_String?(Not@*FileExistsQ)]:=
  With[{f=ChemDVRFile[$dvrinst,StringTrim[dvr,".m"]<>".m"]},  
    If[FileExistsQ@f,
      ChemDVRCreate@f,
      Message[ChemDVRCreate::nodvr,f]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*Save*)



ChemDVRSave//Clear


Options[ChemDVRSave]=
  Options@ChemDVRFile;
ChemDVRSave[
  $dvrinst,
  name_String,
  a_Association,
  o:OptionsPattern[]
  ]:=
  Block[{$ContextPath={"System`"}},
    Export[ChemDVRFile[$dvrinst, name, o],a]
    ];
ChemDVRSave[
  prop:$dvrke|$dvrpe|$dvrwf, 
  name_String, 
  mx_List?MatrixQ,
  o:OptionsPattern[]
  ]:=
  Export[  
    ChemDVRFile[prop, name, o],
    mx
    ];


ChemDVRSave[
  Optional[$dvrinst,$dvrinst],
  ChemDVRObject[uuid_],
  o:OptionsPattern[]
  ]:=
  ChemDVRSave[
    $dvrinst,
    uuid<>".m",
    $ChemDVRManager["Objects",uuid],
    o
    ];
ChemDVRSave[
  prop:$dvrke|$dvrpe|$dvrwf, 
  ChemDVRObject[uuid_],
  mx_List?MatrixQ,
  o:OptionsPattern[]
  ]:=
  ChemDVRSave[
    prop,
    uuid<>".mx",
    mx,
    o
    ];


(* ::Subsubsection::Closed:: *)
(*Clear*)



Options[ChemDVRClear]=
  Options@ChemDVRFile;
ChemDVRClear[prop:$dvrinst|$dvrke|$dvrpe|$dvrwf, name_String,
  ops:OptionsPattern[]
  ]:=
  Quiet@DeleteFile@ChemDVRFile[prop,name, ops];


ChemDVRClear[
  prop:$dvrinst|$dvrke|$dvrpe|$dvrwf,$dvrinst,
  ChemDVRObject[uuid_],
  ops:OptionsPattern[]
  ]:=
  ChemDVRClear[prop,
    uuid<>".m",
    ops
    ];


(* ::Subsection:: *)
(*Helper Methods*)



(* ::Subsubsection::Closed:: *)
(*Helpers*)



chemDVRValidQ[uuid_String]:=
  KeyMemberQ[$ChemDVRManager["Objects"],uuid];
chemDVRValidQ[ChemDVRObject[uuid_]]:=
  chemDVRValidQ[uuid];
chemDVRValidQ[___]:=False;
dvrObjPattern=ChemDVRObject[uuid_?chemDVRValidQ]


dvrOpsLookup[ops___,key_,default_]:=
  Lookup[
    Flatten@Replace[{ops}, a_Association?AssociationQ:>Normal[a], 1],
    key,
    default
    ];
dvrOpsLookup~SetAttributes~HoldAll;


(* ::Subsubsection::Closed:: *)
(*Reloading*)



ChemDVRObject//Clear


ChemDVRObject[a_Association]:=
  ChemDVRCreate[a];
ChemDVRObject[uuid_String?(
  Not@KeyMemberQ[$ChemDVRManager["Objects"],#]&&
    FileExistsQ@ChemDVRFile[$dvrinst, #<>".m"]
  &)]:=
  ChemDVRCreate[uuid];
ChemDVRObject[
  s_String?(
    Quiet@MatchQ[ChemDVRClass[#], ChemDVRClass[_Association?AssociationQ]]&
    ), 
  o___?OptionQ
  ]:=
  ChemDVRClass[s][o];


(* ::Subsubsection::Closed:: *)
(*Association*)



ChemDVRAssociation[obj:dvrObjPattern]:=
  $ChemDVRManager["Objects",First@obj];


(* ::Subsubsection::Closed:: *)
(*Get*)



ChemDVRGet[obj:dvrObjPattern,attribute_]:=
  Lookup[$ChemDVRManager["Objects",First@obj],attribute];
ChemDVRGet[obj:dvrObjPattern,attribute_,default_]:=
  Lookup[$ChemDVRManager["Objects",First@obj],attribute,default];


ChemDVRGet[obj:ChemDVRClass[a_Association],attribute_]:=
  Lookup[a,attribute];
ChemDVRGet[obj:ChemDVRClass[a_Association],attribute_,default_]:=
  Lookup[a,attribute,default];


(*PackageAddAutocompletions[
	ChemDVRGet,
	{
		None,
		{
			$dvrgr,
			$dvrke,$dvrpe,
			$dvrwf,$dvrgrwf,
			$dvrintwf,$dvrexv,
			$dvrexm,$dvrvw
			}
		}
	]*)


(* ::Subsubsection::Closed:: *)
(*Mutate*)



ChemDVRMutate//ClearAll
ChemDVRMutate~SetAttributes~HoldAll;
With[{obPat=dvrObjPattern},
  ChemDVRMutate[(obj:obPat)[at___], fn_, args___]:=
    With[{k=First@obj},
      fn[
        $ChemDVRManager["Objects", k, at],
        args
        ]
      ];
  ChemDVRMutate[(obj:obPat)[[at___]], fn_, args___]:=
    With[{k=First@obj},
      fn[
        $ChemDVRManager[["Objects", k, at]],
        args
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*Set*)



ChemDVRSet//Clear


ChemDVRSet[obj:dvrObjPattern, attribute__, value_]:=
  ChemDVRMutate[
    obj[attribute],
    Set,
    value
    ]


(* ::Subsubsection::Closed:: *)
(*Options*)



ChemDVROptions[obj:dvrObjPattern, method_String]:=
  Options@ChemDVRGet[obj, method];
ChemDVROptions[obj:dvrObjPattern, methods:{__String}]:=
  AssociationMap[ChemDVROptions[obj,#]&, methods];
ChemDVROptions[obj:dvrObjPattern, Optional[All, All]]:=
  ChemDVROptions[obj, 
    {$dvrgr, $dvrke, "PotentialEnergy", $dvrwf, "View"}
    ]


PackageAddAutocompletions[
  ChemDVROptions,
  {
    None,
    {
      $dvrgr,
      $dvrke, $dvrpe, $dvrwf,
      $dvrvw
      }
    }
  ]


(* ::Subsection:: *)
(*Run Methods*)



(* ::Subsubsection::Closed:: *)
(*Dimension*)



ChemDVRDimension[obj:dvrObjPattern]:=
  Length@ChemDVRGet[obj,"Range"];


(* ::Subsubsection::Closed:: *)
(*Grid*)



(* ::Subsubsubsection::Closed:: *)
(*New Version*)



(* ::Text:: *)
(*
	We\[CloseCurlyQuote]ll just fallback on the old version... but at least it\[CloseCurlyQuote]ll provide a consistent interface if we want to change things up later.
*)



ChemDVRGrid[obj_ChemDVRResultsObject, ops:OptionsPattern[]]:=
  ChemDVRGrid[obj["Object"], ops];


(* ::Subsubsubsection::Closed:: *)
(*Old Version*)



ChemDVRGrid[obj:dvrObjPattern, ops:OptionsPattern[]]:=
  Block[
    {
      RunRange=None,
      RunPoints=None
      },
    RunRange=
      Replace[dvrOpsLookup[ops, "Range", None],
        l:{Repeated[_?NumericQ|_DirectedInfinity, {2}]}:>{l}
        ];
    If[MatchQ[RunRange,{{Repeated[_?NumericQ|_DirectedInfinity, {2}]}..}],
      ChemDVRSet[obj, "Range", RunRange]
      ];
    RunRange=ChemDVRGet[obj, "Range"];
    If[!MatchQ[RunRange, {{Repeated[_?NumericQ|_DirectedInfinity, {2}]}..}],
      PackageRaiseException[
        "DVRRun",
        "\"Range\" `` isn't a valid DVR domain specification",
        "MessageParameters"->{RunRange}
        ]
      ];
    RunPoints=
      Replace[dvrOpsLookup[ops, "Points", None],
        l:_?IntegerQ:>{l}
        ];
    If[MatchQ[RunPoints, {__?IntegerQ}],
      ChemDVRSet[obj, "Points", RunPoints]
      ];
    RunPoints=ChemDVRGet[obj, "Points"];
    If[!MatchQ[RunPoints, {__?IntegerQ}],
      PackageRaiseException[
        "DVRRun",
        "\"Points\" `` isn't valid DVR division specification",
        "MessageParameters"->{RunPoints}
        ]
      ];
    ChemDVRGet[obj, $dvrfmgr,(#&)][
      ChemDVRGet[obj,$dvrgr][
        RunPoints,
        RunRange,
        Sequence@@FilterRules[{ops},Options@ChemDVRGet[obj,$dvrgr]]
        ],
      RunPoints
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*KineticEnergy*)



(* ::Subsubsubsection::Closed:: *)
(*New Version*)



(* ::Text:: *)
(*
	Clean way to get the kinetic energy off the new DVR results object
*)



ChemDVRKineticEnergy[obj:_ChemDVRResultsObject, ops:OptionsPattern[]]:=
  ChemDVRGet[obj["Object"], $dvrke][
    obj["Grid"],
    "TransformationMatrix"->obj["Transformation"],
    ops
    ];


(* ::Subsubsubsection::Closed:: *)
(*Old Version*)



dvrCalcKE[obj_,ops___]:=
  With[{g=dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]]},
    ChemDVRGet[obj,$dvrke][g,Sequence@@FilterRules[{ops},Options@ChemDVRGet[obj,$dvrke]]]
    ]


ChemDVRKineticEnergy[obj:dvrObjPattern, ops:OptionsPattern[]]:=
  With[{dvrke=ChemDVRGet[obj, $dvrke]},
    If[StringQ@dvrke,
      If[FileExistsQ@dvrke,Import@dvrke,Import@ChemDVRFile[$dvrke,dvrke]],
      With[{tryLoad=
        TrueQ@dvrOpsLookup[ops,"Load"<>$dvrke,
            dvrOpsLookup[ops,"Load",
              $ChemDVRManager["Settings","Load"<>$dvrke]]
            ]},
        If[tryLoad,
          If[FileExistsQ@ChemDVRFile[$dvrke,obj],
            Import@ChemDVRFile[$dvrke,obj],
            ChemDVRKineticEnergy[obj,
              "Load"<>$dvrke->False,
              "Load"->False,
              ops
              ]
            ],
          With[{ke=dvrCalcKE[obj,ops]},
            If[MatrixQ[ke],
              If[TrueQ@dvrOpsLookup[ops,"Save"<>$dvrke,
                  dvrOpsLookup[ops,"Save",
                    $ChemDVRManager["Settings","Save"<>$dvrke]]
                  ],
                ChemDVRSave[$dvrke,obj,ke]
                ]
              ];
            ke
            ]
          ]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*PotentialEnergy*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



(* ::Text:: *)
(*
	Clean way to get the potential energy off the new DVR results object
*)



ChemDVRPotentialEnergy[obj:_ChemDVRResultsObject, ops:OptionsPattern[]]:=
  ChemDVRGet[obj["Object"], $dvrpe][
    obj["Grid"],
    ops
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



(* ::Subsubsubsubsection::Closed:: *)
(*dvrCalcPE*)



dvrCalcPE[obj_,ops___]:=
  With[{g=dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]]},
    ChemDVRGet[obj,$dvrpe][g,
      Sequence@@FilterRules[{ops},Options@ChemDVRGet[obj,$dvrpe]]
      ]
    ]


(* ::Subsubsubsubsection::Closed:: *)
(*dvrLoadPotential*)



dvrLoadPotential[obj_,file_,ops___]:=
  DiagonalMatrix@
    Flatten[
      dvrImportAlignPotential[
        obj,
        With[{
          gBase=dvrOpsLookup[ops, $dvrgr,ChemDVRGrid[obj,ops]],
          dim=ChemDVRDimension[obj]
          },
          If[Dimensions[gBase[[1]]][[dim]]=!=dim,
            SelectFirst[
              gBase,
              With[{d2=Dimensions[#[[1]]]},
                Length[d2]>=dim&&d2[[dim]]===dim
                ]&,
              Throw[$Failed]
              ],
            gBase
            ]
          ],
        file,
        FilterRules[{ops},Options@dvrImportAlignPotential]
        ]
      ]


(* ::Subsubsubsubsection::Closed:: *)
(*Main*)



ChemDVRPotentialEnergy[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{dvrpe=dvrOpsLookup[ops,$dvrpe,ChemDVRGet[obj,$dvrpe]]},
    If[StringQ@dvrpe,
      If[FileExistsQ@dvrpe,
        dvrLoadPotential[obj,dvrpe,ops],
        dvrLoadPotential[obj,ChemDVRFile[$dvrpe, dvrpe],ops]
        ],
      With[{tryLoad=
        TrueQ@dvrOpsLookup[ops,"Load"<>$dvrpe,
            dvrOpsLookup[ops,"Load",
              $ChemDVRManager["Settings","Load"<>$dvrpe]]
            ]},
        If[tryLoad,
          If[FileExistsQ@ChemDVRFile[$dvrpe,obj],
            dvrLoadPotential[obj,ChemDVRFile[$dvrpe,obj],ops],
            ChemDVRPotentialEnergy[obj,
              "Load"<>$dvrpe->False,
              "Load"->False,
              ops]
            ],
          With[{pe=dvrCalcPE[obj,ops]},
            If[MatrixQ[pe],
              If[TrueQ@dvrOpsLookup[ops,"Save"<>$dvrpe,
                  dvrOpsLookup[ops,"Save",
                    $ChemDVRManager["Settings","Save"<>$dvrpe]]
                  ],
                ChemDVRSave[$dvrpe,obj,pe]
                ]
              ];
            pe
            ]
          ]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*PotentialOptimization*)



(* ::Text:: *)
(*
	Need to keep adding support for the new ChemDVRResultsObject (should be clean and simple but will drastically improve the state of things)
*)



ChemDVRPotentialOptimization//Clear


(* ::Subsubsubsection::Closed:: *)
(*New Version*)



ChemDVRPotentialOptimization[
  obj_ChemDVRResultsObject,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      po=ChemDVRGet[obj["Object"],  $dvrpo]
      },
    po[obj["Grid"], FilterRules[{ops}, Options@po]]
    ]


(* ::Subsubsubsection::Closed:: *)
(*Old Version*)



ChemDVRPotentialOptimization[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      po=
        ChemDVRGet[obj,  $dvrpo]
      },
    po[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj, ops]],
      FilterRules[{ops}, Options@po]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*GuessWavefunctions*)



ChemDVRGuessWavefunctions//Clear


(* ::Subsubsubsection::Closed:: *)
(*V2*)



ChemDVRGuessWavefunctions[
  res:_ChemDVRResultsObject,
  ops:OptionsPattern[]
  ]:=
  With[
    {wf=ChemDVRGet[res["Object"],  $dvrguwf]},
    wf[Normal@res["Grid"], FilterRules[{ops}, Options@wf]]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



ChemDVRGuessWavefunctions[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      wf=
        ChemDVRGet[obj,  $dvrguwf]
      },
    wf[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj, ops]],
      FilterRules[{ops}, Options@wf]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*GridPotentialEnergy*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



ChemDVRGridPotentialEnergy[
  res:_ChemDVRResultsObject,
  ops:OptionsPattern[]
  ]:=
  With[{gp=ChemDVRGet[obj, $dvrgp]},
    gp[Normal@res["Grid"], res["PotentialEnergy"],
      FilterRules[{ops}, Options@gp]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



ChemDVRGridPotentialEnergy[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[{gp=ChemDVRGet[obj, $dvrgp]},
    gp[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj, ops]
        ],
      FilterRules[{ops},
        Options@gp
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Wavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



ChemDVRWavefunctions[res_ChemDVRResultsObject, ops:OptionsPattern[]]:=
  With[
    {
      ke=res["KineticEnergy"],
      pe=res["PotentialEnergy"],
      wf=ChemDVRGet[res["Object"], $dvrwf]
      },
    wf[ke, pe, 
      FilterRules[{ops}, Options@wf]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



dvrCalcWFs[obj_,ops___]:=
  With[{
    ke=
      dvrOpsLookup[ops,
        $dvrke,
        ChemDVRKineticEnergy[obj,ops]
        ],
    pe=
      dvrOpsLookup[ops,
        "PotentialEnergy",
        ChemDVRPotentialEnergy[obj,ops]
        ],
    wf=ChemDVRGet[obj,$dvrwf]
    },
    wf[
      ke,
      pe,
      Sequence@@
        FilterRules[{ops},
          Options@wf]
          ]
    ];


ChemDVRWavefunctions[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{tryLoad=
    TrueQ@dvrOpsLookup[ops,"Load"<>$dvrwf,
      dvrOpsLookup[ops,"Load",
        $ChemDVRManager["Settings","Load"<>$dvrwf]]
      ]},
    If[tryLoad,
      If[FileExistsQ@ChemDVRFile[$dvrwf,obj],
        Import@ChemDVRFile[$dvrwf,obj],
        ChemDVRWavefunctions[obj,
          "Load"<>$dvrwf->False,
          "Load"->False,
          ops
          ]
        ],
      With[{wf=dvrCalcWFs[obj,ops]},
        If[Length@wf==2&&MatrixQ[Last@wf,NumericQ],
          If[TrueQ@dvrOpsLookup[ops,"Save"<>$dvrwf,
              dvrOpsLookup[ops,"Save",
                $ChemDVRManager["Settings","Save"<>$dvrwf]]
              ],
            ChemDVRSave[$dvrwf,obj,wf]
            ]
          ];
        wf
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*GridWavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



ChemDVRGridWavefunctions[res_ChemDVRResultsObject, ops:OptionsPattern[]]:=
  With[{gridwf=ChemDVRGet[res["Object"], $dvrgrwf]},
    gridwf[
      Normal@res["Grid"],
      res["Wavefunctions"],
      FilterRules[{ops}, Options@gridwf]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



ChemDVRGridWavefunctions[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{gridwf=ChemDVRGet[obj,$dvrgrwf]},
    gridwf[
      dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@gridwf
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*InterpolatingWavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



ChemDVRInterpolatingWavefunctions[res_ChemDVRResultsObject, ops:OptionsPattern[]]:=
  With[{interpf=ChemDVRGet[res["Object"], $dvrintwf]},
    interpf[Normal@res["Grid"], res["Wavefunctions"], 
      FilterRules[{ops},
        Options@interpf
        ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



ChemDVRInterpolatingWavefunctions[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{interpf=ChemDVRGet[obj, $dvrintwf]},
    interpf[
      dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@interpf
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*ExpectationValues*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



ChemDVRExpectationValues[
  res_ChemDVRResultsObject, 
  efuns:Except[_?OptionQ], 
  ops:OptionsPattern[]
  ]:=
  With[{exFun=ChemDVRGet[res["Object"], $dvrexv]},
    exFun[
      Normal@res["Grid"], 
      res["Wavefunctions"], 
      efuns,
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



ChemDVRExpectationValues[
  obj:dvrObjPattern, 
  efuns:Except[_?OptionQ], 
  ops:OptionsPattern[]
  ]:=
  With[{exFun=ChemDVRGet[obj, $dvrexv]},
    exFun[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      efuns,
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*OperatorMatrix*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



ChemDVROperatorMatrix[
  res_ChemDVRResultsObject, 
  efuns:Except[_?OptionQ], 
  ops:OptionsPattern[]
  ]:=
  With[{exFun=ChemDVRGet[res["Object"], $dvrexm]},
    exFun[
      Normal@res["Grid"],
      res["Wavefunctions"], 
      efuns,
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



ChemDVROperatorMatrix[
  obj:dvrObjPattern, 
  efuns:Except[_?OptionQ], 
  ops:OptionsPattern[]
  ]:=
  With[{exFun=ChemDVRGet[obj, $dvrexm]},
    exFun[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      efuns,
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*OperatorMatrixElements*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



ChemDVROperatorMatrixElements[
  res_ChemDVRResultsObject, 
  efuns:
    (({_, _}->_)|
    ({{_, _}...}->_)|
    {(({{_, _}...}|{_, _})->_)..}), 
  ops:OptionsPattern[]
  ]:=
  With[{exFun=ChemDVRGet[res["Object"], $dvrexmel]},
    exFun[
      Normal@res["Grid"],
      res["Wavefunctions"], 
      efuns,
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



ChemDVROperatorMatrixElements//Clear


ChemDVROperatorMatrixElements[
  obj:dvrObjPattern, 
  efuns:
    (({_, _}->_)|
    ({{_, _}...}->_)|
    {(({{_, _}...}|{_, _})->_)..}), 
  ops:OptionsPattern[]
  ]:=
  With[{exFun=ChemDVRGet[obj,  $dvrexmel]},
    exFun[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      efuns,
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*ExtendWavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



(* ::Text:: *)
(*
	Not implemented yet...
*)



(* ::Subsubsubsection::Closed:: *)
(*V1*)



ChemDVRExtendWavefunctions//Clear


ChemDVRExtendWavefunctions[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      exFun=
        ChemDVRGet[obj,  $dvrexwf],
      wf=
        dvrOpsLookup[ops, $dvrwf, None]
      },
    If[
      !MatchQ[wf, 
        _Hold|{_List?(VectorQ[#, Internal`RealValuedNumberQ]&), _List?MatrixQ}
        ],
      PackageRaiseException[
        Automatic,
        "\"ExtendWavefunctions\" requires an initial set of wavefunctions"
        ]
      ];
    exFun[
      dvrOpsLookup[ops, $dvrke, ChemDVRKineticEnergy[obj,ops]],
      dvrOpsLookup[ops, $dvrpe, ChemDVRPotentialEnergy[obj,ops]],
      wf,
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*View*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



ChemDVRView[res_ChemDVRResultsObject, ops:OptionsPattern[]]:=
  ChemDVRGet[res["Object"], "View"][
    res["Wavefunctions"],
    res["Grid"],
    res["PotentialEnergy"],
    {ops}
    ];


(* ::Subsubsubsection::Closed:: *)
(*V1*)



ChemDVRView[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{g=
    dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]]},
    With[{pe=
      dvrOpsLookup[ops,"PotentialEnergy",
        ChemDVRPotentialEnergy[obj,$dvrgr->g,ops]]},
      With[{wfs=
        dvrOpsLookup[ops,
          $dvrwf,
          ChemDVRWavefunctions[obj,
            $dvrgr->g,
            "PotentialEnergy"->pe,
            ops
            ]
          ]},
          ChemDVRGet[obj,"View"][wfs,g,pe,
            {ops}
            ]
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Notebook*)



ChemDVRNotebook//Clear


Options[ChemDVRNotebook]=
  Join[
    {
      "SaveObject"->True
      },
    Options@Notebook
    ];
ChemDVRNotebook[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      so=OptionValue["SaveObject"]
      },
    If[so,
      ChemDVRSave@obj
      ];
    CreateDocument@
      Notebook[
        First@
          Get[PackageFilePath["Resources", "Templates", "DVRNotebook.nb"]],
        FilterRules[
          {
            ops,
            WindowTitle->ChemDVRGet[obj,"UUID"]
            },
          Options@Notebook
          ]
        ]
    ]


(* ::Subsection:: *)
(*Run*)



(* ::Subsubsection::Closed:: *)
(*iChemDVRGetRuntimeOptions*)



iChemDVRGetRuntimeOptions[baseOpts_?OptionQ, keys__String]:=
  With[
      {
        passedOpts=
          dvrOpsLookup[
            baseOpts, 
            "PassedOptions",
            {}
            ]
        },
      Normal@
        Merge[
          {
            Fold[
              KeyDrop[
                Merge[
                  {
                    dvrOpsLookup[
                      {#}, 
                      #2<>"Options",
                      {}
                      ],
                    #
                    },
                  First
                  ],
                #2<>"Options"
                ]&,
              passedOpts,
              Reverse@{keys}
              ],
            Fold[
              KeyDrop[
                Merge[
                  {
                    dvrOpsLookup[
                      {#}, 
                      #2<>"Options",
                      {}
                      ],
                    #
                    },
                  First
                  ],
                #2<>"Options"
                ]&,
              baseOpts,
              Reverse@{keys}
              ]
          },
        First
        ]
      ];


iChemDVRGetRuntimeOptions[res_ChemDVRResultsObject, keys__]:=
  iChemDVRGetRuntimeOptions[res["Options"], keys];
iChemDVRGetRuntimeOptions[keys__String]:=
(*If[{keys}==={"View"}, Apply[Sequence]@*Echo@*List, ##&]@*)
  With[
    {
      baseOpts={RunRuntimeOptions}
      },
    iChemDVRGetRuntimeOptions[baseOpts, keys]
    ]//Apply[Sequence];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGrid*)



(* ::Subsubsubsection::Closed:: *)
(*Version 2*)



iChemDVRRunGrid[res_ChemDVRResultsObject]:=
  ChemDVRGrid[res, iChemDVRGetRuntimeOptions[res, $dvrgr]]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunCalculateKEQ*)



(* ::Subsubsubsection::Closed:: *)
(*Core*)



iChemDVRRunCalculateKEQ[end_, wfs_]:=
  !(
    MatchQ[end, $dvrpe]||
      (
        MatchQ[Flatten[{end}, 1][[1]], 
          $dvrwf|$dvrgrwf|$dvrintwf|$dvrexv|$dvrexm|$dvrexmel|$dvrvw
          ]&&
          MatchQ[wfs, _List|_Hold|_WavefunctionsObject]
        )
      )


(* ::Subsubsubsection::Closed:: *)
(*Version 2*)



iChemDVRRunCalculateKEQ[res_]:=
  iChemDVRRunCalculateKEQ[
    res["Options", "EndPoint"],
    res["Wavefunctions"]
    ]


(* ::Subsubsubsection::Closed:: *)
(*Version 1*)



iChemDVRRunCalculateKEQ[]:=
  iChemDVRRunCalculateKEQ[
    RunEndPoint,
    If[RunWavefunctions===None,
      RunWavefunctions=
        dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions],
      RunWavefunctions
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunKineticEnergy*)



(* ::Subsubsubsection::Closed:: *)
(*Version 2*)



iChemDVRRunKineticEnergy[res_ChemDVRResultsObject]:=
  Replace[l_List:>Developer`ToPackedArray[l]]@
  Replace[
    res["KineticEnergy"],
    {
      None:>
        ChemDVRKineticEnergy[res, iChemDVRGetRuntimeOptions[res, $dvrke]],
      r:_?SquareMatrixQ|Hold[_?SquareMatrixQ]:>r,
      m:{__?SquareMatrixQ}:>
        ChemDVRKroeneckerProductKineticEnergy@m,
      m:Hold[_?(MatchQ[{__?SquareMatrixQ}])]:>
        Hold[Evaluate@ChemDVRKroeneckerProductKineticEnergy@m],
      _:>
        PackageRaiseException[
          Automatic,
          "Kinetic energy isn't in valid format"
          ]
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*Version1*)



iChemDVRRunKineticEnergy[obj_ChemDVRObject]:=
  Switch[
    RunKineticEnergy=
      dvrOpsLookup[RunRuntimeOptions, $dvrke, RunKineticEnergy],
    None,
      ChemDVRKineticEnergy[
        obj,
        $dvrgr->RunGrid,
        "TransformationMatrix"->RunTransforms,
        iChemDVRGetRuntimeOptions[$dvrke]
        ],
    _?SquareMatrixQ|Hold[_?SquareMatrixQ],
      RunKineticEnergy,
    {__?SquareMatrixQ},
      ChemDVRKroeneckerProductKineticEnergy@RunKineticEnergy,
    Hold[_?(MatchQ[{__?SquareMatrixQ}])],
      Hold[Evaluate@ChemDVRKroeneckerProductKineticEnergy@RunKineticEnergy],
    True,
      PackageRaiseException[
        Automatic,
        "Kinetic energy isn't in valid format"
        ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunCalculatePEQ*)



(* ::Subsubsubsection::Closed:: *)
(*Core*)



iChemDVRRunCalculatePEQ[end_, wf_]:=
  !(
    MatchQ[end, 
      $dvrwf|$dvrgrwf|$dvrintwf|$dvrexv|$dvrexm| $dvrexmel
      ]&&
    MatchQ[wf, _List|_Hold|_WavefunctionsObject]
    )


(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunCalculatePEQ[res_]:=
  iChemDVRRunCalculatePEQ[
    res["Options", "EndPoint"],
    res["Wavefunctions"]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunCalculatePEQ[]:=
  iChemDVRRunCalculatePEQ[
    RunEndPoint,
    If[RunWavefunctions===None,
        RunWavefunctions=
          dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions],
        RunWavefunctions
        ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunPotentialEnergy*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunPotentialEnergy[res_ChemDVRResultsObject]:=
  Replace[l_List:>Developer`ToPackedArray[l]]@
  Replace[
    res["PotentialEnergy"],
    {
      None:>
        ChemDVRPotentialEnergy[res, iChemDVRGetRuntimeOptions[res, $dvrpe]],
      r:_?SquareMatrixQ|Hold[_?SquareMatrixQ]:>r,
      m:{__?SquareMatrixQ}:>
        ChemDVRDefaultDirectProductPotentialEnergy@m,
      m:Hold[_?(MatchQ[{__?SquareMatrixQ}])]:>
        Hold[Evaluate@ChemDVRDefaultDirectProductPotentialEnergy@m],
      _:>
        PackageRaiseException[
          Automatic,
          "Potential energy isn't in valid format"
          ]
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunPotentialEnergy[obj_ChemDVRObject]:=
  Switch[
    RunPotentialEnergy=
      dvrOpsLookup[RunRuntimeOptions, $dvrpe, RunPotentialEnergy],
    None,
      ChemDVRPotentialEnergy[
        obj,
        $dvrgr->RunGrid,
        "TransformationMatrix"->RunTransformation,
        iChemDVRGetRuntimeOptions[$dvrpe]
        ],
    _?SquareMatrixQ|Hold[_?SquareMatrixQ],
      RunPotentialEnergy,
    {__?SquareMatrixQ},
        ChemDVRDefaultDirectProductPotentialEnergy@RunPotentialEnergy,
    Hold[_?(MatchQ[{__?SquareMatrixQ}])],
      Hold[
        Evaluate@
          ChemDVRDefaultDirectProductPotentialEnergy@
            RunPotentialEnergy
        ],
    True,
      PackageRaiseException[
        Automatic,
        "Potential energy isn't in valid format"
        ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunHamiltonian*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunHamiltonian[res_ChemDVRResultsObject]:=
  ChemDVRDefaultPrepareHamiltonian[
    res@"KineticEnergy", 
    res@"PotentialEnergy", 
    FilterRules[
      {iChemDVRGetRuntimeOptions[res, $dvrwf]}, 
      Options[ChemDVRDefaultPrepareHamiltonian]
      ]
    ][[1]];


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunHamiltonian[obj_ChemDVRObject]:=
  ChemDVRDefaultPrepareHamiltonian[
    Hold@RunKineticEnergy, 
    Hold@RunPotentialEnergy, 
    FilterRules[
      {iChemDVRGetRuntimeOptions[$dvrwf]}, 
      Options[ChemDVRDefaultPrepareHamiltonian]
      ]
    ][[1]];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunCalculateWFQ*)



iiChemDVRRunCalculateWFQ[end_]:=
  Length@
    Complement[
      Flatten[{end}, 1], 
      {$dvrham, $dvrke, $dvrpe, $dvrgr}
      ]>0;


iChemDVRRunCalculateWFQ[res_]:=
  iiChemDVRRunCalculateWFQ@res["Options", "EndPoint"]


iChemDVRRunCalculateWFQ[]:=
  iiChemDVRRunCalculateWFQ@RunEndPoint;


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGridPotentialEnergy*)



(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunGridPotentialEnergy[res_ChemDVRResultsObject]:=
  ChemDVRGridPotentialEnergy[
    res,
    iChemDVRGetRuntimeOptions[res, $dvrgp, $dvrpe]
    ];


(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunGridPotentialEnergy[obj_ChemDVRObject]:=
  ChemDVRGridPotentialEnergy[obj,
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, "GridPotentialEnergy"]===ChemDVRDefaultGridPotentialEnergy, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrgp, $dvrpe]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGridKineticEnergy*)



(* ::Text:: *)
(*
	This is such a hack...
*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunGridKineticEnergy[res_ChemDVRResultsObject]:=
  ChemDVRGridPotentialEnergy[res,
    iChemDVRGetRuntimeOptions[res, $dvrgp, $dvrpe]
    ];


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunGridKineticEnergy[obj_ChemDVRObject]:=
  ChemDVRGridPotentialEnergy[obj,
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, "GridPotentialEnergy"]===ChemDVRDefaultGridPotentialEnergy, 
        If[Head[RunKineticEnergy]===Hold,
          RunKineticEnergy,
          Hold[RunKineticEnergy]
          ],
        RunKineticEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrgp, $dvrpe]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunPOQ*)



(* ::Subsubsubsection::Closed:: *)
(*Core*)



iChemDVRRunPOQ[end_, wf_, poQ_, poOps_]:=
  end===$dvrpo||
    (
      (
        wf===None||
        MemberQ[
          Flatten@{end}, 
          Alternatives[
            $dvrgrwf, $dvrintwf,
            $dvrexv, $dvrexm,
            $dvrexmel
            ]
          ]
        )&&
        Replace[
          poQ,
          {
            Automatic:>
              Length@poOps>0,
            Except[True|False]->False
            }
          ]
      )


(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunPOQ[res_ChemDVRResultsObject]:=
  iChemDVRRunPOQ[
    res["Options", "EndPoint"],
    res["Wavefunctions"],
    Replace[res["Options", "PotentialOptimize"], _Missing->Automatic],
    Replace[res["Options", "PotentialOptimizationOptions"], _Missing->None]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunPOQ[]:=
  iChemDVRRunPOQ[
    RunEndPoint,
    RunWavefunctions,
    dvrOpsLookup[RunRuntimeOptions, "PotentialOptimize", Automatic],
    dvrOpsLookup[RunRuntimeOptions, "PotentialOptimizationOptions", None]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunPotentialOptimization*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunPotentialOptimization[res_ChemDVRResultsObject]:=
  Module[{po, gr, ke},
    po=
      ChemDVRPotentialOptimization[
        res,
        FilterRules[
          {
            "OptimizedComponents"->{
              $dvrgr, 
              $dvrke
              },
            iChemDVRGetRuntimeOptions[res, $dvrpo, $dvrke, $dvrpe]
            },
          Options@ChemDVRDefaultPotentialOptimize
          ]
        ];
    gr=
      With[{l=po[$dvrgr]},
        If[Length@l>1,
          ChemDVRDirectProductGrid@l,
          l[[1]]
          ]
        ];
    ke=
      If[res["Options", "EndPoint"]=!=$dvrgr,
        With[{l=po[$dvrke]},
          If[Length@l>1,
            ChemDVRKroeneckerProductKineticEnergy@l,
            l[[1]]
            ]
          ],
        None
        ];
    {po, gr, ke}
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunPotentialOptimization[obj_]:=
  Module[{po, gr, ke},
    po=
      ChemDVRPotentialOptimization[
        obj,
        $dvrgr->
          RunGrid,
        FilterRules[
          {
            "OptimizedComponents"->{
              $dvrgr, 
              $dvrke
              },
            iChemDVRGetRuntimeOptions[
              $dvrpo,
              $dvrke,
              $dvrpe
              ]
            },
          Options@ChemDVRDefaultPotentialOptimize
          ]
        ];
    gr=
      With[{l=po[$dvrgr]},
        If[Length@l>1,
          ChemDVRDirectProductGrid@l,
          l[[1]]
          ]
        ];
    ke=
      If[RunEndPoint=!=$dvrgr,
        With[{l=po[$dvrke]},
          If[Length@l>1,
            ChemDVRKroeneckerProductKineticEnergy@l,
            l[[1]]
            ]
          ],
        None
        ];
    {po, gr, ke}
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGWQ*)



(* ::Subsubsubsection::Closed:: *)
(*Core*)



iChemDVRRunGWQ[end_, ugwf_, ugwfO_]:=
  end===$dvrguwf||
    Replace[
      ugwf,
      {
        Automatic:>
          Length@ugwfO>0,
        Except[True|False]->False
        }
      ]


(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunGWQ[res_]:=
  iChemDVRRunGWQ[
    res["Options", "EndPoint"],
    res["Options", "UseGuessWavefunctions"],
    Replace[Missing->None]@
      res["Options", "GuessWavefunctionsOptions"]
    ];


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunGWQ[]:=
  iChemDVRRunGWQ[
    RunEndPoint,
    dvrOpsLookup[RunRuntimeOptions, "UseGuessWavefunctions", False],
    dvrOpsLookup[
      RunRuntimeOptions, 
      "GuessWavefunctionsOptions", 
      None
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGuessWavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*iChemDVRRunGuessWavefunctionsComponents*)



iChemDVRRunGuessWavefunctionsComponents[end_]:=
  Switch[end,
        $dvreng,
          "GuessWavefunctionsComponents"->
            {
              "Energies"
              },
        $dvrwf|$dvrgrwf|$dvrintwf,
          "GuessWavefunctionsComponents"->
            {
              "Grid",
              "Wavefunctions"
              },
        $dvrguwf,
          Sequence@@{},
        _,
          "GuessWavefunctionsComponents"->
            {
              "Grid",
              "Wavefunctions",
              "KineticEnergy",
              "PotentialEnergy"
              }
        ]


(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunGuessWavefunctions[res_ChemDVRResultsObject]:=
  ChemDVRGuessWavefunctions[
    res,
    iChemDVRRunGuessWavefunctionsComponents[res["Options", "EndPoint"]],
    iChemDVRGetRuntimeOptions[
      res,
      $dvrguwf,
      $dvrke,
      $dvrpe
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunGuessWavefunctions[obj_ChemDVRObject]:=
  ChemDVRGuessWavefunctions[
    obj,
    $dvrgr->
      RunGrid,
    iChemDVRRunGuessWavefunctionsComponents@
      RunEndPoint,
    iChemDVRGetRuntimeOptions[
      $dvrguwf,
      $dvrke,
      $dvrpe
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunWavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunWavefunctions[res_ChemDVRResultsObject]:=
  Developer`ToPackedArray/@
    ChemDVRWavefunctions[res,
      iChemDVRGetRuntimeOptions[res, $dvrwf]
      ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunWavefunctions[obj_ChemDVRObject]:=
  ChemDVRWavefunctions[obj,
    $dvrke->
      If[ChemDVRGet[obj, "Wavefunctions"]===ChemDVRDefaultWavefunctions, 
        If[Head[RunKineticEnergy]===Hold,
          RunKineticEnergy,
          Hold[RunKineticEnergy]
          ],
        RunKineticEnergy
        ],
    $dvrpe->
      If[ChemDVRGet[obj, "Wavefunctions"]===ChemDVRDefaultWavefunctions, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrwf]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunExtendWavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunExtendWavefunctions[res_ChemDVRResultsObject]:=
  ChemDVRExtendWavefunctions[res,
    iChemDVRGetRuntimeOptions[res, $dvrexwf]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunExtendWavefunctions[obj_ChemDVRObject]:=
  ChemDVRExtendWavefunctions[obj,
    $dvrke->
      If[ChemDVRGet[obj,  $dvrexwf]===ChemDVRDefaultExtendWavefunctions, 
        If[Head[RunKineticEnergy]===Hold,
          RunKineticEnergy,
          Hold[RunKineticEnergy]
          ],
        RunKineticEnergy
        ],
    $dvrpe->
      If[ChemDVRGet[obj,  $dvrexwf]===ChemDVRDefaultExtendWavefunctions, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    $dvrwf->
      If[ChemDVRGet[obj,  $dvrexwf]===ChemDVRDefaultExtendWavefunctions, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    iChemDVRGetRuntimeOptions[ $dvrexwf]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunEnergies*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunEnergies[res_ChemDVRResultsObject]:=
  If[MatchQ[res["Wavefunctions"], _WavefunctionsObject], 
    res["Wavefunctions"]["Energies"],
    ChemDVRWavefunctions[res,
      "WavefunctionEigensolver"->Eigenvalues,
      iChemDVRGetRuntimeOptions[$dvrwf]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunEnergies[obj_]:=
  If[!ListQ[RunEnergies],
    If[
      MatchQ[RunWavefunctions, 
        {_List?(VectorQ[#, Internal`RealValuedNumericQ]&), _}
        ],
      RunWavefunctions[[1]],
      ChemDVRWavefunctions[obj,
        $dvrke->
          If[ChemDVRGet[obj, "Wavefunctions"]===ChemDVRDefaultWavefunctions, 
            If[Head[RunKineticEnergy]===Hold,
              RunKineticEnergy,
              Hold[RunKineticEnergy]
              ],
            RunKineticEnergy
            ],
        $dvrpe->
          If[ChemDVRGet[obj, "Wavefunctions"]===ChemDVRDefaultWavefunctions, 
            If[Head[RunPotentialEnergy]===Hold,
              RunPotentialEnergy,
              Hold[RunPotentialEnergy]
              ],
            RunPotentialEnergy
            ],
        "WavefunctionEigensolver"->Eigenvalues,
        iChemDVRGetRuntimeOptions[$dvrwf]
        ]
      ],
    RunEnergies
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGridWavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunGridWavefunctions[res_ChemDVRResultsObject]:=
  ChemDVRGridWavefunctions[res,
    iChemDVRGetRuntimeOptions[res, $dvrgrwf, $dvrwf]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunGridWavefunctions[obj_ChemDVRObject]:=
  ChemDVRGridWavefunctions[obj,
    $dvrwf->
      If[ChemDVRGet[obj, $dvrgrwf]===ChemDVRDefaultGridWavefunctions, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, $dvrgrwf]===ChemDVRDefaultGridWavefunctions, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrgrwf, $dvrwf]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunInterpolatingWavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunInterpolatingWavefunctions[res_ChemDVRResultsObject]:=
  ChemDVRInterpolatingWavefunctions[res,
    iChemDVRGetRuntimeOptions[res, $dvrintwf]
    ];


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunInterpolatingWavefunctions[obj_ChemDVRObject]:=
  ChemDVRInterpolatingWavefunctions[obj,
    $dvrwf->
      If[ChemDVRGet[obj, $dvrintwf]===ChemDVRDefaultInterpolatingWavefunctions, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, $dvrintwf]===ChemDVRDefaultInterpolatingWavefunctions, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrintwf]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunExpectationValues*)



(* ::Subsubsubsection::Closed:: *)
(*getExpectValueFns*)



getExpectValueFns[end_]:=
  Replace[
    Rest@end,
    {
      {f:Except[_List]}:>f,
      e_:>Flatten[e]
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunExpectationValues[res_ChemDVRResultsObject]:=
  ChemDVRExpectationValues[res,
    getExpectValueFns@res["Options", "EndPoint"],
    iChemDVRGetRuntimeOptions[res, $dvrexv]
    ];


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunExpectationValues[obj_ChemDVRObject]:=
  ChemDVRExpectationValues[obj,
    getExpectValueFns@RunEndPoint,
    $dvrwf->
      If[ChemDVRGet[obj, $dvrexv]===ChemDVRDefaultExpectationValues, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, $dvrexv]===ChemDVRDefaultExpectationValues, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrexv]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunOperatorMatrix*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunOperatorMatrix[res_ChemDVRResultsObject]:=
  ChemDVROperatorMatrix[
    res,
    getExpectValueFns@res["EndPoint"],
    iChemDVRGetRuntimeOptions[
      res,
      $dvrexm,
      $dvrexv
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunOperatorMatrix[obj_ChemDVRObject]:=
  ChemDVROperatorMatrix[obj,
    getExpectValueFns@RunEndPoint,
    $dvrwf->
      If[ChemDVRGet[obj, $dvrexm]===ChemDVRDefaultOperatorMatrix, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, $dvrexm]===ChemDVRDefaultOperatorMatrix, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[
       $dvrexm,
       $dvrexv
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunOperatorMatrixElements*)



(* ::Subsubsubsection::Closed:: *)
(*V2*)



iChemDVRRunOperatorMatrix[res_ChemDVRResultsObject]:=
  ChemDVROperatorMatrixElements[
    res,
    getExpectValueFns@res["EndPoint"],
    iChemDVRGetRuntimeOptions[
      res,
      $dvrexmel,
      $dvrexm,
      $dvrexv
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*V1*)



iChemDVRRunOperatorMatrixElements[obj_ChemDVRObject]:=
  ChemDVROperatorMatrixElements[obj,
    Replace[
      Rest@RunEndPoint,
      {
        {f:Except[_List]}:>f,
        e_:>Flatten[e]
        }
      ],
    $dvrwf->
      If[ChemDVRGet[obj,  $dvrexmel]===
          ChemDVRDefaultOperatorMatrixElements, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj,  $dvrexmel]===
          ChemDVRDefaultOperatorMatrixElements, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[
       $dvrexmel,
       $dvrexm,
       $dvrexv
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*checkResults*)



checkResults[res_]:=
  If[!ChemDVRResultsObjectQ@res,
      PackageRaiseException[Automatic,
        "Bad intermediate result object"
        ]
      ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRun*)



iChemDVRRun[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{meth=Lookup[Flatten[{ops}, 1], Method]},
    If[meth==="Legacy",
      iChemDVRRun1[obj, ops],
      iChemDVRRun2[obj, ops]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*New*)



(* ::Text:: *)
(*
	The idea here is *only* return the core data and push all other stuff into the DVRResultsObject
*)



iChemDVRRun2[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  Block[{RunCheckPoint=None},
  Module[
    {
      res,
      object=obj,
      grid,
      tf,
      options=
        Normal@
          Merge[
            {
              "PassedOptions"->{ops},
              ChemDVRGet[obj, "RuntimeOptions", {}],
              ChemDVRGet[obj, "Defaults", {}],
              ops
              },
            First
            ]
      },
    If[!OptionQ[options],
      PackageRaiseException[
        Automatic,
        "Options `` aren't valid for ChemDVRRun (OptionQ failed)",
        options
        ]
      ];
    res=NewDVRResultsObject@<|
      "Object"->object,
      "Options"->Association@options,
      "Extensions"-><||>
      |>;
    res["Options", "EndPoint"]=
      Lookup[options, Return, "View"];
    If[res["Options", "Save"], ChemDVRSave@obj];
    (** --------------------------------- DEFAULTS --------------------------------- **)
    res["Grid"]=
      Lookup[res["Options"], $dvrgr, res["Grid"]];
    checkResults[res];
    res["Options", $dvrgr]=.;
    res["KineticEnergy"]=
      Lookup[res["Options"], $dvrke, res["KineticEnergy"]];
    checkResults[res];
    res["Options", $dvrke]=.;
    res["PotentialEnergy"]=
      Lookup[res["Options"], $dvrpe, res["PotentialEnergy"]];
    checkResults[res];
    res["Options", $dvrpe]=.;
    (** ----------------------------------- GRID ------------------------------------ **)
    grid=res["Grid"];
    Switch[grid,
      None,
        grid=iChemDVRRunGrid[res],
      {__?VectorQ},
        grid=
          ChemDVRDirectProductGrid@res["Grid"]
          (* this should honestly be a Grid object where this would be a method... *)
      ];
    (* test if grid also has a Transformation matrix *)
    With[{g=grid},
      Which[
        VectorQ@g[[1]]&&(SquareMatrixQ@g[[2]]||g[[2]]===None),
          res["Grid"]=grid[[1]];
          res["Transformation"]=grid[[2]];,
        MatchQ[g[[1]], {__List}]&&
          AllTrue[g[[2]], #===None||SquareMatrixQ@#&],
          res["Grid"]=grid[[1]];
          res["Transformation"]=grid[[2]];,
        True,
          res["Grid"]=g
        ]
      ];
    checkResults[res];
    (** -------------------------------- TRANSFORM -------------------------------- **)
    If[res["Options", "EndPoint"]==="Transform", Return@res];
    (** --------------------------- GUESS WAVEFUNCTIONS --------------------------- **)
    If[iChemDVRRunGWQ[res],
      res["Extensions", "GuessWavefunctions"]=
        iChemDVRRunGuessWavefunctions[res];
      If[res["Options", "EndPoint"]===$dvrguwf, Return@res];
      res["Options", "UseGuessWavefunctions"]=
        Lookup[res["Options"], "UseGuessWavefunctions", False];
      If[res["Options", "UseGuessWavefunctions"],
        res["Wavefunctions"]=
          WavefunctionsObject[
            res["Extensions", "GuessWavefunctions", "Wavefunctions"],
            Replace[res["Extensions", "GuessWavefunctions", "Grid"],
              _Missing:>res["Grid"]
              ]
            ];
        res["PotentialEnergy"]:=
          Replace[res["Extensions", "GuessWavefunctions", "PotentialEnergy"],
            _Missing:>res["PotentialEnergy"]
            ];
        res["KineticEnergy"]:=
          Replace[res["Extensions", "GuessWavefunctions", "KineticEnergy"],
            _Missing:>res["KineticEnergy"]
            ];
        ]
      ];
    checkResults[res];
    If[res["Options", "EndPoint"]==="GuessWavefunctions", Return@res];
    (** --------------------------- POTENTIAL OPTIMIZATION -------------------------- **)
    res["Options", "PotentialOptimize"]=iChemDVRRunPOQ[res];
    If[res["Options", "PotentialOptimize"],
      With[{po=iChemDVRRunPotentialOptimization[res]},
        res["Extensions", "PotentialOptimization"]=po[[1]];
        res["Grid"]=po[[2]];
        res["KineticEnergy"]=po[[3]];
        ]
      ];
    checkResults[res];
    If[res["Options", "EndPoint"]===$dvrpo, Return@res];
    (** ------------------------------- RETURN GRID -------------------------------- **)
    RunCheckPoint=$dvrgr;
    If[Complement[
        Flatten[{res["Options", "EndPoint"]}, 1], 
        {$dvrgr, "Transform"}
        ]=={}, 
      Return@res
      ];
    (** ------------------------------ KINETIC ENERGY ------------------------------- **)
    If[iChemDVRRunCalculateKEQ[res],
      res["KineticEnergy"]=iChemDVRRunKineticEnergy[res];
      ];
    checkResults[res];
    If[res["Options", "EndPoint"]===$dvrke, Return@res];
    RunCheckPoint=$dvrke;
    
    (** ---------------------------- POTENTIAL ENERGY ------------------------------ **)
    If[iChemDVRRunCalculatePEQ[res],
      res["PotentialEnergy"]=
        iChemDVRRunPotentialEnergy[res]
      ];
    checkResults[res];
    If[res["Options", "EndPoint"]===$dvrpe, Return@res];
    RunCheckPoint=$dvrpe;
    
    (** ------------------------- EXTENDED WAVEFUNCTIONS ------------------------- **)
    (* 
			Need better support for this. It should be used in place of the Wavefunctions or something... 
	*)
    If[res["Options", "EndPoint"]===$dvrexwf,
      res["Wavefunctions"]=iChemDVRRunExtendWavefunctions[res];
      Return@res
      ];
    checkResults[res]'
    (** ----------------------------- WAVEFUNCTIONS ------------------------------- **)
    If[iChemDVRRunCalculateWFQ[res],
      res["Wavefunctions"]=
        WavefunctionsObject[
          Evaluate@iChemDVRRunWavefunctions[res],
          Evaluate@res["Grid"]
          ];
      If[res["Options", "EndPoint"]===$dvrwf, Return@res];
      RunCheckPoint=$dvrwf
      ];
    checkResults[res];
    res
    ]
  ]


(* ::Subsubsubsection::Closed:: *)
(*Old*)



iChemDVRRun1[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  Block[
  {
    RunObject=obj,
    RunRuntimeOptions=
      Sequence@@
        Normal@
          Merge[
            {
              "PassedOptions"->{ops},
              ChemDVRGet[obj, "RuntimeOptions", {}],
              ChemDVRGet[obj, "Defaults", {}],
              ops
              },
            First
            ],
    RunCheckPoint=None,
    RunEndPoint,
    RunGrid=None,
    RunTransforms=None,
    RunKineticEnergy=None,
    RunPotentialEnergy=None,
    RunEnergies=None,
    RunWavefunctions=None,
    RunPotentialOptimize=Automatic,
    RunGuessWavefunctions=Automatic,
    RunUseGuessWavefunctions=False
    },
    If[!OptionQ[{RunRuntimeOptions}],
      PackageRaiseException[
        Automatic,
        "Options `` aren't valid for ChemDVRRun (OptionQ failed)",
        {RunRuntimeOptions}
        ]
      ];
    RunEndPoint=
      dvrOpsLookup[RunRuntimeOptions, Return, "View"];
    If[dvrOpsLookup[RunRuntimeOptions, "Save", False],
      ChemDVRSave@obj
      ];
    (** --------------------------------- DEFAULTS --------------------------------- **)
    RunGrid=dvrOpsLookup[RunRuntimeOptions, $dvrgr, RunGrid];
    RunWavefunctions=dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions];
    RunKineticEnergy=dvrOpsLookup[RunRuntimeOptions, $dvrke, RunKineticEnergy];
    RunPotentialEnergy=dvrOpsLookup[RunRuntimeOptions, $dvrpe, RunPotentialEnergy];
    (** ----------------------------------- GRID ------------------------------------ **)
    Switch[RunGrid,
      None,
        RunGrid=
          ChemDVRGrid[obj,
            iChemDVRGetRuntimeOptions[$dvrgr]
            ],
      {__?VectorQ},
        RunGrid=
          ChemDVRDirectProductGrid@RunGrid
      ];
    Which[
      VectorQ@RunGrid[[1]]&&(SquareMatrixQ@RunGrid[[2]]||RunGrid[[2]]===None),
        {RunGrid, RunTransforms}=RunGrid,
      MatchQ[RunGrid[[1]], {__List}]&&
        AllTrue[RunGrid[[2]], #===None||SquareMatrixQ@#&],
        {RunGrid, RunTransforms}=RunGrid
      ];
    (** -------------------------------- TRANSFORM -------------------------------- **)
    If[RunEndPoint==="Transform", Return@RunTransforms];
    
    (** --------------------------- GUESS WAVEFUNCTIONS --------------------------- **)
    If[iChemDVRRunGWQ[],
      RunGuessWavefunctions=iChemDVRRunGuessWavefunctions[obj];
      If[RunEndPoint===$dvrguwf, 
        Return@RunGuessWavefunctions
        ];
      RunUseGuessWavefunctions=
        dvrOpsLookup[RunRuntimeOptions, "UseGuessWavefunctions", False];
      If[RunUseGuessWavefunctions,
        RunEnergies=
          Lookup[RunGuessWavefunctions, "Energies", RunEnergies];
        RunWavefunctions=
          Lookup[RunGuessWavefunctions, "Wavefunctions", RunWavefunctions];
        RunGrid=
          Lookup[RunGuessWavefunctions, "Grid", RunGrid];
        RunPotentialEnergy=
          Lookup[RunGuessWavefunctions, "PotentialEnergy", RunPotentialEnergy];
        RunKineticEnergy=
          Lookup[RunGuessWavefunctions, "KineticEnergy", RunKineticEnergy]
        ]
      ];
    
    (** --------------------------- POTENTIAL OPTIMIZATION -------------------------- **)
    RunPotentialOptimize=iChemDVRRunPOQ[];
    If[RunPotentialOptimize,
      {
        RunPotentialOptimize,
        RunGrid,
        RunKineticEnergy
        }=iChemDVRRunPotentialOptimization[obj]
      ];
    If[RunEndPoint===$dvrpo, 
      Return@RunPotentialOptimize
      ];
    
    (** ------------------------------- RETURN GRID -------------------------------- **)
    If[RunEndPoint===$dvrgr, Return@RunGrid];
    RunCheckPoint=$dvrgr;
    If[Complement[Flatten@{RunEndPoint}, {$dvrgr, "Transform"}]=={}, 
      Return@
        Replace[Flatten@{RunEndPoint},
          {$dvrgr:>RunGrid, "Transform":>RunTransform}, 
          1
          ]
      ];
    
    (** ------------------------------ KINETIC ENERGY ------------------------------- **)
    If[iChemDVRRunCalculateKEQ[],
      RunKineticEnergy=
        iChemDVRRunKineticEnergy[obj];
      ];
    If[RunEndPoint===$dvrke, Return@RunKineticEnergy];
    RunCheckPoint=$dvrke;
    
    (** ---------------------------- GRID KINETIC ENERGY ---------------------------- **)
    If[RunEndPoint==="GridKineticEnergy", 
      Return@iChemDVRRunGridKineticEnergy[obj]];
    
    (** ---------------------------- POTENTIAL ENERGY ------------------------------ **)
    If[iChemDVRRunCalculatePEQ[],
      RunPotentialEnergy=
        iChemDVRRunPotentialEnergy[obj]
      ];
    If[RunEndPoint===$dvrpe, Return@RunPotentialEnergy];
    RunCheckPoint=$dvrpe;
    (** -------------------------- GRID POTENTIAL ENERGY --------------------------- **)
    If[RunEndPoint===$dvrgp, 
      Return@iChemDVRRunGridPotentialEnergy[obj]];
    If[RunEndPoint=== $dvrexwf,
      If[RunWavefunctions===None,
        RunWavefunctions=
          dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions]
        ];
      Return@iChemDVRRunExtendWavefunctions[obj]
      ];
    (** ------------------------------- HAMILTONIAN -------------------------------- **)
    If[RunEndPoint===$dvrham, 
      Return[iChemDVRRunHamiltonian[obj]]
      ];
    (** -------------------------------- ENERGIES ---------------------------------- **)
    If[RunEndPoint===$dvreng, 
      If[RunWavefunctions===None,
        RunWavefunctions=
          dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions]
        ];
      Return@iChemDVRRunEnergies[obj]
      ];
    (** ----------------------------- WAVEFUNCTIONS ------------------------------- **)
    If[iChemDVRRunCalculateWFQ[],
      If[RunWavefunctions===None,
        RunWavefunctions=
          dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions]
        ];
      If[RunWavefunctions===None,
        RunWavefunctions=iChemDVRRunWavefunctions[obj];
        ];
      If[RunEndPoint===$dvrwf,
        Return@RunWavefunctions
        ];
      RunCheckPoint=$dvrwf
      ];
    (** ----------------------------- RUN ENDPOINTS ------------------------------ **)
    Switch[RunEndPoint,
      (** --------------------------- MULTIPLE RETURN ---------------------------- **)
      {
        (
          $dvrgr|$dvrke|$dvrpe|$dvrwf|$dvrham|$dvreng|
            $dvrgrwf|$dvrintwf|
            {$dvrexv, __}|{$dvrexm, __}|{ $dvrexmel, __}
          )..
        },
        Replace[
          Replace[
            DeleteDuplicates@RunEndPoint,
            {
              k:$dvrgr:>
                Block[{RunEndPoint=k},
                  ($dvrgr->RunGrid)
                  ],
              k:$dvrke:>
                Block[{RunEndPoint=k},
                  ($dvrke->RunKineticEnergy)
                  ],
              k:$dvrpe:>
                  Block[{RunEndPoint=k},
                    ($dvrpe->RunPotentialEnergy)
                    ],
              k:$dvrwf:>
                Block[{RunEndPoint=k},
                  ($dvrwf->RunWavefunctions)
                  ],
              k:$dvrham:>
                Block[{RunEndPoint=k},
                  ($dvrham->RunPotentialEnergy+RunKineticEnergy)
                  ],
              k:$dvreng:>
                Block[{RunEndPoint=k},
                  ($dvreng->RunWavefunctions[[1]])
                  ],
              k:$dvrgrwf:>
                Block[{RunEndPoint=k},
                  ($dvrgrwf->iChemDVRRunGridWavefunctions[obj])
                  ],
              k:$dvrintwf:>
                Block[{RunEndPoint=k},
                  ($dvrintwf->iChemDVRRunInterpolatingWavefunctions[obj])
                  ],
              k:{$dvrexv, __}:>
                Block[{RunEndPoint=k},
                  ($dvrexv->iChemDVRRunExpectationValues[obj])
                  ],
              k:{$dvrexm, __}:>
                Block[{RunEndPoint=k},
                  ($dvrexm->iChemDVRRunOperatorMatrix[obj])
                  ],
              k:{ $dvrexmel, __}:>
                Block[{RunEndPoint=k},
                  ( $dvrexmel->iChemDVRRunOperatorMatrixElements[obj])
                  ]
              },
            1
            ],
        o:{__Rule}:>Merge[o, Replace[{v_}:>v]]
        ],
      (** --------------------------- GRID WAVEFUNCTIONS -------------------------- **)
      $dvrgrwf,
        iChemDVRRunGridWavefunctions[obj],
      (** ---------------------- INTERPOLATING WAVEFUNCTIONS --------------------- **)
      $dvrintwf,
        iChemDVRRunInterpolatingWavefunctions[obj],
      (** --------------------------- EXPECTATION VALUES -------------------------- **)
      {$dvrexv, __},
        iChemDVRRunExpectationValues[obj],
      (** ---------------------------- OPERATOR MATRIX ---------------------------- **)
      {$dvrexm, __},
        iChemDVRRunOperatorMatrix[obj],
      (** ------------------------ OPERATOR MATRIX ELEMENTS ---------------------- **)
      { $dvrexmel, __},
        iChemDVRRunOperatorMatrixElements[obj],
      (** ------------------------------- FULL RESULTS ----------------------------- **)
      "FullResults",
        If[ListQ@RunWavefunctions,
          <|
            $dvrgr->
              If[ListQ@RunGrid, 
                RawArray["Real64", RunGrid],
                RunGrid
                ],
            $dvrpe->
              If[ListQ@RunPotentialEnergy, 
                RawArray["Real64", RunPotentialEnergy],
                RunPotentialEnergy
                ],
            $dvrke->
              If[ListQ@RunKineticEnergy, 
                RawArray["Real64", RunKineticEnergy],
                RunKineticEnergy
                ],
            $dvreng->
              If[ListQ@RunWavefunctions, 
                RawArray["Real64", RunWavefunctions[[1]]],
                RunWavefunctions[[1]]
                ],
            $dvrwf->
              If[ListQ@RunWavefunctions, 
                RawArray["Real64", RunWavefunctions[[2]]],
                RunWavefunctions[[2]]
                ]
            |>
          ],
      (** ----------------------------------- PLOT --------------------------------- **)
      _,
        ChemDVRView[obj,
          $dvrwf->
            If[ChemDVRGet[obj, "View"]===ChemDVRDefaultPlot, 
              If[Head[RunWavefunctions]===Hold,
                RunWavefunctions,
                Hold[RunWavefunctions]
                ],
              RunWavefunctions
              ],
          $dvrpe->
            If[ChemDVRGet[obj, "View"]===ChemDVRDefaultPlot, 
              If[Head[RunPotentialEnergy]===Hold,
                RunPotentialEnergy,
                Hold[RunPotentialEnergy]
                ],
              RunPotentialEnergy
              ],
          $dvrgr->RunGrid,
          "TransformationMatrix"->RunTransformation,
          iChemDVRGetRuntimeOptions[$dvrvw]
          ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*ChemDVRRun*)



ChemDVRRun[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  PackageExceptionBlock["DVRRun"]@
  With[{m=If[$Notebooks,dvrOpsLookup[ops,Monitor,False],False]},
    Switch[m,
      Automatic|True,  
        With[{start=Now,clock=Unique@"clock$"},
          Monitor[iChemDVRRun[obj, ops],
            With[{p=
              Replace[
                Position[
                  {$dvrgr,$dvrke,$dvrpe,$dvrwf},
                  RunCheckPoint
                  ],{
                {{i_}}:>i,
                _->-1
                }]},
              Panel@Grid[{
                {"Time Elapsed:",
                  If[p<4,
                    Row@{Dynamic[clock;Round[Now-start,.02]],
                      Invisible@Pane[Animator[Dynamic@clock,{0,1,.1},1],{5,5}]},
                    Now-start
                    ]},
                {"Grid:",If[p<1,"\[EmptySquare]","\[CheckmarkedBox]"]},
                {"Kinetic Energy:",If[p<2,"\[EmptySquare]","\[CheckmarkedBox]"]},
                {"Potential Energy:",If[p<3,"\[EmptySquare]","\[CheckmarkedBox]"]},
                {"Wavefunctions:",If[p<4,"\[EmptySquare]","\[CheckmarkedBox]"]}
                },
                Alignment->Left
                ]
              ]
            ]
          ],
      _Function,
        Monitor[iChemDVRRun[obj, ops], m@RunCheckPoint],
      _,
        iChemDVRRun[obj, ops]
      ]
    ];


(* ::Subsection:: *)
(*OOP Interface*)



(* ::Subsubsection::Closed:: *)
(*Call*)



$dvrBasicKeys=
  $dvrgr|$dvrpe|$dvrke|$dvrwf;
$dvrSimpleKeys=
  $dvrgp|$dvrgrwf|$dvrintwf|
    $dvrham|$dvreng|$dvrpo|
    $dvrexwf|$dvrguwf|"FullResults";
$dvrExVKeys=
  $dvrexv|$dvrexm|$dvrexmel;


ChemDVRObject[uuid_?chemDVRValidQ][a___?OptionQ]:=
  ChemDVRRun[ChemDVRObject[uuid],a];
(obj:_ChemDVRObject?chemDVRValidQ)[k:$dvrBasicKeys, args___?OptionQ]:=
  Replace[ChemDVRRun[obj, Return->k, args],
    c_ChemDVRResultsObject:>c[k]
    ];
(obj:_ChemDVRObject?chemDVRValidQ)[k:$dvrSimpleKeys, args___?OptionQ]:=
  Replace[ChemDVRRun[obj, Return->k, args],
    c_ChemDVRResultsObject:>c[k]
    ];
(obj:_ChemDVRObject?chemDVRValidQ)[
    k:$dvrExVKeys, 
    efuns:Except[_?OptionQ], args___?OptionQ]:=
  ChemDVRRun[obj, Return->{k, efuns}, args];
(obj:_ChemDVRObject?chemDVRValidQ)["Properties"]:=
  Keys@ChemDVRAssociation[obj];
(obj:_ChemDVRObject?chemDVRValidQ)["Association"]:=
  Keys@ChemDVRAssociation[obj];
(obj:_ChemDVRObject?chemDVRValidQ)["Options", thing___]:=
  ChemDVROptions[obj, thing];
(obj:_ChemDVRObject?chemDVRValidQ)[k:Except[_?OptionQ]..]:=
  ChemDVRGet[obj, k];
ChemDVRObject/:
  (obj:_ChemDVRObject?chemDVRValidQ)[[k:Except[_?OptionQ]..]]:=
    ChemDVRGet[obj, k];


(* ::Subsubsection::Closed:: *)
(*Mutate*)



ChemDVRObjMutate//ClearAll;
ChemDVRObjMutate~SetAttributes~HoldAllComplete;
$ChemDVROneArgMutators=
  Set|SetDelayed|TimesBy|DivideBy|AddTo|SubtractFrom|
    PrependTo|AppendTo|AssociateTo|KeyDropFrom;
$ChemDVRBaseNoArgMutators=
  Increment|Decrement;
ChemDVRObject/:(m:Set|SetDelayed)[
  obj_ChemDVRObject?chemDVRValidQ[k:Except[_?OptionQ]..],
  v_]:=
  ChemDVRMutate[obj[k], m, v];
With[{oneArgs=$ChemDVROneArgMutators, noArg=$ChemDVRNoArgMutators},
  ChemDVRObjMutate[
    (m:oneArgs)[
      (obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[k:Except[_?OptionQ]..],
      a_
      ]
    ]:=
    With[{o=obj},
      ChemDVRMutate[o[k], m, a]
      ];
  ChemDVRObjMutate[
    (m:oneArgs)[
      (obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[[k:Except[_?OptionQ]..]],
      a_
      ]
    ]:=
    With[{o=obj},
      ChemDVRMutate[o[[k]], m, a]
      ];
  ChemDVRObjMutate[
    (m:noArg)[
      (obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[k:Except[_?OptionQ]..]
      ]
    ]:=
    With[{o=obj},
      ChemDVRMutate[o[k], m]
      ];
  ChemDVRObjMutate[
    (m:noArg)[
      (obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[[k:Except[_?OptionQ]..]]
      ]
    ]:=
    With[{o=obj},
      ChemDVRMutate[o[[k]], m]
      ];
    ];


Language`SetMutationHandler[ChemDVRObject, ChemDVRObjMutate]


(* ::Subsubsection::Closed:: *)
(*Formatting*)



$dvrimg=
  Pane[
    Import[PackageFilePath["Resources", "Icons", "DVRIcon.png"]], 
    {28,28},
    ImageSizeAction->"ShrinkToFit"
    ];


Format[obj:dvrObjPattern?chemDVRValidQ]:=
  RawBoxes@ReplaceAll[
    With[{a=ChemDVRAssociation[obj]},
      $$$wtf:>
        If[TrueQ[chemDVRValidQ[obj]], obj, ChemDVRObject@a]
      ]
    ]@
    BoxForm`ArrangeSummaryBox[
      "ChemDVRObject",
      $$$wtf,
      Replace[ChemDVRGet[obj,"Icon"], _Missing->$dvrimg],
        {
          BoxForm`MakeSummaryItem[{"Name: ",ChemDVRGet[obj,"Name"]},StandardForm],
          Replace[ChemDVRGet[obj, "Description"],
            {
              s_String?(StringLength[#]>0&):>
                Pane[
                  s,
                  {{Automatic, 250}, Automatic}
                  ],
              _->Nothing
              }
            ]
            },
      Prepend[
        BoxForm`MakeSummaryItem[
          {"UUID: ",ChemDVRGet[obj,"UUID"]},
          StandardForm
          ]
        ]@
      Internal`WithLocalSettings[
        System`Private`NewContextPath@{"System`"},
        Map[
          BoxForm`MakeSummaryItem[{Row@{#,": "},ChemDVRGet[obj,#]},StandardForm]&,{
            "Range",
            "Points",
            $dvrgr,
            $dvrke,
            $dvrpe,
            $dvrwf
          }
          ],
        System`Private`RestoreContextPath[]  
        ],
      StandardForm
      ];
    


End[];



