(* ::Package:: *)

(* Autogenerated Package *)

(* ::Subsection:: *)
(*Management*)



$ChemDVRManager::usage="Manager interface for ChemDVR things";
ChemDVRDirectory::usage="Directory finder";
ChemDVRFile::usage=
  "Simple combination of FileNameJoin and ChemDVRDirectory";
ChemDVRPotentials::usage=
  "Lists all matching files in ChemDVRDirectory[\"PotentialEnergy\"]";
$ChemDVRPotentials::usage="Alias for ChemDVRPotentials[\"*@.@*\"]";


ChemDVRCreate::usage="OOP constructor for a ChemDVR";
ChemDVRAssociation::usage="Returns the base association for the instance";


ChemDVRSave::usage="Saves various ChemDVR components";
ChemDVRClear::usage="Clears saved ChemDVR components";


(* ::Subsection:: *)
(*Usage*)



ChemDVRDimension::usage=
  "Returns the dimension of a ChemDVR object";


(* ::Subsubsection::Closed:: *)
(*Methods*)



ChemDVRGrid::usage=
  "Returns the grid used in ChemDVR calculations";
ChemDVRKineticEnergy::usage=
  "Returns the kinetic energy used in ChemDVR calculations";
ChemDVRPotentialEnergy::usage=
  "Returns the potential energy used in ChemDVR calculations";
ChemDVRGridPotentialEnergy::usage=
    "Returns the potential energy used in ChemDVR calculations on the grid";
ChemDVRPotentialOptimization::usage=
  "Returns potential optimized DVR parameters";
ChemDVRGuessWavefunctions::usage=
  "Returns guess wavefunctions from uncoupled representation";
ChemDVRWavefunctions::usage=
  "Returns the wavefunctions computed in ChemDVR calculations";
ChemDVRGridWavefunctions::usage=
  "Returns the wavefunction imposed on the grid";
ChemDVRInterpolatingWavefunctions::usage=
  "Returns the wavefunctions interpolating over a grid";
ChemDVRExpectationValues::usage=
  "Returns the expectation values of a set of functions";
ChemDVROperatorMatrix::usage=
  "Returns the cross-state expectation matrix of a set of states->function specs";
ChemDVROperatorMatrixElements::usage=
  "Returns specific elements of the expectation matrix for states->function specs";
ChemDVRExtendWavefunctions::usage=
  "Extends the set of wavefunctions based on previous set";
ChemDVRView::usage="Displays the wavefunctions from a ChemDVR run";


(* ::Subsubsection::Closed:: *)
(*Interfaces*)



ChemDVRNotebook::usage=
  "Opens a notebook for playing with a single ChemDVR instance";


Begin["`Private`"];


(* ::Subsection:: *)
(*Management*)



(* ::Subsubsection::Closed:: *)
(*Key Symbols*)



$dvroot="Root";
$dvalt="ExtraDirs";
$dvrinst="Instances";
$dvrke="KineticEnergy";
$dvrpe="PotentialEnergy";
$dvrgp="GridPotentialEnergy";
$dvrpo="PotentialOptimization";
$dvrham="Hamiltonian";
$dvreng="Energies";
$dvrwf="Wavefunctions";
$dvrguwf="GuessWavefunctions";
$dvrexwf="ExtendWavefunctions";
$dvrgr="Grid";
$dvrgrwf="GridWavefunctions";
$dvrintwf="InterpolatingWavefunctions";
$dvrexv="ExpectationValues";
$dvrexm="OperatorMatrix";
$dvrexmel="OperatorMatrixElements";
$dvrfmgr="FormatGrid";
$dvrvw="View";


(* ::Subsubsection::Closed:: *)
(*Manager*)



If[!MatchQ[$ChemDVRManager,_Association],
  $ChemDVRManager=
    <|
      "Directories"->
        <|
          $dvroot->ChemExtensionDir["DVR"],
          $dvalt->
            Map[
              FileNameJoin[{#, "DVR"}]&,
              {$ChemExtensionsApp, $ChemExtensionsDev}
              ],
          "Classes"->"Classes",
          $dvrinst->$dvrinst,
          $dvrpe->$dvrpe,
          $dvrke->$dvrke,
          $dvrwf->$dvrwf
          |>,
      "Objects"->
        <|
          |>,
      "Settings"->
        <|
          "Load"<>$dvrke->False,
          "Save"<>$dvrke->False,
          "Load"<>$dvrpe->False,
          "Save"<>$dvrpe->False,
          "Load"<>$dvrwf->False,
          "Save"<>$dvrwf->False
          |>
      |>
  ];


(* ::Subsubsection::Closed:: *)
(*Directory*)



$ChemDVRRoot:=
  $ChemDVRManager["Directories", $dvroot];
$ChemDVRPath:=
  Prepend[
    $ChemDVRManager["Directories", $dvalt],
    $ChemDVRRoot
    ]


Options[ChemDVRDirectory]=
  {
    "Root":>$ChemDVRRoot,
    "Path":>$ChemDVRPath
    };
ChemDVRDirectory[
  dSpec_?(KeyMemberQ[$ChemDVRManager["Directories"],#]&),
  alt:True|False:False,
  ops:OptionsPattern[]
  ]:=
  With[{d=$ChemDVRManager["Directories", dSpec]},
    If[!alt,
      If[Not@DirectoryQ@ExpandFileName@d,
        (
          If[Not@DirectoryQ@#,
            CreateDirectory[#, CreateIntermediateDirectories->True]
            ];
          #
          )&@
            FileNameJoin@{OptionValue["Root"], dSpec},
        d
        ],
      FileNameJoin@{#,dSpec}&/@
        OptionValue["Path"]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*File*)



ChemDVRFile//Clear


Options[ChemDVRFile]=
  Options@ChemDVRDirectory;
ChemDVRFile[
  dSpec_String?(KeyMemberQ[$ChemDVRManager["Directories"],#]&),
  fspec__String,
  o:OptionsPattern[]
  ]:=
  With[
    {
      ops=
        FileNameJoin@{#,fspec}&/@
          ChemDVRDirectory[dSpec, True, o]
      },
    SelectFirst[ops, FileExistsQ, Last@ops]
    ];
ChemDVRFile[
  dSpec_String?(KeyMemberQ[$ChemDVRManager["Directories"],#]&),
  ChemDVRObject[uuid_]
  ]:=
  ChemDVRFile[
    dSpec,
    uuid<>If[MatchQ[dSpec,$dvrke|$dvrpe|$dvrwf],".mx",".m"]
    ]
ChemDVRFile[ChemDVRObject[uuid_]]:=
  ChemDVRFile[$dvrinst,uuid<>".m"];


(* ::Subsubsection::Closed:: *)
(*Potentials*)



ChemDVRPotentials[
  pat:_?StringPattern`StringPatternQ:"*@.@*",
  nameTake:True|False:True
  ]:=
  If[nameTake,Map@FileNameTake,Identity]@
    FileNames[pat,ChemDVRDirectory[$dvrpe]];


(* ::Subsubsection::Closed:: *)
(*Create*)



ChemDVRCreate::norng="No range function provided";
ChemDVRCreate::nogrid="No grid function provided";
ChemDVRCreate::noke="No kinetic energy function provided";
ChemDVRCreate::nope="No potential energy function provided";
ChemDVRCreate::novw="No view function provided";


ChemDVRCreate[a_Association]:=
  Block[{dvrAssoc=a},
    If[KeyMemberQ[a,"Class"],
      ChemDVRClass@a["Class"]];
    If[!KeyMemberQ[dvrAssoc,"UUID"],
      dvrAssoc["UUID"]=CreateUUID["ChemDVR-"]
      ];
    If[!KeyMemberQ[dvrAssoc,"Name"],
      dvrAssoc["Name"]="ChemDVR Instance"
      ];
    Map[
      If[!KeyExistsQ[dvrAssoc, #[[1]]],
        dvrAssoc[#[[1]]]=#[[2]]
        ]&,
      {
        {$dvrgr, ChemDVRDefaultGrid},
        {$dvrke, ChemDVRDefaultKineticEnergy},
        {$dvrpe, ChemDVRDefaultPotentialEnergy},
        {$dvrgp, ChemDVRDefaultGridPotentialEnergy},
        {$dvrpo, ChemDVRDefaultPotentialOptimize},
        {$dvrguwf, ChemDVRDefaultGuessWavefunctions},
        {$dvrwf, ChemDVRDefaultWavefunctions},
        {$dvrexwf, ChemDVRDefaultExtendWavefunctions},
        {$dvrvw, ChemDVRDefaultPlot},
        {$dvrgrwf, ChemDVRDefaultGridWavefunctions},
        {$dvrintwf, ChemDVRDefaultInterpolatingWavefunctions},
        {$dvrexv, ChemDVRDefaultExpectationValues},
        {$dvrexm, ChemDVRDefaultOperatorMatrix},
        {$dvrexmel, ChemDVRDefaultOperatorMatrixElements},
        {$dvrfmgr, ChemDVRDefaultFormatGrid}
        }
      ];
    $ChemDVRManager["Objects",dvrAssoc["UUID"]]=
      dvrAssoc;
    ChemDVRObject[dvrAssoc["UUID"]]
    ];


ChemDVRCreate::nodvr="No ChemDVR found at ``";
ChemDVRCreate[dvr_String?FileExistsQ]:=
  With[{a=Get@dvr},
    If[AssociationQ@a,
      ChemDVRCreate@a,
      Message[ChemDVRCreate::nodvr,dvr];
      $Failed
      ]
    ];
ChemDVRCreate[dvr_String?(Not@*FileExistsQ)]:=
  With[{f=ChemDVRFile[$dvrinst,StringTrim[dvr,".m"]<>".m"]},  
    If[FileExistsQ@f,
      ChemDVRCreate@f,
      Message[ChemDVRCreate::nodvr,f]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*Save*)



ChemDVRSave//Clear


Options[ChemDVRSave]=
  Options@ChemDVRFile;
ChemDVRSave[
  $dvrinst,
  name_String,
  a_Association,
  o:OptionsPattern[]
  ]:=
  Block[{$ContextPath={"System`"}},
    Export[ChemDVRFile[$dvrinst, name, o],a]
    ];
ChemDVRSave[
  prop:$dvrke|$dvrpe|$dvrwf, 
  name_String, 
  mx_List?MatrixQ,
  o:OptionsPattern[]
  ]:=
  Export[  
    ChemDVRFile[prop, name, o],
    mx
    ];


ChemDVRSave[
  Optional[$dvrinst,$dvrinst],
  ChemDVRObject[uuid_],
  o:OptionsPattern[]
  ]:=
  ChemDVRSave[
    $dvrinst,
    uuid<>".m",
    $ChemDVRManager["Objects",uuid],
    o
    ];
ChemDVRSave[
  prop:$dvrke|$dvrpe|$dvrwf, 
  ChemDVRObject[uuid_],
  mx_List?MatrixQ,
  o:OptionsPattern[]
  ]:=
  ChemDVRSave[
    prop,
    uuid<>".mx",
    mx,
    o
    ];


(* ::Subsubsection::Closed:: *)
(*Clear*)



Options[ChemDVRClear]=
  Options@ChemDVRFile;
ChemDVRClear[prop:$dvrinst|$dvrke|$dvrpe|$dvrwf, name_String,
  ops:OptionsPattern[]
  ]:=
  Quiet@DeleteFile@ChemDVRFile[prop,name, ops];


ChemDVRClear[
  prop:$dvrinst|$dvrke|$dvrpe|$dvrwf,$dvrinst,
  ChemDVRObject[uuid_],
  ops:OptionsPattern[]
  ]:=
  ChemDVRClear[prop,
    uuid<>".m",
    ops
    ];


(* ::Subsection:: *)
(*Helper Methods*)



(* ::Subsubsection::Closed:: *)
(*Helpers*)



chemDVRValidQ[uuid_String]:=
  KeyMemberQ[$ChemDVRManager["Objects"],uuid];
chemDVRValidQ[ChemDVRObject[uuid_]]:=
  chemDVRValidQ[uuid];
chemDVRValidQ[___]:=False;
dvrObjPattern=ChemDVRObject[uuid_?chemDVRValidQ]


dvrOpsLookup[ops___,key_,default_]:=
  Lookup[
    Flatten@Replace[{ops}, a_Association?AssociationQ:>Normal[a], 1],
    key,
    default
    ];
dvrOpsLookup~SetAttributes~HoldAll;


(* ::Subsubsection::Closed:: *)
(*Reloading*)



ChemDVRObject//Clear


ChemDVRObject[a_Association]:=
  ChemDVRCreate[a];
ChemDVRObject[uuid_String?(
  Not@KeyMemberQ[$ChemDVRManager["Objects"],#]&&
    FileExistsQ@ChemDVRFile[$dvrinst, #<>".m"]
  &)]:=
  ChemDVRCreate[uuid];
ChemDVRObject[
  s_String?(
    Quiet@MatchQ[ChemDVRClass[#], ChemDVRClass[_Association?AssociationQ]]&
    ), 
  o___?OptionQ
  ]:=
  ChemDVRClass[s][o];


(* ::Subsubsection::Closed:: *)
(*Association*)



ChemDVRAssociation[obj:dvrObjPattern]:=
  $ChemDVRManager["Objects",First@obj];


(* ::Subsubsection::Closed:: *)
(*Get*)



ChemDVRGet[obj:dvrObjPattern,attribute_]:=
  Lookup[$ChemDVRManager["Objects",First@obj],attribute];
ChemDVRGet[obj:dvrObjPattern,attribute_,default_]:=
  Lookup[$ChemDVRManager["Objects",First@obj],attribute,default];


ChemDVRGet[obj:ChemDVRClass[a_Association],attribute_]:=
  Lookup[a,attribute];
ChemDVRGet[obj:ChemDVRClass[a_Association],attribute_,default_]:=
  Lookup[a,attribute,default];


PackageAddAutocompletions[
  ChemDVRGet,
  {
    None,
    {
      $dvrgr,
      $dvrke,$dvrpe,
      $dvrwf,$dvrgrwf,
      $dvrintwf,$dvrexv,
      $dvrexm,$dvrvw
      }
    }
  ]


(* ::Subsubsection::Closed:: *)
(*Mutate*)



ChemDVRMutate//ClearAll
ChemDVRMutate~SetAttributes~HoldAll;
With[{obPat=dvrObjPattern},
  ChemDVRMutate[(obj:obPat)[at___], fn_, args___]:=
    With[{k=First@obj},
      fn[
        $ChemDVRManager["Objects", k, at],
        args
        ]
      ];
  ChemDVRMutate[(obj:obPat)[[at___]], fn_, args___]:=
    With[{k=First@obj},
      fn[
        $ChemDVRManager[["Objects", k, at]],
        args
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*Set*)



ChemDVRSet//Clear


ChemDVRSet[obj:dvrObjPattern, attribute__, value_]:=
  ChemDVRMutate[
    obj[attribute],
    Set,
    value
    ]


(* ::Subsubsection::Closed:: *)
(*Options*)



ChemDVROptions[obj:dvrObjPattern, method_String]:=
  Options@ChemDVRGet[obj, method];
ChemDVROptions[obj:dvrObjPattern, methods:{__String}]:=
  AssociationMap[ChemDVROptions[obj,#]&, methods];
ChemDVROptions[obj:dvrObjPattern, Optional[All, All]]:=
  ChemDVROptions[obj, 
    {$dvrgr, $dvrke, "PotentialEnergy", $dvrwf, "View"}
    ]


PackageAddAutocompletions[
  ChemDVROptions,
  {
    None,
    {
      $dvrgr,
      $dvrke, $dvrpe, $dvrwf,
      $dvrvw
      }
    }
  ]


(* ::Subsection:: *)
(*Run Methods*)



(* ::Subsubsection::Closed:: *)
(*Dimension*)



ChemDVRDimension[obj:dvrObjPattern]:=
  Length@ChemDVRGet[obj,"Range"];


(* ::Subsubsection::Closed:: *)
(*Grid*)



ChemDVRGrid[obj:dvrObjPattern, ops:OptionsPattern[]]:=
  Block[
    {
      RunRange=None,
      RunPoints=None
      },
    RunRange=
      Replace[dvrOpsLookup[ops, "Range", None],
        l:{Repeated[_?NumericQ|_DirectedInfinity, {2}]}:>{l}
        ];
    If[MatchQ[RunRange,{{Repeated[_?NumericQ|_DirectedInfinity, {2}]}..}],
      ChemDVRSet[obj, "Range", RunRange]
      ];
    RunRange=ChemDVRGet[obj, "Range"];
    If[!MatchQ[RunRange, {{Repeated[_?NumericQ|_DirectedInfinity, {2}]}..}],
      PackageRaiseException[
        "DVRRun",
        "\"Range\" `` isn't a valid DVR domain specification",
        "MessageParameters"->{RunRange}
        ]
      ];
    RunPoints=
      Replace[dvrOpsLookup[ops, "Points", None],
        l:_?IntegerQ:>{l}
        ];
    If[MatchQ[RunPoints, {__?IntegerQ}],
      ChemDVRSet[obj, "Points", RunPoints]
      ];
    RunPoints=ChemDVRGet[obj, "Points"];
    If[!MatchQ[RunPoints, {__?IntegerQ}],
      PackageRaiseException[
        "DVRRun",
        "\"Points\" `` isn't valid DVR division specification",
        "MessageParameters"->{RunPoints}
        ]
      ];
    ChemDVRGet[obj, $dvrfmgr,(#&)][
      ChemDVRGet[obj,$dvrgr][
        RunPoints,
        RunRange,
        Sequence@@FilterRules[{ops},Options@ChemDVRGet[obj,$dvrgr]]
        ],
      RunPoints
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*KineticEnergy*)



dvrCalcKE[obj_,ops___]:=
  With[{g=dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]]},
    ChemDVRGet[obj,$dvrke][g,Sequence@@FilterRules[{ops},Options@ChemDVRGet[obj,$dvrke]]]
    ]


ChemDVRKineticEnergy[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{dvrke=ChemDVRGet[obj,$dvrke]},
    If[StringQ@dvrke,
      If[FileExistsQ@dvrke,Import@dvrke,Import@ChemDVRFile[$dvrke,dvrke]],
      With[{tryLoad=
        TrueQ@dvrOpsLookup[ops,"Load"<>$dvrke,
            dvrOpsLookup[ops,"Load",
              $ChemDVRManager["Settings","Load"<>$dvrke]]
            ]},
        If[tryLoad,
          If[FileExistsQ@ChemDVRFile[$dvrke,obj],
            Import@ChemDVRFile[$dvrke,obj],
            ChemDVRKineticEnergy[obj,
              "Load"<>$dvrke->False,
              "Load"->False,
              ops
              ]
            ],
          With[{ke=dvrCalcKE[obj,ops]},
            If[MatrixQ[ke],
              If[TrueQ@dvrOpsLookup[ops,"Save"<>$dvrke,
                  dvrOpsLookup[ops,"Save",
                    $ChemDVRManager["Settings","Save"<>$dvrke]]
                  ],
                ChemDVRSave[$dvrke,obj,ke]
                ]
              ];
            ke
            ]
          ]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*PotentialEnergy*)



(* ::Subsubsubsection::Closed:: *)
(*dvrCalcPE*)



dvrCalcPE[obj_,ops___]:=
  With[{g=dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]]},
    ChemDVRGet[obj,$dvrpe][g,
      Sequence@@FilterRules[{ops},Options@ChemDVRGet[obj,$dvrpe]]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*dvrLoadPotential*)



dvrLoadPotential[obj_,file_,ops___]:=
  DiagonalMatrix@
    Flatten[
      dvrImportAlignPotential[
        obj,
        With[{
          gBase=dvrOpsLookup[ops, $dvrgr,ChemDVRGrid[obj,ops]],
          dim=ChemDVRDimension[obj]
          },
          If[Dimensions[gBase[[1]]][[dim]]=!=dim,
            SelectFirst[
              gBase,
              With[{d2=Dimensions[#[[1]]]},
                Length[d2]>=dim&&d2[[dim]]===dim
                ]&,
              Throw[$Failed]
              ],
            gBase
            ]
          ],
        file,
        FilterRules[{ops},Options@dvrImportAlignPotential]
        ]
      ]


(* ::Subsubsubsection::Closed:: *)
(*Main*)



ChemDVRPotentialEnergy[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{dvrpe=dvrOpsLookup[ops,$dvrpe,ChemDVRGet[obj,$dvrpe]]},
    If[StringQ@dvrpe,
      If[FileExistsQ@dvrpe,
        dvrLoadPotential[obj,dvrpe,ops],
        dvrLoadPotential[obj,ChemDVRFile[$dvrpe, dvrpe],ops]
        ],
      With[{tryLoad=
        TrueQ@dvrOpsLookup[ops,"Load"<>$dvrpe,
            dvrOpsLookup[ops,"Load",
              $ChemDVRManager["Settings","Load"<>$dvrpe]]
            ]},
        If[tryLoad,
          If[FileExistsQ@ChemDVRFile[$dvrpe,obj],
            dvrLoadPotential[obj,ChemDVRFile[$dvrpe,obj],ops],
            ChemDVRPotentialEnergy[obj,
              "Load"<>$dvrpe->False,
              "Load"->False,
              ops]
            ],
          With[{pe=dvrCalcPE[obj,ops]},
            If[MatrixQ[pe],
              If[TrueQ@dvrOpsLookup[ops,"Save"<>$dvrpe,
                  dvrOpsLookup[ops,"Save",
                    $ChemDVRManager["Settings","Save"<>$dvrpe]]
                  ],
                ChemDVRSave[$dvrpe,obj,pe]
                ]
              ];
            pe
            ]
          ]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*PotentialOptimization*)



ChemDVRPotentialOptimization//Clear


ChemDVRPotentialOptimization[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      po=
        ChemDVRGet[obj,  $dvrpo]
      },
    po[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj, ops]],
      FilterRules[{ops}, Options@po]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*GuessWavefunctions*)



ChemDVRGuessWavefunctions//Clear


ChemDVRGuessWavefunctions[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      wf=
        ChemDVRGet[obj,  $dvrguwf]
      },
    wf[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj, ops]],
      FilterRules[{ops}, Options@wf]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*GridPotentialEnergy*)



ChemDVRGridPotentialEnergy[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[{gp=ChemDVRGet[obj, $dvrgp]},
    gp[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj, ops]
        ],
      FilterRules[{ops},
        Options@gp
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Wavefunctions*)



dvrCalcWFs[obj_,ops___]:=
  With[{
    ke=
      dvrOpsLookup[ops,
        $dvrke,
        ChemDVRKineticEnergy[obj,ops]
        ],
    pe=
      dvrOpsLookup[ops,
        "PotentialEnergy",
        ChemDVRPotentialEnergy[obj,ops]
        ],
    wf=ChemDVRGet[obj,$dvrwf]
    },
    wf[
      ke,
      pe,
      Sequence@@
        FilterRules[{ops},
          Options@wf]
          ]
    ];


ChemDVRWavefunctions[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{tryLoad=
    TrueQ@dvrOpsLookup[ops,"Load"<>$dvrwf,
      dvrOpsLookup[ops,"Load",
        $ChemDVRManager["Settings","Load"<>$dvrwf]]
      ]},
    If[tryLoad,
      If[FileExistsQ@ChemDVRFile[$dvrwf,obj],
        Import@ChemDVRFile[$dvrwf,obj],
        ChemDVRWavefunctions[obj,
          "Load"<>$dvrwf->False,
          "Load"->False,
          ops
          ]
        ],
      With[{wf=dvrCalcWFs[obj,ops]},
        If[Length@wf==2&&MatrixQ[Last@wf,NumericQ],
          If[TrueQ@dvrOpsLookup[ops,"Save"<>$dvrwf,
              dvrOpsLookup[ops,"Save",
                $ChemDVRManager["Settings","Save"<>$dvrwf]]
              ],
            ChemDVRSave[$dvrwf,obj,wf]
            ]
          ];
        wf
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*GridWavefunctions*)



ChemDVRGridWavefunctions[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{gridwf=ChemDVRGet[obj,$dvrgrwf]},
    gridwf[
      dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@gridwf
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*InterpolatingWavefunctions*)



ChemDVRInterpolatingWavefunctions[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{interpf=ChemDVRGet[obj, $dvrintwf]},
    interpf[
      dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@interpf
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*ExpectationValues*)



ChemDVRExpectationValues[
  obj:dvrObjPattern, 
  efuns:Except[_?OptionQ], 
  ops:OptionsPattern[]
  ]:=
  With[{exFun=ChemDVRGet[obj, $dvrexv]},
    exFun[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      efuns,
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*OperatorMatrix*)



ChemDVROperatorMatrix[
  obj:dvrObjPattern, 
  efuns:Except[_?OptionQ], 
  ops:OptionsPattern[]
  ]:=
  With[{exFun=ChemDVRGet[obj, $dvrexm]},
    exFun[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      efuns,
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*OperatorMatrixElements*)



ChemDVROperatorMatrixElements//Clear


ChemDVROperatorMatrixElements[
  obj:dvrObjPattern, 
  efuns:
    (({_, _}->_)|
    ({{_, _}...}->_)|
    {(({{_, _}...}|{_, _})->_)..}), 
  ops:OptionsPattern[]
  ]:=
  With[{exFun=ChemDVRGet[obj,  $dvrexmel]},
    exFun[
      dvrOpsLookup[ops, $dvrgr, ChemDVRGrid[obj,ops]],
      dvrOpsLookup[ops,
        $dvrwf,
        ChemDVRWavefunctions[obj,ops]
        ],
      efuns,
      dvrOpsLookup[ops,
        $dvrpe,
        ChemDVRPotentialEnergy[obj,ops]
        ],
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*ExtendWavefunctions*)



ChemDVRExtendWavefunctions//Clear


ChemDVRExtendWavefunctions[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      exFun=
        ChemDVRGet[obj,  $dvrexwf],
      wf=
        dvrOpsLookup[ops, $dvrwf, None]
      },
    If[
      !MatchQ[wf, 
        _Hold|{_List?(VectorQ[#, Internal`RealValuedNumberQ]&), _List?MatrixQ}
        ],
      PackageRaiseException[
        Automatic,
        "\"ExtendWavefunctions\" requires an initial set of wavefunctions"
        ]
      ];
    exFun[
      dvrOpsLookup[ops, $dvrke, ChemDVRKineticEnergy[obj,ops]],
      dvrOpsLookup[ops, $dvrpe, ChemDVRPotentialEnergy[obj,ops]],
      wf,
      FilterRules[{ops},
        Options@exFun
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*View*)



ChemDVRView[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  With[{g=
    dvrOpsLookup[ops,$dvrgr,ChemDVRGrid[obj,ops]]},
    With[{pe=
      dvrOpsLookup[ops,"PotentialEnergy",
        ChemDVRPotentialEnergy[obj,$dvrgr->g,ops]]},
      With[{wfs=
        dvrOpsLookup[ops,
          $dvrwf,
          ChemDVRWavefunctions[obj,
            $dvrgr->g,
            "PotentialEnergy"->pe,
            ops
            ]
          ]},
          ChemDVRGet[obj,"View"][wfs,g,pe,
            {ops}
            ]
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Notebook*)



ChemDVRNotebook//Clear


Options[ChemDVRNotebook]=
  Join[
    {
      "SaveObject"->True
      },
    Options@Notebook
    ];
ChemDVRNotebook[
  obj:dvrObjPattern,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      so=OptionValue["SaveObject"]
      },
    If[so,
      ChemDVRSave@obj
      ];
    CreateDocument@
      Notebook[
        First@
          Get[PackageFilePath["Resources", "Templates", "DVRNotebook.nb"]],
        FilterRules[
          {
            ops,
            WindowTitle->ChemDVRGet[obj,"UUID"]
            },
          Options@Notebook
          ]
        ]
    ]


(* ::Subsection:: *)
(*Run*)



(* ::Subsubsection::Closed:: *)
(*iChemDVRGetRuntimeOptions*)



iChemDVRGetRuntimeOptions[keys__String]:=
(*If[{keys}==={"View"}, Apply[Sequence]@*Echo@*List, ##&]@*)
  With[
    {
      baseOpts={RunRuntimeOptions}
      },
    With[
      {
        passedOpts=
          dvrOpsLookup[
            baseOpts, 
            "PassedOptions",
            {}
            ]
        },
      Normal@
        Merge[
          {
            Fold[
              KeyDrop[
                Merge[
                  {
                    dvrOpsLookup[
                      {#}, 
                      #2<>"Options",
                      {}
                      ],
                    #
                    },
                  First
                  ],
                #2<>"Options"
                ]&,
              passedOpts,
              Reverse@{keys}
              ],
            Fold[
              KeyDrop[
                Merge[
                  {
                    dvrOpsLookup[
                      {#}, 
                      #2<>"Options",
                      {}
                      ],
                    #
                    },
                  First
                  ],
                #2<>"Options"
                ]&,
              baseOpts,
              Reverse@{keys}
              ]
          },
        First
        ]
      ]
    ]//Apply[Sequence];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunCalculateKEQ*)



iChemDVRRunCalculateKEQ[]:=
  !(
    MatchQ[RunEndPoint, $dvrpe]||
      (
        MatchQ[RunEndPoint, 
          $dvrwf|$dvrgrwf|$dvrintwf|$dvrev|$dvrexm|$dvrexmel|$dvrvw
          ]&&
          MatchQ[
            If[RunWavefunctions===None,
              RunWavefunctions=
                dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions],
              RunWavefunctions
              ],
            _List|_Hold
            ]
        )
      )


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunKineticEnergy*)



iChemDVRRunKineticEnergy[obj_]:=
  Switch[
    RunKineticEnergy=
      dvrOpsLookup[RunRuntimeOptions, $dvrke, RunKineticEnergy],
    None,
      ChemDVRKineticEnergy[
        obj,
        $dvrgr->RunGrid,
        "TransformationMatrix"->RunTransforms,
        iChemDVRGetRuntimeOptions[$dvrke]
        ],
    _?SquareMatrixQ|Hold[_?SquareMatrixQ],
      RunKineticEnergy,
    {__?SquareMatrixQ},
      ChemDVRKroeneckerProductKineticEnergy@RunKineticEnergy,
    Hold[_?(MatchQ[{__?SquareMatrixQ}])],
      Hold[Evaluate@ChemDVRKroeneckerProductKineticEnergy@RunKineticEnergy],
    True,
      PackageRaiseException[
        Automatic,
        "Kinetic energy isn't in valid format"
        ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunCalculatePEQ*)



iChemDVRRunCalculatePEQ[]:=
  !(
    MatchQ[RunEndPoint, 
      $dvrwf|$dvrgrwf|$dvrintwf|$dvrev|$dvrexm| $dvrexmel
      ]&&
    MatchQ[
      If[RunWavefunctions===None,
        RunWavefunctions=
          dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions],
        RunWavefunctions
        ],
      _List|_Hold
      ]
    )


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunPotentialEnergy*)



iChemDVRRunPotentialEnergy[obj_]:=
  Switch[
    RunPotentialEnergy=
      dvrOpsLookup[RunRuntimeOptions, $dvrpe, RunPotentialEnergy],
    None,
      ChemDVRPotentialEnergy[
        obj,
        $dvrgr->RunGrid,
        "TransformationMatrix"->RunTransformation,
        iChemDVRGetRuntimeOptions[$dvrpe]
        ],
    _?SquareMatrixQ|Hold[_?SquareMatrixQ],
      RunPotentialEnergy,
    {__?SquareMatrixQ},
        ChemDVRDefaultDirectProductPotentialEnergy@RunPotentialEnergy,
    Hold[_?(MatchQ[{__?SquareMatrixQ}])],
      Hold[
        Evaluate@
          ChemDVRDefaultDirectProductPotentialEnergy@
            RunPotentialEnergy
        ],
    True,
      PackageRaiseException[
        Automatic,
        "Potential energy isn't in valid format"
        ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunHamiltonian*)



iChemDVRRunHamiltonian[obj_]:=
  ChemDVRDefaultPrepareHamiltonian[
    Hold@RunKineticEnergy, 
    Hold@RunPotentialEnergy, 
    FilterRules[
      {iChemDVRGetRuntimeOptions[$dvrwf]}, 
      Options[ChemDVRDefaultPrepareHamiltonian]
      ]
    ][[1]];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunCalculateWFQ*)



iChemDVRRunCalculateWFQ[]:=
  Length@
    Complement[
      Flatten@{RunEndPoint}, 
      {$dvrham, $dvrke, $dvrpe, $dvrgr}
      ]>0;


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGridPotentialEnergy*)



iChemDVRRunGridPotentialEnergy[obj_]:=
  ChemDVRGridPotentialEnergy[obj,
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, "GridPotentialEnergy"]===ChemDVRDefaultGridPotentialEnergy, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrgp, $dvrpe]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGridKineticEnergy*)



iChemDVRRunGridKineticEnergy[obj_]:=
  ChemDVRGridPotentialEnergy[obj,
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, "GridPotentialEnergy"]===ChemDVRDefaultGridPotentialEnergy, 
        If[Head[RunKineticEnergy]===Hold,
          RunKineticEnergy,
          Hold[RunKineticEnergy]
          ],
        RunKineticEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrgp, $dvrpe]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunPOQ*)



iChemDVRRunPOQ[]:=
  RunEndPoint===$dvrpo||
    (
      RunWavefunctions===None&&
        Replace[
          dvrOpsLookup[RunRuntimeOptions, "PotentialOptimize", Automatic],
          {
            Automatic:>
              Length@
                dvrOpsLookup[RunRuntimeOptions, 
                  "PotentialOptimizationOptions", None]>0,
            Except[True|False]->False
            }
          ]
      )


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunPotentialOptimization*)



iChemDVRRunPotentialOptimization[obj_]:=
  Module[{po, gr, ke},
    po=
      ChemDVRPotentialOptimization[
        obj,
        $dvrgr->
          RunGrid,
        FilterRules[
          {
            "OptimizedComponents"->{
              $dvrgr, 
              $dvrke
              },
            iChemDVRGetRuntimeOptions[
              $dvrpo,
              $dvrke,
              $dvrpe
              ]
            },
          Options@ChemDVRDefaultPotentialOptimize
          ]
        ];
    gr=
      With[{l=po[$dvrgr]},
        If[Length@l>1,
          ChemDVRDirectProductGrid@l,
          l[[1]]
          ]
        ];
    ke=
      If[RunEndPoint=!=$dvrgr,
        With[{l=po[$dvrke]},
          If[Length@l>1,
            ChemDVRKroeneckerProductKineticEnergy@l,
            l[[1]]
            ]
          ],
        None
        ];
    {po, gr, ke}
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGWQ*)



iChemDVRRunGWQ[]:=
  RunEndPoint===$dvrguwf||
    Replace[
      dvrOpsLookup[RunRuntimeOptions, "UseGuessWavefunctions", False],
      {
        Automatic:>
          Length@
            dvrOpsLookup[
              RunRuntimeOptions, 
              "GuessWavefunctionsOptions", 
              None
              ]>0,
        Except[True|False]->False
        }
      ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGuessWavefunctions*)



iChemDVRRunGuessWavefunctions[obj_]:=
  ChemDVRGuessWavefunctions[
    obj,
    $dvrgr->
      RunGrid,
    Switch[RunEndPoint,
      $dvreng,
        "GuessWavefunctionsComponents"->
          {
            "Energies"
            },
      $dvrwf|$dvrgrwf|$dvrintwf,
        "GuessWavefunctionsComponents"->
          {
            "Grid",
            "Wavefunctions"
            },
      $dvrguwf,
        Sequence@@{},
      _,
        "GuessWavefunctionsComponents"->
          {
            "Grid",
            "Wavefunctions",
            "KineticEnergy",
            "PotentialEnergy"
            }
      ],
    iChemDVRGetRuntimeOptions[
      $dvrguwf,
      $dvrke,
      $dvrpe
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunWavefunctions*)



iChemDVRRunWavefunctions[obj_]:=
  ChemDVRWavefunctions[obj,
    $dvrke->
      If[ChemDVRGet[obj, "Wavefunctions"]===ChemDVRDefaultWavefunctions, 
        If[Head[RunKineticEnergy]===Hold,
          RunKineticEnergy,
          Hold[RunKineticEnergy]
          ],
        RunKineticEnergy
        ],
    $dvrpe->
      If[ChemDVRGet[obj, "Wavefunctions"]===ChemDVRDefaultWavefunctions, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrwf]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunExtendWavefunctions*)



iChemDVRRunExtendWavefunctions[obj_]:=
  ChemDVRExtendWavefunctions[obj,
    $dvrke->
      If[ChemDVRGet[obj,  $dvrexwf]===ChemDVRDefaultExtendWavefunctions, 
        If[Head[RunKineticEnergy]===Hold,
          RunKineticEnergy,
          Hold[RunKineticEnergy]
          ],
        RunKineticEnergy
        ],
    $dvrpe->
      If[ChemDVRGet[obj,  $dvrexwf]===ChemDVRDefaultExtendWavefunctions, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    $dvrwf->
      If[ChemDVRGet[obj,  $dvrexwf]===ChemDVRDefaultExtendWavefunctions, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    iChemDVRGetRuntimeOptions[ $dvrexwf]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunEnergies*)



iChemDVRRunEnergies[obj_]:=
  If[!ListQ[RunEnergies],
    If[
      MatchQ[RunWavefunctions, 
        {_List?(VectorQ[#, Internal`RealValuedNumericQ]&), _}
        ],
      RunWavefunctions[[1]],
      ChemDVRWavefunctions[obj,
        $dvrke->
          If[ChemDVRGet[obj, "Wavefunctions"]===ChemDVRDefaultWavefunctions, 
            If[Head[RunKineticEnergy]===Hold,
              RunKineticEnergy,
              Hold[RunKineticEnergy]
              ],
            RunKineticEnergy
            ],
        $dvrpe->
          If[ChemDVRGet[obj, "Wavefunctions"]===ChemDVRDefaultWavefunctions, 
            If[Head[RunPotentialEnergy]===Hold,
              RunPotentialEnergy,
              Hold[RunPotentialEnergy]
              ],
            RunPotentialEnergy
            ],
        "WavefunctionEigensolver"->Eigenvalues,
        iChemDVRGetRuntimeOptions[$dvrwf]
        ]
      ],
    RunEnergies
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunGridWavefunctions*)



iChemDVRRunGridWavefunctions[obj_]:=
  ChemDVRGridWavefunctions[obj,
    $dvrwf->
      If[ChemDVRGet[obj, $dvrgrwf]===ChemDVRDefaultGridWavefunctions, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, $dvrgrwf]===ChemDVRDefaultGridWavefunctions, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrgrwf, $dvrwf]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunInterpolatingWavefunctions*)



iChemDVRRunInterpolatingWavefunctions[obj_]:=
  ChemDVRInterpolatingWavefunctions[obj,
    $dvrwf->
      If[ChemDVRGet[obj, $dvrintwf]===ChemDVRDefaultInterpolatingWavefunctions, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, $dvrintwf]===ChemDVRDefaultInterpolatingWavefunctions, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrintwf]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunExpectationValues*)



iChemDVRRunExpectationValues[obj_]:=
  ChemDVRExpectationValues[obj,
    Replace[
      Rest@RunEndPoint,
      {
        {f:Except[_List]}:>f,
        e_:>Flatten[e]
        }
      ],
    $dvrwf->
      If[ChemDVRGet[obj, $dvrev]===ChemDVRDefaultExpectationValues, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, $dvrev]===ChemDVRDefaultExpectationValues, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[$dvrexv]
    ];


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunOperatorMatrix*)



iChemDVRRunOperatorMatrix[obj_]:=
  ChemDVROperatorMatrix[obj,
    Replace[
      Rest@RunEndPoint,
      {
        {f:Except[_List]}:>f,
        e_:>Flatten[e]
        }
      ],
    $dvrwf->
      If[ChemDVRGet[obj, $dvrexm]===ChemDVRDefaultOperatorMatrix, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj, $dvrexm]===ChemDVRDefaultOperatorMatrix, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[
       $dvrexm,
       $dvrexv
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRunOperatorMatrixElements*)



iChemDVRRunOperatorMatrixElements[obj_]:=
  ChemDVROperatorMatrixElements[obj,
    Replace[
      Rest@RunEndPoint,
      {
        {f:Except[_List]}:>f,
        e_:>Flatten[e]
        }
      ],
    $dvrwf->
      If[ChemDVRGet[obj,  $dvrexmel]===
          ChemDVRDefaultOperatorMatrixElements, 
        If[Head[RunWavefunctions]===Hold,
          RunWavefunctions,
          Hold[RunWavefunctions]
          ],
        RunWavefunctions
        ],
    $dvrgr->RunGrid,
    $dvrpe->
      If[ChemDVRGet[obj,  $dvrexmel]===
          ChemDVRDefaultOperatorMatrixElements, 
        If[Head[RunPotentialEnergy]===Hold,
          RunPotentialEnergy,
          Hold[RunPotentialEnergy]
          ],
        RunPotentialEnergy
        ],
    iChemDVRGetRuntimeOptions[
       $dvrexmel,
       $dvrexm,
       $dvrexv
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*iChemDVRRun*)



iChemDVRRun[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  Block[{
    RunObject=obj,
    RunRuntimeOptions=
      Sequence@@
        Normal@
          Merge[
            {
              "PassedOptions"->{ops},
              ChemDVRGet[obj, "RuntimeOptions", {}],
              ChemDVRGet[obj, "Defaults", {}],
              ops
              },
            First
            ],
    RunCheckPoint=None,
    RunEndPoint,
    RunGrid=None,
    RunTransforms=None,
    RunKineticEnergy=None,
    RunPotentialEnergy=None,
    RunEnergies=None,
    RunWavefunctions=None,
    RunPotentialOptimize=Automatic,
    RunGuessWavefunctions=Automatic,
    RunUseGuessWavefunctions=False
    },
    If[!OptionQ[{RunRuntimeOptions}],
      PackageRaiseException[
        Automatic,
        "Options `` aren't valid for ChemDVRRun (OptionQ failed)",
        {RunRuntimeOptions}
        ]
      ];
    RunEndPoint=
      dvrOpsLookup[RunRuntimeOptions, Return, "View"];
    If[dvrOpsLookup[RunRuntimeOptions, "Save", False],
      ChemDVRSave@obj
      ];
    (** --------------------------------- DEFAULTS --------------------------------- **)
    RunGrid=dvrOpsLookup[RunRuntimeOptions, $dvrgr, RunGrid];
    RunWavefunctions=dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions];
    RunKineticEnergy=dvrOpsLookup[RunRuntimeOptions, $dvrke, RunKineticEnergy];
    RunPotentialEnergy=dvrOpsLookup[RunRuntimeOptions, $dvrpe, RunPotentialEnergy];
    (** ----------------------------------- GRID ------------------------------------ **)
    Switch[RunGrid,
      None,
        RunGrid=
          ChemDVRGrid[obj,
            iChemDVRGetRuntimeOptions[$dvrgr]
            ],
      {__?VectorQ},
        RunGrid=
          ChemDVRDirectProductGrid@RunGrid
      ];
    Which[
      VectorQ@RunGrid[[1]]&&(SquareMatrixQ@RunGrid[[2]]||RunGrid[[2]]===None),
        {RunGrid, RunTransforms}=RunGrid,
      MatchQ[RunGrid[[1]], {__List}]&&
        AllTrue[RunGrid[[2]], #===None||SquareMatrixQ@#&],
        {RunGrid, RunTransforms}=RunGrid
      ];
    (** -------------------------------- TRANSFORM -------------------------------- **)
    If[RunEndPoint==="Transform", Return@RunTransforms];
    (** --------------------------- GUESS WAVEFUNCTIONS --------------------------- **)
    If[iChemDVRRunGWQ[],
      RunGuessWavefunctions=iChemDVRRunGuessWavefunctions[obj];
      If[RunEndPoint===$dvrguwf, 
        Return@RunGuessWavefunctions
        ];
      RunUseGuessWavefunctions=
        dvrOpsLookup[RunRuntimeOptions, "UseGuessWavefunctions", False];
      If[RunUseGuessWavefunctions,
        RunEnergies=
          Lookup[RunGuessWavefunctions, "Energies", RunEnergies];
        RunWavefunctions=
          Lookup[RunGuessWavefunctions, "Wavefunctions", RunWavefunctions];
        RunGrid=
          Lookup[RunGuessWavefunctions, "Grid", RunGrid];
        RunPotentialEnergy=
          Lookup[RunGuessWavefunctions, "PotentialEnergy", RunPotentialEnergy];
        RunKineticEnergy=
          Lookup[RunGuessWavefunctions, "KineticEnergy", RunKineticEnergy]
        ]
      ];
    (** --------------------------- POTENTIAL OPTIMIZATION -------------------------- **)
    RunPotentialOptimize=iChemDVRRunPOQ[];
    If[RunPotentialOptimize,
      {
        RunPotentialOptimize,
        RunGrid,
        RunKineticEnergy
        }=iChemDVRRunPotentialOptimization[obj]
      ];
    If[RunEndPoint===$dvrpo, 
      Return@RunPotentialOptimize
      ];
    (** ------------------------------- RETURN GRID -------------------------------- **)
    If[RunEndPoint===$dvrgr, Return@RunGrid];
    RunCheckPoint=$dvrgr;
    If[Complement[Flatten@{RunEndPoint}, {$dvrgr, "Transform"}]=={}, 
      Return@
        Replace[Flatten@{RunEndPoint},
          {$dvrgr:>RunGrid, "Transform":>RunTransform}, 
          1
          ]
      ];
    (** ------------------------------ KINETIC ENERGY ------------------------------- **)
    If[iChemDVRRunCalculateKEQ[],
      RunKineticEnergy=
        iChemDVRRunKineticEnergy[obj];
      ];
    If[RunEndPoint===$dvrke, Return@RunKineticEnergy];
    RunCheckPoint=$dvrke;
    (** ---------------------------- GRID KINETIC ENERGY ---------------------------- **)
    If[RunEndPoint==="GridKineticEnergy", 
      Return@iChemDVRRunGridKineticEnergy[obj]];
    (** ---------------------------- POTENTIAL ENERGY ------------------------------ **)
    If[iChemDVRRunCalculatePEQ[],
      RunPotentialEnergy=
        iChemDVRRunPotentialEnergy[obj]
      ];
    If[RunEndPoint===$dvrpe, Return@RunPotentialEnergy];
    RunCheckPoint=$dvrpe;
    (** -------------------------- GRID POTENTIAL ENERGY --------------------------- **)
    If[RunEndPoint===$dvrgp, 
      Return@iChemDVRRunGridPotentialEnergy[obj]];
    If[RunEndPoint=== $dvrexwf,
      If[RunWavefunctions===None,
        RunWavefunctions=
          dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions]
        ];
      Return@iChemDVRRunExtendWavefunctions[obj]
      ];
    (** ------------------------------- HAMILTONIAN -------------------------------- **)
    If[RunEndPoint===$dvrham, 
      Return[iChemDVRRunHamiltonian[obj]]
      ];
    (** -------------------------------- ENERGIES ---------------------------------- **)
    If[RunEndPoint===$dvreng, 
      If[RunWavefunctions===None,
        RunWavefunctions=
          dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions]
        ];
      Return@iChemDVRRunEnergies[obj]
      ];
    (** ----------------------------- WAVEFUNCTIONS ------------------------------- **)
    If[iChemDVRRunCalculateWFQ[],
      If[RunWavefunctions===None,
        RunWavefunctions=
          dvrOpsLookup[RunRuntimeOptions, $dvrwf, RunWavefunctions]
        ];
      If[RunWavefunctions===None,
        RunWavefunctions=iChemDVRRunWavefunctions[obj];
        ];
      If[RunEndPoint===$dvrwf,
        Return@RunWavefunctions
        ];
      RunCheckPoint=$dvrwf
      ];
    (** ----------------------------- RUN ENDPOINTS ------------------------------ **)
    Switch[RunEndPoint,
      (** --------------------------- MULTIPLE RETURN ---------------------------- **)
      {
        (
          $dvrgr|$dvrke|$dvrpe|$dvrwf|$dvrham|$dvreng|
            $dvrgrwf|$dvrintwf|
            {$dvrexv, __}|{$dvrexm, __}|{ $dvrexmel, __}
          )..
        },
        Replace[
          Replace[
            DeleteDuplicates@RunEndPoint,
            {
              k:$dvrgr:>
                Block[{RunEndPoint=k},
                  ($dvrgr->RunGrid)
                  ],
              k:$dvrke:>
                Block[{RunEndPoint=k},
                  ($dvrke->RunKineticEnergy)
                  ],
              k:$dvrpe:>
                  Block[{RunEndPoint=k},
                    ($dvrpe->RunPotentialEnergy)
                    ],
              k:$dvrwf:>
                Block[{RunEndPoint=k},
                  ($dvrwf->RunWavefunctions)
                  ],
              k:$dvrham:>
                Block[{RunEndPoint=k},
                  ($dvrham->RunPotentialEnergy+RunKineticEnergy)
                  ],
              k:$dvreng:>
                Block[{RunEndPoint=k},
                  ($dvreng->RunWavefunctions[[1]])
                  ],
              k:$dvrgrwf:>
                Block[{RunEndPoint=k},
                  ($dvrgrwf->iChemDVRRunGridWavefunctions[obj])
                  ],
              k:$dvrintwf:>
                Block[{RunEndPoint=k},
                  ($dvrintwf->iChemDVRRunInterpolatingWavefunctions[obj])
                  ],
              k:{$dvrexv, __}:>
                Block[{RunEndPoint=k},
                  ($dvrexv->iChemDVRRunExpectationValues[obj])
                  ],
              k:{$dvrexm, __}:>
                Block[{RunEndPoint=k},
                  ($dvrexm->iChemDVRRunOperatorMatrix[obj])
                  ],
              k:{ $dvrexmel, __}:>
                Block[{RunEndPoint=k},
                  ( $dvrexmel->iChemDVRRunOperatorMatrixElements[obj])
                  ]
              },
            1
            ],
        o:{__Rule}:>Merge[o, Replace[{v_}:>v]]
        ],
      (** --------------------------- GRID WAVEFUNCTIONS -------------------------- **)
      $dvrgrwf,
        iChemDVRRunGridWavefunctions[obj],
      (** ---------------------- INTERPOLATING WAVEFUNCTIONS --------------------- **)
      $dvrintwf,
        iChemDVRRunInterpolatingWavefunctions[obj],
      (** --------------------------- EXPECTATION VALUES -------------------------- **)
      {$dvrexv, __},
        iChemDVRRunExpectationValues[obj],
      (** ---------------------------- OPERATOR MATRIX ---------------------------- **)
      {$dvrexm, __},
        iChemDVRRunOperatorMatrix[obj],
      (** ------------------------ OPERATOR MATRIX ELEMENTS ---------------------- **)
      { $dvrexmel, __},
        iChemDVRRunOperatorMatrixElements[obj],
      (** ------------------------------- FULL RESULTS ----------------------------- **)
      "FullResults",
        If[ListQ@RunWavefunctions,
          <|
            $dvrgr->
              If[ListQ@RunGrid, 
                RawArray["Real64", RunGrid],
                RunGrid
                ],
            $dvrpe->
              If[ListQ@RunPotentialEnergy, 
                RawArray["Real64", RunPotentialEnergy],
                RunPotentialEnergy
                ],
            $dvrke->
              If[ListQ@RunKineticEnergy, 
                RawArray["Real64", RunKineticEnergy],
                RunKineticEnergy
                ],
            $dvreng->
              If[ListQ@RunWavefunctions, 
                RawArray["Real64", RunWavefunctions[[1]]],
                RunWavefunctions[[1]]
                ],
            $dvrwf->
              If[ListQ@RunWavefunctions, 
                RawArray["Real64", RunWavefunctions[[2]]],
                RunWavefunctions[[2]]
                ]
            |>
          ],
      (** ----------------------------------- PLOT --------------------------------- **)
      _,
        ChemDVRView[obj,
          $dvrwf->
            If[ChemDVRGet[obj, "View"]===ChemDVRDefaultPlot, 
              If[Head[RunWavefunctions]===Hold,
                RunWavefunctions,
                Hold[RunWavefunctions]
                ],
              RunWavefunctions
              ],
          $dvrpe->
            If[ChemDVRGet[obj, "View"]===ChemDVRDefaultPlot, 
              If[Head[RunPotentialEnergy]===Hold,
                RunPotentialEnergy,
                Hold[RunPotentialEnergy]
                ],
              RunPotentialEnergy
              ],
          $dvrgr->RunGrid,
          "TransformationMatrix"->RunTransformation,
          iChemDVRGetRuntimeOptions[$dvrvw]
          ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*ChemDVRRun*)



ChemDVRRun[obj:dvrObjPattern,ops:OptionsPattern[]]:=
  PackageExceptionBlock["DVRRun"]@
  With[{m=If[$Notebooks,dvrOpsLookup[ops,Monitor,False],False]},
    Switch[m,
      Automatic|True,  
        With[{start=Now,clock=Unique@"clock$"},
          Monitor[iChemDVRRun[obj, ops],
            With[{p=
              Replace[
                Position[
                  {$dvrgr,$dvrke,$dvrpe,$dvrwf},
                  RunCheckPoint
                  ],{
                {{i_}}:>i,
                _->-1
                }]},
              Panel@Grid[{
                {"Time Elapsed:",
                  If[p<4,
                    Row@{Dynamic[clock;Round[Now-start,.02]],
                      Invisible@Pane[Animator[Dynamic@clock,{0,1,.1},1],{5,5}]},
                    Now-start
                    ]},
                {"Grid:",If[p<1,"\[EmptySquare]","\[CheckmarkedBox]"]},
                {"Kinetic Energy:",If[p<2,"\[EmptySquare]","\[CheckmarkedBox]"]},
                {"Potential Energy:",If[p<3,"\[EmptySquare]","\[CheckmarkedBox]"]},
                {"Wavefunctions:",If[p<4,"\[EmptySquare]","\[CheckmarkedBox]"]}
                },
                Alignment->Left
                ]
              ]
            ]
          ],
      _Function,
        Monitor[iChemDVRRun[obj, ops], m@RunCheckPoint],
      _,
        iChemDVRRun[obj, ops]
      ]
    ];


(* ::Subsection:: *)
(*OOP Interface*)



(* ::Subsubsection::Closed:: *)
(*Call*)



$dvrBasicKeys=
  $dvrgr|$dvrpe|$dvrke|$dvrgp|
    $dvrwf|$dvrgrwf|$dvrintwf|
    $dvrham|$dvreng|"FullResults"|
    $dvrpo|$dvrexwf|$dvrguwf;


ChemDVRObject[uuid_?chemDVRValidQ][a___?OptionQ]:=
  ChemDVRRun[ChemDVRObject[uuid],a];
(obj:_ChemDVRObject?chemDVRValidQ)[k:$dvrBasicKeys, args___?OptionQ]:=
  ChemDVRRun[obj, Return->k, args];
(obj:_ChemDVRObject?chemDVRValidQ)[
    k:$dvrexv|$dvrexm| $dvrexmel, 
    efuns:Except[_?OptionQ], args___?OptionQ]:=
  ChemDVRRun[obj, Return->{k, efuns}, args];
(obj:_ChemDVRObject?chemDVRValidQ)["Properties"]:=
  Keys@ChemDVRAssociation[obj];
(obj:_ChemDVRObject?chemDVRValidQ)["Association"]:=
  Keys@ChemDVRAssociation[obj];
(obj:_ChemDVRObject?chemDVRValidQ)["Options", thing___]:=
  ChemDVROptions[obj, thing];
(obj:_ChemDVRObject?chemDVRValidQ)[k:Except[_?OptionQ]..]:=
  ChemDVRGet[obj, k];
ChemDVRObject/:
  (obj:_ChemDVRObject?chemDVRValidQ)[[k:Except[_?OptionQ]..]]:=
    ChemDVRGet[obj, k];


(* ::Subsubsection::Closed:: *)
(*Mutate*)



ChemDVRObjMutate//ClearAll;
ChemDVRObjMutate~SetAttributes~HoldAllComplete;
$ChemDVROneArgMutators=
  Set|SetDelayed|TimesBy|DivideBy|AddTo|SubtractFrom|
    PrependTo|AppendTo|AssociateTo|KeyDropFrom;
$ChemDVRBaseNoArgMutators=
  Increment|Decrement;
ChemDVRObject/:(m:Set|SetDelayed)[
  obj_ChemDVRObject?chemDVRValidQ[k:Except[_?OptionQ]..],
  v_]:=
  ChemDVRMutate[obj[k], m, v];
With[{oneArgs=$ChemDVROneArgMutators, noArg=$ChemDVRNoArgMutators},
  ChemDVRObjMutate[
    (m:oneArgs)[
      (obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[k:Except[_?OptionQ]..],
      a_
      ]
    ]:=
    With[{o=obj},
      ChemDVRMutate[o[k], m, a]
      ];
  ChemDVRObjMutate[
    (m:oneArgs)[
      (obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[[k:Except[_?OptionQ]..]],
      a_
      ]
    ]:=
    With[{o=obj},
      ChemDVRMutate[o[[k]], m, a]
      ];
  ChemDVRObjMutate[
    (m:noArg)[
      (obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[k:Except[_?OptionQ]..]
      ]
    ]:=
    With[{o=obj},
      ChemDVRMutate[o[k], m]
      ];
  ChemDVRObjMutate[
    (m:noArg)[
      (obj:(_Symbol|_ChemDVRObject)?chemDVRValidQ)[[k:Except[_?OptionQ]..]]
      ]
    ]:=
    With[{o=obj},
      ChemDVRMutate[o[[k]], m]
      ];
    ];


Language`SetMutationHandler[ChemDVRObject, ChemDVRObjMutate]


(* ::Subsubsection::Closed:: *)
(*Formatting*)



$dvrimg=
  Pane[
    Import[PackageFilePath["Resources", "Icons", "DVRIcon.png"]], 
    {28,28},
    ImageSizeAction->"ShrinkToFit"
    ];


Format[obj:dvrObjPattern?chemDVRValidQ]:=
  RawBoxes@
    BoxForm`ArrangeSummaryBox[
      "ChemDVRObject",
      obj,
      Replace[ChemDVRGet[obj,"Icon"], _Missing->$dvrimg],
        {
          BoxForm`MakeSummaryItem[{"Name: ",ChemDVRGet[obj,"Name"]},StandardForm],
          Replace[ChemDVRGet[obj, "Description"],
            {
              s_String?(StringLength[#]>0&):>
                Pane[
                  s,
                  {{Automatic, 250}, Automatic}
                  ],
              _->Nothing
              }
            ]
            },
      Prepend[
        BoxForm`MakeSummaryItem[
          {"UUID: ",ChemDVRGet[obj,"UUID"]},
          StandardForm
          ]
        ]@
      Internal`WithLocalSettings[
        System`Private`NewContextPath@{"System`"},
        Map[
          BoxForm`MakeSummaryItem[{Row@{#,": "},ChemDVRGet[obj,#]},StandardForm]&,{
            "Range",
            "Points",
            $dvrgr,
            $dvrke,
            $dvrpe,
            $dvrwf
          }
          ],
        System`Private`RestoreContextPath[]  
        ],
      StandardForm
      ];
    


End[];



