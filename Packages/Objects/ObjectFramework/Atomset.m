(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Subsection:: *)
(*Atomset Methods*)



(* ::Subsubsection::Closed:: *)
(*Creation*)



CreateAtomset::usage="Creates an atom set";


AtomsetAddAtom::usage="Adds an atom to an atomset";
AtomsetRemoveAtom::usage="Removes an atom from an atomset";
AtomsetGetAtoms::usage="Gets atoms matching a property";


AtomsetJoin::usage=
	"Creates a new atomset from a collection of atomsets";


AtomsetEmpiricalFormula::usage=
	"Pulls the empirical formula for the atomset";


(* ::Subsubsection::Closed:: *)
(*Atom Properties*)



AtomsetElementPositions::usage=
	"Returns element position pairs for all the atoms";
AtomsetNeighborMap::usage=
	"Returns a map of an atom and its neighbors";
AtomsetMolTable::usage=
	"Returns a mol table form of the atomset";


AtomsetSubstituteAtom::usage=
	"Substitutes in a new atom for an old one";


(* ::Subsubsection::Closed:: *)
(*Bond Properties*)



AtomsetBondsIndexed::usage=
	"Returns an {i1, i2, type} matrix";
AtomsetBonds::usage=
	"Returns the bonds an {i, j} -> b association"; 
AtomsetBondLengths::usage=
	"Returns the indices and length for each bond in the atomset";
AtomsetBondVectors::usage=
	"Returns the indices and bond vector for each bond";
AtomsetMeanBondLengths::usage="Returns the mean bond length by atom type";


AtomsetNormalizeBonds::usage=
	"Normalizes bonds against the standard lookup table";
AtomsetSetBondLengths::usage=
	"Sets bond lengths within an atomset";


(* ::Subsubsection::Closed:: *)
(*Point-wise ops*)



AtomsetBounds::usage=
	"Applies CoordinateBounds to atomset";
AtomsetMassPositions::usage=
	"Returns mass position pairs for all the atoms";
AtomsetCenter::usage="Returns the center of the atomset";
AtomsetCenterOfMass::usage="Gets the center of pass of the Atomset";
AtomsetMove::usage="Moves an atom set";
AtomsetTransform::usage="Applies a matrix mult or transformation to the atoms";
AtomsetRotate::usage="Rotates an atom set";
AtomsetRotationTransform::usage=
	"Returns a rotation transform on an atom set";
AtomsetAxisAlign::usage=
	"Aligns the atomset along a pair of axis specs";
AtomsetAlign::usage=
	"Aligns the atomset with another atomset";


(* ::Subsubsection::Closed:: *)
(*Rotational Spec*)



AtomsetInertialTensor::usage="Returns the inertial tensor of the atomset";
AtomsetInertialEigensystem::usage="Returns the eigensystem of the atomset";
AtomsetInertialSystem::usage="Returns inertial system of atomset";
AtomsetPrincipalAxes::usage=
	"Returns the principal axes of the system with sizes equal to the moments";


(* ::Subsubsection::Closed:: *)
(*Symmetry*)



AtomsetSymmetryElements::usage=
	"Finds the symmetry elements of the specified atoms in the atomset";
AtomsetInertialSymmetry::usage=
	"Finds the symmetry elements of the atomset relating to the inertial axes";
AtomsetPointGroup::usage=
	"Guesses the atomset point group";


(* ::Subsubsection::Closed:: *)
(*Surfaces and Point functions*)



AtomsetVdWSurface::usage="Returns a mesh of the Van der Waals surface of the atomset";
AtomsetVdWVolume::usage="Returns the Van der Waals volume of the atomset";


AtomsetCompile::usage=
	"Macro to generate function over the atoms in an atomset";
AtomsetPointCompile::usage=
	"Version of AtomsetCompile with Point as the first argument";


AtomsetPartialCharges::usage=
	"Calculates the Gasteiger partial charges";
AtomsetElectricPotential::usage=
	"Uses the partial charges to generate an esp function";


AtomsetElectricPotentialMap::usage=
	"Plots the electric potential on the VdW surface";


(* ::Subsubsection::Closed:: *)
(*Extensions*)



AtomsetOrbitals::usage=
	"Calculates orbitals for an atomset";
AtomsetOrbitalsPlot::usage=
	"Plots orbitals as DensityPlot3D";


AtomsetEnergyScan::usage=
	"Scans atomset energy with molecules in different positions";


(* ::Subsubsection::Closed:: *)
(*Sample function*)



(*AtomsetPolarMoment::usage="Returns a polarization gradient vector";
AtomsetPolarCenter::usage=
	"Uses FixedPoint to follow the polarization vectors";
AtomsetPolarMomentPlot::usage=
	"Uses compiled PolarMoment to generate a ChemSurfacePlot";
AtomsetPolarization::usage=
	"Returns the vector from the center of an atomset to its polar center";*)


(* ::Subsubsection::Closed:: *)
(*Connections and Type Testing*)



AtomsetGraph::usage="Returns the graph of the atomset";
AtomsetGraphScan::usage=
	"Applies a BFS or DFS scan to atomset";
AtomsetConnectedComponents::usage=
	"Returns the collection of connected components for the atomset";


AtomsetRings::usage=
	"Returns the collection of rings for the atomset";
AtomsetConjugatedSystems::usage=
	"Returns the collection of conjugated systems for the atomset";
AtomsetAromaticRings::usage=
	"Returns the collection of aromatic rings for the atomset";
AtomsetAromaticQ::usage=
	"Checks whether an atom or collection of atoms are aromatic";


AtomsetAtomMemberQ::usage=
	"Checks whether an atom or collection of atoms are of a certain type";


(* ::Subsubsection::Closed:: *)
(*Graphics*)



AtomsetGraphic::usage="Gets a 2D atom set graphics object";
AtomsetGraphic3D::usage="Gets a 3D bond graphics object";


(* ::Subsection:: *)
(*Wrappers*)



AtomsetWrapper::usage=
	"A wrapper that acts like an atomset that creates and deletes itself";


Begin["`Private`"];


(* Load the symbolic python package *)
PyToolsLoad[];


(* ::Subsection:: *)
(*Class*)



(*$ChemObjectDefaults["Atomset"]=.*)


If[!KeyMemberQ[$ChemObjectDefaults, "Atomset"],
	$ChemObjectDefaults["Atomset"]=
			<|
				"Atoms"->{},
				
				"Join"->
					ChemMethod[AtomsetJoin],
				"GetAtom"->
					ChemMethod[AtomsetGetAtoms],
				"AddAtom"->
					ChemMethod[AtomsetAddAtom],
				"RemoveAtom"->
					ChemMethod[AtomsetRemoveAtom],
				"SubstitueAtom"->
					ChemMethod[AtomsetSubstitueAtom],
					
				"Bonds"->
					ChemProperty[AtomsetBonds],
				"BondVectors"->
					ChemProperty[AtomsetBondVectors],
				"BondsIndexed"->
					ChemProperty[AtomsetBondsIndexed],
				"SetBondLength"->
					ChemMethod[AtomsetSetBondLength],
				"NormalizeBonds"->
					ChemMethod[AtomsetNormalizeBonds],
				"GuessBonds"->
					ChemMethod[AtomsetGuessBonds],
					
				"Center"->
					ChemProperty[AtomsetCenter],
				"CenterOfMass"->
					ChemProperty[AtomsetCenterOfMass],
				"MassPositions"->
					ChemProperty[AtomsetMassPositions],
				"Bounds"->
					ChemProperty[AtomsetBounds],
				
				"Rotate"->
					ChemMethod[AtomsetRotate],
				"Move"->
					ChemMethod[AtomsetMove],
				"Transform"->
					ChemMethod[AtomsetTransform],
				"Align"->
					ChemMethod[AtomsetAlign],
				"AxisAlign"->
					ChemMethod[AtomsetAxisAlign],
				
				"IntertialTensor"->
					ChemProperty[AtomsetIntertialTensor],
				"InertialEigensystem"->
					ChemProperty[AtomsetInertialEigensystem],
				"InertialSystem"->
					ChemProperty[AtomsetInertialSystem],
				"PrincipalAxes"->
					ChemProperty[AtomsetPrincipalAxes],

				"EmpiricalFormula"->
					ChemProperty[EmpiricalFormula],
				
				"AdjacencyMatrix"->
					ChemProperty[AtomsetAdjacencyMatrix],
				"ConnectedComponents"->
					ChemProperty[AtomsetConnectedComponents],
				"Graph"->
					ChemProperty[AtomsetGraph],
				"GraphScan"->
					ChemMethod[AtomsetGraphScan],
				"NeighborMap"->
					ChemProperty[AtomsetNeighborMap],
				"Rings"->
					ChemProperty[AtomsetRings],
				"AromaticRings"->
					ChemProperty[AtomsetAromaticRings],
				"AtomMemberQ"->
					ChemProperty[AtomsetAtomMemberQ],
				"AromaticQ"->
					ChemMethod[AtomsetAromaticQ],
				
				"Surface"->
					ChemMethod[AtomsetVdWSurface],
				"Volume"->
					ChemMethod[AtomsetVdWVolume],
				
				"ElectricPotential"->
					ChemMethod[AtomsetElectricPotential],
				"ElectricPotentialMap"->
					ChemMethod[AtomsetElectricPotentialMap],
				
				"Orbitals"->
					ChemMethod[AtomsetOrbitals],
				"OrbitalsPlot"->
					ChemMethod[AtomsetOrbitalsPlot],
					
				"Graphic"->ChemMethod[
					With[{o={##}},
						AtomsetGraphic[First@o,
							Sequence@@FilterRules[Rest@o, Options@AtomsetGraphic]
							]
						]&
					],
				"Graphic3D"->ChemMethod[
					With[{o={##}},
						AtomsetGraphic3D[First@o,
							Sequence@@FilterRules[Rest@o, Options@AtomsetGraphic3D]
							]
						]&
					]
				|>
  ];


(* ::Subsection:: *)
(*Atomset Creation*)



(* ::Subsubsection::Closed:: *)
(*Create*)



parseToAtoms[system_,{{a_,b_},o__}]:=
	With[{atoms=
			CreateAtom[system, 
				Map[
					{
						First@#,
						"Position"->
							#[[2]],
						Sequence@@Rest@Rest@#
						}&,
					{o}[[;;a]]]
					]
			},
		Do[
			AtomCreateBond[
				atoms[[ First@bond ]],
				atoms[[ bond[[2]] ]], 
				If[Length@bond>2,bond[[3]],1],
				False
				],
			{bond,{o}[[a+1;;a+b]]}
			];
		atoms
		];


CreateAtomset//Clear


CreateAtomset[
	sys:ChemSysPattern|Automatic:Automatic,
	atoms:ChemObjVectorPattern|{},
	others:ChemOptionsPattern
	]:=
	With[{co=
		ChemAdd[Replace[sys,Automatic->$ChemDefaultSystem],
			"Atomset",
			"Atoms"->atoms,
			others
			]
		},
		ChemAddReference[co,atoms];
		AtomsetAddAtom[co,atoms];
		co
		];
CreateAtomset[sys:ChemSysPattern|Automatic:Automatic,
	atoms:ChemObjPattern...,
	ops:ChemOptionsPattern]:=
	CreateAtomset[sys,
		{atoms},
		ops];


chemAtomListPattern=
	{_String,
			{
				_?NumericQ|_Quantity,
				_?NumericQ|_Quantity,
				_?NumericQ|_Quantity
				}|_QuantityArray,
			___
			};
chemZMxListPattern=
	{
		{_String},
		{_String, _?NumericQ}
		};


chemAtomsetBaseSpec=
	{
		{_Integer,_Integer},
		chemAtomListPattern,
		___
		}|
	{
		chemAtomListPattern,
		___List
		}|
	chemZMxListPattern;


CreateAtomset[sys:ChemSysPattern|Automatic:Automatic,
	atoms:chemAtomsetBaseSpec,
	o:ChemOptionsPattern]:=
	With[{atSpec=
		Which[
			MatchQ[First@atoms,{_Integer,_Integer}],
				atoms,
			MatchQ[atoms, chemZMxListPattern],
				Prepend[#,
					{
						Length@Cases[#,{_String,__}],
						Length@Cases[#,{_Integer,__}]
						}
					]&@ChemUtilsGenerateMolTable[atoms],
			True,
				Prepend[atoms,
					{
						Length@Cases[atoms,{_String,__}],
						Length@Cases[atoms,{_Integer,__}]
						}
					]
			]},
		CreateAtomset[sys,
			Sequence@@parseToAtoms[sys,atSpec],
			o
			]
		];


CreateAtomset[
	sys:ChemSysPattern|Automatic:Automatic,
	aspecs:
		(
			chemAtomsetBaseSpec|
			{chemAtomsetBaseSpec,ChemOptionsPattern}
			)..
	]:=
	Replace[{aspecs},{
		a:chemAtomsetBaseSpec:>
			CreateAtomset[sys,a],
		e_:>
			CreateAtomset[sys,Sequence@@e]
		},
		1]
		


AtomsetGetAtoms[obj:ChemObjPattern,test_]:=
	Replace[test,{
		Identity|All|
			Verbatim[MatchQ[_]]|Verbatim[HoldPattern[True&]]:>
			ChemGet[obj,"Atoms"],
		_String?(
				ChemDataAtomQ@#&&
					ChemDataLookup[#,"Symbol"]=!=$Failed&
					):>
			With[{atoms=ChemGet[obj,"Atoms"]},
				With[{
					elements=
						ChemGet[atoms,"Element"],
					sn=
						ChemDataLookup[test,"Symbol"]
					},
					Pick[atoms,#===sn&/@elements]
					]
				],
		(_String|_Rule|_RuleDelayed):>
			With[{ats=ChemGet[obj,"Atoms"]},
				With[{as=AtomsetAtomMemberQ[obj,ats,test]},
					RuleCondition[
						Pick[ats,as],
						ListQ@as
						]
					]
				],
		HoldPattern[t_[ChemGet[#,p_],v_]&]:>
			With[{atoms=ChemGet[obj,"Atoms"]},
				With[{
					prop=
						ChemGet[atoms,p],
					val=v
					},
					Pick[atoms,t[#,val]&/@prop]
					]
				],
		e_:>
			Select[ChemGet[obj,"Atoms"],e]
		}];


AtomsetAddAtom[obj:ChemObjPattern,atoms:ChemObjAllPattern]:=(
	ChemIncrement[obj,"Atoms",atoms,DeleteDuplicates@*Flatten@*List];
	ChemAddReference[obj,atoms];
	ChemMutate[atoms "Atomset",Replace[{_Missing:>{obj},{l___}:>{l,obj}}]];
	atoms
	);


AtomsetRemoveAtom[obj:ChemObjPattern,atoms:ChemObjAllPattern]:=(
	ChemMutate[obj,"Atoms",
		DeleteCases[Alternatives@@Flatten@{atoms}]];
	ChemRemoveReference[obj,atoms];
	ChemMutate[atoms "Atomset",
		Replace[{_Missing:>{},
			l_List:>DeleteCases[l,obj]}]];
	);


AtomsetJoin[objV:ChemObjVectorPattern]:=
	CreateAtomset@Flatten@ChemGet[objV,"Atoms"];
AtomsetJoin[objV:ChemObjPattern..]


AtomsetSubstituteAtom//Clear


(
	AtomsetSubstituteAtom[
		obj:ChemObjPattern,
		reps:{(ChemObjPattern->ChemObjPattern)..},
		check:True|False:True
		]/;
			(
				Sort@Intersection[
					ChemGet[obj,"Atoms"],
					Map[First,reps]
					]==Sort@Map[First,reps]
				)
		):=
	Module[
		{
			old=First/@reps,
			new=Last/@reps,
			bonds=DeleteCases[{}]@ChemGet[First/@reps,"Bonds"],
			types,
			atoms,
			pos
			},
		AtomsetRemoveAtom[obj,old];
		AtomsetAddAtom[obj,new];
		pos=ChemGet[old,"Position"];
		ChemThreadSet[new,"Position",pos];
		If[Length[bonds]>0,
			BondBreak/@DeleteDuplicates@Flatten@bonds;
			types=ChemGet[bonds,"Type"];
			atoms=
				Replace[
					ChemGet[bonds,"Atoms"],
					({Alternatives@@old,a_}|{a_,Alternatives@@old}):>a,
					{2}
					];
			MapThread[
				With[{
					a=#,
					b=Replace[#2,a:(Alternatives@@old):>Replace[a,reps],1],
					t=#3
					},
					MapThread[
						Function[
							If[a=!=#,
								AtomCreateBond[a,#,#2,check]
								]
							],
						{
							b,
							t
							}
						]
					]&,
				{
					new,
					atoms,
					types
					}];
			]
		]


AtomsetSubstituteAtom[
	obj:ChemObjPattern,
	at1:ChemObjPattern->at2:ChemObjPattern,
	check:True|False:True
	]:=
	With[
		{
			a=
				AtomsetSubstituteAtom[obj,
					{at1->at2},
					check
					]
			},
		a/;Head[a]=!=AtomsetSubstituteAtom
		];


(*AtomsetSubstituteAtom[
	obj:ChemObjPattern,
	a:{
	]:=
	With[
		{
			a=
				AtomsetSubstituteAtom[obj,
					{at1\[Rule]at2}
					]
			},
		a/;Head[a]=!=AtomsetSubstituteAtom
		];*)


(* ::Subsection:: *)
(*Atomset Structural Properties*)



(* ::Subsubsection::Closed:: *)
(*EmpiricalFormula*)



AtomsetEmpiricalFormula[obj:ChemObjPattern]:=
	With[{els=
		ChemDataLookup[
			ChemGet[ChemGet[obj,"Atoms"],"Element"],
			"Symbol"]
		},
		KeyValueMap[#<>ToString@#2&]@
			KeySortBy[Counts[els],
				Switch[#,
					"C",
						1,
					"O"|"N",
						2,
					"H",
						3,
					_,
						4
					]&
				]//StringJoin
		];


(* ::Subsubsection::Closed:: *)
(*ElementPositions*)



AtomsetElementPositions[obj:ChemObjPattern]:=
	With[{a=ChemGet[obj,"Atoms"]},
		Transpose@{
			ChemGet[a,"Element"],
			ChemGet[a,"Position"]
			}];


(* ::Subsubsection::Closed:: *)
(*Bonds*)



AtomsetBonds[obj:ChemObjPattern]:=
	With[
		{
			a=ChemGet[obj,"Atoms"]
			},
		With[
			{
				b=DeleteDuplicates@Flatten@ChemGet[a, "Bonds"],
				index=Association@MapIndexed[#->#2[[1]]&, a]
				},
			AssociationThread[
				Map[
					(* Finds the first position for the atom in the bond in the atomset *)
					Lookup[index, #]&,
					ChemGet[b, "Atoms"]
					],
				b
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Bounds*)



AtomsetBounds[
	obj:ChemObjPattern,
	padding:_?NumericQ:0
	]:=
	Module[{
		ats=ChemGet[obj,"Atoms"],
		rads,
		pos,
		moves=Tuples[{1,-1},3]
		},
		rads=QuantityMagnitude/@ChemGet[ats,"Radius"];
		pos=ChemGet[ats,"Position"];
		pos=
			Flatten[
				MapThread[
					With[{
						base=#*moves,
						p=#2
						},
						p+#&/@base
						]&,{
					rads+padding,
					pos
					}],
				1
				];
		CoordinateBounds@pos
		];


(* ::Subsubsection::Closed:: *)
(*BondsIndexed*)



AtomsetBondsIndexed[obj:ChemObjPattern]:=
	With[{a=ChemGet[obj,"Atoms"]},
		With[{b=DeleteDuplicates@Flatten@ChemGet[a,"Bonds"]},
			Map[
				{
					First@FirstPosition[a,#[[1,1]]],
					First@FirstPosition[a,#[[1,2]]],
					#[[2]]}&,
				Transpose@{
					ChemGet[b,"Atoms"],
					ChemGet[b,"Type"]
					}
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*BondVectors*)



AtomsetBondVectors[obj:ChemObjPattern]:=
	With[{a=ChemGet[obj,"Atoms"]},
		With[{
			b=DeleteDuplicates@Flatten@ChemGet[a,"Bonds"],
			p=ChemGet[a,"Position"]
			},
			AssociationMap[
				Subtract@@p[[#]]&,
				Map[
					Map[First@FirstPosition[a,#]&],
					ChemGet[b,"Atoms"]
					]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*BondLengths*)



AtomsetBondLengths[obj:ChemObjPattern]:=
	Norm/@AtomsetBondVectors[obj]


(* ::Subsubsection::Closed:: *)
(*MeanBondLengths*)



AtomsetMeanBondLengths[obj:ChemObjPattern,extras_:None]:=
	Mean@*Map[Last]/@
		With[{
			bm=AtomsetBonds@obj,
			a=ChemGet[obj,"Atoms"]
			},
			With[{
				els=
					ChemDataLookup[ChemGet[a,"Element"],"Symbol"],
				vecs=Norm/@BondVector@Values@bm
				},
				With[{
					toGroup=
						If[extras=!=None,
							MapThread[
								Append[
									SortBy[
										els[[#]],
										Position[Values@$ChemElements,#]&
										],
									#2]->#3&,{
									Keys@bm,
									ChemGet[Values@bm,extras],
									vecs
									}],
							MapThread[Rule,{
								SortBy[
									els[[#]],
									Position[Values@$ChemElements,#]&
									]&/@Keys@bm,
								vecs
								}]
							]
					},
					GroupBy[toGroup,First]
					]
				]
			]


(* ::Subsubsection::Closed:: *)
(*NeighborMap*)



AtomsetNeighborMap[obj:ChemObjPattern]:=
	With[{
		bindex=AtomsetBondsIndexed[obj],
		atoms=ChemGet[obj,"Atoms"]
		},
		Map[Last]/@
			GroupBy[
				Flatten@
				ReplaceAll[
					bindex,
					{i_Integer,j_,___}:>
						{atoms[[i]]->atoms[[j]],atoms[[j]]->atoms[[i]]}
					],
				First
				]
		];


(* ::Subsubsection::Closed:: *)
(*MolTable*)



AtomsetMolTable[obj:ChemObjPattern]:=
	With[{
		a=AtomsetElementPositions[obj],
		b=AtomsetBondsIndexed[obj]
		},
		Join[
			{{Length@a,Length@b}},
			a,
			b
			]
		];


(* ::Subsubsection::Closed:: *)
(*SetBondLength*)



Options[AtomsetSetBondLengths]=
	{
		AccuracyGoal->Automatic,
		"AllowUnconnected"->False
		};
AtomsetSetBondLengths[
	obj:ChemObjPattern,
	bondSel:{(ChemObjPattern->_)..},
	ops:OptionsPattern[]
	]:=
	Catch@
	Module[
		{
			conoverride=TrueQ@OptionValue["AllowUnconnected"],
			graphs,
			atoms=ChemGet[obj,"Atoms"],
			bonds=Keys@bondSel,devs,vecs,
			bondats,
			ats,
			comps
			},
		graphs=
			With[{e=EdgeList@AtomGraph[atoms]},
				With[{c=ConnectedComponents[e]},
					GatherBy[e,
						First@FirstPosition[c,First[#]]&
						]
					]
				];
		(* Make sure we're dealing with only connected components *)
		If[conoverride||Length[graphs]===1,
			vecs=BondVector@bonds;
			devs=AssociationThread[bonds, Map[Norm, vecs]-Values@bondSel];
			vecs=AssociationThread[bonds, vecs];
			bondats=ChemGet[bonds,"Atoms"];
			(* Reassociate computed info with each connected chunk *)
			bonds=
				Table[
					Pick[
						bonds,
						MemberQ[g,
							Alternatives@@(UndirectedEdge@@@{#,Reverse[#]})
							]&/@bondats
						],
					{g,graphs}
					];
			bondats=ChemGet[bonds,"Atoms"];
			devs=Lookup[devs,#]&/@bonds;
			vecs=Lookup[vecs,#]&/@bonds;
			
			(* Map over chunks *)
			MapThread[
				With[{
					graph=#,
					gbonds=#2,
					gats=#3,
					gdevs=#4,
					gvecs=#5
					},
					If[Length[graph]>1,
						(* Map over bonds *)
						MapThread[
							Function[
								(* Compute segments on either side of the bond *)
								comps=
									ConnectedComponents[
										DeleteCases[
											graph,
											Alternatives@@(UndirectedEdge@@@{#2,Reverse[#2]})
											]
										];
								If[Length[comps]===1,
									With[{
										c=
											Complement[
												VertexList[graph],
												Flatten@comps
												]
										},
										If[Length[c]>0,
											AppendTo[comps,c]
											]
										]
									];
								If[Length[comps]>1,
									comps=First@MinimalBy[comps,Length];
									(* Determine which atom is with which chunk *)
									If[MemberQ[comps,First[#2]],
										AtomMove[comps,
											-(#3*Normalize[#4])
											],
										AtomMove[comps,
											(#3*Normalize[#4])
											]
										];
									]
								],
							{
								gbonds,
								gats,
								gdevs,
								gvecs
								}
							],
						AtomMove[First[gats],
							-(#3*#4/2)
							];
						AtomMove[Last[gats],
							(#3*#4/2)
							];
					]
				]&,
				{
					graphs,
					bonds,
					bondats,
					devs,
					vecs
					}
				];,
			$Failed
			]
		];
AtomsetSetBondLengths[
	obj:ChemObjPattern,
	bondSel:(ChemObjPattern->_),
	ops:OptionsPattern[]
	]:=
	AtomsetSetBondLengths[obj, {bondSel}, ops]


(* ::Subsubsection::Closed:: *)
(*NormalizeBonds*)



Options[AtomsetNormalizeBonds]=
	{
		AccuracyGoal->Automatic,
		"AllowUnconnected"->False
		};
AtomsetNormalizeBonds[
	obj:ChemObjPattern,
	bondSel:ChemObjPattern|ChemObjVectorPattern|All:All,
	ops:OptionsPattern[]
	]:=
	Catch@
	Module[
		{
			conoverride=TrueQ@OptionValue["AllowUnconnected"],
			tol=
				Replace[
					OptionValue[AccuracyGoal],
					Except[_?NumericQ]->.1
					],
			graphs,
			atoms=ChemGet[obj,"Atoms"],
			bonds,devs,vecs,
			bondats,
			ats,
			comps
			},
		graphs=
			With[{e=EdgeList@AtomGraph[atoms]},
				With[{c=ConnectedComponents[e]},
					GatherBy[e,
						First@FirstPosition[c,First[#]]&
						]
					]
				];
		(* Make sure we're dealing with only connected components *)
		If[conoverride||Length[graphs]===1,
			bonds=
				Replace[
					bondSel,
					All:>
						DeleteDuplicates@
							Flatten@ChemGet[atoms,"Bonds"]
					];
			devs=BondDeviation[bonds];
			bonds=Pick[bonds,#>tol&/@Abs[devs]];
			If[Length[bonds]===0,Throw[Null]];
			devs=AssociationThread[bonds,Pick[devs,#>tol&/@Abs[devs]]];
			vecs=AssociationThread[bonds,BondVector@bonds];
			bondats=ChemGet[bonds,"Atoms"];
			
			(* Reassociate computed info with each connected chunk *)
			bonds=
				Table[
					Pick[
						bonds,
						MemberQ[g,
							Alternatives@@(UndirectedEdge@@@{#,Reverse[#]})
							]&/@bondats
						],
					{g,graphs}
					];
			bondats=ChemGet[bonds,"Atoms"];
			devs=Lookup[devs,#]&/@bonds;
			vecs=Lookup[vecs,#]&/@bonds;
			
			(* Map over chunks *)
			MapThread[
				With[{
					graph=#,
					gbonds=#2,
					gats=#3,
					gdevs=#4,
					gvecs=#5
					},
					If[Length[graph]>1,
						(* Map over bonds *)
						MapThread[
							Function[
								(* Compute segments on either side of the bond *)
								comps=
									ConnectedComponents[
										DeleteCases[
											graph,
											Alternatives@@(UndirectedEdge@@@{#2,Reverse[#2]})
											]
										];
								If[Length[comps]===1,
									With[{
										c=
											Complement[
												VertexList[graph],
												Flatten@comps
												]
										},
										If[Length[c]>0,
											AppendTo[comps,c]
											]
										]
									];
								If[Length[comps]>1,
									comps=First@MinimalBy[comps,Length];
									(* Determine which atom is with which chunk *)
									If[MemberQ[comps,First[#2]],
										AtomMove[comps,
											-(#3*Normalize[#4])
											],
										AtomMove[comps,
											(#3*Normalize[#4])
											]
										];
									]
								],
							{
								gbonds,
								gats,
								gdevs,
								gvecs
								}
							],
						AtomMove[First[gats],
							-(#3*#4/2)
							];
						AtomMove[Last[gats],
							(#3*#4/2)
							];
					]
				]&,
				{
					graphs,
					bonds,
					bondats,
					devs,
					vecs
					}
				];,
			$Failed
			]
		]


(* ::Subsection:: *)
(*Atomset Connectivity Properties*)



AtomsetAdjacencyMatrix[obj:ChemObjPattern]:=
	ReplacePart[
		Map[Boole]/@AtomBondedQ[#,#]&@ChemGet[obj,"Atoms"],
		{i_,i_}->0
		]


AtomsetGraph[obj:ChemObjPattern,style:True|False:False]:=
	With[{adjMat=AtomsetAdjacencyMatrix@obj,atoms=ChemGet[obj,"Atoms"]},
		If[Not@style,
			Graph[
				EdgeList@AdjacencyGraph@adjMat/.
					i_Integer:>atoms[[i]]
				],
			Graph[
				EdgeList@AdjacencyGraph@adjMat/.
					i_Integer:>atoms[[i]],
				VertexShape->
					Table[
						a->
							Graphics[{
								AtomColor@a,
								Darker@AtomColor@a,
								Tooltip[Disk[],
									StringJoin@StringSplit[ChemGet[a,"ObjectKey"],"-"->"-"][[;;3]]
									]
								}],
						{a,atoms}
						],
				EdgeStyle->Directive[Thick,Black],
				VertexSize->
					MapThread[#->QuantityMagnitude[#2]/2.&,{
						atoms,
						ChemGet[atoms,"Radius"]
						}]
				]
			]
		];


atomsetGraphEvents[basevs_,bs_,as_,DepthFirstScan]:=
	With[{evs=
		Merge[
			Replace[Flatten@{basevs},{
				(k:("BackEdge"|"FrontierEdge"|
					"ForwardEdge"|"CrossEdge")->f_):>
					k->(f[#/.bs]&),
				({k:"BackEdge"|"FrontierEdge"|
					"ForwardEdge"|"CrossEdge",
					c:ChemObjPattern}->f_):>
					(If[MatchQ[#/.bs,c],f[c]]&),
				({k_,c:ChemObjPattern}->f_):>
					k->(If[MatchQ[#,c],f[c]]&),
				(c:ChemObjPattern->f_):>
					If[MemberQ[c,as],
						Thread[
							{"DiscoverVertex",
								"UnvisitedVertex","VisitedVertex",
								"PrevisitVertex","PostvisitVertex"}->
								(If[MatchQ[#,c],f[c]]&)
							],
						Thread[
							{"BackEdge","FrontierEdge",
								"ForwardEdge","CrossEdge"}->
								 (If[MatchQ[#/.bs,c],f[c]]&)
							]
						]
				},1],
			Replace[f:{__}:>
				(Through[f[#]]&)
				]
			]},
		evs
		];


atomsetGraphEvents[basevs_,bs_,as_,BreadthFirstScan]:=
	Merge[
		Replace[Flatten@{basevs},{
			(k:("FrontierEdge"|"CycleEdge")->f_):>
				k->(f[#/.bs]&),
			({k:("FrontierEdge"|"CycleEdge"),
				c:ChemObjPattern}->f_):>
				(If[MatchQ[#/.bs,c],f[c]]&),
			({k_,c:ChemObjPattern}->f_):>
				k->(If[MatchQ[#,c],f[c]]&),
			(c:ChemObjPattern->f_):>
				If[MemberQ[as,c],
					Thread[
						{"DiscoverVertex",
							"UnvisitedVertex","VisitedVertex",
							"PrevisitVertex","PostvisitVertex"}->
							(If[MatchQ[#,c],f[c]]&)
						],
					Thread[
						{"FrontierEdge","CycleEdge"}->
							(If[MatchQ[#/.bs,c],f[c]]&)
						]
					]
			},
			1],
		Replace[f:{__}:>
			(Through[f[#]]&)
			]
		];


AtomsetGraphEvents[obj:ChemObjPattern,
	mode:BreadthFirstScan|DepthFirstScan:BreadthFirstScan,
	events_:{}
	]:=
	With[{as=ChemGet[obj,"Atoms"]},
		With[{
			basevs=
				Flatten@events,
			bs=
				Dispatch@Normal@KeyMap[
					(UndirectedEdge@@#|UndirectedEdge@@Reverse@#)&@
						as[[#]]&,
					AtomsetBonds[obj]
					]
			},
			atomsetGraphEvents[basevs,bs,as,mode]
			]
		];


AtomsetGraphScan[obj:ChemObjPattern,
	startingNode:ChemObjPattern|None:None,
	mode:BreadthFirstScan|DepthFirstScan|Automatic:Automatic,
	events_:{}]:=
	With[{scanF=
		Replace[mode,
			Automatic:>
				If[
					FreeQ[events,
						("BackEdge"|"FrontierEdge"|
							"ForwardEdge"|"CrossEdge")],
					BreadthFirstScan,
					DepthFirstScan
					]
				]},
		If[startingNode===None,
			scanF[AtomsetGraph@obj,
				AtomsetGraphEvents[obj,scanF,events]
				],
			scanF[AtomsetGraph@obj,startingNode,
				AtomsetGraphEvents[obj,scanF,events]
				]
			]
		]


AtomsetConnectedComponents[obj:ChemObjPattern]:=
	With[{a=ChemGet[a,"Atoms"]},
		ConnectedComponents@(AtomsetGraph[obj])/.
			(i_Integer:>a[[i]])
		];


findRing[baseAtoms_,vds_,ed_]:=
	With[{edges1=
		Cases[ed,
			(Alternatives@@baseAtoms)\[UndirectedEdge](Alternatives@@baseAtoms)
			]
		},
		If[AllTrue[VertexDegree[edges1],GreaterThan[1]],
			baseAtoms,
			If[Sort@baseAtoms==Sort@VertexList@ed,
				$Failed,
				findRing[
					VertexList@
						Cases[ed,
							(Alternatives@@baseAtoms)\[UndirectedEdge]_|
							_\[UndirectedEdge]Alternatives@@baseAtoms],
					vds,
					ed
					]
				]
			]
		]


AtomsetRings[obj:ChemObjPattern]:=
	With[{gbase=
		AtomGraph@
			FixedPoint[
				Pick[VertexList@#,
					GreaterThan[1]/@VertexDegree@#]&@
					AtomGraph@#&,
				ChemGet[obj,"Atoms"]
				]},
		With[{
			edges=EdgeList@gbase,
			vds=AssociationThread[VertexList@gbase,VertexDegree@gbase]
			},
			With[{rings=
				DeleteCases[
					findRing[#,vds,edges]&/@
						ConnectedComponents[
							AtomGraph@Keys@Select[vds,EqualTo[2]]
							],
					$Failed
					]
				},
				DeleteDuplicates@MapIndexed[
					Replace[
						Intersection[
								Flatten@Delete[rings,First@#2],
								#
								],{
						{}->#,
						Sort[#]->#,
						l_:>
							If[
								MemberQ[rings,l]||
								!ConnectedGraphQ@
									Graph@Cases[edges,
										(Alternatives@@l)\[UndirectedEdge]
											(Alternatives@@l)
										],
								Nothing,
								l
								]
						}]&,
					rings
					]
				]
			]
		];


AtomsetConjugatedSystems[obj:ChemObjPattern]:=
	With[{atoms=ChemGet[obj,"Atoms"]},
		With[{bonds=ChemGet[atoms,"Bonds"]},
			With[{types=
				AssociationThread[
					DeleteDuplicates@Flatten@bonds,
					ChemGet[DeleteDuplicates@Flatten@bonds,"Type"]
					]},
				With[{
					mx=
						ReplacePart[
							AtomsetAdjacencyMatrix[obj],
							Join@@Table[
								If[
									Length@
										Select[bonds[[i]],types[#]>1&]==0,
									{i,j}->0,
									Nothing
									],
							{i,Length@bonds},
							{j,Length@bonds}
							]
						]
					},
				Select[ConnectedComponents@AdjacencyGraph@mx,
					Length@#>1&
					]/.i_Integer:>atoms[[i]]
				]
			]
		]
	];


AtomsetAromaticRings[obj:ChemObjPattern]:=
	With[{
		rs=AtomsetRings[obj],
		cs=AtomsetConjugatedSystems[obj]
		},
		Select[
			Intersection[rs,cs],
			With[{t=
				2*Total[
					(ChemGet[DeleteDuplicates@
						Flatten[ChemGet[#,"Bonds"]],"Type"]-1)
					]},
				Mod[t,4]==2
				]&
			]
		];


AtomsetAtomMemberQ//Clear


AtomsetAtomMemberQ[obj:ChemObjPattern,ov:ChemObjVectorPattern,"Ring"]:=
	With[{rings=Flatten@AtomsetRings[obj]},
		Replace[MemberQ[rings,#]&/@ov,
			{b_}:>b
			]
		];


AtomsetAtomMemberQ[obj:ChemObjPattern,ov:ChemObjVectorPattern,"ConjugatedSystem"]:=
	With[{rings=Flatten@AtomsetConjugatedSystems[obj]},
		Replace[MemberQ[rings,#]&/@{ov},
			{b_}:>b
			]
		];


AtomsetAtomMemberQ[obj:ChemObjPattern,ov:ChemObjVectorPattern,"AromaticRing"]:=
	With[{rings=Flatten@AtomsetAromaticRings[obj]},
		Replace[MemberQ[rings,#]&/@ov,
			{b_}:>b
			]
		];


atomsetAtomMatchQPattern=
	_String|Verbatim[Blank][]|
		_PatternTest|_Alternatives;
atomsetTypeMatchQPattern=
	_Integer|Verbatim[Blank][]|_PatternTest|
		_PatternTest|_Alternatives;


AtomsetAtomMemberQ[
	obj:ChemObjPattern,ov:ChemObjVectorPattern,
	Rule[el:atomsetAtomMatchQPattern,
		pat:{
				(
					(
						atomsetAtomMatchQPattern->
							atomsetTypeMatchQPattern
						)|
					(
						atomsetAtomMatchQPattern|
						Verbatim[BlankSequence][]|
						Verbatim[BlankNullSequence][]|
						_Repeated
						)
					)..
			}]->(
			inclusionMode:Center|Outer|String|All|atomsetAtomMatchQPattern:All
		)
	]:=
	Module[{
		atoms=ChemGet[obj,"Atoms"],
		elements,
		bondsIndexed=AtomsetBondsIndexed[obj],
		nbrs,inds,
		bpat=
			Sort@
				Replace[pat,{
					k:atomsetAtomMatchQPattern:>
						{k,_},
					Verbatim[Repeated][k_->v_,spec___]:>
						Repeated[{k,v},spec],
					(k_->v_):>{k,v}
					},
					1],
		elpat=Alternatives@@Replace[pat,(k_->_):>k,2],
		outerPat,
		corePat,
		coreElQ,
		conElQ
		},
		corePat=
			Replace[inclusionMode,{
				Center|All->el,
				String:>
					If[MatchQ[el,_String|Verbatim[Alternatives][__String]],
						el,
						None
						],
				Outer->None
				}];
		outerPat=
			Replace[inclusionMode,{
				Center->None,
				String:>
					DeleteCases[elpat,Except[_String]],
				Outer|All:>
					elpat
				}];
		elements=
			ChemGet[atoms,"Element"];
		nbrs=
			Association[
				Normal@AtomsetNeighborMap@obj/.
					c_ChemObject:>First@FirstPosition[atoms,c]
				];
		inds=
			First@FirstPosition[atoms,#]&/@ov;
		coreElQ=
			With[{i=#},
				(Length[#]>2&&
					(
						MemberQ[pat,
							Verbatim[BlankSequence][]|
							Verbatim[BlankNullSequence][]
							]||
						Length@#==Length@pat
						)&&
						With[{oinds=
							Select[#,MatchQ[elements[[#]],elpat]&
							]},
							MatchQ[
								Cases[bondsIndexed,
									(
										{i,a:Alternatives@@oinds,t_}|
										{a:Alternatives@@oinds,i,t_}
										):>{elements[[a]],t}
									],
								{OrderlessPatternSequence@@bpat}
								]
							]
					)&@nbrs[i]
				]&;
		conElQ=
			With[{i=#},
				Length[nbrs[i]]>=1&&
					With[{
						cinds=
							Select[nbrs[i],MatchQ[elements[[#]],el]&]
						},
						AnyTrue[cinds,coreElQ]
						]
				]&;
		Table[
			Switch[elements[[i]],
				corePat,
					coreElQ@i||
					(MatchQ[elements[[i]],outerPat]&&conElQ@i),
				outerPat,
					conElQ@i,
				_,
					False
				],
			{i,inds}
			]
		];


atomsetAtomMemberQMatchPats=
	<|
		"Carboxyl"->
			Rule["C",
				{
					"O"->2,
					"O"->1,
					_
					}
				],
		"Sulfate"->
			Rule["S",
				{
					"O"->2,
					"O"->2,
					"O"->1,
					"O"->1
					}
				],
		"Phosphate"->
			Rule["P",
				{
					"O"->2,
					"O"->1,
					"O"->1,
					"O"->1
					}
				],
		"Sulfone"->
			Rule["S",
				{
					"O"->2,
					"O"->2,
					_,
					_
					}
				],
		"Nitro"->
			Rule["N",
				{
					"O"->1,
					"O"->2,
					_
					}
				],
		"Amide"->
			Rule["C",
				{
					"N"->1,
					"O"->2,
					_
					}
				],
		"Methyl"->
			Rule["C",
				{
					"H"->1,
					"H"->1,
					"H"->1,
					_
					}
				],
		"Methylene"->
			Rule["C",
				{
					"H"->1,
					"H"->1,
					_,
					_
					}
				]
		|>


AtomsetAtomMemberQ[obj:ChemObjPattern,ov:ChemObjVectorPattern,
	m_String?(KeyMemberQ[atomsetAtomMemberQMatchPats,#]&)]:=
	AtomsetAtomMemberQ[
		obj,ov,
		atomsetAtomMemberQMatchPats[m]->String
		];
AtomsetAtomMemberQ[obj:ChemObjPattern,ov:ChemObjVectorPattern,
	m_String?(KeyMemberQ[atomsetAtomMemberQMatchPats,#]&)->sel_]:=
	AtomsetAtomMemberQ[
		obj,ov,
		atomsetAtomMemberQMatchPats[m]->sel
		];


AtomsetAtomMemberQ[obj:ChemObjPattern,type_String]:=
	AtomsetAtomMemberQ[obj,ChemGet[obj,"Atoms"],type];
AtomsetAtomMemberQ[obj:ChemObjPattern,ov:ChemObjPattern..,type_String]:=
	AtomsetAtomMemberQ[obj,{ov},type];


`Package`PackageAddAutocompletions[
	"AtomsetAtomMemberQ",
	{"0",#,#}
	]&@
		Cases[First/@DownValues[AtomsetAtomMemberQ],
			Verbatim[HoldPattern][
				HoldPattern[AtomsetAtomMemberQ[_,_,s_String]]
				]:>s
			]


AtomsetAromaticQ[obj:ChemObjPattern,ov:ChemObjVectorPattern]:=
	AtomsetAtomMemberQ[obj,ov,"AromaticRing"];
AtomsetAromaticQ[obj:ChemObjPattern,ob:ChemObjPattern]:=
	First@AtomsetAtomMemberQ[obj,{ob},"AromaticRing"];
AtomsetAromaticQ[obj:ChemObjPattern,ob:ChemObjPattern..]:=
	AtomsetAtomMemberQ[obj,{ob},"AromaticRing"];


(* ::Subsection:: *)
(*Atomset Point-Wise Properties*)



AtomsetMassPositions[obj:ChemObjPattern]:=
	With[{a=ChemGet[obj,"Atoms"]},
		Transpose@{
			Replace[ChemGet[a,"Mass"],{
				Quantity[m_,"AtomicMassUnit"]:>m,
				q_Quantity:>QuantityMagnitude@UnitConvert[q,"AtomicMassUnit"]
				},
				1],
			ChemGet[a,"Position"]
		}];


AtomsetCenter[obj:ChemObjPattern]:=
	Mean@ChemGet[
		ChemGet[obj,"Atoms"],
		"Position"];


AtomsetCenterOfMass[obj:ChemObjPattern]:=
	With[{a=ChemGet[obj,"Atoms"]},
		WeightedData[
			ChemGet[a,"Position"],
			ChemGet[a,"Mass"]
			]//Mean
		];


AtomsetMove[
	obj:ChemObjPattern,
	{x_,y_,z_},
	mode:"Set"|"Add":"Add"
	]:=
	With[{inc=
		If[mode==="Set",
			{x,y,z}-AtomsetCenterOfMass@obj,
			{x,y,z}
			]
		},
		AtomMove[ChemGet[obj,"Atoms"],inc,"Add"]
		];


AtomsetMove[
	obj:ChemObjPattern,
	at:ChemObjPattern?(ChemInstanceQ["Atom"])->{x_,y_,z_},
	Optional["Set","Set"]
	]:=
	With[{inc=
		{x,y,z}-ChemGet[at,"Position"]
		},
		AtomMove[ChemGet[obj,"Atoms"],inc,"Add"]
		];


AtomsetRotate[obj:ChemObjPattern,
	theta:_?NumericQ,
	axis:{_,_,_}|"A"|"B"|"C":{0,0,1},
	point:({_,_,_}|_String|_Plus):"CenterOfMass"]:=
	With[{
		rpoint=
			Replace[point,{
				"Center":>
					AtomsetCenter[obj],
				(n_+"Center"):>
					n+AtomsetCenter[obj],
				"CenterOfMass"|"COM":>
					AtomsetCenterOfMass[obj],
				(n_+"CenterOfMass"|"COM"):>
					n+AtomsetCenterOfMass[obj],
				_:>
					AtomsetCenterOfMass[obj]
				}],
		raxis=
			Replace[axis,{
				"A":>AtomsetPrincipalAxes[obj][[1]],
				"B":>AtomsetPrincipalAxes[obj][[2]],
				"C":>AtomsetPrincipalAxes[obj][[3]]
				}]
			},
		AtomRotate[ChemGet[obj,"Atoms"],theta,raxis,rpoint]
		];


AtomsetRotationTransform[
	obj:ChemObjPattern,
	theta:_?NumericQ,
	axis:{_,_,_}|"A"|"B"|"C":{0,0,1},
	point:({_,_,_}|_String|_Plus):"CenterOfMass"]:=
	With[{
		rpoint=
			Replace[point,{
				"Center":>
					AtomsetCenter[obj],
				(n_+"Center"):>
					n+AtomsetCenter[obj],
				"CenterOfMass"|"COM":>
					AtomsetCenterOfMass[obj],
				(n_+"CenterOfMass"|"COM"):>
					n+AtomsetCenterOfMass[obj],
				_:>
					AtomsetCenterOfMass[obj]
				}],
		raxis=
			Replace[axis,{
				"A":>AtomsetPrincipalAxes[obj][[1]],
				"B":>AtomsetPrincipalAxes[obj][[2]],
				"C":>AtomsetPrincipalAxes[obj][[3]]
				}]
			},
		RotationTransform[theta,raxis,rpoint]
		];


AtomsetTransform[obj:ChemObjPattern,
	mat:_List?MatrixQ|_TransformationFunction]:=
	AtomTransform[
		ChemGet[obj,"Atoms"],
		If[MatchQ[mat,_List],
			(Dot[mat,#])&,
			mat]
		];


(* ::Text:: *)
(*Essentially we should take the first axis, rotate it into the new one, and then take the second one and rotate it around the first spec in to the second*)



axisPatternBase=
	(
		ChemObjPattern?(ChemInstanceQ["Bond"])|
		"Center"|"CenterOfMass"|
		"A"|"B"|"C"|"X"|"Y"|"Z"|
		{_?NumericQ,_?NumericQ,_?NumericQ}
		);
axisPattern=axisPatternBase|-axisPatternBase;
AtomsetAxisAlignmentTransform[
	obj:ChemObjPattern,
	a:(axisPattern->axisPattern)|None,
	b:((axisPattern->axisPattern)|None):None,
	center:"Center"|"CenterOfMass":"CenterOfMass"
	]:=
	With[
		{
			com=
				Replace[center,
					{
						"CenterOfMass":>
							AtomsetCenterOfMass@obj,
						"Center":>
							AtomsetCenter@obj
						}
					],
			coords=ChemGet[ChemGet[obj,"Atoms"],"Position"],
			abc=AtomsetInertialSystem[obj][[{"AAxis","BAxis","CAxis"}]]
			},
		ChemUtilsAxisAlignmentTransform[
			Replace[a,
				(ax1_->ax2_):>
					Rule@@
						Plus[
							{com, 0},
							Replace[
								{ax1, ax2},
								{
									bond:ChemObjPattern?(ChemInstanceQ["Bond"]):>
										BondVector[bond],
									-bond:ChemObjPattern?(ChemInstanceQ["Bond"]):>
										-BondVector[bond],
									"Center"|"CenterOfMass"->com,
									-"Center"|"CenterOfMass"->-com,
									"A"->abc["AAxis"],
									-"A"->-abc["AAxis"],
									"B"->abc["BAxis"],
									-"B"->-abc["BAxis"],
									"C"->abc["CAxis"],
									-"C"->-abc["CAxis"]
									},
								1
								]
							]
				],
			Replace[b,
				(ax1_->ax2_):>
					Rule@@
						Plus[
							{com, 0},
							Replace[
								{ax1,ax2},
								{
									bond:ChemObjPattern?(ChemInstanceQ["Bond"]):>
										BondVector[bond],
									-bond:ChemObjPattern?(ChemInstanceQ["Bond"]):>
										-BondVector[bond],
									"Center"|"CenterOfMass"->com,
									-"Center"|"CenterOfMass"->-com,
									"A"->abc["AAxis"],
									-"A"->-abc["AAxis"],
									"B"->abc["BAxis"],
									-"B"->-abc["BAxis"],
									"C"->abc["CAxis"],
									-"C"->-abc["CAxis"]
									},
								1
								]
							]
				],
			com
			]
		];
AtomsetAxisAlign[
	obj:ChemObjPattern,
	a:(axisPattern->axisPattern)|None,
	b:((axisPattern->axisPattern)|None):None,
	center:"Center"|"CenterOfMass":"CenterOfMass"
	]:=
	Replace[
		AtomsetAxisAlignmentTransform[
			obj,
			a,
			b,
			center
			],
		transform_TransformationFunction:>
			AtomsetTransform[obj,transform]
		];


pt=
	ChemObjPattern?(ChemInstanceQ["Atom"])|
	"Center"|"CenterOfMass"|
	"X"|"Y"|"Z"|{_?NumericQ,_?NumericQ,_?NumericQ};


AtomsetAlignmentTransform[
	obj:ChemObjPattern,
	{a:pt,b:pt,c:pt}->
		{ta:pt,tb:pt,tc:pt}
	]:=
	With[{
		center=
			AtomsetCenter[obj],
		com=
			AtomsetCenterOfMass[obj],
		abc=AtomsetInertialSystem[obj][[{"AAxis","BAxis","CAxis"}]]
		},
		With[
			{
				pos=
					Replace[{a,b,c,ta,tb,tc},{
						"Center"->center,
						"CenterOfMass"->com,
						"A"->abc["AAxis"],
						"B"->abc["BAxis"],
						"C"->abc["CAxis"],
						o:ChemObjPattern:>
							ChemGet[o,"Position"]
						}]
				},
			ChemUtilsAlignmentTransform@
				Take[pos,{1,3}]->Take[pos,{4,6}]
			]
		];
AtomsetAlignmentTransform[
	obj:ChemObjPattern,
	b:
		{
			{_?StringQ|_?NumericQ,{_?NumericQ,_?NumericQ,_?NumericQ}},
			___
			}
	]:=
	ChemUtilsAlignmentTransform[
		AtomsetMassPositions[obj]->
			b
		];
AtomsetAlignmentTransform[
	obj:ChemObjPattern,
	b:ChemObjPattern?(ChemInstanceQ["Atomset"])
	]:=
	ChemUtilsAlignmentTransform[
		AtomsetMassPositions[obj]->
			AtomsetMassPositions[b]
		];


AtomsetAlign[
	obj:ChemObjPattern,
	b:
		(
			({pt,pt,pt}->{pt,pt,pt})|
			{{(_?StringQ)|(_?NumericQ),{_?NumericQ,_?NumericQ,_?NumericQ}},___}|
			ChemObjPattern?(ChemInstanceQ["Atomset"])
			)
	]:=
	Replace[
		AtomsetAlignmentTransform[
			obj,
			b
			],
		transform_TransformationFunction:>
			AtomsetTransform[obj,transform]
		];


(* ::Subsection:: *)
(*Atomset Rotational Properties*)



AtomsetInertialTensor[obj:ChemObjPattern]:=
	ChemUtilsInertialTensor@
		AtomsetMassPositions[obj];


AtomsetInertialEigensystem[obj:ChemObjPattern]:=
	ChemUtilsInertialEigensystem@
		AtomsetElementPositions[obj];


AtomsetInertialSystem[obj:ChemObjPattern]:=
	ChemUtilsInertialSystem@
		AtomsetInertialEigensystem[obj];


AtomsetPrincipalAxes[obj:ChemObjPattern]:=
	With[{es={1/First@#,Last@#}&@AtomsetInertialEigensystem[obj]},
		Times@@SortBy[es,First]
		];


(* ::Subsection:: *)
(*Atomset Symmetry*)



AtomsetSymmetryElements//Clear


Options[AtomsetSymmetryElements]=
	Options[ChemUtilsSymmetryElements];
AtomsetSymmetryElements[
	obj:ChemObjPattern,
	atomPattern:Except[_?OptionQ]:_,
	ops:OptionsPattern[]
	]:=
	With[{stest1=ChemGet[obj, "SymmetryElements"]},
		If[AssociationQ@stest1&&KeyMemberQ[stest1, Hash@AtomsetElementPositions[obj]],
			stest1[Hash@AtomsetElementPositions[obj]],
			With[{
				smells=ChemUtilsSymmetryElements[
					Cases[AtomsetElementPositions[obj],atomPattern],
					ops
					]},
				ChemSet[obj, "SymmetryElements", 
					<|Hash@AtomsetElementPositions[obj]->smells|>];
				smells
				]
			]
		]


AtomsetInertialSymmetry[obj:ChemObjPattern]:=
	ChemUtilsInertialSymmetry@
		AtomsetElementPositions@obj;


AtomsetPointGroup//Clear


Options[AtomsetPointGroup]=
	Options[ChemUtilsPointGroup];
AtomsetPointGroup[
	obj:ChemObjPattern,
	atomPattern:Except[_?OptionQ]:_,
	ops:OptionsPattern[]
	]:=
	ChemUtilsPointGroup[
		AtomsetSymmetryElements[obj, atomPattern, ops]
		]


(* ::Subsection:: *)
(*Atomset Surface Properties*)



(* ::Subsubsection::Closed:: *)
(*VdWSurface*)



Options[AtomsetVdWSurface]=
	Options@BoundaryDiscretizeRegion;
AtomsetVdWSurface[obj:ChemObjPattern,ops:OptionsPattern[]]:=
	With[{atoms=ChemGet[obj,"Atoms"]},
		With[{
			radii=QuantityMagnitude/@ChemGet[atoms,"Radius"],
			positions=ChemGet[atoms,"Position"]
			},
			BoundaryDiscretizeRegion[
				RegionUnion@@MapThread[Ball,{positions,radii}],
				ops,
				PlotTheme->"SmoothShading"
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*VdWVolume*)



AtomsetVdWVolume[obj:ChemObjPattern]:=
	Quantity[Volume@AtomsetVdWSurface[obj],"Angstroms"^3];


(* ::Subsubsection::Closed:: *)
(*PartialCharges*)



atomsetGastInitialCharges[obj:ChemObjPattern]:=
	With[{
		phos=AtomsetAtomMemberQ[obj,"Phosphate"],
		sulf=AtomsetAtomMemberQ[obj,"Sulfate"],
		carb=AtomsetAtomMemberQ[obj,"Carboxyl"],
		formal=(0.0)&/@ChemGet[obj,"Atoms"],
		elements=ChemGet[ChemGet[obj,"Atoms"],"Element"]
		},
		Table[
			If[
				elements[[i]]=="O",
					Which[
						carb[[i]],
							-.5,
						phos[[i]],
							-.666,
						sulf[[i]],
							-.5,
						True,
							formal[[i]]
						],
				formal[[i]]
				],
			{i,Length@elements}
			]		
		];


atomsetGastSigmaChi[atom_]:=
	Block[{
		gscVal={0,0,0}
		},
		Switch[
			ChemGet[atom,"AtomicNumber"],
			1,
				gscVal={.37,7.17,12.85},
			6,
				Switch[AtomHybridization@atom,
					"sp",
						gscVal={.68,7.98,19.04},
					"sp2",
						gscVal={.98,8.79,19.62},
					"sp3",
						gscVal={1.67,10.39,20.57}
					],
			7,
				Switch[AtomHybridization@atom,
					"sp3",
						If[Length@ChemGet[atom,"Bonds"]==4,
							gscVal={0.0,0.0,23.72},
							gscVal={2.08,11.54,23.72}
							],
					"sp2",
						gscVal={2.57,12.87,24.87},
					"sp",
						gscVal={2.71,15.68,27.11}
					],
			8,
				Switch[AtomHybridization@atom,
					"sp3",
						gscVal={2.65,14.81,28.94},
					"sp2",
						gscVal={3.75,17.07,31.33}
					],
			9,
				gscVal={3.12,14.66,30.82},
      15,
      	gscVal={1.62,8.90,18.10},
      16,
        If[True(*CountFreeOxygens<2*),
        	gscVal={2.39,10.14,20.65},
        	gscVal={2.39,12.00,24.00}
        	],
      17,
      	gscVal={2.66,11.00,22.04},
      35,
      	gscVal={2.77,10.08,19.71},
      53,
      	gscVal={2.90,9.90,18.82},
      13,
        gscVal={1.06,5.47,11.65}
        ];
     If[(gscVal[[3]]>.001),
     	True->
     		ReplacePart[gscVal,{
     			2->(gscVal[[3]]-gscVal[[1]])/2,
     			3->(gscVal[[3]]+gscVal[[1]])/2-gscVal[[2]]
     			}],
     	False->gscVal
     	]
		]


atomsetGastAssign[obj:ChemObjPattern,log:True|False:False]:=
	Block[{
		gastAtoms=ChemGet[obj,"Atoms"],
		gastBonds,
		gastState,
		gastDenom,gastA,gastB,gastC,
		gastSrc,gastDst,gastCharge,
		gastAlpha=1.0,
		gastDampening=.5,gastDefaultDenom=20.02,
		gastIters=6,gastLog={}
		},
		gastBonds=
			DeleteDuplicates[Join@@ChemGet[gastAtoms,"Bonds"]];
		gastState=
			atomsetGastInitialCharges[obj];
		gastState=
			AssociationThread[gastAtoms,
				Table[
					Replace[atomsetGastSigmaChi@gastAtoms[[i]],{
						(True->{a_,b_,c_}):>
							<|
								"a"->a,
								"b"->b,
								"c"->c,
								"chi"->0.0,
								"denom"->a+b+c,
								"q"->gastState[[i]]
								|>,
						(False->_):>
							$Failed
						}],
					{i,Length@gastAtoms}
					]
				];
		If[MemberQ[gastState,$Failed],Return@$Failed];
		Do[
			gastAlpha*=gastDampening;
			Do[
				gastState[gastAtom]["chi"]=
					Block[{tempa,tempb,tempc,tempq},
						{tempa,tempb,tempc}=
							Lookup[gastState[gastAtom],{"a","b","c"}];
						tempq=gastState[gastAtom]["q"];
						
						tempa+
							tempb*tempq+
							tempc*tempq*tempq
						],
				{gastAtom,gastAtoms}
				];
			Do[
				{gastSrc,gastDst}=ChemGet[gastBond,"Atoms"];
				With[{ga=
					First@MaximalBy[
						{gastSrc,gastDst},
						gastState[#,"chi"]&
						]},
					If[ChemGet[ga,"Element"]=="H",
						gastDenom=gastDefaultDenom,
						gastDenom=gastState[ga,"denom"]
						];
					];
				gastCharge=
					(gastState[gastSrc,"chi"]-gastState[gastDst,"chi"])/
						gastDenom;
				gastState[gastSrc,"q"]-=gastAlpha*gastCharge;
				gastState[gastDst,"q"]+=gastAlpha*gastCharge,
				{gastBond,gastBonds}];
			If[log,
				AppendTo[gastLog,gastState]
				],
			{gastIter,gastIters}
			];
		If[log,
			gastLog,
			gastState
			]
		];


AtomsetPartialCharges[
	obj:ChemObjPattern,
	mode:"Cached"|"Gasteiger":"Cached"]:=
	Module[{
		ats=ChemGet[obj,"Atoms"],
		pCharge
		},
		Switch[mode,
			"Cached",
				pCharge=ChemGet[ats,"PartialCharge",Automatic];
				If[AnyTrue[pCharge,Not@*NumericQ],
					Replace[ChemGet[obj,"MMFF94PartialCharges"],
						{
							{
								{n_},
								p__
								}:>
								Set[
									AtomPartialCharge[ats],
										Join[
											Map[Last,{p}],
											ConstantArray[0.,Length[ats]-n]
											]
									],
							_:>
								Replace[atomsetGastAssign[obj],
									a_Association:>
										Set[
											AtomPartialCharge[Keys[a]],
											Lookup[Values[a],"q"]
											]
									]
							}
						];
					pCharge=ChemGet[ats,"PartialCharge",0.];
					],
				"Gasteiger",
					pCharge=
						Replace[atomsetGastAssign[obj],
							a_Association:>
								Lookup[Values[a],"q"]
							]
				];
			Thread[{pCharge,ChemGet[ats,"Position"]}]
		];


AtomsetPartialCharges/:
	Unset[AtomsetPartialCharges[obj:_?(MatchQ[ChemObjPattern])]]:=
		With[{g=ChemGet[obj,"Atoms"]},
			AtomPartialCharge[g]=.
			];
AtomsetPartialCharges/:
	Set[AtomsetPartialCharges[obj:_?(MatchQ[ChemObjPattern])],v_List]:=
		With[{g=ChemGet[obj,"Atoms"]},
			If[Length[v]===Length[g],
				AtomPartialCharge[g]=v,
				$Failed
				]
			];
AtomsetPartialCharges/:
	SetDelayed[AtomsetPartialCharges[obj:_?(MatchQ[ChemObjPattern])],v_List]:=
		With[{g=ChemGet[obj,"Atoms"]},
			If[Length[Unevaluated[v]]===Length[g],
				AtomPartialCharge[g]:=v,
				$Failed
				]
			];
AtomsetPartialCharges/:
	SetDelayed[AtomsetPartialCharges[obj:_?(MatchQ[ChemObjPattern])],v_]:=
		With[{g=ChemGet[obj,"Atoms"]},
			AtomPartialCharge[g]:=v
			]


(* ::Subsubsection::Closed:: *)
(*ElectricPotential*)



Options[AtomsetElectricPotential]=
	{
		"Mode"->"Cached"
		};
AtomsetElectricPotential[
	obj:ChemObjPattern,
	ops:OptionsPattern[]
	]:=
	With[{
		mode=
			Replace[
				Replace[
					s_String:>(
						ToUpperCase@StringTake[s,1]<>
							ToLowerCase@StringTake[s,{2,-1}]
					)]@OptionValue["Mode"],
				Except["Cached"|"Gasteiger"|"Psi4"]->"Cached"
				]
		},
		Switch[
			mode,
			"Psi4",
				Block[{$CubeFileCacheDepth=\[Infinity]},
					With[{
						esp=
							$Psi4@Psi4CubeElectrostaticPotential[AtomsetElementPositions@obj]
						},
						CubeFileFunction@CubeFileRead[esp["ESP.cube"]]
						]
					],
			_,
				Replace[AtomsetPartialCharges[obj,mode],
					c_List:>
						With[{k=8.9875517873681764*^9},
							With[{charges=c[[All,1]],points=c[[All,2]]},
								Compile[{{p,_Real,1}},
									Total@
										MapThread[
											k*#2/(Norm@(p-#)+10.^-15)&,
											{points,charges}]
									]
								]
							]
					]
			]
		];


(* ::Subsubsection::Closed:: *)
(*ElectricPotentialMap*)



Options[AtomsetElectricPotentialMap]=
	Join[
		Options@ChemSurfacePlot,
		Options[AtomsetElectricPotential]
		];
AtomsetElectricPotentialMap[
	obj:ChemObjPattern,
	ops:OptionsPattern[]
	]:=
	Replace[
		AtomsetElectricPotential[obj,
			FilterRules[{ops},Options[AtomsetElectricPotential]]
			],{
		f_CompiledFunction:>
			ChemSurfacePlot[
				f,
				obj,
				ops,
				ColorFunction->
					ColorData@{"DarkRainbow","Reverse"}
				]
		}];


(* ::Subsubsection::Closed:: *)
(*PolarMoment*)



(*AtomsetPolarMoment[system_String,id_,
	point:{_,_,_}|"Center"|"CenterOfMass"|Function:"CenterOfMass"]:=
	With[{atoms=ChemGet[system,id,"Atoms"]},
		With[{
			positions=ChemGet["Position"]/@atoms,
			ens=ChemGet["Electronegativity"]/@atoms
			},
			If[point===Function,
				Compile[{{center,_Real,1}},
					ens*
					Map[With[{v=Subtract[#,center]},v/((1+Norm@v)^2)]&,
						positions]//Total
					],
				With[{center=
					Switch[point,
						"Center",
							Mean@positions,
						"CenterOfMass",
							Mean@WeightedData[positions,QuantityMagnitude@*ChemGet["Mass"]/@atoms],
						_,
							point
						]},
					ens*
						Map[With[{v=Subtract[#,center]},v/((1+Norm@v)^2)]&,
							positions]//Total
					]
				]
			]
		];
AtomsetPolarMoment[ChemObject[system_,id_],s___]:=
	AtomsetPolarMoment[system,id,s];*)


(* ::Subsubsection::Closed:: *)
(*PolarCenter*)



(*AtomsetPolarCenter[system_String,id_,
	testPoint:{_?NumericQ,_?NumericQ,_?NumericQ}|"Center"|"CenterOfMass":"Center",
	steps_Integer:100,
	convergence_Real:.1
	]:=
	With[{
		pt=
			Switch[testPoint,
				"Center",
					AtomsetCenter[system,id],
				"CenterOfMass",
					AtomsetCenterOfMass[system,id],
				_,
					testPoint
				],
		pf=AtomsetPolarMoment[system,id,Function]
		},
			FixedPoint[
				#+convergence*Normalize@pf[#]&,
				pt,
				steps,
				SameTest\[Rule](Abs[(#2-#)]<convergence&)
				]
		];
AtomsetPolarCenter[ChemObject[system_,id_],a___]:=
	AtomsetPolarCenter[system,id,a];*)


(* ::Subsubsection::Closed:: *)
(*PolarMomentPlot*)



(*AtomsetPolarMomentPlot[system_,id_]:=
	Show[
		ChemSurfacePlot[
			AtomsetVdWSurface[system,id],
			Norm@*AtomsetPolarMoment[system,id,Function],
			Mean,
			({Hue[.8*#],Opacity[.8]}&)
			],
		ChemView[system,id]
		];
AtomsetPolarMomentPlot[ChemObject[system_,id_]]:=
	AtomsetPolarMomentPlot[system,id];*)


(* ::Subsubsection::Closed:: *)
(*Polarization*)



(*AtomsetPolarization[system_,id_]:=
	With[{c=AtomsetCenter[system,id]},
		AtomsetPolarCenter[system,id]-c
		];
AtomsetPolarization[ChemObject[system_,id_]]:=
	AtomsetPolarization[system,id];*)


(* ::Subsection:: *)
(*Atomset QChem*)



(*Options[AtomsetPsi4Call]={
	"Function"\[Rule]Automatic
	};
AtomsetPsi4Scan[
	obj:ChemObjPattern,
	specs:{(ChemObjPattern\[Rule](_List|_Integer))..},
	ops:OptionsPattern[]]:=
	Psi4ConfigureCall
		
		);*)


Options[AtomsetOrbitals]=
	{
		"Mode"->"Psi4",
		"Orbitals"->All
		};
AtomsetOrbitals[
	obj:ChemObjPattern,
	ops:OptionsPattern[]
	]:=
	With[{
		mode=
			Replace[
				Replace[
					s_String:>(
						ToUpperCase@StringTake[s,1]<>
							ToLowerCase@StringTake[s,{2,-1}]
					)]@OptionValue["Mode"],
				Except["Cached"|"Psi4"]->"Psi4"
				],
		which=
			Replace[
				OptionValue["Orbitals"],
				Except[_Span|_Integer|_String|{__Integer}|{__String}]->All
				]
		},
	Switch[mode,
		"Cached",
			With[{orbitals=
				Replace[
					ChemGet[obj,"Orbitals"],
					Except[
						KeyValuePattern[{_->_CompiledFunction}]|
							{__CompiledFunction}
						]:>
						With[{orbs=AtomsetOrbitals[obj]},
							ChemSet[obj,"Orbitals",orbs];
							orbs
							]
					]
				},
				Switch[which,
					All,
						orbitals,
					_Integer,
						orbitals[[Range[which]]],
					{__Integer}|_Span,
						orbitals[[which]],
					_String|{__String},
						AssociationThread[Flatten@{which},
							Lookup[orbitals,Flatten@{which}]],
					_,
						$Failed
					]
				],
		"Psi4",
			Block[{$CubeFileCacheDepth=\[Infinity]},
				With[{
					cube=
						KeyMap[
							StringRiffle@
								ToUpperCase@Rest@StringSplit[StringTrim[#,".cube"],"_"]&
							]@
						$Psi4[Psi4CubeOrbitals[AtomsetElementPositions@obj]][[1,"OutputFiles"]]
					},
					CubeFileFunction@*CubeFileRead/@
						Switch[which,
							All,
								cube,
							_Integer,
								cube[[Range[which]]],
							{__Integer}|_Span,
								cube[[which]],
							_String|{__String},
								AssociationThread[Flatten@{which},Lookup[cube,Flatten@{which}]],
							_,
								$Failed
							]
					]
				]
			]
		];


Options[AtomsetOrbitalsPlot]=
	Join[
		Options[AtomsetOrbitals],
		{
			"PlotFunction"->Automatic,
			"ShowFunction"->Show,
			Quiet->True
			},
		(*{
			"OpacityFunction"->
				(Power[#,2]&)
			},*)
		Options[DensityPlot3D],
		{
			Contours->{-.0005,.0005},
			ContourStyle->{Blue,Red},
			Lighting->{{"Ambient",GrayLevel[.95]}},
			MeshStyle->GrayLevel[.5,.5]
			},
		Options[ContourPlot3D]
		];
AtomsetOrbitalsPlot[
	obj:ChemObjPattern,
	orbs:{__CompiledFunction},
	ops:OptionsPattern[]
	]:=
	With[{plotf=
		Replace[OptionValue["PlotFunction"],{
			"Density"->DensityPlot3D,
			"Lobes"->ContourPlot3D,
			Except[DensityPlot3D|ContourPlot3D]->ContourPlot3D
			}]
		},
		Block[{x,y,z},
				Replace[OptionValue["ShowFunction"],{
					"GIF"->
						(
							ListAnimate[
								Table[
									Rasterize[
										Show[#[[1]],#[[wfn+1]]],
										ImageResolution->120
										],
									{wfn,1,Length[#]-1}
									]
								]&
							),
					Manipulate->(
						Manipulate[
							Show[#[[1]],#[[wfn+1]]],
							{{wfn,1,"\[Psi]"},1,Length[#]-1,1}
							]&
						),
					List->
						(Rest)
					}]@
					Prepend[
						Function[Null,
							If[OptionValue[Quiet]//TrueQ,
								Quiet[#,CompiledFunction::cfta],
								#
								],
							HoldAllComplete
							]@
						plotf[
							#[{x,y,z}],
							Evaluate[
								Sequence@@
									MapThread[
										Prepend[#,#2]&,{
											First@FirstCase[#,_InterpolatingFunction,None,\[Infinity]],
											{x,y,z}
											}
										]
								],
							Evaluate@FilterRules[
								Flatten@{ops,Options[AtomsetOrbitalsPlot]},
								Options[plotf]
								]
							]&/@orbs,
						ChemView[obj]
						]
			]
		];
AtomsetOrbitalsPlot[
	obj:ChemObjPattern,
	a_Association,
	ops:OptionsPattern[]
	]:=
	With[{plot=AtomsetOrbitalsPlot[obj,Values[a],ops]},
		plot/;Head[plot]=!=AtomsetOrbitalsPlot
		];
AtomsetOrbitalsPlot[
	obj:ChemObjPattern,
	ops:OptionsPattern[]
	]:=
	AtomsetOrbitalsPlot[obj,
		Values@
			AtomsetOrbitals[obj,
				FilterRules[{ops},Options[AtomsetOrbitals]]],
		ops
		]


Options[AtomsetPsi4Scan]=
	Join[
		{
			"Function"->Automatic,
			"Configuration"->Automatic
			},
		Options[Psi4Scan]
		];
AtomsetPsi4Scan[
	obj:ChemObjPattern,
	specs:{(ChemObjPattern->{{_,_,_}..})..},
	ops:OptionsPattern[]
	]:=
	Module[{
		atoms=ChemGet[obj,"Atoms"],
		apos=AtomsetElementPositions[obj],
		scans
		},
		scans=
			DeleteCases[
				FirstPosition[atoms,First[#],None]->Last[#]&/@specs,
				None->_
				];
		apos=
			ReplacePart[apos,
				MapIndexed[
					Append[First[#],2]->
						StringJoin/@
							Thread[{{"x","y","z"},ToString@First@#2}]&,
					scans
					]
				];
		Psi4Scan[
			<|
				ops,
				"Molecules"->
					("mol"->apos),
				"Scan"->
					MapIndexed[
						{"pos_"<>ToString@First@#2,Last[#]}&,
						scans
						],
				"Configuration"->
					Replace[OptionValue["Configuration"],
						Automatic:>
							<|
								"basis"->"cc-pvdz",
								"scf_type"->"pk"
								|>
						],
				"Function"->
					With[{
						f=
							ToSymbolicPython@
								Replace[OptionValue["Function"],
									Automatic:>PyCall["energy"][PyString@"scf"]
									],
						blocks=
							Map[
								StringTemplate["mol.x`1`, mol.y`1`, mol.z`1` = pos_`1`"],
								Range@Length@scans
								]
						},
						PyColumn@
							Append[blocks,f]
						]
				|>
			]
		];
AtomsetPsi4Scan[
	obj:ChemObjPattern,
	specs:(ChemObjPattern->{{_,_,_}..}),
	ops:OptionsPattern[]
	]:=
	AtomsetPsi4Scan[obj,{specs},ops]


Options[AtomsetEnergy]=
	Options[Psi4Energy];
AtomsetEnergy[obj:ChemObjPattern,ops:OptionsPattern[]]:=
	$Psi4@
		Psi4Energy[
			AtomsetElementPositions@obj,
			ops
			]


atomsetEnergyScanPrepSpec[p:{{_,_,_}..}]:=p;
atomsetEnergyScanPrepSpec[
	{
		{{xm_,xM_},{ym_,yM_},{zm_,zM_}},
		{xD_Integer,yD_Integer,zD_Integer}
		}
	]:=
	Tuples[{Subdivide[xm,xM,xD],Subdivide[ym,yM,yD],Subdivide[zm,zM,zD]}];
atomsetEnergyScanPrepSpec[p_->f_]:=
	With[{r=atomsetEnergyScanPrepSpec[p]},
		f/@r/;ListQ[r]
		];


AtomsetEnergyScan//Clear


Options[AtomsetEnergyScan]=
	Options[AtomsetPsi4Scan];
AtomsetEnergyScan[obj:ChemObjPattern,
	specs:{(ChemObjPattern->_)..},
	ops:OptionsPattern[]
	]:=
	With[{s=atomsetEnergyScanPrepSpec@*Last/@specs},
		Thread[{
			If[Length@specs>1,
				Tuples[s],
				First@s
				],
			Fold[
				Lookup,
				Psi4DataParseGeometry@
					$Psi4[
						AtomsetPsi4Scan[
							obj,
							Thread[Map[First,specs]->s],
							ops
							]
						]["output.dat"],
				{"Properties","TotalEnergy"}
				]
			}]/;AllTrue[s,ListQ]
		];
AtomsetEnergyScan[
	obj:ChemObjPattern,
	specs:(ChemObjPattern->_),
	ops:OptionsPattern[]
	]:=
	AtomsetEnergyScan[obj,{specs},ops]


(* ::Subsection:: *)
(*Atomset Graphics*)



Options[AtomsetGraphic]=
	Join[
		Options@AtomGraphic,
		Options@BondGraphic
		];
AtomsetGraphic[obj:ChemObjPattern,ops:OptionsPattern[]]:=
	With[{a=DeleteDuplicates@ChemGet[obj,"Atoms"]},
		With[{b=
			Pick[#,
				Map[Length@Intersection[a,#]==2&,ChemGet[#,"Atoms"]]
				]&@
					DeleteDuplicates@Flatten@ChemGet[a,"Bonds"]
				},
			{
				BondGraphic[b,
					FilterRules[{ops},
						Options[BondGraphic]
						]
					],
				AtomGraphic[a,
					FilterRules[{ops},
						Options[AtomGraphic]
						]
					]
				}
			]
		];


symmetryGraphics[as_,
	atoms_:{Except@_String?(StringMatchQ[("H"|"Hydrogen")~~(NumberString|"")]),_}
	]:=
	With[{eps=AtomsetElementPositions@as},
		If[Length[eps]>2,
			ChemUtilsSymmetryGraphicsObjects[
				If[Length@Cases[eps,atoms]>3,Cases[eps,atoms],eps]
				],
			{}
			]
		]


axesGraphics[as_,
	drawAxes:{{_,_,_},{_,_,_},{_,_,_}}|"Inertial":"Inertial",
	origin:{_,_,_}|"Center"|"CenterOfMass"|True|False:"Center"]:=
	With[{
			c=
				Replace[origin,{
					"CenterOfMass"|True:>AtomsetCenterOfMass@as,
					"Center"|False:>AtomsetCenter@as
					}],
			axes=
				If[drawAxes==="Inertial",
					Lookup[AtomsetInertialSystem@as,{"AAxis","BAxis","CAxis"}],
					Normalize/@drawAxes
					],
			m=.5+Max@
					Map[Abs,
						Thread@CoordinateBoundingBox[ChemGet[ChemGet[as,"Atoms"],"Position"]]
						]},
			{
				AbsoluteThickness[2],
				Arrowheads[{-.05,.05},Appearance->"Projected"],
				MapThread[{#2,Arrow@{c-m*#,c+m*#},Inset[#3,c+(.1+m)*#]}&,
					{
						axes,
						{Hue[.1,.5,.8],Hue[.4,.5,.5],Hue[0,1,.65]},
						{"A","B","C"}
						}
					]
				}
		]


Options[AtomsetGraphic3D]:=
	Options[AtomsetGraphic3D]=
	Normal@
		Merge[Flatten@{
			Options@AtomGraphic3D,
			Options@BondGraphic3D,
			Options[AtomsetGraphic],
			"UseAxes"->Automatic,
			"UseOrigin"->Automatic,
			"InertialAxes"->False,
			"SymmetryElements"->None,
			"SymmetryAtoms"->
				Except["H"|"D"|"H2"|"T"|"H3"],
			"SymmetryCoordinates"->
				_,
			"CenterOfMass"->False,
			"OriginFunction"->Point
			},
		Last
		];
AtomsetGraphic3D[obj:ChemObjPattern,ops:OptionsPattern[]]:=
	With[{a=DeleteDuplicates@ChemGet[obj,"Atoms"]},
		With[{b=
			Pick[#,
				Map[
					Length@Intersection[a,#]==2&,
					ChemGet[#, "Atoms"]]
				]&@
					DeleteDuplicates@Flatten@ChemGet[a,"Bonds"]
				},
			{
				If[Length@a>0,
					AtomGraphic3D[a,
						FilterRules[{
							ops
							},
							Options@AtomGraphic3D
							]
						],
					Nothing
					],
				If[Length@b>0,
					BondGraphic3D[b,
						FilterRules[{ops},Options@BondGraphic3D]],
					Nothing
					],
				If[Length@a>0,{
					Replace[OptionValue@"UseAxes",{
						Automatic:>
							If[OptionValue@"InertialAxes"//TrueQ,
								axesGraphics[
										obj,
										"Inertial",
										Replace[OptionValue@"UseOrigin",
											Automatic:>
												TrueQ@OptionValue@"CenterOfMass"
											]
										],
								Nothing
								],
						l_List:>
							Replace[
								axesGraphics[obj,l,
									Replace[OptionValue@"UseOrigin",
											Automatic:>
												TrueQ@OptionValue@"CenterOfMass"
											]
									],
								Except[_List]:>Nothing
								],
						_->Nothing
						}],
					Switch[OptionValue@"SymmetryElements",
						All,
							Values@
								symmetryGraphics[obj,{
									OptionValue@"SymmetryAtoms",
									OptionValue@"SymmetryCoordinates"
									}],
						_List|_String,
							Lookup[
								symmetryGraphics[obj,{
									OptionValue@"SymmetryAtoms",
									OptionValue@"SymmetryCoordinates"
									}],
								OptionValue@"SymmetryElements",
								Null
								],
						_,
							Nothing
						],
					Replace[OptionValue@"UseOrigin",{
						Automatic:>
							If[TrueQ@OptionValue@"CenterOfMass",
								OptionValue["OriginFunction"]@AtomsetCenterOfMass[obj]
								],
						l:{_,_,_}:>
							OptionValue["OriginFunction"]@l
						}]
					},
				Nothing
				]
			}]
		];


(* ::Subsection:: *)
(*Wrappers*)



validAtomsetWrapperQ[a_Association]:=
	MatchQ[a["Atoms"],{{_String,{_?NumericQ,_?NumericQ,_?NumericQ}}..}]&&
		MatchQ[a["Bonds"],{{_Integer,_Integer,___?NumericQ}...}];


AtomsetWrapper/:
	HoldPattern[
		CreateAtomset[AtomsetWrapper[a_?validAtomsetWrapperQ]]
		]:=
		With[{atoms=a["Atoms"],bonds=a["Bonds"]},
			CreateAtomset[$ChemDefaultSystem,
				Join[
					{{Length@atoms,Length@bonds}},
					atoms,
					bonds
					]
				]
			];


AtomsetWrapper[elements:({{_String},{_String,_},___}|{{_,_},___})]:=
	Replace[CreateAtomset[$ChemDefaultSystem,elements],{
		Except[_ChemObject]->$Failed,
		co_:>
			With[{w=AtomsetWrapper@co},
				ChemRemove@co;
				w
				]
		}];
AtomsetWrapper[co:ChemObjPattern]:=
	With[{t=AtomsetMolTable@co},
		With[{a=t[[1,1]],b=t[[1,2]]},
			AtomsetWrapper@<|
				"Atoms"->If[a>0,t[[ 2;;1+a ]],{}],
				"Bonds"->If[b>0,t[[ 2+a;; ]],{}]
				|>
			]
		]


atomsetWrapperAppliableQ[s_]:=
	MatchQ[Unevaluated[s],
		Except[CreateAtomset|_List|_Association|_Dataset]
		]&&
	Context[Unevaluated@s]=!="System`";
atomsetWrapperAppliableQ~SetAttributes~HoldFirst;


AtomsetWrapper/:
	HoldPattern[
		(c_?atomsetWrapperAppliableQ)[
			AtomsetWrapper[a_?validAtomsetWrapperQ],
			args___
			]
		]:=
		With[{as=CreateAtomset@AtomsetWrapper[a]},
			With[{r=c[as,args]},
				ChemRemove@as;
				r
				]
			];


(* ::Subsection:: *)
(*Format*)



AtomsetWrapper[s_String]:=
	Replace[ChemImport[s],
		o_ChemObject:>
			With[{a=AtomsetWrapper[o]},
				ChemRemove@o;
				a
				]
		];


Format[AtomsetWrapper[a_?validAtomsetWrapperQ]]:=
	RawBoxes@BoxForm`ArrangeSummaryBox[
		"AtomsetWrapper",
		AtomsetWrapper[a],
		None,
		{
			BoxForm`MakeSummaryItem[{"Atom Count: ",Length@a["Atoms"]},StandardForm],
			BoxForm`MakeSummaryItem[{"Bond Count: ",Length@a["Bonds"]},StandardForm]
			},
		{
			BoxForm`MakeSummaryItem[{"Atoms:",a["Atoms"]},StandardForm],
			BoxForm`MakeSummaryItem[{"Bonds: ",a["Bonds"]},StandardForm]
			},
		StandardForm
		];	


End[];



