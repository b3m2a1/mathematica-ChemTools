(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Subsection:: *)
(*Manipulation*)



ChemMove::usage=
	"Generalizes \[Star]Move operations";
ChemRotate::usage=
	"Generalizes \[Star]Rotate operations";
ChemTransform::usage=
	"Generalizes \[Star]Transform operations";


(* ::Subsection:: *)
(*Visualization*)



(* ::Subsubsection::Closed:: *)
(*View*)



ChemView::usage="Views a ChemObject";
ChemViewList::usage=
	"ChemView / Manipulate combo";


(* ::Subsubsection::Closed:: *)
(*Surface*)



ChemSurface::usage="Generates a surface from a graphic or ChemObject";
ChemSurfacePlot::usage="Plots a function on a surface";


(* ::Subsubsection::Closed:: *)
(*Animate*)



ChemAnimate::usage=
	"Animates a command and view expression. 
Just ListAnimate / Table / Interpretation joined";
ChemSaveAnimation::usage=
	"Exports a set of frames to a file";


Begin["`Private`"];


(* ::Subsection:: *)
(*Manipulations*)



(* ::Subsubsection::Closed:: *)
(*GetApply*)



ChemGetApply[obj:ChemManyPattern,prop_,args___]:=
	With[{attrs=
		Block[{$ChemFormatMethods=True},
			ChemGet[Flatten@obj,prop]
			]
		},
		If[ListQ@attrs,
			Through[Map[Apply,attrs][{args}]],
			attrs[args]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Move*)



ChemMove[obj:ChemManyPattern, pt_,mode:"Set"|"Add":"Add"]:=
	(ChemGetApply[obj,"Move",pt,mode];);
ChemMove[pt_,mode:"Set"|"Add":"Add"][obj:ChemManyPattern]:=
	ChemMove[obj,pt,mode];


(* ::Subsubsection::Closed:: *)
(*Rotate*)



ChemRotate[obj:ChemManyPattern,theta_,axis_:{0.,0.,1.},pt_:{0.,0.,0.}]:=
	(ChemGetApply[obj,"Rotate",
		theta,axis,pt];);
ChemRotate[theta_,axis_:{0.,0.,1.},pt_:{0.,0.,0.}][obj:ChemManyPattern]:=
	ChemRotate[obj,theta,axis,pt];


(* ::Subsubsection::Closed:: *)
(*Transform*)



ChemTransform[obj:ChemManyPattern,transf_]:=
	(ChemGetApply[obj,"Transform",transf];);
ChemTransform[transf_][obj:ChemManyPattern]:=
	ChemTransform[obj,transf];


(* ::Subsection:: *)
(*Views*)



(* ::Subsubsection::Closed:: *)
(*View*)



ChemView[obj:ChemManyPattern,mode:"2D"|"3D":"3D",
	directives:(Except[_String|_Rule|_RuleDelayed])...,
	ops:OptionsPattern[]]:=
	Switch[mode,
		"2D",
			Graphics[{
				directives,
				ChemGetApply[obj,
					"Graphic",
					FilterRules[{ops},
						Except[Alternatives@@Map[First,Options@Graphics]]
						]
					]
				},
				FilterRules[
					{ops},
					Options@Graphics
					]
				],
		"3D",
			Graphics3D[{
				directives,
				ChemGetApply[
					obj,
					"Graphic3D",
					FilterRules[{ops},
						Except[Alternatives@@Map[First,Options@Graphics3D]]
						]
					]
				},
				FilterRules[
					{ops,"Lighting"->"Neutral",Boxed->False},
					Options@Graphics3D
					]
				]
		];


ChemView[obj:ChemManyPattern,"Atoms",a___]:=
	ChemView[obj,"3D",
		a,
		"AtomicRadius"->.15,
		"BondThickness"->0
		];
ChemView[obj:ChemManyPattern,"Bonds",a___]:=
	ChemView[obj,"3D",
		a,
		"AtomicRadius"->0.,
		"BondThickness"->.1
		];
ChemView[obj:ChemManyPattern,"SpaceFilling",a___]:=
	ChemView[obj,"3D",
		a,
		"RadiusScaling"->1,
		"AtomicRadius"->Automatic
		];
ChemView[obj:ChemManyPattern,"TraditionalForm",a___]:=
	ChemView[obj,"3D",
		Specularity[White,100],
		a
		];
ChemView[obj:ChemManyPattern,"Tube",a___]:=
	ChemView[obj,"3D",
		Specularity[White,100],
		a,
		"AtomicRadius"->.15,
		"BondThickness"->.15,
		"DoubleBondSeparation"->None,
		"TripleBondSeparation"->None
		];
ChemView[obj:ChemManyPattern,"Line",a___]:=
	ChemView[obj,"3D",
		Specularity[White,100],
		a,
		"AtomicRadius"->.01,
		"BondThickness"->.01,
		"DoubleBondSeparation"->None,
		"TripleBondSeparation"->None
		];


ChemView[s:(_String|_Integer|{(_String|_Integer)..}),a___]:=
	Replace[ChemImport@s,
		c:ChemObjAllPattern:>
			With[{g=ChemView[c,a]},
				ChemRemoveRecursive@c;
				g
				]
		];	


(* ::Subsubsection::Closed:: *)
(*ViewList*)



ChemViewList[l_List,ops___]:=
	With[{
		len=Length@l,
		barSize=Rasterize[Slider[],"RasterSize"],
		bW=25
		},
		Manipulate[
			ChemView[l[[i]],ops],
			Framed[
				Grid[
					{
						{
							Button[
								Style["\[LeftTriangleBar]",Gray],
								i=1,
								Appearance->"AbuttingRight"(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,Last@barSize}*)],
							Button[
								Style["\[LeftTriangle]",Gray],
								i=Max@{i-1,1},
								Appearance->"AbuttingLeftRight"(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,Last@barSize}*)],
							Framed[
								Control@{{i,1,""},1,Length@l,1,
									ControlType->Manipulator},
								FrameMargins->{{0,10},{-1,-1}},
								FrameStyle->Directive[Thin,GrayLevel[.9]]
								],
							Button[
								Style["\[RightTriangle]",Gray],
								i=Min@{i+1,len},
								Appearance->"AbuttingLeftRight"(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,Last@barSize}*)],
							Button[
								Style["\[RightTriangleBar]",Gray],
								i=len,
								Appearance->"AbuttingLeft",
								FrameMargins->{{0,3},{-1,0}}(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,.5}*)]
							}
						},
					Spacings->0,
					Alignment->Top
					],
				RoundingRadius->5,
				FrameMargins->{{-2,-2},{-3,-2}},
				Background->White,
				FrameStyle->GrayLevel[.9]
				]
			]
		];


(* ::Subsection:: *)
(*Surfaces*)



(* ::Subsubsection::Closed:: *)
(*Surface*)



Options[ChemSurface]=
	Join[
		Options[BoundaryDiscretizeRegion],
		Options[DiscretizeGraphics]
		];
ChemSurface[g_Graphics3D, ops:OptionsPattern[]]:=
	With[{c=Cases[g,_Sphere,\[Infinity]]/.Sphere->Ball},
		If[Length@c>0,
			BoundaryDiscretizeRegion[
				RegionUnion@@c,
				FilterRules[{ops},
					Options@BoundaryDiscretizeRegion
					],
				PlotTheme->"SmoothShading"
				],
			DiscretizeGraphics[g,
				FilterRules[{ops},
					Options@DiscretizeGraphics
					],
				PlotTheme->"SmoothShading"
				]
			]
		];
ChemSurface[obj:ChemObjPattern,ops:OptionsPattern[]]:=
	ChemSurface[ChemView[obj,"SpaceFilling"], ops];


(* ::Subsubsection::Closed:: *)
(*Cached CSP*)



(*Options[ChemSurfacePlot]={
	Function\[Rule]Compile[{{p,_Real,1}},Norm@p],
	InterpolatingFunction\[Rule]Compile[{{c,_Real,1}},Mean@c],
	ColorFunction\[Rule](Hue[1-.8*#]&),
	ColorFunctionScaling\[Rule]True
	};
ChemSurfacePlot[
	surface_?RegionQ,
	ops:OptionsPattern[]
	]:=
	With[{
		coordinateFunction=OptionValue@Function,
		interpolationFunction=OptionValue@InterpolatingFunction,
		colorFunction=OptionValue@ColorFunction,
		csScaling=TrueQ[OptionValue@ColorFunctionScaling]
		},
	Block[{
		csPlotCoordinateValues=coordinateFunction/@MeshCoordinates@surface,
		csPlotMinMax,csPlotMin,csPlotDiff,
		csPlotCellStyling},
		csPlotMinMax=MinMax@csPlotCoordinateValues;
		csPlotMin=First@csPlotMinMax;
		csPlotDiff=Abs@First@Differences@csPlotMinMax;
		csPlotCoordinateValues=
			Association@
				If[csScaling,
					If[csPlotDiff==0,
						MapIndexed[First@#2\[Rule].5&,
							csPlotCoordinateValues],
						MapIndexed[First@#2\[Rule](#-csPlotMin)/csPlotDiff&,
							csPlotCoordinateValues]
						],
					MapIndexed[First@#2\[Rule]#&,csPlotCoordinateValues]
					];
		csPlotCellStyling=
			With[{cf=
				colorFunction/.HoldPattern@ColorData[a__]\[RuleDelayed]
					RuleCondition[ColorData[a],True]},
			MapIndexed[
				Style[{2,First@#2},
					cf@interpolationFunction[First@#/.csPlotCoordinateValues]
					]&,
				MeshCells[surface,2]
				]
			];
		HighlightMesh[surface,
			csPlotCellStyling,
			PlotTheme\[Rule]"SmoothShading"
			]
		]
	];
ChemSurfacePlot[system_String,id_,f_,
	a___
	]:=
	With[{
		s=ChemSurface[system,id],
		ops=
			Sequence@@
				Normal@
					With[{op=Association@{
						ColorFunction\[Rule]({ColorData["TemperatureMap"]@#,Opacity[.65]}&),
						a
						}},
						If[FreeQ[op[ColorFunction],_Opacity],
							With[{cf=op[ColorFunction]},
								Append[op,ColorFunction\[Rule](Flatten@{cf@#,Opacity[.65]}&)]
								],
							op
							]
						]
			},
		Replace[
			ChemSurfacePlot[s,
				If[FreeQ[Hold[f],Point],
					f,
					AtomsetPointCompile[system,id,
						f
						]
					],
				ops
				],
			p:Except[_ChemSurfacePlot]:>
				Show[
					p,
					ChemView[system,id]
					]
			]
		];
ChemSurfacePlot[ChemObject[system_,id_],a__]:=
	ChemSurfacePlot[system,id,a];
ChemSurfacePlot~SetAttributes~HoldRest;*)


(* ::Subsubsection::Closed:: *)
(*SurfacePlot*)



Options[ChemSurfacePlot]=
	Join[
		Options@SliceDensityPlot3D,
		Options@ChemSurface,{
		Quiet->True
		}];
ChemSurfacePlot[
	function_,
	surface_?RegionQ,
	ops:OptionsPattern[]
	]:=
	With[{m=MinMax@MeshCoordinates@surface},
		With[{
			drops=
				Sequence@@
					FilterRules[{ops,
						ColorFunction->ColorData["TemperatureMap"],
						Boxed->False,
						Axes->False
						},
					Options@SliceDensityPlot3D
					]
			},
			With[{h=
				Hold@
					SliceDensityPlot3D[function@{x,y,z},surface,
						{x,First@m,Last@m},
						{y,First@m,Last@m},
						{z,First@m,Last@m},
						drops
						]
				},
				If[OptionValue@Quiet//TrueQ,
					Quiet[ReleaseHold@h,CompiledFunction::cfta],
					ReleaseHold@h
					]
				]
			]
		];
ChemSurfacePlot[f_,
	obj_?ChemObjectQ,
	ops:OptionsPattern[]]:=
	With[{
		s=
		ChemSurface[obj,
			FilterRules[{ops},Options@ChemSurface]
			],
		opacity=
			Lookup[
				FilterRules[{ops},
					Opacity],
				Opacity,
				.85]
			},
		With[{
			pf=
				If[FreeQ[Hold[f],$ChemCompilePoint|$ChemCompileObject],
					f,
					Replace[Unevaluated[f],{
						c_ChemPointCompile:>
							c[obj],
						_:>
							Replace[ChemPointCompile[f],{
								c:Except[_CompiledFunction]:>
									c[obj]
								}]
						}]
					],
			pops=
				Sequence@@
					Replace[
						FilterRules[
							{
								ops,
								ColorFunction->ColorData["TemperatureMap"]
								},
							Options@ChemSurfacePlot],
						(ColorFunction->v_):>
							With[{cfOld=Replace[v,{_String|_Integer:>ColorData[v]}]},
								ColorFunction->
									(Directive[
										cfOld@#,
										Opacity[opacity]
										]&)
								],
						1]
			},
			Replace[
				ChemSurfacePlot[pf,s,pops],
				p:Except[_ChemSurfacePlot]:>
					Show[p,
						ChemView[obj, ops]
						]
				]
			]
		];
ChemSurfacePlot~SetAttributes~HoldFirst;


(* ::Subsection:: *)
(*Animations*)



(* ::Subsubsection::Closed:: *)
(*ChemAnimate*)



chemAnimationTime=
	(_Times?(MatchQ[_Integer])|_Integer|_List|\[Infinity]);
chemAnimationObjs=
	ChemManyPattern|_Symbol?(MatchQ[ChemManyPattern])|
		{((_Symbol?(MatchQ[ChemObjAllPattern]))|ChemManyPattern)..};


ChemAnimate//ClearAll;
Options[ChemAnimate]=
	Join[
		Options@ListAnimate,{
		Prolog->{},
		Epilog->{},
		"AnimationTime"->10.,
		"ChemViewOptions"->{}
		}];
ChemAnimate[
	cmd_,
	steps:chemAnimationTime:10,
	ops:OptionsPattern[]]:=
	With[{
		frames=
			Join[
				Flatten@{OptionValue@Prolog},
				If[MatchQ[steps,_Integer|\[Infinity]],{cmd},{}],
				With[{
					start=Now,
					anmQ=
						Quantity[
							Replace[OptionValue@"AnimationTime",Except[_?NumericQ]->0],
							"Seconds"]
						},
					If[steps===\[Infinity],
						Reap[
							While[Now-start<anmQ,
								Sow@cmd
								]
							][[2,1]],
						Table[
							If[Now-start<anmQ,
								cmd,
								Nothing
								],
							steps
							]
						]
					],
				Flatten@{OptionValue@Epilog}
				]},
		Interpretation[
			ListAnimate[frames,
				FilterRules[{ops},Options@ListAnimate]],
			frames
			]
		];
ChemAnimate[
	obj:chemAnimationObjs,
	mutate_,
	steps:chemAnimationTime:10,
	ops:OptionsPattern[]]:=
	With[{cvops=
		Sequence@@
			Flatten@{OptionValue@"ChemViewOptions"}
			},
		ChemAnimate[
			mutate@obj;
			ChemView[obj,cvops],
			steps,
			ops,
			Prolog->{ChemView[obj,cvops]}
			]
		];
SyntaxInformation[ChemAnimate]=
	{
		"ArgumentsPattern"->{_,_.,_.,OptionsPattern[]},
		"LocalVariables"->{Table,{2,3}}
		};
ChemAnimate~SetAttributes~HoldAll;


(* ::Subsubsection::Closed:: *)
(*ChemSaveAnimation*)



ChemSaveAnimation[file_,
	frames_List|Interpretation[_,frames_List],
	ops:OptionsPattern[]]:=
	With[{images=
		Rasterize[#,"Image",FilterRules[{ops},Options@Rasterize]]&/@
			frames
			},
		With[{dims=ImageDimensions@First@images},
   	 Export[file,
   	 	ImageResize[ColorConvert[#, "RGB"], dims] & /@ images,
   	 	ops
   	 	]
    	]
    ]


End[];



