(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*Interfaces*)



RegisterInterface::usage=
  "Registers an object interface";


$InterfacePropertyStore::usage=
  "ExpressionStore for cached object properties";
InterfaceSetProperty::usage=
  "Sets a property value";
InterfacePropertyValue::usage=
  "Gets a property value";  
InterfaceRemoveProperty::usage=
  "Removes a property value";
InterfacePropertyList::usage=
  "Lists the properties on an object";
InterfaceCopyProperties::usage=
  "Copies properties from one object to another";


InterfaceMethod::usage=
  "Alias for defining object methods";
InterfaceAttribute::usage=
  "Alias for defining object attributes";


Begin["`Private`"];


(* ::Subsection:: *)
(*Properties*)



If[!ValueQ@$InterfacePropertyStore,
  $InterfacePropertyStore=Language`NewExpressionStore["<ObjectPropertyStore>"]
  ];


(* ::Subsubsection::Closed:: *)
(*get*)



propGet[spec_, prop_]:=
  Replace[$InterfacePropertyStore@"get"[spec, prop],
    {
      Null->Missing["KeyAbsent", prop],
      $$hold[x_]:>x
      }
    ];


(* ::Subsubsection::Closed:: *)
(*set*)



propSet[spec_, prop_, val_]:=
  (
    $InterfacePropertyStore@"put"[spec, prop, val];
    val
    )


(* ::Subsubsection::Closed:: *)
(*set*)



$$hold~SetAttributes~HoldAllComplete


propSetDelayed~SetAttributes~HoldRest


propSetDelayed[spec_, prop_, val_]:=
  (
    $InterfacePropertyStore@"put"[spec, prop, $$hold@val];
    )


(* ::Subsubsection::Closed:: *)
(*remove*)



propRemove[spec_, prop_]:=
  $InterfacePropertyStore@"remove"[spec, prop];


(* ::Subsubsection::Closed:: *)
(*keys*)



propKeys[spec__]:=
  $InterfacePropertyStore@"getKeys"[spec]


(* ::Subsubsection::Closed:: *)
(*computeProp*)



computeProp[spec_, prop_, func_, args___]:=
  Replace[propGet[spec, prop],
    Missing["KeyAbsent", prop]:>
      With[{v=func[args]},
        propSet[spec, prop, v];
        v
        ]
    ]
computeProp~SetAttributes~HoldAllComplete


(* ::Subsubsection::Closed:: *)
(*copyProps*)



copyProps[obj1_, obj2_, keyTest_:(True&)]:=
  Scan[If[keyTest[#], propSet[obj2, #, propGet[obj1, #]]]&, propKeys[obj1]]


(* ::Subsubsection::Closed:: *)
(*Properties*)



InterfaceSetProperty[spec_, prop_->val_]:=
  propSet[spec, prop, val];
InterfaceSetProperty[spec_, prop_:>val_]:=
  propSetDelayed[spec, prop, val];
InterfacePropertyValue[spec_, prop_]:=
  propGet[spec, prop];
InterfaceRemoveProperty[spec_, prop_]:=
  propRemove[spec, prop];
InterfacePropertyList[spec_]:=
  propKeys[spec]


(* ::Subsection:: *)
(*RegisterInterface*)



(* ::Text:: *)
(*
	This function makes it really easy to create a new object and avoid the boilerplate
*)



(* ::Subsubsection::Closed:: *)
(*Defaults*)



(* ::Subsubsubsection::Closed:: *)
(*defaultConstructorFailureFunction*)



defaultConstructorFailureFunction[head_, args__]:=
  PackageRaiseException[
    Automatic,
    "Failed to build `` object from data ``",
    head, 
    HoldForm[{args}]
    ];
defaultConstructorFailureFunction~SetAttributes~HoldAllComplete;


(* ::Subsubsubsection::Closed:: *)
(*createConstructor*)



createConstructor[constructor_, keys_]:=
  (
    constructor[a_Association]:=
      If[Length@keys>1||Length@keys===1&&KeyExistsQ[a, keys[[1]]],
        a,
        Quiet[AssociationThread[keys, {a}], AssociationThread::idim]
        ];
    constructor[args__]:=
      Quiet[AssociationThread[keys, {args}], AssociationThread::idim]
    )


(* ::Subsubsubsection::Closed:: *)
(*createAccessorFunctions*)



createAccessorFunctions[head_, headQ_]:=
  Module[
    {
      key,
      part
      },
    part[HoldPattern[head[a_]?headQ], k_String, p___]:=
      With[{res=Quiet[a[[k, p]], Part::partd]}, res/;Head[res]=!=Part];
    key[HoldPattern[head[a_]?headQ], k__]:=
      a[k];
    <|"Keys"->key, "Parts"->part|>
    ]


(* ::Subsubsubsection::Closed:: *)
(*createMutationHandlers*)



(* ::Text:: *)
(*	
	Need to finish this up so I can have automatic creation of mutation handlers for the default case of wanting all basic mutations based on Set and stuff
*)



createMutationHandlers[
  head_,
  headQ_,
  handlers_List
  ]:=
  Module[
    {
      res=<||>,
      selfMutate,
      keyMutate,
      partMutate,
      selfDispatch,
      keyDispatch,
      partDispatch
      },
    If[MemberQ[handlers, "Self"],
      selfMutate[
        h_,
        HoldPattern[head[a_]?headQ],
        args___
        ]:=
        Block[{core=a},
          h[core["Value"], args];
          head@core
          ];
      selfDispatch[h_]:=
        Function[Null, selfMutate[h, ##], HoldAllComplete];
      res["Self"]=selfDispatch;
      ];
    If[MemberQ[handlers, "Keys"],
      keyMutate[
        h_,
        HoldPattern[head[a_]?headQ],
        {k__},
        args___
        ]:=
        Block[{core=a},
          h[core[k], args];
          head@core
          ];
      keyDispatch[h_]:=
        Function[Null, keyMutate[h, ##], HoldAllComplete];
      res["Keys"]=keyDispatch;
      ];
    If[MemberQ[handlers, "Parts"],
      partMutate[
        h_,
        HoldPattern[head[a_]?headQ],
        {p__},
        args___
        ]:=
        Block[{core=a},
          h[core[[p]], args];
          head@core
          ];
      partDispatch[h_]:=
        Function[Null, partMutate[h, ##], HoldAllComplete];
      res["Parts"]=partDispatch;
      ];
    res
    ]
      


(* ::Subsubsection::Closed:: *)
(*RegisterInterface*)



Options[RegisterInterface]=
  {
    "Version"->1,
    "Atomic"->True,
    "Validator"->Automatic,
    "Constructor"->Automatic,
    "MutationHandler"->Automatic,
    "MutationFunctions"->None,
    "AccessorFunctions"->None,
    "NormalFunction"->Automatic,
    "Formatted"->True,
    "Icon"->None,
    "DefaultMethods"->{
      Keys, SetProperty, PropertyValue,
      RemoveProperty, PropertyList
      }
    };
RegisterInterface[
  head_,
  keys_,
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      entryQ=True@OptionValue["Atomic"],
      ctor=OptionValue["Constructor"],
      constructor,
      ctorFail=defaultConstructorFailureFunction,
      ctorFailOnUndef=False,
      vdtor=OptionValue["Validator"],
      objQ,
      version=OptionValue["Version"],
      muh=OptionValue["MutationHandler"],
      mutationHandler,
      mud=OptionValue["MutationFunctions"],
      acc=OptionValue["AccessorFunctions"],
      norm=
        Replace[OptionValue["NormalFunction"],
          Automatic:>(KeyDrop[#, "Version"]&)
          ],
      format=OptionValue["Formatted"],
      icon=OptionValue["Icon"]
      },
    iRegisterInterfaceEntryQ[
      head,
      !entryQ
      ];
    If[vdtor===Automatic, vdtor=objQ];
    iRegisterInterfaceValidator[head, keys, vdtor];
    Which[
      ctor===Automatic,
        createConstructor[constructor, keys];
        ctor=constructor,
      Head[ctor]===Symbol&&DownValues[ctor]=={},
        createConstructor[ctor, keys],
      AssociationQ@ctor,
        ctorFail=
          Lookup[ctor, "FailureFunction", ctorFail];
        ctorFailOnUndef=
          Lookup[ctor, "FailOnUndefined", ctorFailOnUndef];
        ctor=ctor["Function"]
      ];
    iRegisterInterfaceConstructor[
      head,
      version,
      ctor,
      ctorFail,
      ctorFailOnUndef
      ];
    If[mud=!=None,
      If[mud===Automatic, mud={"Self", "Keys", "Parts"}];
      If[ListQ@mud,
        mud=createMutationHandlers[head, vdtor, mud];
        ];
      If[muh===Automatic,
        muh=mutationHandler
        ];
      iRegisterInterfaceMutationHandler[
        head,
        mutationHandler,
        mud
        ]
      ];
    If[acc=!=None,
      Which[
        acc===Automatic,
          iRegisterInterfaceAccessor[head, createAccessorFunctions[head, vdtor]],
        acc==="Keys",
          iRegisterInterfaceAccessor[head, 
            KeyDrop["Parts"]@createAccessorFunctions[head, vdtor]
            ],
        acc==="Parts",
          iRegisterInterfaceAccessor[head, 
            KeyDrop["Keys"]@createAccessorFunctions[head, vdtor]
            ],
        True,
          iRegisterInterfaceAccessor[head, acc]
        ]
      ];
    If[norm=!=None,
      iRegisterInterfaceNormalForm[head, norm]
      ];
    If[format,
      iRegisterInterfaceFormatting[head, icon]
      ];
    iRegisterDefaultInterfaceMethods[head, OptionValue["DefaultMethods"]];
    head
    ];


(* ::Subsubsection::Closed:: *)
(*$InterfaceData*)



(* ::Subsubsubsection::Closed:: *)
(*$InterfaceData*)



If[!ValueQ@$InterfaceData,
  $InterfaceData=Language`NewExpressionStore["<ObjectDataStore>"]
  ];


(* ::Subsubsubsection::Closed:: *)
(*InterfaceConstructor*)



InterfaceConstructor/:
  (InterfaceConstructor[head_]=fn_):=
    $InterfaceData@"put"[head, "Constructor", fn];
InterfaceConstructor[head_]:=
  $InterfaceData@"get"[head, "Constructor"];


(* ::Subsubsubsection::Closed:: *)
(*InterfaceValidator*)



InterfaceValidator/:
  (InterfaceValidator[head_]=fn_):=
    $InterfaceData@"put"[head, "Validator", fn];
InterfaceValidator[head_]:=
  $InterfaceData@"get"[head, "Validator"];


(* ::Subsubsubsection::Closed:: *)
(*InterfaceCheckValid*)



InterfaceCheckValid/:
  (InterfaceCheckValid[head_]=fn_):=
    $InterfaceData@"put"[head, "CheckValid", fn];
InterfaceCheckValid[head_]:=
  $InterfaceData@"get"[head, "CheckValid"];


(* ::Subsubsubsection::Closed:: *)
(*InterfaceCheckInvalid*)



InterfaceCheckInvalid/:
  (InterfaceCheckInvalid[head_]=fn_):=
    $InterfaceData@"put"[head, "CheckInvalid", fn];
InterfaceCheckInvalid[head_]:=
  $InterfaceData@"get"[head, "CheckInvalid"];


(* ::Subsubsubsection::Closed:: *)
(*InterfaceSetValid*)



InterfaceSetValid/:
  (InterfaceSetValid[head_]=fn_):=
    $InterfaceData@"put"[head, "SetValid", fn];
InterfaceSetValid[head_]:=
  $InterfaceData@"get"[head, "SetValid"];


(* ::Subsubsubsection::Closed:: *)
(*InterfaceMethods*)



InterfaceMethods/:
  (InterfaceMethods[head_]=meths_):=
    $InterfaceData@"put"[head, "Methods", meths];
InterfaceMethods[head_]:=
  If[#===Null, <||>, #]&@$InterfaceData@"get"[head, "Methods"];


(* ::Subsubsubsection::Closed:: *)
(*InterfaceAttributes*)



InterfaceAttributes/:
  (InterfaceAttributes[head_]=attrs_):=
    $InterfaceData@"put"[head, "Attributes", attrs];
InterfaceAttributes[head_]:=
  $InterfaceData@"get"[head, "Attributes"];


(* ::Subsubsection::Closed:: *)
(*iRegisterInterfaceEntryQ*)



iRegisterInterfaceEntryQ[head_, entryQ_]:=
  With[
    {
      checkInvalid=
        If[TrueQ@entryQ,
          System`Private`HoldNotValidQ,
          System`Private`HoldEntryQ
          ],
      checkValid=
        If[TrueQ@entryQ,
          System`Private`HoldValidQ,
          System`Private`HoldNoEntryQ
          ],
      setValid=
        If[TrueQ@entryQ,
          System`Private`HoldSetValid,
          System`Private`HoldSetNoEntry
          ]
      },
    InterfaceCheckInvalid[head]=checkInvalid;
    InterfaceCheckValid[head]=checkValid;
    InterfaceSetValid[head]=setValid;
    ]


(* ::Subsubsection::Closed:: *)
(*iRegisterInterfaceValidator*)



iRegisterInterfaceValidator[
  head_,
  keys_,
  testFunction_
  ]:=
  With[
    {
      checkValid=InterfaceCheckValid[head]
      },
    (* Test if object is object *)
    InterfaceValidator[head]=testFunction;
    testFunction[d_Association?AssociationQ]:=
      AllTrue[keys, KeyExistsQ[d, #]&];
    testFunction/:
      HoldPattern[testFunction[head[a_Association]?checkValid]]:=
      testFunction[a];
    testFunction[___]:=False;
    ]


(* ::Subsubsection::Closed:: *)
(*iRegisterInterfaceConstructor*)



(* ::Text:: *)
(*
	Need to decide whether it\[CloseCurlyQuote]s best to leave unevaluated if the constructor returns an Association or not...
*)



iRegisterInterfaceConstructor[
  head_,
  version_,
  constructor_,
  failureFunction_,
  failOnUndefinedArguments_
  ]:=
  With[
    {
      validator=InterfaceValidator[head],
      checkInvalid=InterfaceCheckInvalid[head],
      setValid=InterfaceSetValid[head]
      },
    InterfaceConstructor[head]=constructor;
    (* Constructor DownValue on the object *)
    head//ClearAll;
    head~SetAttributes~HoldAllComplete;
    head[args___]?checkInvalid:=
      With[{a=constructor[args]},
        If[AssociationQ@a,
          With[{a2=Append[a, "Version"->version]},
            If[TrueQ@validator@a2,
              setValid@head[a2],
              failureFunction[head, args]
              ]
            ],
          failureFunction[head, args]
          ]/;(TrueQ[failOnUndefinedArguments]||AssociationQ[a])
        ];
    ]


(* ::Subsubsection::Closed:: *)
(*iRegisterInterfaceMutationHandler*)



$noArgMutations=
  Alternatives@@
    {Unset, Increment, Decrement};


$oneArgMutations=
  Alternatives@@
    {
        Set, SetDelayed,
        AddTo, SubtractFrom, TimesBy, DivideBy,
        AppendTo, PrependTo,
        AssociateTo, KeyDropFrom
        };


iRegisterInterfaceMutationHandler[
  head_,
  func_,
  dispatcher_
  ]:=
  With[
    {
      oQ=InterfaceValidator[head],
      symQ=Unique[symbolQ],
      oA=$oneArgMutations,
      nA=$noArgMutations,
      d=
        If[!AssociationQ@dispatcher, 
          <|"Keys"->dispatcher|>,
          dispatcher
          ]
      },
    symQ~SetAttributes~{Temporary, HoldFirst};
    symQ[sym_]:=
      MatchQ[OwnValues[sym], {_:>_head?oQ}];
    func // ClearAll;
    func~SetAttributes~HoldAllComplete;
    If[KeyExistsQ[d, "Self"],
      With[{subdispatch=dispatcher["Self"]},
        func[
          (h: oA)[obj_Symbol?symQ, val_]
          ] :=
          With[{res=subdispatch[h][obj, val]},
            (obj=res)/;Head[res]===head
            ];
        func[
          (h : nA)[obj_Symbol?symQ]
          ] :=
          With[{res=subdispatch[h][obj]},
            (obj=res)/;Head[res]===head
            ];
        ];
      ];
    If[KeyExistsQ[d, "Keys"],
      With[{subdispatch=dispatcher["Keys"]},
        func[
          (h: oA)[obj_Symbol?symQ[attr__], val_]
          ] :=
          With[{res=subdispatch[h][obj, {attr}, val]},
            (obj=res)/;Head[res]===head
            ];
        func[
          (h : nA)[obj_Symbol?symQ[attr__]]
          ] :=
          With[{res=subdispatch[h][obj, {attr}]},
            (obj=res)/;Head[res]===head
            ];
        ]
      ];
    If[KeyExistsQ[d, "Parts"],
      With[{subdispatch=dispatcher["Parts"]},
        func[
          (h: oA)[obj_Symbol?symQ[[part__]], val_]
          ] :=
          With[{res=subdispatch[h][obj, {part}, val]},
            (obj=res)/;Head[res]===head
            ];
        func[
          (h : nA)[obj_Symbol?symQ[[part__]]]
          ] :=
          With[{res=subdispatch[h][obj, {part}]},
            (obj=res)/;Head[res]===head
            ];
        ]
      ];
    (* fallthrough to get normal behavior back *)
    func[___] := Language`MutationFallthrough;
    Language`SetMutationHandler[head, func];
    ]


(* ::Subsubsection::Closed:: *)
(*iRegisterInterfaceMethod*)



iRegisterInterfaceMethod~SetAttributes~HoldRest;
iRegisterInterfaceMethod[
  head_,
  methodName_,
  name_,
  args___,
  def_
  ]:=
  With[
    {
      mn=methodName,
      valid=InterfaceValidator[head],
      meths=InterfaceMethods[head],
      noop=Unevaluated@name
      },
    InterfaceMethods[head]=
      If[meths===Null,
        <|mn->True|>,
        Append[meths, mn->True]
        ]; 
    noop_head?valid[mn[args]]:=
      def;
    noop_head?valid[mn][args]:=
      def;
    ];


InterfaceMethod/:
  (
    InterfaceMethod[
      Verbatim[Pattern][name_, Verbatim[Blank][head_]][method_][args___]
      ]:=def_
    ):=
    iRegisterInterfaceMethod[head, method, name, args, def];


(* ::Subsubsection::Closed:: *)
(*iRegisterInterfaceAttribute*)



iRegisterInterfaceAttribute~SetAttributes~HoldRest;
iRegisterInterfaceAttribute[
  head_,
  attr_,
  name_,
  def_
  ]:=
  With[
    {
      mn=attr,
      valid=InterfaceValidator[head],
      meths=InterfaceAttributes[head],
      noop=Unevaluated@name
      },
    InterfaceAttributes[head]=
      If[meths===Null,
        <|mn->True|>,
        Append[meths, mn->True]
        ]; 
    noop_head?valid[mn]:=
      def;
    ];


InterfaceAttribute/:
  (
    InterfaceAttribute[
      Verbatim[Pattern][name_, Verbatim[Blank][head_]][attr_]
      ]:=def_
    ):=
    iRegisterInterfaceAttribute[head, attr, name, def];


(* ::Subsubsection::Closed:: *)
(*iRegisterInterfaceAccessor*)



iRegisterInterfaceAccessor[head_, dispatcher_]:=
  With[
    {
      ea=If[!AssociationQ@dispatcher, <|"Keys"->dispatcher|>, dispatcher],
      valid=InterfaceValidator[head]
      },
    If[KeyExistsQ[ea, "Keys"],
      With[{lookup=dispatcher["Keys"]},
        obj_head?valid[attr_?(!KeyExistsQ[InterfaceMethods[head], #]&)]:=
          lookup[obj, attr];
        obj_head?valid[attr1_, attrs__]:=
          lookup[obj, attr1, attrs];
        ];
      ];
    If[KeyExistsQ[ea, "Parts"],
      With[{part=dispatcher["Parts"]},
        head/:obj_head?valid[[p__]]:=
          part[obj, p];
        ];
      ];
    ];


(* ::Subsubsection::Closed:: *)
(*iRegisterInterfaceNormalForm*)



iRegisterInterfaceNormalForm[head_, norm_]:=
  With[
    {
      valid=InterfaceValidator[head]
      },
    head/:HoldPattern[Normal[head[a_]?valid]]:=norm@a
    ];


(* ::Subsubsection::Closed:: *)
(*iRegisterInterfaceFormatting*)



iRegisterInterfaceFormatting[
  head_,
  icon_(*,
	keys_ I'll add this in the future...
	*)
  ]:=
  With[{valid=InterfaceValidator[head]},
    Format[HoldPattern[obj:head[a_]?valid]]:=
      RawBoxes@
        BoxForm`ArrangeSummaryBox[
          head,
          Unevaluated[Head@@{a}],
          icon,
          {
            BoxForm`MakeSummaryItem[
              {
                "Keys: ", 
                DeleteCases[Keys@a, "Version"]
                },
              StandardForm
              ]
            },
          {
            },
          StandardForm
          ]
    ]


(* ::Subsubsection::Closed:: *)
(*iRegisterDefaultInterfaceMethods*)



(* ::Subsubsubsection::Closed:: *)
(*Keys*)



registerDefault[head_, validator_, Keys]:=
  head/:HoldPattern@Keys[head[a_]?validator]:=
    Keys[a];


(* ::Subsubsubsection::Closed:: *)
(*ReplacePart*)



registerDefault[head_, validator_, ReplacePart]:=
  head/:HoldPattern@ReplacePart[head[a_]?validator, k_]:=
    head[ReplacePart[a, k]]


(* ::Subsubsubsection::Closed:: *)
(*MapAt*)



registerDefault[head_, validator_, MapAt]:=
  head/:HoldPattern@MapAt[f_, head[a_]?validator, k_]:=
    head[MapAt[f, a, k]]


(* ::Subsubsubsection::Closed:: *)
(*SetProperty*)



registerDefault[head_, validator_, SetProperty]:=
  head/:HoldPattern@SetProperty[obj:_head?validator, p:_Rule|_RuleDelayed]:=
    InterfaceSetProperty[obj, p]


(* ::Subsubsubsection::Closed:: *)
(*PropertyValue*)



registerDefault[head_, validator_, PropertyValue]:=
  head/:HoldPattern@PropertyValue[obj:_head?validator, p_]:=
    InterfacePropertyValue[obj, p]


(* ::Subsubsubsection::Closed:: *)
(*PropertyValue*)



registerDefault[head_, validator_, RemoveProperty]:=
  head/:HoldPattern@RemoveProperty[obj:_head?validator, p_]:=
    InterfaceRemoveProperty[obj, p]


(* ::Subsubsubsection::Closed:: *)
(*PropertyList*)



registerDefault[head_, validator_, PropertyList]:=
  head/:HoldPattern@PropertyList[obj:_head?validator]:=
    InterfacePropertyList[obj]


(* ::Subsubsubsection::Closed:: *)
(*iRegisterDefaultInterfaceMethods*)



iRegisterDefaultInterfaceMethods[head_, fns_]:=
  With[{v=InterfaceValidator[head]},
    Scaled[registerDefault[head, v, #]&, fns]
    ]


End[];



