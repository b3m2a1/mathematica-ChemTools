(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*Grid Function Tools*)



(* ::Subsubsection::Closed:: *)
(*Constructors*)



ConstructGridFunction;
GridFunctionObjectQ;


(* ::Subsubsection::Closed:: *)
(*Parts*)



GFPart::usage=
  "Applies part to a grid function";
GFKeyPart::usage=
  "Applies key lookup to a grid function";


(* ::Subsubsection::Closed:: *)
(*Structural*)



GFPoints::usage=
  "Flattens down to the coordinate points";
GFArray::usage=
  "Creates the normal array";
GFMap::usage=
  "Applies a transformation to the coordinates points, maintaining ordering";
GFSort::usage=
  "";
GFTranspose::usage=
  "";



(* ::Subsubsection::Closed:: *)
(*Manipulation*)



GFScale::usage="";
GFShift::usage="";
GFRescale::usage="";
GFClip::usage="";
GFChop::usage="";


(* ::Subsubsection::Closed:: *)
(*Higher-Level*)



GFDerivative::usage=
  "Finite difference derivatives";
GFIntegrate::usage=
  "Dot-based integration";
(*GFInterpolate::usage=
	"Distinct from GFInterpolation in that it does the interpolation by hand";*)


GFKroneckerProduct::usage=
  "Kronecker product over grid functions";


(* ::Subsubsection::Closed:: *)
(*Mindless*)



GFInterpolation::usage=
  "";
GFMinMax::usage=
  "";


Begin["`Private`"];


(* ::Subsection:: *)
(*Constructor*)



(* ::Subsubsection::Closed:: *)
(*ConstructGridFunction*)



(* ::Subsubsubsection::Closed:: *)
(*validateGFData*)



validateGFData[{grid_, values_}]:=
  Module[
    {
      dn
      },
    If[!Developer`PackedArrayQ@values,
      PackageRaiseException[
        Automatic,
        "grid function values cannot be packed"
        ]
      ];
    Dimensions[values]===GridDimensions[grid]
    ]


(* ::Subsubsubsection::Closed:: *)
(*cleanGFData*)



cleanGFData[g_, vals_]:=
  Module[
    {
      base=N@Developer`ToPackedArray@vals,
      grid,
      gplen
      },
    If[!Developer`PackedArrayQ[base],
      PackageRaiseException[
        Automatic,
        "Function data cannot be packed"
        ]
      ];
    grid=If[!CoordinateGridObjectQ@g, CoordinateGridObject[g], g];
    If[!CoordinateGridObjectQ@grid,
      PackageRaiseException[
        Automatic,
        "grid function coordinate grid improperly defined"
        ]
      ];
    If[GridPointNumber[grid]=!=Times@@Dimensions[base],
      PackageRaiseException[
        Automatic,
        "number of grid points (``) and function values (``) disagaree",
        GridPointNumber[grid],
        GridPointNumber[base]
        ]
      ];
    If[GridDimensions[grid]=!=Dimensions[base],
      If[Depth@base==2,
        base=ArrayReshape[base, Dimensions[grid]],
        PackageRaiseException[
          Automatic,
          "Grid dimensions (``) and function dimensions (``) disagaree",
          Dimensions[grid],
          Dimensions[base]
          ]
        ]
      ];
    {
      grid,
      base(*Map[List, base, {Depth[base]-1}]*)
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*ConstructCoordinateGrid*)



ConstructGridFunction[grid_, vals_]:=
  With[{g=cleanGFData[grid, vals]},
    If[validateGFData[g],
      <|"Grid"->g[[1]], "Values"->g[[2]]|>,
      <|$Failed->True|> (* requires Association return to throw the error *)
      ]
    ];
ConstructGridFunction[a_Association]:=
  a; (* should probably just do a quick validation... *)


(* ::Subsection:: *)
(*GridFunction Parts*)



(* ::Subsubsection::Closed:: *)
(*GFPart*)



GFPart[c:GridFunctionObject[a_], p__]:=
  If[CoordinateGridObjectQ@#["Grid"],
    GridFunctionObject[#],
    Append@@Lookup[#, {"Grid", "Values"}]
    ]&@
    MapAt[
      Part[#, p]&,
      a,
      {{"Grid"}, {"Values"}}
      ];


(* ::Subsubsection::Closed:: *)
(*GFKeyPart*)



GFKeyPart[c:GridFunctionObject[a_], sel__]:=
  a[sel]


(* ::Subsection:: *)
(*Structural*)



(* ::Subsubsection::Closed:: *)
(*GFArray*)



GFArray[grid_List, vals_List]:=
  Module[{d1=Dimensions[grid], d2=Dimensions[vals], dp=Depth[vals]},
    If[d1[[;;-2]]=!=d2,
      PackageRaiseException["GridFunction",
        "Grid function grid and values have inconsistent dimensions (`` and ``)",
        d1,
        d2
        ]
      ];
    If[
      Length@d1>1,
        Join[grid, Map[List, vals, {dp-1}], dp],
        PackageRaiseException["Grid",
          "Grid `` has depth 1...?",
          grid
          ]
      ]
    ];
GFArray[grid_]:=
  GFArray[grid["Grid"]["Grid"], grid["Values"]]


(* ::Subsubsection::Closed:: *)
(*GFPoints*)



GFPoints[grid_List, vals_List]:=
  Flatten[GFArray[grid, vals], Depth[vals]-2];
GFPoints[grid_]:=
  GFPoints[grid["Grid"]["Grid"], grid["Values"]]


(* ::Subsubsection::Closed:: *)
(*GFMap*)



GFMap[tf_, {grid_List, vals_List}]:=
  Module[{d=Depth[vals], array=GFArray[grid, vals]},
    Developer`ToPackedArray@N@Map[tf, array, {Depth[vals]-1}]
    ];
GFTransform[tf_, f_]:=
  GFTransform[tf, {f["Grid"]["Grid"], f["Values"]}];


(* ::Subsection:: *)
(*Manipulation*)



(* ::Subsubsection::Closed:: *)
(*GFScale*)



GFScale//Clear
GFScale[{grid_, values_}, n_?NumericQ]:=
  {grid, values*n};
GFScale[{grid_, values_}, {n_?NumericQ, base_?NumericQ}]:=
  {grid, base+n*(values-base)};
GFScale[gf_GridFunctionObject, spec:_?NumericQ|{_?NumericQ, _?NumericQ}]:=
  GridFunctionObject@@
    GFScale[{gf["Grid"], gf["Values"]}, spec];


(* ::Subsubsection::Closed:: *)
(*GFShift*)



GFShift//Clear
GFShift[{grid_, values_}, n_?NumericQ]:=
  {grid, values+n};
GFShift[{grid_, values_}, Scaled[i_?NumericQ]]:=
  GFShift[{grid, values}, Subtract@@Reverse@MinMax[values]];
GFShift[gf_GridFunctionObject, spec:_?NumericQ|Scaled[_?NumericQ]]:=
  GridFunctionObject@@
    GFShift[{gf["Grid"], gf["Values"]}, spec];


(* ::Subsubsection::Closed:: *)
(*GFRescale*)



(* ::Text:: *)
(*
	This requires some thought to do appropriately and cleanly
*)



(* ::Subsubsubsection::Closed:: *)
(*getGFScalingRange*)



getGFScalingRange[values_, minmax_, {m_?NumericQ, n_?NumericQ}]:=
  {m, n};
getGFScalingRange[values_, minmax_, {Scaled[i_?NumericQ], n_}]:=
  getGFScalingRange[values, minmax, {i*minmax[[1]], n}];
getGFScalingRange[values_, minmax_, {m_, Scaled[i_?NumericQ]}]:=
  getGFScalingRange[values, minmax, {m, i*minmax[[2]]}];
getGFScalingRange[values_, minmax_, 
  Offset[spec_, x_?NumericQ]
  ]:=
  With[{s=getGFScalingRange[values, minmax, spec]},
    s-x(* ...this might not be right...? *)
    ];
getGFScalingRange[values_, minmax_, 
  Offset[spec_, Scaled[n_]]
  ]:=
  getGFScalingRange[
    values, minmax,
    Offset[spec, Rescale[n, {0, 1}, minmax]]
    ]


(* ::Subsubsubsection::Closed:: *)
(*iGFRescale*)



iGFRescale//Clear
iGFRescale[{grid_, values_}, minmax_, spec_]:=
  With[{gspec=getGFScalingRange[values, minmax, spec]},
    If[ListQ@gspec,
      {grid, Rescale[values, minmax, gspec]},
      PackageRaiseException[
        Automatic,
        "Spec `` is invalid for GFRescale",
        spec
        ]
      ]
    ];
iGFRescale[{grid_, values_}, spec_]:=
  iGFRescale[{grid, values}, MinMax@values, spec];


(* ::Subsubsubsection::Closed:: *)
(*GFRescale*)



GFRescale//Clear


GFRescale[
  gf_GridFunctionObject,
  minMax:({_?NumericQ, _?NumericQ}|Automatic):Automatic,
  spec_
  ]:=
  With[
    {
      res=
        PackageExceptionBlock["GFRescale"]@
          iGFRescale[{gf["Grid"], gf["Values"]}, spec]
      },
    GridFunctionObject@@res/;ListQ@res
    ];


(* ::Subsubsection::Closed:: *)
(*GFClip*)



GFClip[f_GridFunctionObject, s__]:=
  With[{vs=Clip[f["Values"], s]},
    GridFunctionObject[f["Grid"], vs]/;ListQ@vs
    ];


(* ::Subsubsection::Closed:: *)
(*GFChop*)



GFChop[f_GridFunctionObject, s__]:=
  With[{vs=Threshold[f["Values"], s]},
    GridFunctionObject[f["Grid"], vs]/;ListQ@vs
    ];


(* ::Subsection:: *)
(*Mindless*)



GFInterpolation[f_, a___]:=
  Interpolation[GFPoints[f], a];
GFMinMax[f_, a___]:=
  MinMax[f["Values"], a];


(* ::Subsection:: *)
(*Higher Level*)



(* ::Subsubsection::Closed:: *)
(*GFKroneckerProduct*)



GFKroneckerProduct[g__GridFunctionObject]:=
  Module[
    {dimensions, targetDimension, points, grid, vals, kp, op},
    dimensions=#["Dimensions"]&/@{g};
    targetDimension=Join@@dimensions;
    points=GFPoints/@{g};
    grid=points[[All, All, ;;-2]];
    vals=points[[All, All, -1]];
    kp=KroneckerProduct@@vals;
    op=Join@@@Tuples@grid;
    grid=ArrayReshape[op, Append[targetDimension, Length@targetDimension]];
    vals=ArrayReshape[kp, targetDimension];
    GridFunctionObject[grid, vals]
    ]


End[];



