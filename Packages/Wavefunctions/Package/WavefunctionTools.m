(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*Wavefunction Tools*)



(* ::Subsubsection::Closed:: *)
(*Constructor*)



ConstructWavefunctions::usage="";


(* ::Subsubsection::Closed:: *)
(*Parts*)



WFPart::usage=
  "Applies part to a wavefunction";
WFKeyPart::usage=
  "Applies key lookup to a wavefunction";


(* ::Subsubsection::Closed:: *)
(*Creation*)



ChemSeparableWavefunctions::usage=
  "Function for doing 1D SCF averaging of a potential with a DVR";


(* ::Subsubsection::Closed:: *)
(*Combination*)



WFProduct::usage=
  "Creates product wavefunctions out of 1D wavefunctions";


(* ::Subsubsection::Closed:: *)
(*ExpectationValues*)



WFExpectationValues::usage=
  "Expectation values over a normalized, discretized set of wavefunctions";
WFOperatorMatrix::usage=
  "Operator matrix over a normalized, discretized set of wavefunctions";
WFOperatorMatrixElements::usage=
  "Operator matrix elements over a normalized, discretized set of wavefunctions";


(* ::Subsubsection::Closed:: *)
(*Interface*)



WFNormal::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*Constructor*)



(* ::Subsubsection::Closed:: *)
(*validateWavefunctionData*)



validateWavefunctionData[{energies_, wfns_}]:=
  If[!Developer`PackedArrayQ@energies,
    PackageRaiseException[Automatic,
      "Failed to pack wavefunction energies ``",
      energies
      ],
    True
    ]&&
    If[!AllTrue[wfns, GridFunctionObjectQ],
      PackageRaiseException[Automatic,
        "Some wavefunctions could not be turned into GridFunctionObjects"
        ]
      ]


(* ::Subsubsection::Closed:: *)
(*constructWavefunctionData*)



constructWavefunctionData[erg_, wf_, grid_]:=
  Module[
    {
      engs=Developer`ToPackedArray@N[erg],
      wfns=Developer`ToPackedArray@N[wf],
      gr=CoordinateGridObject[grid]
      },
    {engs, GridFunctionObject[gr, #]&/@wfns}
    ]


(* ::Subsubsection::Closed:: *)
(*ConstructWavefunctions*)



ConstructWavefunctions[
  {
    energies_,
    wfns_
    },
  grid_
  ]:=
  With[
    {
      data=constructWavefunctionData[energies, wfns, grid]
      },
    If[validateWavefunctionData[data],
      <|
        "Wavefunctions"->data[[2]],
        "Energies"->data[[1]]
        |>,
      <|$Failed->True|> (* requires Association return to throw the error *)
      ]
    ];
ConstructWavefunctions[a_Association]:=
  a;


(* ::Subsection:: *)
(*WFNormal*)



WFNormal[wfns_]:=
  {
    wfns["Energies"],
    Flatten@#["Values"]&/@wfns["Wavefunctions"]//Developer`ToPackedArray,
    wfns["Wavefunctions"][[1]]["Grid"]//Normal
    }


(* ::Subsection:: *)
(*Wavefunction Parts*)



(* ::Subsubsection::Closed:: *)
(*WFPart*)



WFPart[WavefunctionsObject[c_], sel_]:=
  If[IntegerQ@sel, 
    Lookup[#, {"Energies", "Wavefunctions"}]&,
    WavefunctionsObject
    ]@
    MapAt[
      Part[#, sel]&,
      c,
      {{"Energies"}, {"Wavefunctions"}}
      ]
WFPart[WavefunctionsObject[c_], All, p__]:=
  WavefunctionsObject@
    MapAt[
      Map[#[[p]]&],
      c,
      "Wavefunctions"
      ];
WFPart[WavefunctionsObject[c_], sel_, p__]:=
  If[IntegerQ@sel, 
    Lookup[
      MapAt[#[[p]]&, #, "Wavefunctions"], 
      {"Energies", "Wavefunctions"}
      ]&,
    WavefunctionsObject@
      MapAt[Map[#[[p]]&], #, "Wavefunctions"]&
    ]@
    MapAt[
      Part[#, sel]&,
      c,
      {{"Energies"}, {"Wavefunctions"}}
      ]


(* ::Subsubsection::Closed:: *)
(*WFKeyPart*)



WFKeyPart[c:WavefunctionsObject[a_], sel__]:=
  a[sel]


(* ::Subsection:: *)
(*WavefunctionNormalize*)



WavefunctionNormalize[wfs_]:=
  wfs/Map[Norm, wfs];
WFNormalize[c_WavefunctionsObject]:=
  MapAt[WavefunctionNormalize, c, "Wavefunctions"];


(* ::Subsection:: *)
(*NormalizedQ*)



WFNormalizedQ[c_WavefunctionsObject]:=
  AllTrue[Norm/@c["Wavefunctions"], #==1&];


(* ::Subsection:: *)
(*WavefunctionsProduct*)



WFProduct[
  wfns1_WavefunctionsObject,
  wfnsother__WavefunctionsObject,
  n:_Integer?Positive|All|Automatic:Automatic
  ]:=
  Module[
    {
      numCombo,
      energies=#["Energies"]&/@{wfns1, wfnsother},
      wfns=#["Wavefunctions"]&/@{wfns1, wfnsother},
      wavefunctions,
      indices
      },
    numCombo=
      Replace[
        n, 
        {
          All:>
            Apply[Times, Length/@energies],
          i_Integer?Positive:>
            Min@{i, Apply[Times, Length/@energies]},
          Automatic:>
            Min@{50, Apply[Times, Length/@energies]}
          }
        ];
    {indices, energies}=ChemUtilsProductEnergies[energies, numCombo];
    wavefunctions=
      GFKroneckerProduct@@Map[Extract[wfns, #]&, Echo@indices];
    WavefunctionsObject@
      <|
        "Energies"->energies,
        "Wavefunctions"->wavefunctions
        |>
    ]


(* ::Subsection:: *)
(*GridWavefunctions*)



(* ::Subsubsection::Closed:: *)
(*iChemDVRDefaultThreadGridWavefunctions*)



iChemDVRDefaultThreadGridWavefunctions[gps_, wfns_, retE_]:=
  Module[
    {
      grid=gps
      },
      If[!ListQ@First@grid,
        grid=List/@grid
        ];
    grid=Developer`ToPackedArray@grid;
    If[retE, 
      MapThread[
        #->Join[grid, List/@#2, 2]&,
        wfns
        ],
      Map[
        Join[grid, List/@#, 2]&, 
        wfns[[2]]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*ChemDVRDefaultGridWavefunctions*)



Options[ChemDVRDefaultGridWavefunctions]=
  Join[
    {
      "ReturnEnergies"->False,
      "PruningEnergy"->None
      },
    Options[ChemDVRDefaultWavefunctionSelection],
    Options[ChemDVRDefaultGridPointList]
    ];
ChemDVRDefaultGridWavefunctions[
  grid_, 
  wfs_,
  V_,
  o:OptionsPattern[]
  ]:=
  With[
    {
      coreGridPoints=
        ChemDVRDefaultPruneGridPoints[
          ChemDVRDefaultGridPointList[grid, 
            FilterRules[{o}, Options@ChemDVRDefaultGridPointList]
            ],
          V,
          OptionValue["PruningEnergy"]
          ],
      wfns=
        ChemDVRDefaultWavefunctionSelection[
          ReleaseHold@wfs,
          FilterRules[{o}, Options[ChemDVRDefaultWavefunctionSelection]]
          ],
      retE=TrueQ@OptionValue["ReturnEnergies"]
      },
    iChemDVRDefaultThreadGridWavefunctions[
      coreGridPoints,
      wfns,
      retE
      ]
    ];


(* ::Subsection:: *)
(*ChemDVRDefaultInterpolatingWavefunctions*)



Options[ChemDVRDefaultInterpolatingWavefunctions]=
  Options@ChemDVRDefaultGridWavefunctions;
ChemDVRDefaultInterpolatingWavefunctions[
  grid_,
  wfs_,
  V_,
  ops:OptionsPattern[]
  ]:=
  With[
    {wf=ChemDVRDefaultGridWavefunctions[grid, wfs, V, ops]},
    If[MatchQ[wf[[1]], _Rule],
      #[[1]]->Interpolation[#[[2]]]&,
      Interpolation
      ]/@wf
    ]


(* ::Subsection:: *)
(*ExpectationValues*)



(* ::Subsubsection::Closed:: *)
(*expectationValue*)



expectationValueVec[func_, grid_]:=
  Replace[func@grid, 
    Except[_List?(Length[#]==Length@grid&)]:>Map[func, grid]
    ];
expectationValueVec[func_, grid_, wf_]:=
  Replace[func[grid, wf],
    Except[_List?(Length[#]==Length@grid&)]:>
      MapThread[func, {grid, wf}]
    ];


multiplicativeOperatorQ[func_Function]:=
  !(MemberQ[func, Slot[2], \[Infinity]]||
      MatchQ[func, Verbatim[Function][{_, _}, ___]]);
multiplicativeOperatorQ[e_]:=
  False;


expectationValue[
  func_Function, grid_, wfL_, wfR_,
  multiplicative_
  ]:=
  wfL.
    With[
      {
        mult=
          If[multiplicative===Automatic,
            multiplicativeOperatorQ[func],
            TrueQ@multiplicative
            ]
        },
      If[!mult,
        expectationValueVec[func, grid, wfR],
        wfR*expectationValueVec[func, grid]
        ]
    ];
expectationValue[func:Except[_Function], grid_, wfL_, wfR_,
  multiplicative_
  ]:=
  wfL.Replace[expectationValueVec[func, grid, wfR],
    {
      {_func, __}:>
        Replace[expectationValueVec[func, grid],
          {
            {_func, __}:>
              PackageRaiseException[
                Automatic,
                "Operator `` in matrix element calculation didn't evaluate",
                func
                ],
            l_:>wfR*l
            }
          ]
      }
    ]


(* ::Subsubsection::Closed:: *)
(*operatorMatrix*)



operatorMatrix[exf_, grid_, wfnsL_, wfnsR_, assumeRealSym_, assumeHerm_, mult_]:=
  Block[
    {
      mat=ConstantArray[0., {Length@wfnsL, Length@wfnsR}],
      asrs=TrueQ@assumeRealSym,
      ash=TrueQ@assumeHerm,
      mo=mult
      },
  Which[
    asrs,
      Do[
        If[i>j, 
          mat[[i, j]]=mat[[j, i]],
          mat[[i, j]]=
            expectationValue[exf, grid, wfnsL[[i]], wfnsR[[j]], mo]
          ],
        {i, Length@wfnsL},
        {j, Length@wfnsR}
        ],
    ash,
      Do[
        If[i>j, 
          mat[[i, j]]=Conjugate@mat[[j, i]],
          mat[[i, j]]=
            expectationValue[exf, grid, wfnsL[[i]], wfnsR[[j]], mo]
          ],
        {i, Length@wfnsL},
        {j, Length@wfnsR}
        ],
    True,
      Do[
        mat[[i, j]]=
          expectationValue[exf, grid, wfnsL[[i]], wfnsR[[j]], mo],
        {i, Length@wfnsL},
        {j, Length@wfnsR}
        ]
    ]
  ]


(* ::Subsubsection::Closed:: *)
(*ExpectationValues*)



Options[WFExpectationValues]=
  {
    "MultiplicativeOperator"->Automatic
    };
iWFExpectationValues[
  {grid_, wfns_},
  evs_,
  mul_,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      exfns=Flatten@List@evs
      },
      If[Not@ListQ@evs, Map[First], Identity]@
        Table[
          Map[
            expectationValue[#, grid, wf, wf, mul]&,
            exfns
            ],
          {wf, wfns}
          ]
    ];
WFExpectationValues[
  c_WavefunctionsObject,
  evs_,
  ops:OptionsPattern[]
  ]:=
  iWFExpectationValues[
    {c["Grid"]["Points"], Flatten@#["Values"]&/@c["Wavefunctions"]},
    evs,
    OptionValue["MultiplicativeOperator"],
    ops
    ];


(* ::Subsubsection::Closed:: *)
(*OperatorMatrix*)



Options[WFOperatorMatrix]=
  Join[
    Options@WFExpectationValues,
    {
      "AssumeSymmetric"->True,
      "AssumeHermitian"->False
      }
    ];
iWFOperatorMatrix[
  {grid_, wfns_},
  evs_,
  asrs_,
  ash_,
  mul_,
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      exfns=Flatten@List@evs,
      els,
      sels,
      mat,
      exf,
      mo
      },
      If[!ListQ@mul, mul=ConstantArray[mul, Length@exfns]];
      Table[
        exf=exfns[[n]];
        mo=mul[[n]];
        mat=ConstantArray[0., {Length@wfns, Length@wfns}];
        operatorMatrix[exf, grid, wfns, wfns, asrs, ash, mo],
        {n, Length@exfns}
        ]
    ];
WFOperatorMatrix[
  c_WavefunctionsObject,
  evs_,
  ops:OptionsPattern[]
  ]:=
  iWFOperatorMatrix[
    {c["Grid"]["Points"], Flatten@#["Values"]&/@c["Wavefunctions"]},
    evs,
    TrueQ@OptionValue["AssumeSymmetric"],
    TrueQ@OptionValue["AssumeHermitian"],
    OptionValue["MultiplicativeOperator"],
    ops
    ];


(* ::Subsubsection::Closed:: *)
(*OperatorMatrixElements*)



Options[WFOperatorMatrixElements]=
  Options@WFOperatorMatrix;
iWFOperatorMatrixElements[
  {grid_, wfns_},
  evs_,
  ash_,
  asrs_,
  mul_,
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      exfns=Flatten@List@evs,
      els,
      sels,
      mat,
      exf,
      mo,
      wfL,
      wfR,
      res
      },
    {sels, exfns}=Transpose[List@@@exfns];
    (* get a list of LHS wavefunctions and RHS wavefunctions for each set of expectation value functions *)
    wfL=
      Map[
        Map[
          Part[wfns, #]&,
          Replace[
            Replace[#, k:{Except[_List], _}:>{k}][[All, 1]], 
            i_Integer:>{i},
            1
            ]
          ]&,
        sels
        ];
    wfR=
      Map[
        Map[
          Part[wfns, #]&,
          Replace[
            Replace[#, k:{Except[_List], _}:>{k}][[All, 2]], 
            i_Integer:>{i},
            1
            ]
          ]&,
        sels
        ];
    If[!ListQ@mul, mul=ConstantArray[mul, Length@exfns]];
    (* Thread over the right and left wavefunctions, the operators, and the multiplicativity *)
    res=
      MapThread[
        With[{l=#, r=#2, m=If[ListQ@#3&&!ListQ@#4, ConstantArray[#4, Length@#3], #4]},
          (* Thread over the operators and multiplicativity *)
          If[Length@#3==1, First, Identity]@
            MapThread[
              If[Length@wfL>1||Length@wfR>1,
                operatorMatrix[exf, grid, wfL, wfR, asrs, ash, mo],
                expectationValue[exf, grid, wfL[[1]], wfR[[1]], mo]
                ],
              {
                #3,
                m
                }
              ]
          ]&,
        {
          wfL,
          wfR,
          exfns,
          mul
          }
        ];
    If[Length@wfL==1, res[[1]], res]
    ];


WFOperatorMatrixElements[
  c_WavefunctionsObject,
  evs:
    (({_, _}->_)|
    ({{_, _}...}->_)|
    {(({{_, _}...}|{_, _})->_)..}),
  ops:OptionsPattern[]
  ]:=
  iWFOperatorMatrixElements[
    {c["Grid"]["Points"], Flatten@#["Values"]&/@c["Wavefunctions"]},
    evs,
    TrueQ@OptionValue["AssumeSymmetric"],
    TrueQ@OptionValue["AssumeHermitian"],
    OptionValue["MultiplicativeOperator"],
    ops
    ];


End[];



