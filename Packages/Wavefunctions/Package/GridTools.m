(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*Grid Tools*)



(* ::Text:: *)
(*
	Grid functions should all take an option specifying the axis for the operation
*)



(* ::Subsubsection::Closed:: *)
(*Constructors*)



ConstructCoordinateGrid;
CoordinateGridObjectQ;


(* ::Subsubsection::Closed:: *)
(*Parts*)



GridPart::usage=
  "Applies part to a wavefunction";
GridKeyPart::usage=
  "Applies key lookup to a coordinate grid";


(* ::Subsubsection::Closed:: *)
(*Structural*)



GridPoints::usage=
  "Flattens down to the coordiante points";
GridTransform::usage=
  "Applies a transformation to the coordinates points, maintaining ordering";
GridSort::usage=
  "";
GridTranspose::usage=
  "";


(* ::Subsubsection::Closed:: *)
(*Properties*)



GridDimension::usage=
  "";
GridDimensions::usage=
  "";
GridPointNumber::usage=
  "";
GridMeshSpacings=
  "Only makes sense for regularly sampled grids";
GridRegularlySampledQ=
  "";


(* ::Subsubsection::Closed:: *)
(*Functions*)



GridMap::usage=
  "Maps a function over the grid";
GridCreateMapFunction::usage=
  "Builds a GridFunctionObject by mapping over the grid";


(* ::Subsubsection::Closed:: *)
(*Mindless*)



GridBoundingBox::usage="";
GridBounds::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*Constructor*)



(* ::Subsubsection::Closed:: *)
(*ConstructGrid*)



(* ::Subsubsubsection::Closed:: *)
(*validateGridData*)



validateGridData[grid_]:=
  (*Developer`PackedArrayQ[grid]&&*)(* handled in cleanGridData *)
    Module[
      {
        d=Depth[grid],
        dim=Dimensions[grid],
        dn
        },
      If[d<=2,
        PackageRaiseException[
          Automatic,
          "grid data has insufficient depth to be valid"
          ]
        ];
      If[!(
        dn=grid[[Sequence@@ConstantArray[1, d-2]]];
        Length@dn==d-2
        ),
        PackageRaiseException[
          Automatic,
          "grid depth and grid dimension don't match"
          ],
        True
        ]
      ]


(* ::Subsubsubsection::Closed:: *)
(*cleanGridData*)



cleanGridData//Clear
cleanGridData[g_List]:=
  With[{base=Developer`ToPackedArray@N@g},
    If[!Developer`PackedArrayQ[base],
      base;
      PackageRaiseException[
        Automatic,
        "Grid data cannot be packed"
        ]
      ];
    If[Depth@base==2,
      Transpose@{base},
      base
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*ConstructCoordinateGrid*)



ConstructCoordinateGrid//Clear
ConstructCoordinateGrid[grid_List]:=
  With[{g=cleanGridData@grid},
    If[validateGridData[g],
      <|"Grid"->g|>,
      <|$Failed->True|> (* requires Association return to throw the error *)
      ]
    ];
ConstructCoordinateGrid[CoordinateGridObject[a_]?CoordinateGridObjectQ]:=
  a;
ConstructCoordinateGrid[a_Association]:=
  a;


(* ::Subsection:: *)
(*Grid Parts*)



(* ::Subsubsection::Closed:: *)
(*CoordinateGridPart*)



GridPart[c:CoordinateGridObject[a_], p__]:=
  If[IntegerQ@p, Identity, CoordinateGridObject]@
    a[["Grid", p]]


(* ::Subsubsection::Closed:: *)
(*CoordinateGridKeyPart*)



GridKeyPart[c:CoordinateGridObject[a_], sel__]:=
  a[sel]


(* ::Subsection:: *)
(*Structural*)



(* ::Subsubsection::Closed:: *)
(*GridPoints*)



GridPoints[grid_List]:=
  Module[{d=Depth[grid]},
    Which[
      d>3,
        Flatten[grid, d-3],
      d==3,
        grid,
      d==2,
        List/@grid,
      d==1,
        PackageRaiseException["Grid",
          "Grid `` has depth 1...?",
          grid
          ]
      ]
    ];
GridPoints[grid_]:=
  GridPoints@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridTransform*)



GridTransform[grid_List, tf_]:=
  Module[{d=Depth[grid]},
    Which[
      d>3,
        Map[tf, d-2],
      d==3,
        Map[tf, grid],
      d==2,
        Map[tf, List/@grid],
      d==1,
        PackageRaiseException["Grid",
          "Grid `` has depth 1...?",
          grid
          ]
      ]
    ];
GridTransform[grid_, tf_]:=
  GridTransform[grid["Grid"], tf];


(* ::Subsection:: *)
(*Properties*)



(* ::Subsubsection::Closed:: *)
(*GridDimensions*)



GridDimensions[grid_List]:=
  Dimensions[grid][[;;-2]];
GridDimensions[grid_]:=
  GridDimensions@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridDimension*)



GridDimension[grid_List]:=
  Dimensions[grid][[-1]];
GridDimension[grid_]:=
  GridDimension@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridDepth*)



GridDepth[grid_List]:=
  GridDepth[grid]-1;
GridDepth[grid_]:=
  GridDepth@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridPointNumber*)



GridPointNumber[g_]:=
  Times@@GridDimensions[g];


(* ::Subsection:: *)
(*Functions*)



GridMap[f_, g_List]:=
  Map[f, g, {Depth[g]-2}];
GridMap[f_, g_]:=
  GridMap[f, g["Grid"]];


GridCreateMapFunction[f_, g_]:=
  With[{map=GridMap[f, g]},
    GridFunctionObject[g, map]
    ];


(* ::Subsection:: *)
(*Mindless*)



GridBounds[g_List]:=
  CoordinateBounds[g];
GridBoundingBox[g_List]:=
  CoordinateBoundingBox[g];
GridBounds[g_]:=
  GridBounds[g["Grid"]];
GridBoundingBox[g_List]:=
  GridBoundingBox[g["Grid"]];


End[];



