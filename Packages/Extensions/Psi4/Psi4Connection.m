(* ::Package:: *)

(* Autogenerated Package *)

(* ::Subsubsection::Closed:: *)
(*Defaults*)



$Psi4::usage=
	"The default Psi4 instance";
$Psi4Dir::usage=
	"Directory for the default Psi4 instance";


(* ::Subsubsection::Closed:: *)
(*Build*)



Psi4Build::usage=
	"Gets and compiles the Psi4 system if necessary";


(* ::Subsubsection::Closed:: *)
(*Objects*)



Psi4::usage="A psi4 instance";
Psi4Input::usage="An association configuring a Psi4 run";
Psi4Output::usage="An association with Psi4 output";
Psi4Data::usage="An association of Psi4 data";


(* ::Subsubsection::Closed:: *)
(*Calls and Config*)



Psi4Call::usage="Basic Psi4 call on either an association or a file / directory";
$Psi4ConfigMap::usage="Maps options names to Psi4 names";
$Psi4ConfigChoices::usage="Helpful dict of option choices";
Psi4Compile::usage=
	"Overloads the private ToPython symbolic converter to create Psi4 ready structures";
Psi4Molecule::usage=
	"Turns atoms / positions into a molecule string for a Psi4 input file";
Psi4Config::usage=
	"Configures a 'set' block for a psi4 input file from option names";
Psi4Function::usage=
	"Configures a Psi4 function call";
Psi4GridFile::usage=
	"Configures a grid file string ready for psi4";
Psi4InputFile::usage=
	"Configures an input file string ready for psi4";
Psi4ConfigureCall::usage=
	"Preps an input file + other info ready for psi4";


(* ::Subsubsection::Closed:: *)
(*Utils*)



Psi4UtilsAutoGrid::usage="";
Psi4UtilsAutoScan::usage="";
Psi4DataParseGeometry::usage="";


(* ::Subsubsection::Closed:: *)
(*Basics*)



Psi4GeometryOptimize::usage="Basic geometry optimization";
Psi4GeometryInfo::usage="Gathers basic psi4 structural info";
Psi4Property::usage=
	"Formats a basic call to property";
Psi4Scan::usage=
	"Performs a function in a scan";


(* ::Subsubsection::Closed:: *)
(*Energies*)



Psi4Energy::usage="";
Psi4EnergyScan::usage="";


(* ::Subsubsection::Closed:: *)
(*OneElectronProperty*)



Psi4OneElectronProperty::usage=
	"Calls oeprop. To be subclassed";
Psi4OneElectronElectrostaticPotential::usage=
	"Calls oeprop electrostatic potential";
Psi4OneElectronDipoleMoment::usage=
	"Gets oeprop dipole moments";


(* ::Subsubsection::Closed:: *)
(*CubeProperty*)



Psi4CubeProperty::usage=
	"Calls cubeprop to generate a cubefile for a given property";
Psi4CubeOrbitals::usage=
	"Generates orbitals with cubeprop";
Psi4CubeElectronDensity::usage=
	"Calculates electron density with cubeprop";
Psi4CubeElectrostaticPotential::usage=
	"Calculates electrostatic potential with cubeprop";


Begin["`Private`"];


PyToolsLoad[]


(* ::Subsubsection::Closed:: *)
(*FindPsi4*)



$Psi4Path=
	{
		$ChemExtensionsApp,
		$ChemExtensionsDev
		}


FindPsi4[]:=
	Replace[
		StringTrim@
			RunProcess[			
				{If[$OperatingSystem=="Windows", "where", "which"], "psi4"},
				"StandardOutput"
				],
		{
			psi4_String?(StringLength[#]>0&&FileExistsQ[#]&&psi4Q[Nest[DirectoryName, #, 2]]&):>
				Nest[DirectoryName, psi4, 2],
			_:>
				SelectFirst[
					FileNames["*psi*",
						$Psi4Path
						],
					psi4Q,
					ChemExtensionDir["psi4"]
					]
			}
		]


(* ::Subsubsection::Closed:: *)
(*$Psi4Dir*)



$Psi4Dir:=$Psi4Dir=FindPsi4[];
$Psi4:=Psi4@$Psi4Dir;


(* ::Subsection:: *)
(*Build and Make*)



(* ::Subsubsection::Closed:: *)
(*psi4Download*)



psi4Download[parentDir_?DirectoryQ]:=
	RunInTerminal[{
		"git","clone","--recursive",
		"https://github.com/psi4/psi4.git",
		ExpandFileName@FileNameJoin@{parentDir,"psi4"}
		}];


(* ::Subsubsection::Closed:: *)
(*psi4DirInittedQ*)



psi4DirInittedQ[parentDir_]:=
	DirectoryQ@FileNameJoin@{parentDir, "psi4"}


(* ::Subsubsection::Closed:: *)
(*psi4NoBinQ*)



psi4HasBinQ[parentDir_]:=
	FileExistsQ@FileNameJoin@{parentDir, "psi4", "bin", "psi4"}


(* ::Subsubsection::Closed:: *)
(*psi4NoBuildDirQ*)



psi4NoBuildDirQ[parentDir_]:=
	!DirectoryQ@FileNameJoin@{parentDir, "psi4", "objdir"}


(* ::Subsubsection::Closed:: *)
(*psi4BuildObjDir*)



psi4BuildObjDir[parentDir_]:=
	ExpandFileName@FileNameJoin@{parentDir,"psi4","objdir"}


(* ::Subsubsection::Closed:: *)
(*psi4BuildUnstagedQ*)



psi4BuildUnfinishedQ[parentDir_]:=
	!DirectoryQ@
			FileNameJoin@{
				parentDir,
				"psi4","objdir","stage",
				FileNameTake[ExpandFileName@parentDir,1]
				}


(* ::Subsubsection::Closed:: *)
(*psi4Build*)



Psi4Build::nodir="Directory `` not found";
psi4Build[parentDir_?DirectoryQ]:=
	If[psi4DirInittedQ@parentDir,
		If[psi4HasBinQ@parentDir,
			{0, {FileNameJoin@{parentDir, "psi4", "bin"}}},
			AbsoluteTiming@
				{
					If[psi4NoBuildDirQ@parentDir,
						RunInTerminal[
							{
								CMakeBinary[],
								"-H.","-Bobjdir",
								"-DCMAKE_INSTALL_PREFIX="<>
									ExpandFileName@FileNameJoin@{parentDir, "psi4"}
								},
							ProcessEnvironment-><|
								"PATH"->
									StringRiffle[
										{
											Environment["PATH"],
											ExpandFileName@FileNameJoin@{parentDir, "psi4"}
											},
										":"
										]
								|>,
							ProcessDirectory->ExpandFileName@FileNameJoin@{parentDir,"psi4"}
							]
						],
					If[psi4BuildUnfinishedQ[parentDir],
						RunInTerminal[{"make","-j`getconf _NPROCESSORS_ONLN`"},
							ProcessDirectory->psi4BuildObjDir[parentDir]
							];
						RunInTerminal[{"make","install"},
							ProcessDirectory->psi4BuildObjDir[parentDir]
							]
						],
					With[
					{
						psi4=
							ExpandFileName@
								FileNameJoin@{
									parentDir, "psi4", "objdir", "stage",
									ExpandFileName@parentDir, "psi4"
									}
							},
						If[DirectoryQ@psi4,
							If[!DirectoryQ@FileNameJoin@{parentDir, "psi4", "dist"},
								CreateDirectory@FileNameJoin@{parentDir, "psi4", "dist"}
								];
							CopyDirectory[
								psi4,
								FileNameJoin@{parentDir, "psi4", "dist", "psi4"}
								]
							]
						]
					}
			]//
			If[Last@Last@#=!=Null,
				$Psi4BuildLogs=Last@#;
				TemplateApply["Built to `pkg`. Took `time`.",
						<|
							"time"->
								UnitConvert[Quantity[First@#,"Seconds"],"Minutes"],
							"pkg"->Last@Last@#
							|>],
				PackageRaiseException["Psi4Build",
					"Failed to build Psi4 to ``",
					"MessageParameters"->{FileNameJoin@{parentDir,"psi4"}}
					]
				]&,
		PackageRaiseException["Psi4Build",
			"Failed to download psi4 to ``",
			"MessageParameters"->{FileNameJoin@{parentDir,"psi4"}}
			]
		];


(* ::Subsubsection::Closed:: *)
(*Psi4Build*)



Psi4Build[parentDir_?DirectoryQ]:=
	PackageExceptionBlock["Psi4Build"]@
		If[$OperatingSystem=="Windows",
			PackageRaiseException["Psi4Build",
				"psi4 is designed for Unix systems only"
				],
			If[!FileExistsQ@FileNameJoin@{parentDir, "psi4"},
				psi4Download@parentDir
				];
			psi4Build@parentDir
			];
Psi4Build[Optional[Automatic, Automatic]]:=
	Psi4Build[DirectoryName[$Psi4Dir]];


(* ::Subsection:: *)
(*Utilities*)



(* ::Subsubsection::Closed:: *)
(*bin*)



psiBin[d_String]:=FileNameJoin@{d,"bin","psi4"}


(* ::Subsubsection::Closed:: *)
(*Q*)



psi4Q[d_String]:=
	FileExistsQ@psiBin@d;
psi4Q[_]:=
	False;


(* ::Subsubsection::Closed:: *)
(*AutoGrid*)



Psi4UtilsAutoGrid[
	atomset_List,
	{xpoints_Integer,ypoints_Integer,zpoints_Integer},
	mode:"Sphere"|"Grid":"Grid",
	props___?OptionQ
	]:=
	With[{cbs=ChemUtilsCoordinateBounds[atomset]},
		<|
			"Molecules"->atomset,
			"Grid"->
				Table[
					{x,y,z},
					{x,Replace[Subdivide[cbs[[1]],xpoints],{f_,l_}:>f,1]},
					{y,Replace[Subdivide[cbs[[2]],ypoints],{f_,l_}:>f,1]},
					{z,Replace[Subdivide[cbs[[3]],zpoints],{f_,l_}:>f,1]}
					],
			props
			|>	
		];
Psi4UtilsAutoGrid[
	atomset_List,
	atMostPoints:_Integer:27,
	mode:"Sphere"|"Grid":"Grid",
	props___?OptionQ
	]:=
	With[{
		xp=Floor@Power[atMostPoints,1/3],
		yp=Floor@Power[atMostPoints,1/3],
		zp=Floor@Power[atMostPoints,1/3]
		},
		Psi4UtilsAutoGrid[atomset,{xp,yp,zp},props]
		];


(* ::Subsubsection::Closed:: *)
(*Scan Specs*)



Psi4UtilsCoordinateScanGrid//Clear


Psi4UtilsCoordinateScanGrid[
	coordinateBounds_,
	divs:{Repeated[_->_,{3}]}
	]:=
	Map[
		Replace[divs[[#, 2]],{
			i_?NumericQ:>
				{
					divs[[#,1]],
					Sequence@@coordinateBounds[[#]],
					Apply[Subtract,Reverse[coordinateBounds[[#]]]]/i
					},
			{s_List}:>
				{divs[[#,1]],s},
			{s_,e_,i_}:>
				If[Abs[e-s]>0,
					{divs[[#,1]],{s}},
					{
						divs[[#,1]],
						s,
						e,
						(e-s)/i
						}
					]
			}]&,
		Range[3]
		]
Psi4UtilsCoordinateScanGrid[
	coordinateBounds_,
	divs:{_,_,_}
	]:=
	Psi4UtilsCoordinateScanGrid[
		coordinateBounds,
		Map[
			"pyVar_"<>ToString[#]->divs[[#]]&,
			Range[3]
			]
		]


Psi4UtilsCoordinateScanSphere//Clear


Psi4UtilsCoordinateScanSphere[
	coordinateBounds_,
	divs:{Repeated[_->_,{3}]}
	]:=
	With[{
		r=(Subtract@@Reverse@MinMax[Flatten@coordinateBounds])/2.
		},
		Map[
			Replace[divs[[#, 2]],{
				i_Integer:>
					{
						divs[[#,1]],
						Switch[#,
							1,
								Sequence@@{Min@{.00001,r/100}, r, r/i},
							2,
								Sequence@@{0, 360, 360/i},
							3,
								Sequence@@{0, 180, 180/i}
							]
						},
				{s_List}:>
					{divs[[#,1]],s},
				{s_,e_,i_}:>
					If[Abs[e-s]>0||i==0,
						{divs[[#,1]],{s}},
						{
							divs[[#,1]],
							If[!IntegerQ@s,N@s,s],
							If[!IntegerQ@e,N@e,e],
							If[!IntegerQ@#,N@#,#]&[(e-s)/i]
							}
						]
				}]&,
			Range[3]
			]
		];
Psi4UtilsCoordinateScanSphere[
	coordinateBounds_,
	divs:{_,_,_}
	]:=
	Psi4UtilsCoordinateScanSphere[
		coordinateBounds,
		Map["pyVar_"<>ToString[#]->divs[[#]]&,Range[3]]
		]


(* ::Subsubsection::Closed:: *)
(*AutoScan*)



psi4ScanSpecBasePat=
	_?NumericQ|{_?NumericQ,_?NumericQ,_?NumericQ}|{_List}
psi4ScanSpecPat=
	psi4ScanSpecBasePat|
		(_->psi4ScanSpecBasePat)


Psi4UtilsAutoScan//Clear


Psi4UtilsAutoScan[
	atomset_List,
	pts:{Repeated[psi4ScanSpecPat,{3}]},
	mode:"Sphere"|"Cube":"Cube",
	props___?OptionQ
	]:=
	With[
		{
			cbs=
				ChemUtilsCoordinateBounds@
					DeleteCases[atomset,
						Except[{_,{__?NumericQ}}]
						]
			},
		<|
			props,
			"Molecules"->atomset,
			"Scan"->
				If[mode==="Sphere",
					Psi4UtilsCoordinateScanSphere[cbs,pts],
					Psi4UtilsCoordinateScanGrid[cbs,pts]
					],
			If[mode==="Sphere",
				"ScanCoordinatesPre"->
					With[{scanf=Lookup[{props},"ScanCoordinatesPre",Identity]},
						If[scanf===Identity,
							PyFromSphericalCoordinates[{#,#2,#3}],
							PyFromSphericalCoordinates@
								PyStar[PyCall[scanf][#,#2,#3]]
							]
						],
				Nothing
				]
			|>
		];
Psi4UtilsAutoScan[
	atomset_List,
	atMostPoints:_Integer:27,
	mode:"Sphere"|"Grid":"Grid",
	props___?OptionQ
	]:=
	With[{
		xp=Floor@Power[atMostPoints,1/3],
		yp=Floor@Power[atMostPoints,1/3],
		zp=Floor@Power[atMostPoints,1/3]
		},
		Psi4UtilsAutoScan[atomset,{xp,yp,zp},mode,props]
		];


(* ::Subsection:: *)
(*Formatting*)



(* ::Subsubsection::Closed:: *)
(*Images*)



$psi4RunIcon=
	Import@PackageFilePath["Resources", "Icons", "Psi4RunIcon.png"];


$psi4PNG=
	Image[
		Import@PackageFilePath["Resources", "Icons", "Psi4Icon.png"],
		ImageSize->32
		];


$psi4InIcon=
	With[{bg=GrayLevel@.9,bd=GrayLevel@.8,X=1.15,ys=.25},
		Graphics[
			{
				bg,
				EdgeForm@bd,
				Polygon@{{X/2,1},{X,.5},{X/2,0},{X/2,ys},{0,ys},{0,1-ys},{X/2,1-ys}},
				Inset[$psi4PNG,{0,0},{0,0},{X-.1,1}]
				},
			PlotRange->{{0,X+.05},{0,1}},
			ImageSize->32
			]
		];


$psi4OutIcon=
	With[{bg=GrayLevel@.9,bd=GrayLevel@.8,X=1.15,ys=.25},
		Graphics[
			{
				bg,
				EdgeForm@bd,
				Polygon@{{X/2,1},{0,.5},{X/2,0},{X/2,ys},{X,ys},{X,1-ys},{X/2,1-ys}},
				Inset[$psi4PNG,{0,0},{0,0},{X-.1,1}]
				},
			PlotRange->{{0,X+.05},{0,1}},
			ImageSize->32
			]
		];


(* ::Subsubsection::Closed:: *)
(*Functions*)



sysOpen[f_]:=
	Switch[$OperatingSystem,
		"MacOSX",
			With[{r=
				RunProcess[{"open","-a","TextWrangler",f}]},
				If[r["ExitCode"]=!=0,
					RunProcess[{"open","-t",f}]
					]
				],
		"Windows",
			RunProcess[{"start",f}]
		];


openTMP[f_,s_]:=
	With[{opf=
		With[{tmp=OpenWrite@FileNameJoin@{$TemporaryDirectory,f}},
			WriteString[tmp,s];
			Close@tmp
			]},
		sysOpen@opf;
		RunScheduledTask[DeleteFile@opf,{1,1}]
		];


(* ::Subsubsection::Closed:: *)
(*Psi4*)



Format[Psi4[dir_?psi4Q]]:=
	RawBoxes@BoxForm`ArrangeSummaryBox[
		"Psi4",
		Psi4[dir],
		$psi4PNG,
		{
			BoxForm`MakeSummaryItem[{
				"Directory: ",
				Button[
					Mouseover[
						Style[FileNameTake@dir,"Hyperlink"],
						Style[FileNameTake@dir,"HyperlinkActive"]
						],
					SystemOpen@ExpandFileName@dir,
					Appearance->"Frameless",
					BaseStyle->"Hyperlink"
					]},
				StandardForm]
			},
		{
			BoxForm`MakeSummaryItem[{
				"Program: ",
				Button[
					Mouseover[
						Style["psi4","Hyperlink"],
						Style["psi4","HyperlinkActive"]
						],
					SystemOpen@ExpandFileName@FileNameJoin@{dir,"bin"},
					Appearance->"Frameless",
					BaseStyle->"Hyperlink"
					]
				},
				StandardForm]
			},
		StandardForm
		];


(* ::Subsubsection::Closed:: *)
(*Data*)



Format[Psi4Data[a_Association]]:=
	RawBoxes@BoxForm`ArrangeSummaryBox[
		"Psi4Data",
		Psi4Data[a],
		$psi4Icon,
		{
			BoxForm`MakeSummaryItem[{"Items: ",Length@a},StandardForm]
			},
		{ 
			BoxForm`MakeSummaryItem[{"Keys: ",Keys@a},StandardForm],
			BoxForm`MakeSummaryItem[{"Iterations: ",Max@(Length/@a)},StandardForm]
			},
		StandardForm
		];


(* ::Subsubsection::Closed:: *)
(*Input*)



Format[Psi4Input[a_Association]]:=
	RawBoxes@BoxForm`ArrangeSummaryBox[
		"Psi4Input",
		Psi4Input[a],
		$psi4InIcon,
		{
			BoxForm`MakeSummaryItem[{"Main: ",
				With[{t=a["Input","input.dat"], ct=Context@Psi4Input},
					Button[Mouseover["input.dat",Style["input.dat","HyperlinkActive"]],
						Get[StringTrim[ct]];
						openTMP["input.dat",t],
						BaseStyle->"Hyperlink",
						Appearance->"Frameless"
						]
					]},
				StandardForm]
			},
		{
			Replace[a["Directory"],
				{
					s_String?DirectoryQ:>
						BoxForm`MakeSummaryItem[{"Directory: ",
							Button[Mouseover[FileNameTake@s,Style[FileNameTake@s,"HyperlinkActive"]],
								SystemOpen@s,
								BaseStyle->"Hyperlink",
								Appearance->"Frameless"
								]},
							StandardForm],
					_->Nothing
					}],
			With[{o=KeyDrop[a["Input"],"input.dat"], ct=Context@Psi4Input},
				If[Length@o>0,
					BoxForm`MakeSummaryItem[{
						"Other Inputs:",
						Replace[Normal@o,
							(f_->t_):>
								Button[Mouseover["input.dat",Style["input.dat","HyperlinkActive"]],
									Get[StringTrim[ct, "Private`"]];
									openTMP[f,t],
									BaseStyle->"Hyperlink",
									Appearance->"Frameless"
									],
							1]
						},
						StandardForm],
					Nothing
					]
				],
			BoxForm`MakeSummaryItem[{"Output Files:",Lookup[a,"Output","output.dat"]},
				StandardForm]
			},
		StandardForm
		]


(* ::Subsubsection::Closed:: *)
(*Output*)



Format[Psi4Output[a_Association]]:=
	RawBoxes@BoxForm`ArrangeSummaryBox[
		"Psi4Output",
		Psi4Output[a],
		$psi4OutIcon,
		{
			BoxForm`MakeSummaryItem[{"Exit code: ",a["ExitCode"]},StandardForm]
			},
		{
			If[StringLength@a["StandardOutput"]>0,
				Button[Mouseover["Output Messages",Style["Output Messages","HyperlinkActive"]],
					CreateDialog[
						Framed[
							Pane[a["StandardOutput"],{Automatic,{150,500}},Scrollbars->Automatic],
							Background->White
							],
						Deployed->False,
						Selectable->True,
						WindowClickSelect->True,
						WindowTitle->"Standard Output"
						],
					BaseStyle->"Hyperlink",
					Appearance->"Frameless"
					],
				Nothing
				],
			If[StringLength@a["StandardError"]>0,
				Button[Mouseover["Error Messages",Style["Error Messages","HyperlinkActive"]],
					CreateDialog[
						Framed[
							Pane[a["StandardError"],{Automatic,{150,500}},Scrollbars->Automatic],
							Background->White
							],
						Deployed->False,
						Selectable->True,
						WindowClickSelect->True,
						WindowTitle->"Standard Error"
						],
					BaseStyle->"Hyperlink",
					Appearance->"Frameless"
					],
				Nothing
				],
			If[KeyMemberQ[a,"InputFiles"],
				BoxForm`MakeSummaryItem[{
					"Input files:",
					Column@
						Replace[Normal@a["InputFiles"],
							{
								(f_->t_):>
									With[{ct=Context@Psi4Input},
										Button[Mouseover[f,Style[f,"HyperlinkActive"]],
											Get[ct];
											openTMP[f,t],
											BaseStyle->"Hyperlink",
											Appearance->"Frameless"
											]
										],
								f_:>
									With[{ct=Context@Psi4Input},
										Button[
											Mouseover[FileNameTake@f,Style[FileNameTake@f,"HyperlinkActive"]],
											Get[ct];
											sysOpen@f,
											BaseStyle->"Hyperlink",
											Appearance->"Frameless"
											]
										]
								},
							1]
						},
						StandardForm
						],
					Nothing
					],
			If[KeyMemberQ[a,"OutputFiles"],
				BoxForm`MakeSummaryItem[{
					"Output files:",
					Column@
						Replace[Normal@Lookup[a,"OutputFiles",<||>],
							{
								(f_->t_):>
									Button[Mouseover[f,Style[f,"HyperlinkActive"]],
										openTMP[f,t],
										BaseStyle->"Hyperlink",
										Appearance->"Frameless"
										],
								f_:>
									Button[
										Mouseover[FileNameTake@f,Style[FileNameTake@f,"HyperlinkActive"]],
										sysOpen@f,
										BaseStyle->"Hyperlink",
										Appearance->"Frameless"
										]
								},
							1]
						},
						StandardForm
						],
					Nothing
					]
			},
		StandardForm
		];


(* ::Subsection:: *)
(*OOP*)



(* ::Subsubsection::Closed:: *)
(*Directory*)



Psi4/:HoldPattern[Directory@Psi4[d_?psi4Q]]:=d;


(* ::Subsubsection::Closed:: *)
(*Part*)



Psi4Data/:HoldPattern[Psi4Data[a_Association][p__]]:=
	psi4DataLookup[a,p]


(* ::Subsubsection::Closed:: *)
(*Run*)



Psi4/:HoldPattern[Psi4[d_?psi4Q][data:_String?FileExistsQ|_Association,params___]]:=
	Psi4Call[Psi4[d],data,params];
Psi4/:HoldPattern[Psi4[d_?psi4Q][Psi4Input[data_Association,params___]]]:=
	Psi4[d][data,params];


(* ::Subsubsection::Closed:: *)
(*Output*)



Psi4Output/:HoldPattern[Psi4Output[a_Association][k_String]]:=
	Lookup[a,k,
		Replace[
			Lookup[Lookup[a,"OutputFiles",<||>],k],
			_Missing:>Lookup[Lookup[a,"InputFiles",<||>],k]
			]
		];
Psi4Output/:HoldPattern[Psi4Output[a_Association][main_String,sub__String]]:=
	Fold[Replace[#,_List|_Association:>Lookup[#,#2]]&,a,{main,sub}];
Psi4Output/:HoldPattern[Psi4Output[a_Association][keys:{__}]]:=
	Psi4Output[a]/@keys;


(* ::Subsubsection::Closed:: *)
(*Input*)



Psi4Input/:HoldPattern[Psi4Input[a_Association][k_String]]:=
	Lookup[a,k,
		Lookup[a["Input"],k]
		];
Psi4Input/:HoldPattern[Psi4Input[a_Association][main_String,sub__String]]:=
	Fold[Replace[#,_List|_Association:>Lookup[#,#2]]&,a,{main,sub}];
Psi4Input/:HoldPattern[Psi4Input[a_Association][keys:{__}]]:=
	Psi4Output[a]/@keys;
Psi4Input/:
	HoldPattern[Psi4InputFile@Psi4Input[a_Association]]:=
		Psi4Input[a]["input.dat"];


(* ::Subsection:: *)
(*Run*)



(* ::Subsubsection::Closed:: *)
(*Call basic*)



Psi4Call[psi4Binary_String?FileExistsQ,
	file_String?FileExistsQ,
	output:_String|_Alternatives|_StringExpression:"output.dat",
	processFunction:RunProcess|RunInTerminal:RunProcess]:=
	With[{d=
		If[DirectoryQ@file,
				ExpandFileName@file,
				ExpandFileName@DirectoryName@file]},
		With[{r=
			processFunction[
				If[DirectoryQ@file,"psi4",
					{"psi4",FileNameTake@file}],
				ProcessEnvironment-><|
					"PATH"->
						StringJoin@{
							ExpandFileName@FileNameTake[psi4Binary,{1,-2}],
							":",
							Environment["PATH"]
							}
					|>,
				ProcessDirectory->d
				]},
			Psi4Output@
				If[r["ExitCode"]===0,
					Merge[{r,
						<|
							"InputFiles"->(<|FileNameTake@file->ExpandFileName@file|>),
							"OutputFiles"->FileNames[output,d]
							|>
						},
						First],
					Append[r,"InputFiles"->(<|FileNameTake@file->ExpandFileName@file|>)]
					]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Terminal Call*)



Psi4TerminalCall[psi4Binary_String?FileExistsQ,p___]:=
	Psi4TerminalCall[psi4Binary,p]


Psi4Call[Psi4[d_String?DirectoryQ],
	a___
	]:=
	Psi4Call[FileNameJoin@{d,"bin","psi4"},a];
Psi4TerminalCall[Psi4[d_String?DirectoryQ],
	a___
	]:=
	Psi4TerminalCall[FileNameJoin@{d,"bin","psi4"},a]


(* ::Subsubsection::Closed:: *)
(*Association call*)



Psi4Call[psi4Binary_,
	a_Association?(KeyMemberQ@"Input")|Psi4Input[a_Association?(KeyMemberQ@"Input")],
	dir:_String?DirectoryQ|Automatic:Automatic
	]:=
	With[{
		inputFiles=a["Input"],
		outputPattern=
			Replace[Lookup[a,"Output","output.dat"],{
				o_Association:>Alternatives@@Keys@o,
				Except[_String|_Alternatives|_StringExpressions]:>
					"output.dat"
				}],
		postProcessing=
			Replace[Lookup[a,"Output",Identity],{
				_String|_StringExpression|_Alternatives->
					Identity,
				l:(_List|_Rule):>Association@l,
				e:Except[_Association]:>
					<|"output.dat"->e|>
				}],
		directory=
			Replace[dir,
				Automatic:>
					Replace[a["Directory"],
						Except[_String?DirectoryQ]:>
							CreateDirectory@FileNameJoin@{$TemporaryDirectory,CreateUUID["psi4-"]}
							]
						]},
		KeyValueMap[
			With[{f=OpenWrite@FileNameJoin@{directory,#}},
				WriteString[f,#2];
				Close@f
				]&,
			inputFiles];
		With[{r=Psi4Call[psi4Binary,directory,outputPattern]},
			With[{out=
				Psi4Output@ReplacePart[First@r,{
					"InputFiles"->a["Input"],
					"GeneratedFiles"->(FileNameJoin@{directory,#}&/@Keys@a["Input"]),
					"OutputFiles"->
						With[{post=
							Replace[postProcessing,{
								l:_Association|_List:>
									Replace@
										Normal@Append[
											KeyMap[_?(StringMatchQ[#])&,Association@l],
											_->Identity],
								e_:>Replace[_->e]
								}]},
							If[FileExistsQ@#,
								With[{fn=FileNameTake@#},
									fn->
										post[fn]@
											Import[#,"Text"]
									],
								Nothing]&/@r["OutputFiles"]//
								Association
							]
					}]},
				If[dir===Automatic&&!MatchQ[a["Directory"],_String?DirectoryQ],
					DeleteDirectory[directory,DeleteContents->True]];
				out
				]
			]
		];
Psi4Call[psi4Binary_,
	a_Association?(Not@*KeyMemberQ@"Input"),
	dir:_String?DirectoryQ|Automatic:Automatic
	]:=
	Psi4Call[psi4Binary,<|"Input"->a|>,dir];


(* ::Subsection:: *)
(*Configuration*)



(* ::Subsubsection::Closed:: *)
(*Params*)



$Psi4ConfigMap=<|
	"BasisSet"->"basis",
	"SCFType"->"scf_type",
	"DFTBasisSet"->"df_basis",
	"DFTSelfConsistentBasisSet"->"df_basis_scf",
	"ReturnWavefunction"->"return_wfn",
	"Properties"->"properties",
	"GridProperties"->"grid_props",
	"CubePropTasks"->"cubeprop_tasks",
	"CubePropOrbitals"->"cubeprop_orbitals"
	|>;


$Psi4ConfigChoices=<|
	"CubePropTasks"->{"orbitals","density","basis_functions","esp"}
	|>;


(* ::Subsubsection::Closed:: *)
(*Utils*)



psi4DeCamelCase[s_]:=
	ToLowerCase@
		StringReplace[
			s/.$Psi4ConfigMap,
			e_?(LetterQ@#&&LowerCaseQ@#&)~~
				l_?(LetterQ@#&&!LowerCaseQ@#&):>(e<>"_"<>l)
			]


(* ::Subsubsection::Closed:: *)
(*Psi4Compile*)



Psi4Compile[expr_]:=
	With[{
		e=expr/.
			(k_String->v_):>
				(psi4DeCamelCase[k]->
					Replace[v, {s:{__String}:>Map[PyString, s], s_String:>PyString[s]}])
		},
		ToPython[e]
		];


(* ::Subsubsection::Closed:: *)
(*Molecule*)



(* ::Subsubsubsection::Closed:: *)
(*psi4MolSpec*)



psi4MolSpec[els_,mode_]:=
	PyRow[#, " "]&/@Switch[mode,
		Automatic,
			If[MatchQ[els,
					{{_String,{_?NumericQ|_String,_?NumericQ|_String,_?NumericQ|_String}}..}],
				Flatten/@els,
				els
				],
		"MolTable",
			If[MatchQ[els,{
				{_String,{_?NumericQ|_String,_?NumericQ|_String,_?NumericQ|_String}
				}..}],
				Flatten/@els,
				Flatten/@ChemFormatsZMatrixToMol@els
				],
		"ZMatrix",
			If[MatchQ[els,{{_String,{_?NumericQ,_?NumericQ,_?NumericQ}}..}],
				ChemFormatsMolToZMatrix@els,
				Flatten/@els
				]
		]/.{"Invisible"->"X"};


(* ::Subsubsubsection::Closed:: *)
(*$Psi4MolSpecs*)



$Psi4MolSpecs={
	1->"mol",
	2->"dimer",
	3->"trimer",
	4->"tetramer",
	s_String:>s,
	_->""
	};


(* ::Subsubsubsection::Closed:: *)
(*Patterns*)



atomCoordPat=_?NumericQ|_String|_Slot;
molBasePattern=
	{{_String,{Repeated[atomCoordPat,{3}]}}..}|
		{{_String,(atomCoordPat)...},{_String,atomCoordPat..}...};


molBlockPattern=
	{
		molBasePattern..
		};


molPattern=
	molBlockPattern|_String->molBlockPattern;


(* ::Subsubsubsection::Closed:: *)
(*Psi4Molecule*)



Psi4Molecule//Clear


Psi4Molecule[
	name:_String|Automatic:Automatic,
	els:molBlockPattern,
	mode:"MolTable"|"ZMatrix"|Automatic:Automatic,
	ops___String]:=
	PyBlock["molecule "<>Replace[name,Automatic:>(Length@els/.$Psi4MolSpecs)]<>" {"][
		Flatten@{
			Riffle[
				psi4MolSpec[#,mode]&/@
					ReplaceAll[els,Slot[n_]:>"pyVar_"<>ToString[n]]
					,
				"--"
				],
			ops,
			"}"
			}
		];
Psi4Molecule[
	els:molBasePattern,
	mode:"MolTable"|"ZMatrix"|Automatic:Automatic,
	ops___String]:=
	Psi4Molecule[{els},mode,ops];
Psi4Molecule[
	els:(_String->molBasePattern),
	mode:"MolTable"|"ZMatrix"|Automatic:Automatic,
	ops___String]:=
	Psi4Molecule[First[els]->{Last@els},mode,ops];
Psi4Molecule[
	mol:molPattern,
	mode:"MolTable"|"ZMatrix"|Automatic:Automatic,
	ops___String
	]:=
	If[!ListQ@mol,
		Psi4Molecule[mol[[1]],mol[[2]],mode,ops],
		Psi4Molecule[Automatic,mol,mode,ops]
		];


(* ::Subsubsection::Closed:: *)
(*Config*)



(* ::Subsubsubsection::Closed:: *)
(*$psi4Config*)



$psi4ConfigBlockHeader="";
$psi4ConfigBlockRiffle=" ";
$Psi4ConfigBlockHeader=Automatic;
$Psi4ConfigBlockRiffle=Automatic;


(* ::Subsubsubsection::Closed:: *)
(*Psi4Config*)



Psi4Config[props_List]:=
	With[{ps=
		Replace[props,
			(k_String->v_):>
				PyRow[{psi4DeCamelCase[k],v},
					Replace[$Psi4ConfigBlockRiffle,Automatic:>$psi4ConfigBlockRiffle]
					],
			1
			]
		},
		Which[
			Length@Flatten@props>1,
				PyBlock["set "<>
					Replace[$Psi4ConfigBlockHeader,
						Automatic:>$psi4ConfigBlockHeader
						]<>" {"][
					Append[ps,"}"]
					],
			Length@Flatten@props>0,
				PyRow[
					Flatten@{
						"set "<>
							Replace[$Psi4ConfigBlockHeader,
								Automatic:>$psi4ConfigBlockHeader
								]<>" {",
						ps,
						"}"},
					" "
					],
			True,
				Nothing
			]
		];
Psi4Config[a_Association]:=
	Psi4Config@Normal@a;
Psi4Config[r_Rule]:=
	If[MatchQ[r,_->(_?OptionQ)],
		Block[{
			$Psi4ConfigBlockHeader=
				Replace[$Psi4ConfigBlockHeader,
					Automatic:>psi4DeCamelCase[First@r/.$Psi4GeometryParametersMap]
					],
			$Psi4ConfigBlockRiffle=
				Replace[$Psi4ConfigBlockRiffle, Automatic:>""]
			},
			Psi4Config[Last@r]
			],
		Psi4Config@{r}
		];


(* ::Subsubsection::Closed:: *)
(*Function*)



Options@Psi4Function=
	{
		"Call"->"Required",
		"Arguments"->{},
		"KeyWordArguments"->{},
		"AssignTo"->None
		};
Psi4Function//Clear;
Psi4Function[a_Association]:=
	With[{ops=Options@Psi4Function},
		With[{components=
			Merge[{KeySelect[a,KeyMemberQ[ops,#]&],ops},First]},
			If[KeyMemberQ[components,"Function"],
				Psi4Function[components["Function"]],
				With[{
					function=components["Call"],
					args=components["Arguments"],
					kwargs=components["KeyWordArguments"],
					assignment=components["AssignTo"]
					},
					If[assignment===None,
						Identity,
						PyAssign[assignment, #]&
						][
						PyCall[function]@@
							Replace[Flatten@{args,kwargs},{
								s_String:>PyString[s],
								(k_->s_String):>
									k->PyString[s]
								},
								1]
							]
					]
				]
			]
		];
Psi4Function[r:{(_Rule|_RuleDelayed)..}]:=
	Psi4Function@Association@r;
Psi4Function[s_String][args___]:=
	Psi4Function[<|
		"Call"->s,
		"Arguments"->
			Cases[{args},Except[_Rule|_RuleDelayed]],
		"KeyWordArguments"->
			Cases[{args},_Rule|_RuleDelayed]
		|>];
HoldPattern[Psi4Function[a_->s_String][args___]]:=
	Psi4Function[<|
		"AssignTo"->a,
		"Call"->s,
		"Arguments"->
			Cases[{args},Except[_Rule|_RuleDelayed]],
		"KeyWordArguments"->
			Cases[{args},_Rule|_RuleDelayed]
		|>];


(* ::Subsubsection::Closed:: *)
(*GridFile*)



Psi4GridFile[grid_List]:=
	StringJoin@
		Riffle[
			Riffle[
				Psi4Compile/@
					Replace[#,{v_,_}:>v,1]," "]&/@(1.grid),
			"\n"];


(* ::Subsubsection::Closed:: *)
(*InputFile*)



Psi4InputFile::typerr=
	"Expected Head `` for parameter ``";


Psi4InputFile::nomol=
	"No molecules provided";
Psi4InputFile::molfmt=
	"Couldn't format molecules ``";
Psi4InputFile::nostr=
	"Arguments `` are not strings";


Psi4InputFile//Clear;
Options[Psi4InputFile]=
	{
		"Header"->None,
		"MolHeader"->None,
		"Molecules"->{},
		"MoleculeOptions"->{},
		"MolFooter"->None,
		"ConfigHeader"->None,
		"Configuration"-><||>,
		"ConfigFooter"->None,
		"FunctionHeader"->None,
		"Function"-><||>,
		"FunctionFooter"->None,
		"Footer"->None,
		"BlockSeparator"->("\n")
		};
Psi4InputFile[
	a_Association?(
		KeyMemberQ[#,"Molecules"]
			&&(
			KeyMemberQ[#,"Function"]||
			KeyMemberQ[#,"Call"]
			)&)]:=
	With[{ops=Association@Join[Options@Psi4InputFile,Options@Psi4Function]},
	With[{components=Merge[{KeySelect[a,KeyMemberQ[ops,#]&],ops},First]},
		With[{
			header=components["Header"],
			molHead=components["MolHeader"],
			mols=components["Molecules"],molKw=components["MoleculeOptions"],
			molFoot=components["MolFooter"],
			confHead=components["ConfigHeader"],
			conf=components["Configuration"],
			confFoot=components["ConfigFooter"],
			funcHead=components["FunctionHeader"],
			func=components["Function"],
			funcFoot=components["FunctionFooter"],
			footer=components["Footer"],
			sep=ToString@components["BlockSeparator"]<>"\n"
			},
			Psi4Compile@PyColumn@
				Replace[
					{
						header,
						molHead,
						Replace[mols,{
							{}:>(
								Message[Psi4InputFile::nomol,mols];
								$Failed
								),
							m:(_->_List)|{{_String,___},___}|{{{_String,___},___},___}:>
								Psi4Molecule[m,Sequence@@Normal@molKw],
							None->Nothing
							}],
						molFoot,
						confHead,
						Replace[conf,{
							(_Association|_Rule|_RuleDelayed|{__Rule}):>
								Psi4Config@conf,
							{}|None|Nothing->Nothing
							}],
						confFoot,
						funcHead,
						Replace[func,{
							_String?(StringMatchQ[(WordCharacter|"_")..]):>
								Psi4Function@
									Merge[{
										"Call"->func,
										FilterRules[components,Options@Psi4Function]
										},
										First],
							_Association|_Rule|_RuleDelayed|{__Rule}:>
								Psi4Function@
									Merge[{
										func,
										FilterRules[components,Options@Psi4Function]
										},
										First],
							{}->
								Nothing
							}],
						funcFoot,
						footer
						},
					""|None->Nothing,
					1
					]
		]
	]
	];
Psi4InputFile[r:({(_Rule|_RuleDelayed)..}|_Rule|_RuleDelayed)]:=
	Psi4InputFile@Association@r;
Psi4InputFile[r:(_Rule|_RuleDelayed)..]:=
	Psi4InputFile@<|r|>;


Psi4InputFile[
	h:_String|None:"Psi4 input.dat file",
	mh:_String|None:None,
	m:
		(_->({{_String,___},___}|{{{_String,___},___},___}))|
		{{_String,___},___}|{{{_String,___},___},___}|_String|
		_?SymbolicPythonQ,
	ch:_String|None:None,
	c:{___Rule}|_Association|_String|_?SymbolicPythonQ,
	fh:_String|None:None,
	f:{__Rule}|_Association|_String|_?SymbolicPythonQ,
	ft:_String|None:"Configured with the ChemTools suite for Mathematica",
	ops:OptionsPattern[]
	]:=
	Psi4InputFile[
		"Header"->
			Replace[h,
				s_String:>
					PyColumn[PyComment/@StringSplit[s,"\n"]]
				],
		"MolHeader"->mh,
		"Molecules"->m,
		"ConfigHeader"->ch,
		"Configuration"->c,
		"FunctionHeader"->fh,
		"Function"->f,
		"Footer"->
			Replace[ft,
				s_String:>
					PyColumn[PyComment/@StringSplit[s,"\n"]]
				],
		ops
		];


(* ::Subsubsection::Closed:: *)
(*ConfigureCall*)



Options[Psi4ConfigureCall]=
	Normal@Merge[{
		Options@Psi4InputFile,
		<|
			"InputString"->None,
			"Input"-><||>,
			"Output"->"output.dat",
			"Directory"->Automatic
			|>
		},
		Last];
Psi4ConfigureCall[a_Association]:=
	With[{ops=Join[Options@Psi4ConfigureCall]},
		With[{components=Merge[{a,ops},First]},
			Replace[
				Replace[
					components["InputString"],
					None:>
						Psi4InputFile@
							FilterRules[components,
								Join[Options@Psi4InputFile,Options@Psi4Function]
								]
					],
				inp_String:>
					Psi4Input@
						<|
							"Input"->
								Merge[{
									components["Input"],
									<|"input.dat"->inp|>
									},
									First
									],
							"Output"->components["Output"],
							Replace[components["Directory"],{
								Except[_String?DirectoryQ]->Nothing,
								e_:>"Directory"->e
								}]
							|>
					]
			]
		];
Psi4ConfigureCall[r:({(_Rule|_RuleDelayed)..}|_Rule|_RuleDelayed)]:=
	Psi4ConfigureCall@Association@r;
Psi4ConfigureCall[r:(_Rule|_RuleDelayed)..]:=
	Psi4ConfigureCall@Association[r];
Psi4ConfigureCall[s_String,r:(_Rule|_RuleDelayed)..]:=
	Psi4ConfigureCall["InputString"->s,r];
Psi4ConfigureCall[
	h:_String|None:"Psi4 input.dat file",
	mh:_String|None:None,
	m:(_->({{_String,___},___}|{{{_String,___},___},___}))|
		{{_String,___},___}|{{{_String,___},___},___}|_String|
		_?SymbolicPythonQ,
	ch:_String|None:None,
	c:{___Rule}|_Association|_String|_?SymbolicPythonQ,
	fh:_String|None:None,
	f:{__Rule}|_Association|_String|_?SymbolicPythonQ,
	ft:_String|None:"Configured with the ChemTools suite for Mathematica",
	ops:(_Rule|_RuleDelayed)..
	]:=
	Psi4ConfigureCall[
		ops,
		"Header"->
			Replace[h,
				s_String:>
					PyColumn[PyComment/@StringSplit[s,"\n"]]
				],
		"MolHeader"->mh,
		"Molecules"->m,
		"ConfigHeader"->ch,
		"Configuration"->c,
		"FunctionHeader"->fh,
		"Function"->f,
		"Footer"->
			Replace[ft,
				s_String:>
					PyColumn[PyComment/@StringSplit[s,"\n"]]
				]
		];


(* ::Subsection:: *)
(*Geometry*)



(* ::Subsubsection::Closed:: *)
(*Parameters*)



$Psi4GeometryParametersMap=<|
	"OptimizationType"->"opt_type",
	"StepType"->"step_type",
	"MaxIterations"->"geom_maxiter",
	"ConvergenceCriterion"->"g_convergence",
	"HessianComputationInterval"->"full_hess_every",
	"InternalCoordinatesOnly"->"intcos_generate_exit",
	"OptimizationParameters"->"optking"
	|>;


(* ::Subsubsection::Closed:: *)
(*FrozenArgs*)



psi4AtomArgToNum[mList_,a_]:=
	Which[
		a<0,
			Length[mList]+a,
		MatchQ[a,_String],
			First@
				FirstPosition[mList,{a,__},$Failed,{1}][[1]],
		MatchQ[a,{_String,_}],
			First@
				Position[mList,{a[[1]],__},{1}][[a[[2]]]],
		True,
			a
		]


psi4GeometryFrozenSettingPrep[l_]:=
	ToPython@PyCall[PyDot[PyString@"\\n","join"]][l]


(* Formats the frozen_cartesian argument to set optking *)
psi4GeometryFrozenPositions[
	mList_,
	positions_
	]:=
	psi4GeometryFrozenSettingPrep@
		Replace[positions,{
			(m_->l_):>
				"'`` ``'"~TemplateApply~{
					StringPadLeft[ToString@psi4AtomArgToNum[mList,m],3],
					StringJoin@
						Map[ToPython,
							Replace[Flatten@{l},{"X"|1->"x", "Y"|2->"y","Z"|3->"z"},1]
							]
					},
			_->Nothing
			},
			1
			]


(* Formats the frozen_distance argument to set optking *)
psi4GeometryFrozenDistances[
	mList_,
	dists_
	]:=
	psi4GeometryFrozenSettingPrep@
		Replace[dists,{
			(m:{_,_}->l_):>
				If[!NumericQ@l,
					"'`` `` '+ str(``)"~TemplateApply~
						Append[
							Map[StringPadLeft[ToString@psi4AtomArgToNum[mList, #],3]&,m],
							ToPython@l
							],
					"'`` `` ``'"~TemplateApply~
						Append[
							Map[StringPadLeft[ToString@psi4AtomArgToNum[mList, #],3]&,m],
							ToPython@l
							]
					],
			_->Nothing
			},
			1
			]


(* Formats the frozen_bend argument to set optking *)
psi4GeometryFrozenAngles[
	mList_,
	angs_
	]:=
	psi4GeometryFrozenSettingPrep@
		Replace[angs,{
			(m:{_,_,_}->l_):>
				If[!NumericQ@l,
					"'`` `` `` '+ str(``)"~TemplateApply~
						Append[
							Map[StringPadLeft[ToString@psi4AtomArgToNum[mList, #],3]&,m],
							ToPython@l
							],
					"'`` `` `` ``'"~TemplateApply~
						Append[
							Map[StringPadLeft[ToString@psi4AtomArgToNum[mList, #],3]&,m],
							ToPython@l
							]
					],
			_->Nothing
			},
			1
			]


(* Formats the frozen_dihedral argument to set optking *)
psi4GeometryFrozenDihedrals[
	mList_,
	diheds_
	]:=
	psi4GeometryFrozenSettingPrep@
		Replace[diheds,{
			(m:{_,_,_,_}->l_):>
				If[!NumericQ@l,
					"'`` `` `` `` '+ str(``)"~TemplateApply~
						Append[
							Map[StringPadLeft[ToString@psi4AtomArgToNum[mList, #],3]&,m],
							ToPython@l
							],
					"'`` `` `` `` ``'"~TemplateApply~
						Append[
							Map[StringPadLeft[ToString@psi4AtomArgToNum[mList, #],3]&,m],
							ToPython@l
							]
					],
			_->Nothing
			},
			1
			]


psi4GeometryFrozenPrepString[s_]:=
	s


psi4GeometryFrozenParams[mList_,params_List]:=
	With[{ms=First/@mList},
		KeyValueMap[
			Switch[#,
				1,
					"frozen_cartesian"->
						psi4GeometryFrozenPrepString@
							psi4GeometryFrozenPositions[ms,#2],
				2,
					"frozen_distance"->
						psi4GeometryFrozenPrepString@
							psi4GeometryFrozenDistances[ms,#2],
				3,
					"frozen_bend"->
						psi4GeometryFrozenPrepString@
							psi4GeometryFrozenAngles[ms,#2],
				4,
					"frozen_dihedral"->
						psi4GeometryFrozenPrepString@
							psi4GeometryFrozenDihedrals[ms,#2],
				_,
					Nothing
				]&,
			GroupBy[
				Cases[params,_Rule],
				If[ListQ[#],Length[#],1]&@*First
				]
			]
		];
psi4GeometryFrozenParams[mList_,All]:=
	psi4GeometryFrozenParams[
		mList,
		#->"xyz"&/@Range@Length[mList]
		];
psi4GeometryFrozenParams[__]:=
	{}


Psi4OptKingConfig[rules_?OptionQ]:=
	PyColumn@
		Append[
			PyAssign["optking_"<>First@#,Last@#]&/@Flatten@List@rules,
			Block[{
				$Psi4ConfigBlockRiffle = " = "
				},
				Psi4Config[
					"OptimizationParameters"->
						Map[
							First@#->"optKing_"<>First@#&,
							Flatten@List@rules
							]
						]
				]
			]


(* ::Subsubsection::Closed:: *)
(*Optimize*)



Options[Psi4GeometryOptimize]=
	Normal@
		Merge[{Options@Psi4ConfigureCall,
			"Wavefunction"->"scf",
			"FrozenParameters"->{}
			},
			Last];
Psi4GeometryOptimize[a_Association]:=
	With[{defs=Merge[{a,Options@Psi4GeometryOptimize},First]},
	Psi4ConfigureCall@
		Merge[{
			"Output"->
				Psi4DataParseGeometry,
			KeySelect[a,MatchQ[Except["Wavefunction"|"Properties"|"FrozenParameters"]]],
			"Configuration"->
				KeyMap[
					Replace[$Psi4GeometryParametersMap],
					Merge[{
						Lookup[a,"Configuration",<||>],
						"BasisSet"->"dz"
						},
						First
						]
					],
			With[{opts=
				Join[
					Flatten@List@
						Lookup[Lookup[a,"Configuration",<||>],"OptimizationParameters",{}],
					psi4GeometryFrozenParams[
						Lookup[a,"Molecules"],
						Lookup[a,"FrozenParameters"]
						]
					]
				},
				If[Length[opts]>0,
					"ConfigFooter"->
						Psi4OptKingConfig[opts],
					Nothing
					]
				],
			"Function"->
				Merge[{
					Replace[Lookup[a,"Function",<||>],p_String:>("Call"->p)],
					"Call"->"optimize",
					"Arguments"->
						Flatten@{defs["Wavefunction"]}
					},
					First]
			},
			Last]
		];


Psi4GeometryOptimize[atoms_List,props___]:=
	Psi4GeometryOptimize@
		<|
			"Molecules"->{atoms},
			props
			|>;


(* ::Subsubsection::Closed:: *)
(*Info*)



Options[Psi4GeometryInfo]=Options[Psi4GeometryOptimize];
Psi4GeometryInfo[a_Association]:=
	Psi4GeometryOptimize@
		Merge[{
			a,
			"Configuration"->
				<|"InternalCoordinatesOnly"->True|>,
			"Output"->
				First@*Psi4DataParseGeometry
			},
			Last
			];
Psi4GeometryInfo[atoms_List,props___]:=
	Psi4GeometryInfo@
		<|
			"Molecules"->{atoms},
			props
			|>;


(* ::Subsection:: *)
(*Energy*)



(* ::Subsubsection::Closed:: *)
(*Energy*)



Options[Psi4Energy]=
	Normal@
		Merge[{
			Options@Psi4ConfigureCall,
			"Wavefunction"->"scf",
			"FrozenParameters"->{}
			},
			Last
			];
Psi4Energy[a_Association]:=
	With[{defs=Merge[{a,Options@Psi4GeometryOptimize},First]},
	Psi4ConfigureCall@
		Merge[{
			"Output"->
				Psi4DataParseGeometry,
			KeySelect[a,MatchQ[Except["Wavefunction"|"Properties"|"FrozenParameters"]]],
			"Configuration"->
				KeyMap[
					Replace[$Psi4GeometryParametersMap],
					Merge[{
						Lookup[a,"Configuration",<||>],
						"BasisSet"->"dz"
						},
						First
						]
					],
			With[{opts=
				Join[
					Flatten@List@
						Lookup[Lookup[a,"Configuration",<||>],"OptimizationParameters",{}],
					psi4GeometryFrozenParams[
						Lookup[a,"Molecules"],
						Lookup[a,"FrozenParameters"]
						]
					]
				},
				If[Length[opts]>0,
					"ConfigFooter"->
						Psi4OptKingConfig[opts],
					Nothing
					]
				],
			"Function"->
				Merge[{
					Replace[Lookup[a,"Function",<||>],p_String:>("Call"->p)],
					"Call"->"energy",
					"Arguments"->
						Flatten@{defs["Wavefunction"]}
					},
					First]
			},
			Last]
		];


Psi4Energy[atoms_List,props___]:=
	Psi4Energy@
		<|
			"Molecules"->{atoms},
			props
			|>;


(* ::Subsubsection::Closed:: *)
(*EnergyScan*)



Psi4EnergyScan//Clear


Options[Psi4EnergyScan]=
	Normal@
		Merge[{
			Options@Psi4Scan,
			"Wavefunction"->"scf",
			"FrozenParameters"->{}
			},
			Last
			];
Psi4EnergyScan[a_Association]:=
	With[{defs=Merge[{a,Options@Psi4EnergyScan},First]},
	Psi4Scan@
		Merge[{
			"Output"->
				Psi4DataParseGeometry,
			KeySelect[a,MatchQ[Except["Wavefunction"|"Properties"]]],
			With[{opts=
				Join[
					Flatten@List@
						Lookup[Lookup[a,"Configuration",<||>],"OptimizationParameters",{}],
					psi4GeometryFrozenParams[
						Lookup[a,"Molecules"],
						Lookup[a,"FrozenParameters"]/.
							Slot[n_]:>"pyVar_"<>ToString[n]
						]
					]
				},
				If[Length[opts]>0,
					"ScanPre"->
						Psi4OptKingConfig[opts],
					Nothing
					]
				],
			"Configuration"->
				KeyMap[
					Replace[$Psi4GeometryParametersMap],
					Merge[{
						Lookup[a,"Configuration",<||>],
						"BasisSet"->"dz"
						},
						First
						]
					],
			"Function"->
				Merge[{
					Replace[Lookup[a,"Function",<||>],
						p_String:>("Call"->p)
						],
					"Call"->"energy",
					"Arguments"->
						Flatten@{defs["Wavefunction"]}
					},
					First
					]
			},
			Last]
		];
Psi4EnergyScan[atoms_List,props___?OptionQ]:=
	Psi4EnergyScan@
		<|
			"Molecules"->{atoms},
			props
			|>;
Psi4EnergyScan[
	atoms_List,
	grid:{_Integer,_Integer,_Integer}|_Integer:27,
	ops___?OptionQ
	]:=
	Psi4EnergyScan@
		Psi4AutoScan[atoms,grid,ops]


(* ::Subsection:: *)
(*Property*)



$Psi4PropertyParametersMap=<|
	"PropertiesOrigin"->"properties_origin"
	|>;


(* ::Subsection:: *)
(*Scan*)



(* ::Subsubsection::Closed:: *)
(*Scan*)



Options[Psi4Scan]=
	DeleteDuplicatesBy[First]@
		Flatten@{
			Options@Psi4ConfigureCall,
			"Scan"->None,
			"ScanCoordinatesPre"->Identity
			};
With[{varspec=_String|_Symbol|_PySymbol},
Psi4Scan[a_Association]:=
	With[{components=Merge[{a,Options@Psi4Scan},First]},
		Psi4ConfigureCall@Flatten@{
			"Molecules"->components["Molecules"]/.Slot[n_]:>"pyVar_"<>ToString[n],
			Replace[components["Scan"],{
				scan_List:>
					"Function"->
						With[{
							precoords=Lookup[components,"ScanCoordinatesPre",Identity],
							prefunc=Lookup[components,"ScanPre",None],
							molNameVars=
								Association@Flatten@
									Block[{mnameCounter=1},
										Replace[
											Replace[components["Molecules"],
												m:{{_String,_}...}|{{_String},___}:>{m}
												],
											{
												(m_->e_):>
													Thread[Cases[e,_Slot|_PyVar,\[Infinity]]->m],
												e_:>(
													Thread[
														Cases[e,_Slot|_PyVar,\[Infinity]]->
															"mol_"<>ToString[mnameCounter++]
														]
													)
												},
											1
											]
										],
							scanList=
								Block[{itVarCounter=1},
									Replace[
										Reverse@
											Replace[scan/.Slot[n_]:>"pyVar_"<>ToString[n],
												s:{varspec|{varspec..},__}:>{s}
												],
										i:Except[varspec|{varspec..}]:>
											Flatten[{"pyVar_"<>ToString[itVarCounter++],i},1],
										1
										]
									]
							},
							Fold[
								Replace[#2,{
									{i:varspec|{varspec..},s_}:>
										PyForIn[i,Replace[s,n_Integer:>PyRange[n]]][#],
									{i:varspec,s1_,s2__}:>
										PyForIn[i,PyRange[s1,s2]][#],
									_:>
										#
									}]&,
									If[Length[molNameVars]>0,
										With[{
											mnVars=
												KeyValueMap[
													PyDot[#2,
														Replace[#,
															Verbatim[Slot][n_]:>
																"pyVar_"<>ToString[n]
															]
														]&,
													molNameVars
													],
											scanVars:=
												SortBy[
													Map[First,scanList],
													Position[Last/@mnVars,#]&
													]
											},
											With[{
												pref=
													If[prefunc=!=None,
														prefunc/.{
															f_String[args___]:>
																PyCall[f][args]
															}/.Slot[n_]:>"pyVar_"<>ToString[n],
														Nothing
														],
												pf=
													If[precoords=!=Identity,
														precoords/.{
															f_String[args___]:>
																PyCall[f][args]
															}/.Slot[n_]:>"pyVar_"<>ToString[n],
														scanVars
														]
												},
												PyColumn@{
													pref,
													PyAssign[
														mnVars,
														pf
														],
													#
													}&
												]
											],
										Identity
										]@
									Replace[
										Lookup[components,"Function"]/.{
											s_String[args___]:>
												PyCall[s][args]
											}/.Slot[n_]:>"pyVar_"<>ToString[n],{
										f_Association:>
											Psi4Function@f,
										s:_?SymbolicPythonQ|_String:>
											s,
										Defer[e___]:>
											{e},
										_:>
											PyPrint@Psi4Function@components
										}],
							scanList
							]
						],
				e_:>
					Nothing	
				}],
			"Molecules"->
				Replace[Lookup[components,"Molecules",None],{
					l:(_List|_->_List):>
						(l/.Slot[n_]:>"pyVar_"<>ToString[n])
					}],
			Normal@
				KeyDrop[components,
					{
						"Molecules",
						"Scan","ScanCoordinatesPre",
						"Function","Call",
						"AssignTo","Arguments",
						"KeyWordArguments"
						}
					]
			}
		]
	];


(* ::Subsection:: *)
(*OneElectronProperty*)



(* ::Subsubsection::Closed:: *)
(*$OneElectronParametersMap*)



$Psi4OneElectronParametersMap=
	ToUpperCase/@<|
		"DipoleMoment"->"dipole",
		"QuadrupoleMoment"->"quadrupole",
		"MultipoleMoment"->"multipole",
		"NucleiElectrostaticPotential"->"esp_at_nuclei",
		"ElectrostaticPotential"->"grid_esp",
		"ElectricField"->"grid_field",
		"OrbitalExtents"->"mo_extents",
		"MullikenCharges"->"mulliken_charges",
		"LoewdinCharges"->"lowdin_charges",
		"WidbergIndices"->"widberg_lowdin_charges",
		"MayerIndices"->"mayer_indices",
		"OrbitalOccupations"->"no_occupations"
		|>;


(* ::Subsubsection::Closed:: *)
(*OneElectronProperty*)



Options@Psi4OneElectronProperty=
	Normal@
		Merge[
			{
				Options@Psi4ConfigureCall,
				"Wavefunction"->"scf",
				"Properties"->{}
				},
			Last
			];
Psi4OneElectronProperty[a_Association]:=
	With[{defs=Merge[{a,Options@Psi4OneElectronProperty},First]},
	Psi4ConfigureCall@
		Merge[{
			KeySelect[a,MatchQ[Except["Wavefunction"|"Properties"]]],
			"Configuration"->
				Merge[{
					Lookup[a,"Configuration",<||>],
					<|"BasisSet"->"cc-pvdz"|>
					},
					First],
			"FunctionHeader"->
				PyAssign[
					PyTuple[{"h", "wfn"}],
					PyCall["energy"][PyString@defs["Wavefunction"], "return_wfn"->True]
					],
			"Function"->
				Merge[{
					"KeyWordArguments"->
						Lookup[a, "KeyWordArguments",{} ],
					Replace[Lookup[a,"Function",<||>],p_String:>("Call"->p)],
					"Call"->"oeprop",
					"Arguments"->
						Prepend[
							Map[
								Lookup[$Psi4OneElectronParametersMap, #, #]&,
								Flatten@{defs["Properties"]}
								],
							wfn
							]
					},
					First]
			},
			Last]
		];
Psi4OneElectronProperty[r:({(_Rule|_RuleDelayed)..}|(_Rule|_RuleDelayed)..)]:=
	Psi4OneElectronProperty@Association@r;


Psi4OneElectronProperty[
	atoms_List,
	grid:_List|Automatic:Automatic,
	props___?OptionQ
	]:=
	Psi4OneElectronProperty@
		<|
			"Molecules"->{atoms},
			props
			|>;


(* ::Subsubsection::Closed:: *)
(*OneElectronElectrostaticPotential*)



Options[Psi4OneElectronElectrostaticPotential]=
	Append[Options@Psi4OneElectronProperty,"Grid"->None];
Psi4OneElectronElectrostaticPotential[a_Association]:=	
	Psi4OneElectronProperty@Merge[{
		<|
			"Header"->
				"#"<>DateString@Now<>"\n"<>
					"#Grid electrostatic potential calculation",
			"MoleculeOptions"->{"noreorient","nocom"},
			"Arguments"->{"scf"},
			"Properties"->{"GRID_ESP","GRID_FIELD"},
			"Output"->"grid_esp.dat"|"grid_field.dat"
			|>,
		a},
		First];
Psi4OneElectronElectrostaticPotential[
	r:({(_Rule|_RuleDelayed)..}|(_Rule|_RuleDelayed)..)]:=
	Psi4OneElectronElectrostaticPotential@Association@r;


Psi4OneElectronElectrostaticPotential[atomset_List, a___]:=
	Psi4OneElectronElectrostaticPotential@
		Flatten[Psi4UtilsAutoGrid[atomset,a],2];


(* ::Subsubsection::Closed:: *)
(*OneElectronDipoleMoment*)



Psi4OneElectronDipoleMoment[specs__]:=
	Psi4OneElectronProperty[specs,
		"Properties"->
			"DipoleMoment",
		"Output"->
			Psi4DataParseDipoles
		];


(* ::Subsection:: *)
(*CubeProperty*)



(* ::Subsubsection::Closed:: *)
(*CubeProperty*)



Options[Psi4CubeProperty]=Append[Options@Psi4ConfigureCall];
Psi4CubeProperty[a_Association]:=
	Psi4ConfigureCall@Merge[{
		<|
			"MoleculeOptions"->
				Join[
					{"MolTable","noreorient","nocom"},
					Lookup[a,"MoleculeOptions",{}]
					],
			"Configuration"->
				Merge[{
					Lookup[a,"Configuration",<||>],
					<|
						"BasisSet"->"cc-pvdz",
						"SCFType"->"df",
						"CubePropTasks"->"orbitals",
						"CubePropOrbitals"->{1}
						|>
					},
					First
					],
			"Function"->
					<|
						"AssignTo"->{"E","wfn"},
						"Call"->"energy",
						"Arguments"->{"scf"},
						"KeyWordArguments"->{"ReturnWavefunction"->True}
						|>,
			"Footer"->"cubeprop(wfn)",
			If[Lookup[a,"Grid",None]===None,
				Nothing,
				"Input"->
					Merge[{a["Input"],<|"grid.dat"->Psi4GridFile@a["Grid"]|>},Last]
				]
			|>,
		a,
		<|
			"Header"->"#"<>DateString@Now<>"\n"<>
				"#Cube prop call",
			"Output"->"*.cube"|"*.xyz"
			|>
		},
		First
		];
Psi4CubeProperty[r:({(_Rule|_RuleDelayed)..}|(_Rule|_RuleDelayed)..)]:=
	Psi4CubeProperty@Association@r;


(* ::Subsubsection::Closed:: *)
(*CubeOrbitals*)



Options[Psi4CubeOrbitals]=Options@Psi4CubeProperty;
Psi4CubeOrbitals[a_Association]:=
	Psi4CubeProperty@
		Merge[{
			Append[a,
				"Configuration"->
					Merge[{Lookup[a,"Configuration",<||>],
						<|
							"CubePropTasks"->{"orbitals"},
							"CubePropOrbitals"->{1,-1,2,-2,3,-3,4,-4,5,-5}
							|>
						},
						First]
				],
			"Output"->"Psi_*.cube"
			},
			First];
Psi4CubeOrbitals[atomList_List,orbitals:{__Integer}:{1},p:(_Rule|_RuleDelayed)...]:=
	Psi4CubeOrbitals@
		<|
			"Molecules"->atomList,
			"CubePropOrbitals"->orbitals,
			p
			|>;
Psi4CubeOrbitals[atomList_List,orbitals_Integer,p:(_Rule|_RuleDelayed)...]:=
	Psi4CubeOrbitals[atomList,Join[#,-#]&@Range[orbitals]]


(* ::Subsubsection::Closed:: *)
(*CubeElectronDensity*)



Psi4CubeElectronDensity[a_Association]:=
	Psi4CubeProperty@
		Merge[{
			Append[a,
				"Configuration"->
					Merge[{Lookup[a,"Configuration",<||>],
						<|
							"CubePropTasks"->{"density"},
							"CubePropOrbitals"->{1}
							|>
						},
						First]
				],
			"Output"->"Dt.cube"|"Ds.cube"|"Da.cube"|"Db.cube"
			},
			First];
Psi4CubeElectronDensity[atomList_List,p___]:=
	Psi4CubeElectronDensity@
		<|
			"Molecules"->atomList,
			p
			|>;


(* ::Subsubsection::Closed:: *)
(*CubeElectrostaticPotential*)



Psi4CubeElectrostaticPotential[a_Association]:=
	Psi4CubeProperty@
		Merge[{
			"Configuration"->
				Merge[{
					Lookup[a,"Configuration",<||>],
						<|
							"CubePropTasks"->{"esp"},
							"CubePropOrbitals"->{1},
							"DFTSelfConsistentBasisSet"->"cc-pvdz-jkfit",
							"FreezeCore"->True
							|>
						},
					First
					],
				a,
				"Output"->"Dt.cube"|"ESP.cube"
				},
				First];
Psi4CubeElectrostaticPotential[atomList_List,p___]:=
	Psi4CubeElectrostaticPotential@
		<|
			"Molecules"->atomList,
			p
			|>;


(* ::Subsection:: *)
(*Import and manipulations*)



(* ::Subsubsection::Closed:: *)
(*ParseGeometry*)



zmatrix1=
	(Whitespace~~LetterCharacter..~~(Whitespace|EndOfLine));
zmatrix2=
	(Whitespace~~LetterCharacter..~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~(Whitespace|EndOfLine));
zmatrix3=
	(Whitespace~~LetterCharacter..~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~(Whitespace|EndOfLine));
zmatrix4=
	(Whitespace~~LetterCharacter..~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~(Whitespace|EndOfLine));
molTable=
	Whitespace~~LetterCharacter..~~
		Whitespace~~NumberString~~
		Whitespace~~NumberString~~
		Whitespace~~NumberString;


psi4GeomTableHeader=
	StringExpression@@
		Riffle[{
			StartOfLine,
			"Center","X","Y","Z","Mass","\n",
			Sequence@@ConstantArray[Repeated["-"],4],
			(Repeated["-"]~~"\n")
			},
			Whitespace
			];
psi4GeomTableBody=
	Repeated[
		StringExpression@@
			Riffle[
				{
					"",WordCharacter..,
					Sequence@@ConstantArray[NumberString,3],
					NumberString~~"\n"
					},
				Whitespace
				]
		]


$pointGroupList=
	<|
		"c1"->{{"CrystallographicPointGroup",1}},"c2"->{{"CrystallographicPointGroup",3}},
		"c2h"->{{"CrystallographicPointGroup",5}},"c2v"->{{"CrystallographicPointGroup",7}},
		"c3"->{{"CrystallographicPointGroup",16}},"c3h"->{{"CrystallographicPointGroup",22}},
		"c3v"->{{"CrystallographicPointGroup",19}},"c4"->{{"CrystallographicPointGroup",9}},
		"c4h"->{{"CrystallographicPointGroup",11}},
		"c4v"->{{"CrystallographicPointGroup",13}},"c5"->{{"CyclicGroup",5}},"c5h"->"C5h",
		"c5v"->"C5v","c6"->{{"CrystallographicPointGroup",21}},
		"c6h"->{{"CrystallographicPointGroup",23}},
		"c6v"->{{"CrystallographicPointGroup",25}},"c7"->{{"CyclicGroup",7}},"c7v"->"C7v",
		"c8"->{{"CyclicGroup",8}},"c8v"->"C8v",
		"ci"->{{"CrystallographicPointGroup",2}},"cs"->{{"CrystallographicPointGroup",4}},
		"c\[Infinity]v"->"C\[Infinity]v","d2"->{{"CrystallographicPointGroup",6}},
		"d2d"->{{"CrystallographicPointGroup",14}},"d2h"->{{"CrystallographicPointGroup",8}},
		"d3"->{{"CrystallographicPointGroup",18}},"d3d"->{{"CrystallographicPointGroup",20}},
		"d3h"->{{"CrystallographicPointGroup",26}},"d4"->{{"CrystallographicPointGroup",12}},
		"d4d"->"D4d","d4h"->{{"CrystallographicPointGroup",15}},
		"d5"->{{"DihedralGroup",5}},"d5d"->"D5d",
		"d5h"->"D5h","d6"->{{"CrystallographicPointGroup",24}},
		"d6d"->"D6d","d6h"->{{"CrystallographicPointGroup",27}},
		"d7"->{{"DihedralGroup",7}},"d7d"->"D7d",
		"d7h"->"D7h","d8"->{{"DihedralGroup",8}},
		"d8d"->"D8d","d8h"->"D8h",
		"d\[Infinity]h"->"D\[Infinity]h","i"->"I",
		"ih"->{"Icosahedral"},"o"->{{"CrystallographicPointGroup",30}},
		"oh"->{{"CrystallographicPointGroup",32}},"s10"->{{"SymmetricGroup",10}},
		"s12"->{{"SymmetricGroup",12}},"s2"->{{"SymmetricGroup",2}},
		"s4"->{{"CrystallographicPointGroup",10}},"s6"->{{"CrystallographicPointGroup",17}},
		"s8"->{{"SymmetricGroup",8}},"t"->{{"CrystallographicPointGroup",28}},
		"td"->{{"CrystallographicPointGroup",31}},"th"->{{"CrystallographicPointGroup",29}}
		|>;


parsePointGroup[grp_]:=
	With[{s=
		ToLowerCase@
			StringReplace[grp,{
				"_inf_"->"\[Infinity]"
				}]
		},
		Replace[
			Lookup[
				$pointGroupList,
				ToLowerCase@s,
				ToUpperCase[StringTake[s,1]]<>StringDrop[s,1]
				],
			{l_}:>
				Entity["FiniteGroup",l]
			]
		]


$parseUnitList=
	{
		"a.u."->"AtomicUnitOfForce",
		"cm^-1"->(1/"Centimeters")
		}


parseUnit[u_,reps_:{}]:=
	Quantity@
		Replace[StringTrim[u,"]"|"["|")"|"("],
			Flatten@{
				reps,
				$parseUnitList
				}]


propLinePattern=
	Whitespace~~
		(
			"Molecular point group"|
			"Full point group"|
			"Rotational constants"|
			"Nuclear repulsion"|
			"Charge"|"Multiplicity"|"Electrons"|
			"Nalpha"|"Nbeta"|
			"Nuclear Repulsion Energy"|"One-Electron Energy"|
			"Two-Electron Energy"|("Total Energy"~~Whitespace~~"=")|
			(("Nuclear"|"Electronic")~~" Dipole Moment:"~~Except["\n"]..~~"\n")|
			"Setting geometry variable "
			)~~(Except["\n"]..);


parseProp[s_]:=
	Which[
		(* Point Groups *)
		StringContainsQ[s,"point group:"],
			StringTrim@First@StringSplit[s,"point group:"]<>
				"PointGroup"->
					parsePointGroup@
						First@StringCases[s,": "~~p:(Except[WhitespaceCharacter]..):>p],
		(* Rotational Constants *)
		StringContainsQ[s,"Rotational constants"],
			"RotationalConstants"->
				Association@Cases[
					StringReplace[s,{
						l_~~" ="~~Whitespace~~v:NumberString:>
							l->ToExpression@v,
						"["~~u:Except["]"]..~~"]":>
							"Units"->parseUnit[u]
						}],
					_Rule],
		(* Nuclear Repulsion *)
		StringContainsQ[s,"Nuclear repulsion"],
			"NuclearRepulsion"->
				First@StringCases[s,NumberString],
		(* Charge, Multiplicity, Electrons, N_alpha, N_beta *)
		StringContainsQ[s,"Charge"|"Multiplicity"|"Electrons"|"Nalpha"|"Nbeta"],
				First@
					StringCases[s,
						l:(LetterCharacter..)~~Whitespace~~"= "~~n:NumberString:>(l->n)],
		(* Energies *)
		StringContainsQ[s,
			"Nuclear Repulsion Energy"|"One-Electron Energy"|
			"Two-Electron Energy"|"Total Energy"~~Whitespace~~"="
			],
			First@
				StringCases[s,
					l:__~~"= "~~Whitespace~~n:NumberString:>
					(StringReplace[l,Except[WordCharacter]->""]->ToExpression[n])
					],
		(* Dipole Moments *)
		StringContainsQ[s,"Dipole Moment"],
			With[{bits=StringTrim@StringSplit[s, "Dipole Moment:"|"X:"|"Y:"|"Z:"]},
				bits[[1]]<>"DipoleMoment"->
					Append[
						AssociationThread[{"X","Y","Z"},
							ToExpression@bits[[{3,4,5}]]
							],
						"Unit"->parseUnit@bits[[2]]
						]
				],
		(* Scan variables *)
		StringContainsQ[s,"Setting geometry variable "],
			StringCases[s,
				"Setting geometry variable "~~var:Except[WhitespaceCharacter]..~~" to "~~
					val:Except[WhitespaceCharacter]..:>
					"ScanVariable"->
						(var->ToExpression[val])
				]
		]


blockDelimeters=("*** tstart()"~~Except["\n"]..)|("*** tstop()"~~Except["\n"]..);


Psi4DataParseGeometry[os_]:=
	With[{
		atomCount=
			Length@Select[
				StringSplit[First@StringCases[os,"molecule"~~Except["}"]..~~"}"],"\n"],
					StringContainsQ[#,NumberString]||
						ChemDataAtomQ@StringTrim@#&
				]
		},
	Block[{
		blockMolTable=None,
		blockZMatrix=None,
		blockGeomTable=None,
		blockProps={},
		blockMeta={},
		blockCache={},
		cacheBlockData=(
			AppendTo[
				blockCache,
				<|
					"ZMatrix"->blockZMatrix,
					"MolTable"->blockMolTable,
					"GeometryTable"->blockGeomTable,
					"Properties"->blockProps,
					"MetaInfo"->blockMeta
					|>];
				blockProps={};
				blockMeta={};
				blockZMatrix=None;
				blockMolTable=None;
				blockGeomTable=None;
				)&
		},
	
	Replace[
		StringCases[os,{
			(* Extract GeomTable *)
			psi4GeomTableHeader~~s:psi4GeomTableBody:>
				"GeometryTable"->
					Replace[
						ImportString[s,"Table"],
						{e_,x_,y_,z_,m_}:>{e,{x,y,z},m},
						1
						],
			(* Extract MolTable *)
			s:(StartOfLine~~Repeated[molTable~~EndOfLine,{atomCount}]):>
				"MolTable"->
					Replace[ImportString[StringTrim@s,"Table"],
						{e_,x_,y_,z_}:>{e,{x,y,z}},
						1
						],
			(* Extract ZMatrix *)
			s:(StartOfLine~~StringExpression@@
					Switch[atomCount,
						1,
							{zmatrix1},
						2,
							{zmatrix1,zmatrix2},
						_,
							Join[{zmatrix1,zmatrix2,zmatrix3},ConstantArray[zmatrix4,atomCount-3]]
						]):>
				"ZMatrix"->ImportString[StringTrim@s,"Table"],
			(* Extract Properties *)
			s:(StartOfLine~~propLinePattern~~EndOfLine):>
				"Property"->parseProp@s,
			(* Extract run times *)
			timeBlock:
				(
					WordCharacter..~~" time:\n"~~
					Repeated[
						Whitespace~~WordCharacter..~~" time"~~Whitespace~~"="~~Whitespace~~
						NumberString~~" seconds "~~Except["\n"]..
						]
					):>
					"MetaInfo"->(
						"RunTime"->
							With[{blocks=StringSplit[timeBlock,"\n",2]},
								Prepend["Timing"->StringTrim[blocks[[1]]," time:"]]@
								StringCases[Last@blocks,
									Whitespace~~
										sys:WordCharacter..~~" time"~~Whitespace~~"="~~Whitespace~~
											time:NumberString~~" seconds ":>
										(ToUpperCase@StringTake[sys, 1]<>StringDrop[sys, 1])<>
											"Time"->Quantity[ToExpression[time],"Seconds"]
									]
								]
						),
			(* Block Delimiters *)
			s:(StartOfLine~~blockDelimeters~~EndOfLine):>
				Break
				}
			],
		{
			Break:>
				cacheBlockData[],
			("GeometryTable"->t_):>
				If[blockGeomTable===None,
					blockGeomTable=t,
					cacheBlockData[]
					],
			("MolTable"->t_):>
				If[blockMolTable===None,
					blockMolTable=t,
					cacheBlockData[]
					],
			("ZMatrix"->t_):>
				If[blockZMatrix===None,
					blockZMatrix=t,
					cacheBlockData[]
					],
			("Property"->p_):>
				AppendTo[blockProps,p],
			("MetaInfo"->p_):>
				AppendTo[blockMeta,p]
			},
		1];
		If[Length@blockProps>0,cacheBlockData[]];
		DeleteCases[
			blockCache,
			_Association?(
				Lookup[#,
					{"ZMatrix","MolTable","GeometryTable","Properties","MetaInfo"}
					]==={None,None,None,{},{}}&
				)
			]
		]
	];


(* ::Subsubsection::Closed:: *)
(*Dipoles*)



Psi4DataParseDipoles[out_]:=
	Replace[
		With[{lines=StringSplit[out,EndOfLine]},
			With[{p=Position[lines,_String?(StringContainsQ["Dipole"])]},
				Map[lines[[#]]&,Replace[p,{i_}:>{i,i+1},1] ]
				]
			],
		{dLine_,pLine_}:>Association@*Append@@{
			Replace[StringCases[dLine,Except[WhitespaceCharacter]..],
				{dT_:"Overall","Dipole",__,dU_}:>{
					"DipoleType"->dT,
					"DipoleUnits"->
						Quantity[1,
							Evaluate@Switch[dU,
								"(a.u.)",
									"ElementaryCharge"*"BohrRadius",
								"(Debye)",
									"Debye"]
							]
					}],
			Replace[StringCases[pLine,NumberString],
				{x_,y_,z_,___}:>
					"DipoleVector"->ToExpression@{x,y,z}
				]
			},
		1]


(* ::Subsubsection::Closed:: *)
(*Lookup*)



Psi4DataLookup[data_Association,p:(_String..),its:_Integer|_List|All:All]:=
	Replace[data[p],
		l_List:>l[[its]]
		];
Psi4DataLookup[Psi4Data[a_Association],o___]:=
	Psi4DataLookup[a,o];


End[];



