(* ::Package:: *)

(* Autogenerated Package *)

(* ::Subsection:: *)
(*Basics*)



(* ::Subsubsection::Closed:: *)
(*OpenBabel*)



OpenBabel::usage=
	"Primary connection object for running OpenBabel";


$OpenBabel::usage=
	"Default OpenBabel object";
$OBDir::usage=
	"Default OpenBabel directory";


OBBuild::usage=
	"Downloads and builds openbabel";


(* ::Subsubsection::Closed:: *)
(*Run*)



OBInput::usage=
	"Input wrapper for OpenBabel";
OBOutput::usage=
	"Output wrapper for OpenBabel";


$OBPythonInterpreter::usage="The interpreter for OpenBabel";


OBRun::usage=
	"Runs OpenBabel";
OBPyCommand::usage=
	"Converts to OpenBabel ready python code";
OBPyRun::usage=
	"Runs after converting to python";


OBParse::usage=
	"General purpose parsing for open babel output. To be extended.";


(* ::Subsection:: *)
(*Usages*)



OBForceFieldEnergy::usage="A basic energy calculator";
OBFormatConvert::usage="A molecular format converter";
OBRingMap::usage="Maps a function over a molecule"


Begin["`Private`"];


PyToolsLoad[]


(* ::Subsection:: *)
(*Build*)



$eigen3src="http://bitbucket.org/eigen/eigen/get/3.2.10.zip";


$openbabelsrc=
	"https://sourceforge.net/projects/openbabel/files/latest/download?source=files";


eigenDownload[dir_String?DirectoryQ]:=
		With[{
			tmpDir=
				CreateDirectory@
					FileNameJoin@{
						$TemporaryDirectory,
						StringJoin@RandomSample[Alphabet[],10]
						}
			},
			With[{
				f=URLDownload[$eigen3src,FileNameJoin@{tmpDir,"eigen3_tmp.zip"}],
				out=FileNameJoin@{dir,"eigen3"}
				},
				ExtractArchive[f,tmpDir];
				DeleteFile[f];
				If[DirectoryQ@out,DeleteDirectory[out,DeleteContents->True]];
				CopyDirectory[First@FileNames["*",tmpDir],out];
				Quiet@DeleteDirectory[tmpDir,DeleteContents->True];
				Replace[
					out,
					Except[_String?FileExistsQ]->$Failed
					]
			]
		];


$obprefix="openbabel";


openbabelDownload[dir_String?DirectoryQ]:=
	With[{
			tmpDir=
				CreateDirectory@
					FileNameJoin@{
						$TemporaryDirectory,
						StringJoin@RandomSample[Alphabet[],10]
						}
			},
			With[{
				f=URLDownload[$openbabelsrc,
					FileNameJoin@{tmpDir,"openbabel-src.tar.gz"}],
				out=FileNameJoin@{dir,$obprefix}
				},
				ExtractArchive[f,tmpDir];
				DeleteFile[f];
				If[DirectoryQ@out,DeleteDirectory[out,DeleteContents->True]];
				CopyDirectory[First@FileNames["*",tmpDir],out];
				Quiet@DeleteDirectory[tmpDir,DeleteContents->True];
				Replace[
					out,
					Except[_String?FileExistsQ]->$Failed
					]
			]
		];


OBBuild::nodir="Directory `` not found";
obBuild[
	dir_?DirectoryQ,
	eigen:_String?DirectoryQ|Automatic:Automatic]:=
	With[{parentDir=ExpandFileName@dir},
	If[DirectoryQ@FileNameJoin@{parentDir,$obprefix}&&
		Length[FileNames["*",FileNameJoin@{parentDir,$obprefix}]]>0,
		AbsoluteTiming[{
		If[(!DirectoryQ@FileNameJoin@{parentDir,$obprefix,"bin"})&&
				cmakeCheck@parentDir,
			terminalRun[{
				If[FileExistsQ@FileNameJoin@{parentDir,"cmake","bin","cmake"},
					FileNameJoin@{parentDir,"cmake","bin","cmake"},
					"cmake"
					],
				FileNameJoin@{parentDir,$obprefix},
				"-DCMAKE_INSTALL_PREFIX="<>
					FileNameJoin@{parentDir,$obprefix},
				"-DRUN_SWIG=ON",
				"-DSWIG_EXECUTABLE="<>FileNameJoin@{parentDir,"swig","bin","swig"},
				"-DSWIG_DIR="<>FileNameJoin@{parentDir,"swig"},
				"-DPYTHON_BINDINGS=ON",
				"-DEIGEN3_INCLUDE_DIR="<>
					Replace[eigen,
						Automatic:>FileNameJoin@{parentDir,"eigen3"}
						]
				},
				ProcessEnvironment-><|
					"PATH"->
						StringJoin@{
							Environment["PATH"],
							":",
							Riffle[{
									FileNameJoin@{parentDir,"cmake","bin"},
									FileNameJoin@{parentDir,$obprefix}
									},
								":"
								]
							}
					|>,
				ProcessDirectory->
					FileNameJoin@{parentDir,$obprefix}
				]
			],
		If[!FileExistsQ@FileNameJoin@{
					parentDir,
					$obprefix,"build","bin","obabel"
					},
			terminalRun[{"make","install"},
				ProcessDirectory->
					ExpandFileName@FileNameJoin@{parentDir,$obprefix}
				]
			],
		If[FileExistsQ@
				FileNameJoin@{parentDir,$obprefix,"bin","obabel"},
				FileNameJoin@{parentDir,$obprefix}
				]
		}]//If[Last@Last@#=!=Null,
			TemplateApply["Built to `pkg`. Took `time`.",
					<|
						"time"->(
							$OBBuildLogs=Last@#;
							UnitConvert[Quantity[First@#,"Seconds"],"Minutes"]
							),
						"pkg"->Last@Last@#
						|>
					],
			$Failed
			]&,
		Message[OBBuild::nodir,FileNameJoin@{parentDir,$obprefix}]
		]
	];


OBBuild[parentDir:_?DirectoryQ]:=
	(
		If[!cmakeCheck@parentDir,
			cmakeBuild@parentDir
			];
		If[!FileExistsQ@FileNameJoin@{parentDir,"eigen3"},
			eigenDownload@parentDir
			];
		SwigBuild[parentDir];
		If[!FileExistsQ@FileNameJoin@{parentDir,$obprefix}||
			Length[
				Select[DirectoryQ]@
					FileNames["*",FileNameJoin@{parentDir,$obprefix}]
				]===0,
			openbabelDownload@parentDir
			];
		obBuild@parentDir
		);
OBBuild[Optional[Automatic,Automatic]]:=
	OBBuild[DirectoryName[$OBDir]]


(* ::Subsection:: *)
(*Defaults*)



$OBDir=ChemExtensionDir[$obprefix];
$OpenBabel:=OpenBabel[$OBDir, "obabel"];


$OBPythonInterpreter="python2.7";


OBDirQ[babelDir_]:=
	AllTrue[{
		{"lib",$OBPythonInterpreter,"site-packages"},
		{"lib","_openbabel.so"}
		},
		FileExistsQ@FileNameJoin@Flatten@{babelDir,#}&
		]


(* ::Subsubsection::Closed:: *)
(*Formats*)



(* ::Subsubsubsection::Closed:: *)
(*Icon*)



$obPNG=
	Image[
		Import@PackageFilePath["Resources", "Icons", "OpenBabelIcon.png"],
		ImageSize->32
		];


(* ::Subsubsubsection::Closed:: *)
(*OpenBabel*)



Format[OpenBabel[dir_?OBDirQ, prog:_String:"obabel"]]:=
	RawBoxes@BoxForm`ArrangeSummaryBox[
		"OpenBabel",
		OpenBabel[dir],
		$obPNG,
		{
			BoxForm`MakeSummaryItem[{
				"Directory: ",
				Button[
					Mouseover[
						Style[FileNameTake@dir,"Hyperlink"],
						Style[FileNameTake@dir,"HyperlinkActive"]
						],
					SystemOpen@ExpandFileName@dir,
					Appearance->"Frameless",
					BaseStyle->"Hyperlink"
					]},
				StandardForm]
			},
		{
			BoxForm`MakeSummaryItem[{
				"Program: ",
				Button[
					Mouseover[
						Style[prog, "Hyperlink"],
						Style[prog, "HyperlinkActive"]
						],
					SystemOpen@ExpandFileName@FileNameJoin@{dir, "bin"},
					Appearance->"Frameless",
					BaseStyle->"Hyperlink"
					]
				},
				StandardForm]
			},
		StandardForm
		];


(* ::Subsection:: *)
(*Run*)



obabWriteTmp[fil_, string_]:=
	With[{f=OpenWrite@fil},
		WriteString[f,string];
		Close@f
		];


(* ::Subsubsection::Closed:: *)
(*Config*)



(* ::Subsubsubsection::Closed:: *)
(*$OBOptions*)



$OBOptions=<|
	"ImportStart"->"f",
	"ImportEnd"->"l",
	"OutputFile"->"O",
	"SingleMolecule"->"t",
	"IgnoreErrors"->"e",
	"CompressOutput"->"z",
	"MultipleOutputs"->"m",
	"DeleteHydrogens"->"d",
	"AddHydrogens"->"h",
	"pHAppropriateHydrogens"->"p",
	"ConvertDativeBonds"->"b",
	"CenterCoordinates"->"c",
	"JoinInputMolecules"->"j",
	"ConvertMatching"->"s",
	"ConvertExcept"->"v"
	|>;


(* ::Subsubsubsection::Closed:: *)
(*OBParamConvert*)



OBParamConvert//Clear


OBParamConvert[v_String]:=
	If[StringLength@DirectoryName[v]>0&&DirectoryQ@DirectoryName[v],
		ExpandFileName[v],
		v
		];
OBParamConvert[e_]:=
	ToString[e]


(* ::Subsubsection::Closed:: *)
(*obabRun*)



obabRun[a_]:=
	Block[
		{
			babelDir=
				Replace[
					Lookup[a, "OpenBabel", $OpenBabel],
					OpenBabel[d_, ___]:>d
					],
			binary=
				Replace[
					Lookup[a, "Mode", Automatic],
					{
						OpenBabel[d_, m_]:>m,
						Except[_String]->
							Replace[Lookup[a, "OpenBabel", $OpenBabel],
								{
									OpenBabel[d_, m_]:>m,
									_->"obabel"
									}
								]
						}
					],
			processDir=a["Directory"],
			inputData=a["Input"],
			inputFiles,
			outputSpecs=a["Output"],
			babelOps=Lookup[a, "Options", {}],
			runData,
			obcommand
			},
		binary=FileNameJoin@{babelDir, "bin", binary};
		If[!FileExistsQ@binary, 
			PackageRaiseException[
				"OpenBabelRun",
				"No OpenBabel binary found at ``",
				"MessageParameters"->{binary}
				]
			];
		(* gather input files *)
		inputFiles=
			Switch[inputData,
				_String?FileExistsQ,
					<|FileNameTake@inputData->ExpandFileName@inputData|>,
				{__String?FileExistsQ},
					Association@
						Map[
							FileNameTake@#->ExpandFileName@#&,
							inputData
							],
				_String,
					With[
						{
							filname=
								FileNameJoin@{processDir, "input"}
								},
						<|
							FileNameTake@filname->
								obabWriteTmp[filname,inputData]
							|>
						],
				_Association,
					Association@
						KeyValueMap[
							#->
								obabWriteTmp[FileNameJoin@{processDir,#},#2]&,
							inputData
							],
				_,
					PackageRaiseException[
						"OpenBabelRun",
						"Can't determine input files from ``",
						"MessageParameters"->{inputData}
						]
				];
		(* set process directory *)
		processDir=
			Replace[processDir,
				{
					Automatic:>
						Switch[inputFiles[[1]],
							_String?FileExistsQ,
								DirectoryName@inputFiles[[1]],
							_, 
								$TemporaryDirectory
							],
					Except[_String?DirectoryQ]->
						$TemporaryDirectory
					}
				];
			babelOps=
				Replace[
					Flatten@{Normal@babelOps},
					{
						(k_->True):>
							If[KeyExistsQ[$OBOptions, k],
								"-"<>$OBOptions[k],
								k
								],
						(_->False)->
							Nothing,
						(k_->v_):>
							(
								"-"<>Lookup[$OBOptions, k, k]<>""<>
									OBParamConvert[v]
								)
						},
					1
					];
			obcommand=
				Flatten@
						{
							FileBaseName@binary,
							ExpandFileName/@Values@inputFiles,
							Sequence@@babelOps
							};
			If[Lookup[a, "EchoCommand", False],
				Echo@obcommand
				];
			runData=
				RunProcess[
					obcommand,
					ProcessDirectory->
						processDir,
					ProcessEnvironment->
						<|
							"PATH"->
								StringJoin@
									Riffle[
										{
											DirectoryName@binary,
											FileNameJoin@{babelDir, "bin"},
											Environment["PATH"]
											},
										":"
										]
							|>
					];
			If[Lookup[a, "EmitMessages", False],
				With[{errdats=StringTrim@runData["StandardError"]},
					If[StringLength[errdats]>0,
						Message[OpenBabel::runerr,errdats]
						]
					];
				Replace[runData["StandardOutput"], 
					_String?(StringMatchQ[Whitespace])|""->Null
					],
				Replace[
					StringTrim[
						runData["StandardError"]<>"\n\n"<>runData["StandardOutput"]
						], 
					""->Null
					]
				]
		]


(* ::Subsubsection::Closed:: *)
(*pybelRun*)



$pybelSession:=
	If[!PySessionActive["pybel"], PySessionStart["pybel"], PySession["pybel"]]


(* ::Subsubsubsection::Closed:: *)
(*pybelRunProcessRun*)



pybelRunProcessRun[a_]:=
	Block[{
		babelDir=
			Replace[Lookup[a, "OpenBabel", $OpenBabel],
				OpenBabel[d_, ___]:>d
				],
		processDir=a["Directory"],
		inputFile=a["Input"],
		outputSpecs=a["Output"]
		},
		If[!
			AllTrue[{
				{"lib",$OBPythonInterpreter,"site-packages"},
				{"lib","_openbabel.so"}
				},
				FileExistsQ@FileNameJoin@Flatten@{babelDir,#}&
				],
			Return[$Failed]
			];
		processDir=
			Replace[processDir,{
				Automatic:>
					Switch[inputFile,
						_String?FileExistsQ,
							DirectoryName@inputFile,
						_->$TemporaryDirectory
						],
				Except[_String?DirectoryQ]->
					$TemporaryDirectory
				}];
		inputFile=
			Switch[inputFile,
				_String?FileExistsQ,
					inputFile,
				_String,
					With[{filname=
						FileNameJoin@{processDir,"input.py"}
						},
						obabWriteTmp[filname,inputFile]
						],
				_Association|_List,
					Sequence@@
						Replace[Flatten@{Normal@inputFile},{
							(fn_->s_):>
								obabWriteTmp[FileNameJoin@{processDir,fn},s]
							},
						1
						]
				];
			RunProcess[
				Flatten@{
					"python",
					inputFile
					},
				ProcessDirectory->
					processDir,
				ProcessEnvironment-><|
					"PATH"->
						Environment["PATH"],
					"PYTHONPATH"->
						StringJoin@
							Riffle[{
								FileNameJoin@{babelDir,"lib",$OBPythonInterpreter,"site-packages"},
								FileNameJoin@{babelDir,"scripts","python"}
								},":"
								]
					|>
				]
		]


(* ::Subsubsubsection::Closed:: *)
(*pybelSessionStart*)



pybelSessionStart[sessionTag_, processDir_, babelDir_]:=
	PySessionStart[sessionTag,
		ProcessDirectory->
			processDir,
		ProcessEnvironment-><|
			"PATH"->
				Environment["PATH"],
			"PYTHONPATH"->
				StringRiffle[
					{
						FileNameJoin@{babelDir, "lib", $OBPythonInterpreter,"site-packages"},
						FileNameJoin@{babelDir, "scripts", "python"}
						},
					":"
					]
			|>
		]


(* ::Subsubsubsection::Closed:: *)
(*pybelSessionRunInputFile*)



pybelSessionRunInputFile[sessionTag_, inputFile_]:=
	PySessionRun[sessionTag,
		"_pybel_tmp_file = open('"<>ExpandFileName@inputFile<>"')"
			<>"\n"<>
		"try:"
			<>"\n\t"<>
		"exec(_pybel_tmp_file.read())"
			<>"\n"<>
		"finally:"
			<>"\n\t"<>
			"_pybel_tmp_file.close()"
		]


(* ::Subsubsubsection::Closed:: *)
(*pybelSessionRun*)



pybelSessionRun//Clear


pybelSessionRun[a_, sessionTag_:"pybel"]:=
	Block[{
		babelDir=
			Replace[Lookup[a, "OpenBabel", $OpenBabel],
				OpenBabel[d_, ___]:>d
				],
		processDir=a["Directory"],
		inputFile=a["Input"],
		outputSpecs=a["Output"],
		tmpFile
		},
		If[!
			AllTrue[{
				{"lib", $OBPythonInterpreter, "site-packages"},
				{"lib", "_openbabel.so"}
				},
				FileExistsQ@FileNameJoin@Flatten@{babelDir,#}&
				],
			Return[$Failed]
			];
		processDir=
			Replace[processDir,
				{
					Automatic:>
						Switch[inputFile,
							_String?FileExistsQ,
								DirectoryName@inputFile,
							_,
								$TemporaryDirectory
							],
					Except[_String?DirectoryQ]->
						$TemporaryDirectory
					}
				];
		inputFile=
			Switch[inputFile,
				_String?FileExistsQ,
					inputFile,
				_String,
					tmpFile=CreateFile[];
					Export[tmpFile, inputFile, "Text"];
					inputFile=tmpFile,
				_Association|_List,
					tmpFile=CreateFile[];
					Export[tmpFile, 
						StringRiffle[
							Replace[Flatten@{Normal@inputFile},{
								(fn_->s_):>
									s
								},
							1
							],
							"\n\n"
							],
						"Text"
						];
					inputFile=tmpFile
				];
			With[{
				t1=
					pybelSessionRunInputFile[sessionTag, inputFile]
				},
				If[!AssociationQ@t1,
					pybelSessionStart[sessionTag,
						processDir,
						babelDir
						];
					pybelSessionRunInputFile[sessionTag, inputFile],
					t1
					]
				]
		]


(* ::Subsubsubsection::Closed:: *)
(*pybelRun*)



pybelRun//Clear
pybelRun[a_]:=
	Replace[Lookup[a, "Session", Options[OBPyRun, "Session"][[1, 2]]],
		{
			True:>pybelSessionRun@a,
			"Close":>
				(
					PySessionRemove["pybel"];
					<| 
						"StandardError"->"",
						"StandardOutput"->""
						|>
					),
			"Restart":>
				(
					PySessionRemove["pybel"];
					pybelSessionRun@a
					),
			s_String?(StringMatchQ[(WordCharacter|"-")..]):>
				pybelSessionRun[a, s],
			{"Close", s_String?(StringMatchQ[(WordCharacter|"-")..])}:>
				(
					PySessionRemove[s];
					<| 
						"StandardError"->"",
						"StandardOutput"->""
						|>
					),
			{"Restart", s_String?(StringMatchQ[(WordCharacter|"-")..])}:>
				(
					PySessionRemove[s];
					pybelSessionRun[a, s]
					),
			Automatic:>
				If[PySessionActive["pybel"],
					pybelSessionRun@a,
					pybelRunProcessRun@a
					],
			_:>
				pybelRunProcessRun@a
			}
		]


(* ::Subsubsection::Closed:: *)
(*OBRun*)



Options[OBRun]=
	{
		"EmitMessages"->False,
		"EchoCommand"->False,
		"Directory"->Automatic,
		"Mode"->Automatic
		};
OBRun[a_Association]:=
PackageExceptionBlock["OpenBabelRun"]@
	Block[{babelDir, binary},
		binary=
			Replace[a["Mode"],
				{
					s_String?FileExistsQ:>
						FileNameTake@s,
					Except[_String]:>
						Replace[a["Input"],
							{
								{f_String?(FileExistsQ@#&&FileExtension@#=="py"&),___}:>
									"Pybel",
								_->
									Automatic
								}
							]
					}
				];
		babelDir=
			Replace[a["Directory"],
				Except[_String?DirectoryQ]:>
					Replace[a["Mode"],
						{
							s_String?FileExistsQ:>
								Replace[
									FileNameJoin@
										SequenceCases[FileNameSplit@s,
											{base__, $obprefix,___}:>
												FileNameJoin@{base,$obprefix}
											],{
									{d_}:>d,
									_->$OBDir
									}],
							_->
								Automatic
							}]
				];
		Switch[binary,
			"Pybel",
				pybelRun@Merge[{a,
					"Directory"->Replace[babelDir, Automatic->$OBDir],
					"Input"->
						Replace[a["Input"],
							inp_Association:>
								OBPyConfig@inp
							]
					},
					Last],
			_,
				obabRun@Merge[{a, "Directory"->babelDir, "Mode"->binary},Last]
				]
		];
OBRun[f_String?FileExistsQ,args___String, ops___?OptionQ]:=
	OBRun@<|
		"Input"->{f, args},
		"Options"->
			FilterRules[Flatten@{ops}, Except[Options@OBRun]],
		Sequence@@
			FilterRules[Flatten@{ops}, Options@OBRun]
		|>;


(* ::Subsubsection::Closed:: *)
(*OBPyRun*)



(* ::Subsubsubsection::Closed:: *)
(*$OBPyHeader*)



$OBPyHeader=
	With[{dir=FileNameJoin@{$OBDir,"lib",$OBPythonInterpreter,"site-packages"}},
		{
			PyFromImportSow["__future__", "print_function"],
			PyImportSow[{"openbabel", "pybel"}]
			}
		]


(* ::Subsubsubsection::Closed:: *)
(*$OBPyMolecule*)



$OBPyMolecule=
	Evaluate[
		ToSymbolicPython[
			pybelLoadMolString = PyString[#, "'''"];
			pybelLoadName = PyString[#2];
			pybelLoadFormat = PyString@#3;
			#2 = pybel.readstring[PyString@#3, pybelLoadMolString];
			#2.inputString = pybelLoadMolString;
			#2.inputFormat = pybelLoadFormat;
			#2.inputName = pybelLoadName;
			]
		]&


(* ::Subsubsubsection::Closed:: *)
(*OBPyMoleculeString*)



OBPyMoleculeString//Clear
OBPyMoleculeString[fmt_String->molspec:_List|_String, name_]:=
	$OBPyMolecule[
		If[StringQ[molspec],
			molspec,
			ChemFormatsConvert[molspec, fmt->"String"]
			],
		name,
		ChemFormatsCanonicalFormat[fmt]
		];
OBPyMoleculeString[molspec:_List|_String, name_]:=
	With[{fmt=ChemFormatsDetect[molspec]},
		OBPyMoleculeString[
			fmt->molspec,
			name
			]
		];


(* ::Subsubsubsection::Closed:: *)
(*OBPyCommand*)



OBPyCommand[
	molecules_:{},
	body_
	]:=
	PackageExceptionBlock["OpenBabelRun"]@
		Module[{basecmd, stringcounter},
			basecmd=
			PyColumn@Flatten@{
				$OBPyHeader,
				MapIndexed[
					Replace[#,
						{
							(fmt_->thing_->name_String):>
								OBPyMoleculeString[
									fmt->thing,
									name
									],
							(thing_->name_String?(StringMatchQ[(WordCharacter|"_")..])):>
								OBPyMoleculeString[
									thing,
									name
									],
							(fmt_String->thing:Except[_String?(StringMatchQ[(WordCharacter|"_")..])]):>
								OBPyMoleculeString[
									fmt->thing,
									"pybelMol"<>If[#2[[1]]>1,ToString@First@#2,""]
									],
							_:>
								OBPyMoleculeString[
									#,
									"pybelMol"<>If[#2[[1]]>1,ToString@First@#2,""]
									]
							}
						]&,
					If[!ListQ[molecules]||ChemFormatsDetect[molecules]==="MolTable",
						{molecules},
						molecules
						]
					],
				If[SymbolicPythonQ[body]||StringQ[Unevaluated[body]],
					body,
					ToSymbolicPython[body]
					]
				};
		basecmd=ToPython@basecmd;
		If[!StringQ@basecmd, 
			PackageRaiseException["OpenBabelRun",
				"Input `` could not be converted to python",
				"MessageParameters"->{HoldForm[body]}
				]
			];
		basecmd(*//StringDelete["\n\n"]*)
		];
OBPyCommand~SetAttributes~HoldRest


(* ::Subsubsubsection::Closed:: *)
(*OBPyRun*)



OpenBabel::runfile="File string for OpenBabel run:

``";


OpenBabel::runerr="Error in OpenBabel run:

``";


OBPyRun//Clear


Options[OBPyRun]=
	{
		"OpenBabel"->Automatic,
		"Directory"->Automatic,
		"Session"->Automatic,
		"EmitMessages"->True,
		"EchoFile"->False
		};
OBPyRun[
	molecules_:{},
	body:Except[_Rule|_RuleDelayed|_FilterRules|{(_Rule|_RuleDelayed|_FilterRules)..}],
	imps:"StandardError"|"StandardOutput"|{Repeated["StandardError"|"StandardOutput",2]}:
		"StandardOutput",
	ops:OptionsPattern[]
	]:=
	PackageExceptionBlock["FormatConvert"]@
	PackageExceptionBlock["OpenBabelRun"]@
		With[{f=$OBPyRunFileString=OBPyCommand[molecules, body]},
			If[OptionValue["EchoFile"],
				Echo[f]
				];
			With[{
				runData=
					OBRun[
						<|
							ops,
							"OpenBabel"->Replace[OptionValue["OpenBabel"],Automatic:>$OBDir],
							"Mode"->"Pybel",
							"Input"->f
							|>
						]
				},
			If[OptionValue["EmitMessages"],
				With[{errdats=StringTrim@runData["StandardError"]},
					If[StringLength[errdats]>0,
						Message[OpenBabel::runerr,errdats]
						]
					]
				];
		Replace[
			s_String:>
				Replace[
					Quiet@
						ImportString[
							StringReplace[s, "'"->"\""],
							"JSON"
							], 
					$Failed->s
					]
			]@
			If[Length[#]===1,
				If[StringLength@#[[1]]>0, #[[1]]],
				#
				]&@
			Lookup[
				Map[
					StringTrim,
					KeyDrop[runData,"ExitCode"]
					],
				Flatten@{imps}
				]
			]
		];
OBPyRun~SetAttributes~HoldAll


(* ::Subsubsection::Closed:: *)
(*OBForceFieldEnergy*)



OBForceFieldEnergy[molecule_,ops:OptionsPattern[]]:=
	With[
		{
			log=
				Replace[
					Lookup[{ops}, "LogLevel", "Medium"],
					Except[_String]->"None"
					],
			ll=
				Replace[Lookup[{ops}, "LogLevel", "Medium"], 
					{
						s_String:>
							"OBFF_LOGLVL_"<>
								StringTrim[ToUpperCase[s], "OBFF_LOGLVL_"],
						_->
							"OBFF_LOGLVL_NONE"
						}
					],
			field=Lookup[{ops}, "ForceField", "UFF"]
			},
		OBPyRun[molecule,
			ff = openbabel.OBForceField.FindForceField[PyString@field];
			If[!ff,
			  Throw["Could not find forcefield"]
			  ];
			ff.SetLogLevel[openbabel."OBFF_LOGLVL_NONE"];
			ff.SetLogToStdOut[];
			pybelMol.setup = ff.Setup[pybelMol.OBMol];
			If[!pybelMol.setup,
			  Throw["Could not set up forcefield"]
			  ];
			ff.SetLogLevel[openbabel.ll];
			If[MemberQ[{PyString["None"], PyString["Low"]}, PyString@log], 
				ff.Energy[]//Print,
				ff.Energy[]
				];,
			Evaluate@FilterRules[{ops}, Except["LogLevel"|"ForceField"]]
			]
		]


(* ::Subsubsection::Closed:: *)
(*OBFormatConvert*)



OBFormatConvert//Clear
OBFormatConvert[molecule_, format_String, ops:OptionsPattern[]]:=
	OBPyRun[molecule,
		If[MemberQ[{PyString@"SMILES", PyString@"InChI"}, pybelMol.inputFormat],
			pybelMol.make3D[]
			];
		pybelMol.write[PyString[format]]//Print,
		ops
		];
OBFormatConvert[molecule_, curFmt_String->targetFmt_String, ops:OptionsPattern[]]:=
	OBFormatConvert[curFmt->molecule, targetFmt, ops]


(* ::Subsubsection::Closed:: *)
(*OBRingMap*)



OBRingMap[f_,mol_,ops:OptionsPattern[]]:=
	With[{fReal=Replace[f,Identity->Function@#]},
		OBPyRun[mol,
			MapIndexed[
				Function[
					Print["===Ring "<>ToString[#2+1]<>"===="];
					f[#]//Print;
					],
				openbabel.OBMolRingIter[pybelMol.OBMol]
				];,
			ops
			]
		]


End[];



