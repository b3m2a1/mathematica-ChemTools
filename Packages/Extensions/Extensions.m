(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



$ChemExtensions::usage=
	"Directory for all extensions";


PackageScopeBlock[
	ChemExtensionFile::usage="Picks a file matching a pattern";
	ChemExtensionDir::usage="Directory for an extension";
	ChemExtensionBin::usage="Binary executable for an extension";
	$ChemExtensionsApp::usage="";
	$ChemExtensionsDev::usage="";
	]


PackageScopeBlock[
	CMakeBuild::usage="Gets and compiles the CMake system";
	SwigBuild::usage="Gets and compiles the Swig system";
	]


PackageScopeBlock[
	PySession::usage="";
	PySessionProcess::usage="";
	PySessionStart::usage="";
	PySessionKill::usage="";
	PySessionActive::usage="";
	PySessionRun::usage="";
	]


Begin["`Private`"];


$ChemExtensionsDev=
	FileNameJoin@{
		$UserBaseDirectory,
		"ApplicationData",
		"ChemTools",
		"Extensions"
		};


$ChemExtensionsApp=
	With[{baseD=
		Replace[
			$InputFileName,
			{
				"":>ParentDirectory@NotebookDirectory[],
				e_:>$PackageDirectory
				}
			]
		},
		If[DirectoryQ@FileNameJoin@{baseD, "Resources", "Extensions"},
			FileNameJoin@{baseD, "Resources", "Extensions"},
			baseD
			]
		];


$ChemExtensions=
	If[DirectoryQ@$ChemExtensionsDev,
		$ChemExtensionsDev,
		$ChemExtensionsApp
		];


ChemExtensionDir[thing_]:=
	FileNameJoin@{
		SelectFirst[{
			"/usr/local/bin",
			"/usr/bin",
			$ChemExtensionsDev,
			$ChemExtensionsApp
			},
			DirectoryQ@FileNameJoin@{#,thing}&,
			$ChemExtensions
			],
		thing
		};
ChemExtensionFile[thing_]:=
	FileNameJoin@{
		SelectFirst[{
			"/usr/local/bin",
			"/usr/bin",
			$ChemExtensionsDev,
			$ChemExtensionsApp
			},
			FileExistsQ@FileNameJoin@{#,thing}&,
			$ChemExtensions
			],
		thing
		};
ChemExtensionBin[thing_]:=
	With[{d=ChemExtensionDir[thing]},
		If[FileNameTake[d,{-2}]==="bin",
			d,
			FileNameJoin@{d,"bin",FileBaseName[d]}
			]
		]


cmakeCheck[dir_]:=
	Quiet@Check[RunProcess[{"cmake"}],$Failed]=!=$Failed||
	FileExistsQ@FileNameJoin@{dir,"cmake","bin","cmake"};


cmakeRemove[s_String?DirectoryQ]:=
	DeleteDirectory[
		FileNameJoin@{s,"cmake"},
		DeleteContents->True
		];


$cmakeRoot="https://cmake.org/files/v3.7";


$cmakeInstallation="cmake-3.7.1.tar.gz";


cmakeDownload[]:=
	URLDownload[
		URLBuild@{$cmakeRoot,$cmakeInstallation},
		FileNameJoin@{$TemporaryDirectory,$cmakeInstallation}
		];


cmakeBuild[dir_,interactive:(True|False):True]:=
	With[{flag=
		If[interactive,
			FileExistsQ@FileNameJoin@{dir,"cmake"}||
			DialogInput[Column@{
			"This extension requires the cmake source code compiler (~250 MB)
This will install it on your system in the extension directory.
If you have root permissions it will also be installed and usable via
	'cmake /path/to/source/CMakeLists.txt'.

Would you like to continue?",
			Grid@{
				{
					Button["Yes",DialogReturn@True],
					Button["Cancel",DialogReturn@False]
					},
				{
				Button[
					Mouseover[
						Style["I'll install myself","Hyperlink"],
						Annotation[
							Style["I'll install myself","HyperlinkActive"],
							"https://cmake.org/download/"
							]
						],
					MessageDialog@"
Go to the binary distributions and choose the one that's right for you
";
					SystemOpen@$cmakeRoot;
					DialogReturn@False,
					Method->"Queued",
					Appearance->"Frameless"
					],
					SpanFromLeft
					}
				}
			}
			],
			True
			]},
		If[TrueQ@flag,
			If[!FileExistsQ@FileNameJoin@{dir,"cmake","bootstrap"},
				CurrentValue[EvaluationNotebook[],WindowStatusArea]=
					"Downloading from "<>URLBuild@{$cmakeRoot,$cmakeInstallation};
				Monitor[cmakeDownload[],
					Internal`LoadingPanel@"Downloading CMake"
					];
				CurrentValue[EvaluationNotebook[],WindowStatusArea]=
					"Extracting source...";
				Monitor[
					With[{d=CreateDirectory[]},
						ExtractArchive[
							FileNameJoin@{$TemporaryDirectory,$cmakeInstallation},
							d
							];
						DeleteFile@FileNameJoin@{$TemporaryDirectory,$cmakeInstallation};
						If[DirectoryQ@FileNameJoin@{dir,"cmake"},
							DeleteDirectory[FileNameJoin@{dir,"cmake"},DeleteContents->True]
							];
						CopyDirectory[
							FileNameJoin@{
								d,
								StringTrim[$cmakeInstallation,".tar.gz"]
								},
							FileNameJoin@{dir,"cmake"}
							];
						DeleteDirectory[d,DeleteContents->True]
						],
					Internal`LoadingPanel@"Extracting CMake source"
					];
				];
			CurrentValue[EvaluationNotebook[],WindowStatusArea]=
				"Installing cmake...";
			With[{cmakeDir=ExpandFileName@FileNameJoin@{dir,"cmake"}},
				If[!cmakeCheck@dir,
					Monitor[
						terminalRun[
							{
								"./configure",
								"--prefix=\""<>StringReplace[cmakeDir," "->"\\ "]<>"\""
								},
								ProcessDirectory->cmakeDir
							],
						Internal`LoadingPanel@"Configuring CMake"
						]
					];
				Monitor[
					terminalRun[{"make"},
						ProcessDirectory->
							cmakeDir
						];
					terminalRun[{"make","install"},
						ProcessDirectory->cmakeDir
						],
					Internal`LoadingPanel@"Building CMake"
					];
				CurrentValue[EvaluationNotebook[],WindowStatusArea]=None;
				If[FileExistsQ@FileNameJoin@{cmakeDir,"bin","cmake"},
					FileNameJoin@{cmakeDir,"bin","cmake"},
					$Failed
					]
				],
			$Failed
			]
		];


$CMakeDirectory:=
	ChemExtensionDir["cmake"]


CMakeBuild[d:_String?DirectoryQ|Automatic:Automatic]:=
	cmakeBuild[Replace[d,Automatic:>DirectoryName@$CMakeDirectory]];


$swigsrc=
	"http://prdownloads.sourceforge.net/swig/swig-3.0.12.tar.gz";


$swigpcresrc="https://ftp.pcre.org/pub/pcre/pcre-8.41.tar.gz";


swigDownload[dir_String?DirectoryQ]:=
	With[{
		tmpDir=
			CreateDirectory@
				FileNameJoin@{
					$TemporaryDirectory,
					StringJoin@RandomSample[Alphabet[],10]
					}
		},
		With[{
			f=URLDownload[$swigsrc,FileNameJoin@{tmpDir,"swig_tmp.tar.gz"}],
			out=FileNameJoin@{dir,"swig"}
			},
			ExtractArchive[f,tmpDir];
			DeleteFile[f];
			If[DirectoryQ@out,DeleteDirectory[out,DeleteContents->True]];
			CopyDirectory[First@FileNames["*",tmpDir],out];
			Quiet@DeleteDirectory[tmpDir,DeleteContents->True];
			swigpcreDownload[out];
			Replace[
				out,
				Except[_String?FileExistsQ]->$Failed
				]
		]
	];


swigpcreDownload[dir_]:=
	URLDownload[
		$swigpcresrc,
		FileNameJoin@{
			dir,
			FileNameTake[$swigpcresrc]
			}
		]


swigBuild[dir_]:=
	With[{swigdir=ExpandFileName@FileNameJoin@{dir,"swig"}},
		terminalRun[{FileNameJoin@{"Tools","pcre-build.sh"}},
			ProcessDirectory->swigdir
			];
		terminalRun[
			{
				FileNameJoin@{swigdir,"configure"},
				"--prefix="<>
					FileNameJoin@
						Map[
							If[StringContainsQ[#,Whitespace],"\""<>#<>"\"",#]&,
							FileNameSplit[swigdir]
							]
				},
			ProcessDirectory->swigdir
			];
		terminalRun[{"make"},
			ProcessDirectory->swigdir
			];
		terminalRun[{"make","install"},
			ProcessDirectory->swigdir
			];
		If[FileExistsQ@FileNameJoin@{swigdir,"bin","swig"},
			FileNameJoin@{swigdir,"bin","swig"},
			$Failed
			]
		]


swigCheck[dir_?DirectoryQ]:=
	FileExistsQ@FileNameJoin@{dir,"swig","bin","swig"};


$swigExt:=ChemExtensionDir["swig"];


SwigBuild[dir:_String?DirectoryQ|Automatic:Automatic]:=
	With[{d=Replace[dir,Automatic:>DirectoryName@$swigExt]},
		If[!swigCheck[d],
			If[!DirectoryQ@FileNameJoin@{d,"swig"}||
				Length[
					Select[DirectoryQ]@
						FileNames["*",FileNameJoin@{d,"swig"}]
					]===0,
				swigDownload[d]
				];
			swigBuild[d]
			]
		]


If[!AssociationQ@$PySessions,$PySessions=<||>];


PySession[n_]:=
	Replace[$PySessions[n],Except[_Association]->None]


PySessionProcess[n_]:=
	Replace[PySession[n],a:Except[None]:>a["Process"]]


PySessionActive[n_]:=
	MatchQ[$PySessions[n]["Process"],_ProcessObject?(ProcessStatus[#,"Running"]&)];


PySessionKill[n_]:=
	KillProcess@PySessionProcess[n];


PySessionStart[name_,
	ops:OptionsPattern[]
	]:=
	(
		PySessionKill[name];
		$PySessions[name]=
			<|
				"Process"->
					StartProcess[{"python","-i"},ops],
				"Name"->name
				|>
		);


PySessionWrite[name_,s_String]:=
	If[PySessionActive[name],
		WriteLine[PySessionProcess[name],s],
		$Failed
		];
PySessionWrite[name_,l_List]:=
	PySessionWrite[name,PySessionWriteEscape[l]]


Clear[PySessionWriteEscape];
PySessionWriteEscape[s_String]:=
	s;
PySessionWriteEscape[File[f_String]]:=
	"\""<>ExpandFileName[f]<>"\"";
PySessionWriteEscape[URL[u_String]]:=
	"\""<>u<>"\"";
PySessionWriteEscape[l_List]:=
	StringRiffle@Map[PySessionWriteEscape,l]
PySessionWriteEscape[r_Rule]:=
	PySessionWriteEscape[First[r]]<>"--="<>PySessionWriteEscape[Last[r]];
PySessionWriteEscape[Break]:=
	"\n";
PySessionWriteEscape[e_]:=ToString[e];


PySessionRead[name_]:=
Catch@
	With[{proc=PySessionProcess[name]},
		If[!MatchQ[proc,_ProcessObject],Throw[$Failed]];
		AssociationMap[
			With[{strm=ProcessConnection[proc,#]},
				If[!MatchQ[strm,_InputStream],Throw[$Failed]];
				ReadString[ProcessConnection[PySessionProcess[name],#],EndOfBuffer]
				]&,
			{
				"StandardOutput",
				"StandardError"
				}
			]
		];


Options[PySessionRun]=
	{
		TimeConstraint->Automatic,
		"PollTime"->Automatic
		};
PySessionRun[name_,s:_String|_List,ops:OptionsPattern[]]:=
	Catch@
	Block[{
		poll=
			Replace[OptionValue["PollTime"],
				Except[_?NumericQ]->.01
				],
		reads,
		startflag=CreateUUID["process-start-"],
		doneflag=CreateUUID["process-"]
		},
		Quiet@WriteLine[PySessionProcess@name,
			StringRiffle[
				{
					"import sys",
					"from __future__ import print_function",
					"print('"<>startflag<>"')",
					"print('"<>startflag<>"', file=sys.stderr)",
					"#-----Start Block------\n",
					s,
					"\n#-----End Block------",
					"print('"<>doneflag<>"', file=sys.stderr)",
					"print('"<>doneflag<>"')"
					},
				"\n"
				]
			];
		Pause[poll];
		reads=Replace[PySessionRead[name],$Failed:>Throw[$Failed]];
		TimeConstrained[
			While[!StringContainsQ[StringRiffle[Values[reads]],doneflag],
				Pause[poll/10];
				reads=
					Merge[{
						reads,
						Replace[PySessionRead[name],$Failed:>Throw[$Failed]]
						},
						StringJoin]
				],
			Replace[OptionValue[TimeConstraint],
				Except[_?NumericQ]->1
				],
			reads=
				Merge[{
					reads,
					Replace[Echo@PySessionRead[name],$Failed:>Throw[$Failed]]
					},
					StringJoin]
			];
		KeyValueMap[
			#->
				If[#==="StandardError",
					Function[
						StringDelete[#,
							Repeated[">>>"~~" "|""]|
							Repeated["..."~~" "|""]
							]
						],
					Identity
					]@
					StringTrim[
						First@StringSplit[
							Last@StringSplit[#2,startflag,2],
							doneflag,
							2
							],
					("\n"~~EndOfString)|
						startflag|
						doneflag
					]&,
			reads
			]//Association
		];


terminalRead[p_,readVar_]:=
	Block[{$terminalProcessKillFlag=False},
		Replace[
			ReadString[ProcessConnection[p,"StandardOutput"],EndOfBuffer],{
				s_String?(StringLength@#>0&):>AppendTo[readVar,s],
				EndOfFile:>($terminalProcessKillFlag=True)
				}];
		Replace[
			ReadString[ProcessConnection[p,"StandardError"],EndOfBuffer],{
				s_String?(StringLength@#>0&):>AppendTo[readVar,s],
				EndOfFile:>($terminalProcessKillFlag=True)
				}];
		If[$terminalProcessKillFlag,KillProcess@p]
		];
terminalRead~SetAttributes~HoldRest;


terminalRun[cmd_,o___]:=
	With[{p=StartProcess[cmd,o]},
		Block[{
			$terminalDownloadStrings={StringJoin@{Riffle[cmd," "],"\n"}}
			},
			terminalRead[p,$terminalDownloadStrings];
			Monitor[
				While[ProcessStatus@p==="Running",
					terminalRead[p,$terminalDownloadStrings];
					Pause[.1];
					],
				Dynamic[
				Framed[
					Column@{
						Style[StringJoin@Riffle[cmd," "],
							GrayLevel[.2]],
						Framed[
							Pane[Dynamic@StringJoin@$terminalDownloadStrings,
								{{250,500},100},
								Scrollbars->Automatic,
								ScrollPosition->{0,Dynamic@25*Length@$terminalDownloadStrings}
								],
							Background->White
							]
						},
					Background->GrayLevel[.95],
					RoundingRadius->5
					],
				TrackedSymbols:>{}
				]
				];
			StringJoin@$terminalDownloadStrings
			]
		];
terminalRunNoBlocking[cmd_,o___]:=
	With[{p=StartProcess[cmd,o],s=Unique@"$terminalDownloadStrings$"},
		s={StringJoin@Riffle[cmd," "],"\n"};
		Interpretation[
			Dynamic[
				terminalRead[p,s];
				Framed[
					Column@{
						StringJoin@Riffle[cmd," "],
						Framed@
							Pane[StringJoin@s,
								{{250,500},100},
								Scrollbars->Automatic,
								ScrollPosition->{0,22*Length@s}
								]
						},
					RoundingRadius->5
					]
				],
			StringJoin@s
			]
		];


End[];



