(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemMove::usage=
	"Generalizes \[Star]Move operations";
ChemRotate::usage=
	"Generalizes \[Star]Rotate operations";
ChemTransform::usage=
	"Generalizes \[Star]Transform operations";


ChemView::usage="Views a ChemObject";
ChemViewList::usage=
	"ChemView / Manipulate combo";


ChemSurface::usage="Generates a surface from a graphic or ChemObject";
ChemSurfacePlot::usage="Plots a function on a surface";


ChemAnimate::usage=
	"Animates a command and view expression. 
Just ListAnimate / Table / Interpretation joined";
ChemSaveAnimation::usage=
	"Exports a set of frames to a file";


ChemImportString::usage=
	"Imports a chemical structure or structures from a string";
ChemImport::usage=
	"Routes imports to ChemImportString";


ChemEvaluate::usage=
	"An evaluation tag for ChemCompile";
ChemCompile::usage=
	"Compiles a function replacing the ChemTools` scope";
$ChemCompilePoint::usage=
	"The point used in ChemPointCompile";
$ChemCompileObject::usage=
	"The object using in ChemPointCompile";
ChemPointCompile::usage=
	"Compiles a function using a coordinate as the default argument";


Begin["`Private`"];


ChemGetApply[obj:ChemManyPattern,prop_,args___]:=
	With[{attrs=
		Block[{$ChemFormatMethods=True},
			ChemGet[Flatten@obj,prop]
			]
		},
		If[ListQ@attrs,
			Through[Map[Apply,attrs][{args}]],
			attrs[args]
			]
		];


ChemMove[obj:ChemManyPattern,pt_,mode:"Set"|"Add":"Add"]:=
	(ChemGetApply[obj,"Move",pt,mode];);
ChemMove[pt_,mode:"Set"|"Add":"Add"][obj:ChemManyPattern]:=
	ChemMove[obj,pt,mode];


ChemRotate[obj:ChemManyPattern,theta_,axis_:{0.,0.,1.},pt_:{0.,0.,0.}]:=
	(ChemGetApply[obj,"Rotate",
		theta,axis,pt];);
ChemRotate[theta_,axis_:{0.,0.,1.},pt_:{0.,0.,0.}][obj:ChemManyPattern]:=
	ChemRotate[obj,theta,axis,pt];


ChemTransform[obj:ChemManyPattern,transf_]:=
	(ChemGetApply[obj,"Transform",transf];);
ChemTransform[transf_][obj:ChemManyPattern]:=
	ChemTransform[obj,transf];


ChemView[obj:ChemManyPattern,mode:"2D"|"3D":"3D",
	directives:(Except[_String|_Rule|_RuleDelayed])...,
	ops:OptionsPattern[]]:=
	Switch[mode,
		"2D",
			Graphics[{
				directives,
				ChemGetApply[obj,
					"Graphic",
					FilterRules[{ops},
						Except[Alternatives@@Map[First,Options@Graphics]]
						]
					]
				},
				FilterRules[
					{ops},
					Options@Graphics
					]
				],
		"3D",
			Graphics3D[{
				directives,
				ChemGetApply[obj,"Graphic3D",
					FilterRules[{ops},
						Except[Alternatives@@Map[First,Options@Graphics3D]]
						]
					]
				},
				FilterRules[
					{ops,"Lighting"->"Neutral",Boxed->False},
					Options@Graphics3D
					]
				]
		];


ChemView[obj:ChemManyPattern,"Atoms",a___]:=
	ChemView[obj,"3D",
		a,
		"AtomicRadius"->.15,
		"BondThickness"->0
		];
ChemView[obj:ChemManyPattern,"Bonds",a___]:=
	ChemView[obj,"3D",
		a,
		"AtomicRadius"->0.,
		"BondThickness"->.1
		];
ChemView[obj:ChemManyPattern,"SpaceFilling",a___]:=
	ChemView[obj,"3D",
		a,
		"RadiusScaling"->1,
		"AtomicRadius"->Automatic
		];
ChemView[obj:ChemManyPattern,"TraditionalForm",a___]:=
	ChemView[obj,"3D",
		Specularity[White,100],
		a
		];
ChemView[obj:ChemManyPattern,"Tube",a___]:=
	ChemView[obj,"3D",
		Specularity[White,100],
		a,
		"AtomicRadius"->.15,
		"BondThickness"->.15,
		"DoubleBondSeparation"->None,
		"TripleBondSeparation"->None
		];
ChemView[obj:ChemManyPattern,"Line",a___]:=
	ChemView[obj,"3D",
		Specularity[White,100],
		a,
		"AtomicRadius"->.01,
		"BondThickness"->.01,
		"DoubleBondSeparation"->None,
		"TripleBondSeparation"->None
		];


ChemView[s:(_String|_Integer|{(_String|_Integer)..}),a___]:=
	Replace[ChemImport@s,
		c:ChemObjAllPattern:>
			With[{g=ChemView[c,a]},
				ChemRemoveRecursive@c;
				g
				]
		];	


ChemViewList[l_List,ops___]:=
	With[{
		len=Length@l,
		barSize=Rasterize[Slider[],"RasterSize"],
		bW=25
		},
		Manipulate[
			ChemView[l[[i]],ops],
			Framed[
				Grid[
					{
						{
							Button[
								Style["\[LeftTriangleBar]",Gray],
								i=1,
								Appearance->"AbuttingRight"(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,Last@barSize}*)],
							Button[
								Style["\[LeftTriangle]",Gray],
								i=Max@{i-1,1},
								Appearance->"AbuttingLeftRight"(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,Last@barSize}*)],
							Framed[
								Control@{{i,1,""},1,Length@l,1,
									ControlType->Manipulator},
								FrameMargins->{{0,10},{-1,-1}},
								FrameStyle->Directive[Thin,GrayLevel[.9]]
								],
							Button[
								Style["\[RightTriangle]",Gray],
								i=Min@{i+1,len},
								Appearance->"AbuttingLeftRight"(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,Last@barSize}*)],
							Button[
								Style["\[RightTriangleBar]",Gray],
								i=len,
								Appearance->"AbuttingLeft",
								FrameMargins->{{0,3},{-1,0}}(*,
								ImageSize\[Rule]{bW,Last@barSize},
								Alignment\[Rule]{0,.5}*)]
							}
						},
					Spacings->0,
					Alignment->Top
					],
				RoundingRadius->5,
				FrameMargins->{{-2,-2},{-3,-2}},
				Background->White,
				FrameStyle->GrayLevel[.9]
				]
			]
		];


Options[ChemSurface]=
	Join[
		Options[BoundaryDiscretizeRegion],
		Options[DiscretizeGraphics]
		];
ChemSurface[g_Graphics3D,ops:OptionsPattern[]]:=
	With[{c=Cases[g,_Sphere,\[Infinity]]/.Sphere->Ball},
		If[Length@c>0,
			BoundaryDiscretizeRegion[
				RegionUnion@@c,
				FilterRules[{ops},
					Options@BoundaryDiscretizeRegion
					],
				PlotTheme->"SmoothShading"
				],
			DiscretizeGraphics[g,
				FilterRules[{ops},
					Options@DiscretizeGraphics
					],
				PlotTheme->"SmoothShading"
				]
			]
		];
ChemSurface[obj:ChemObjPattern,ops:OptionsPattern[]]:=
	ChemSurface@ChemView[obj,"SpaceFilling"];


(*Options[ChemSurfacePlot]={
	Function\[Rule]Compile[{{p,_Real,1}},Norm@p],
	InterpolatingFunction\[Rule]Compile[{{c,_Real,1}},Mean@c],
	ColorFunction\[Rule](Hue[1-.8*#]&),
	ColorFunctionScaling\[Rule]True
	};
ChemSurfacePlot[
	surface_?RegionQ,
	ops:OptionsPattern[]
	]:=
	With[{
		coordinateFunction=OptionValue@Function,
		interpolationFunction=OptionValue@InterpolatingFunction,
		colorFunction=OptionValue@ColorFunction,
		csScaling=TrueQ[OptionValue@ColorFunctionScaling]
		},
	Block[{
		csPlotCoordinateValues=coordinateFunction/@MeshCoordinates@surface,
		csPlotMinMax,csPlotMin,csPlotDiff,
		csPlotCellStyling},
		csPlotMinMax=MinMax@csPlotCoordinateValues;
		csPlotMin=First@csPlotMinMax;
		csPlotDiff=Abs@First@Differences@csPlotMinMax;
		csPlotCoordinateValues=
			Association@
				If[csScaling,
					If[csPlotDiff==0,
						MapIndexed[First@#2\[Rule].5&,
							csPlotCoordinateValues],
						MapIndexed[First@#2\[Rule](#-csPlotMin)/csPlotDiff&,
							csPlotCoordinateValues]
						],
					MapIndexed[First@#2\[Rule]#&,csPlotCoordinateValues]
					];
		csPlotCellStyling=
			With[{cf=
				colorFunction/.HoldPattern@ColorData[a__]\[RuleDelayed]
					RuleCondition[ColorData[a],True]},
			MapIndexed[
				Style[{2,First@#2},
					cf@interpolationFunction[First@#/.csPlotCoordinateValues]
					]&,
				MeshCells[surface,2]
				]
			];
		HighlightMesh[surface,
			csPlotCellStyling,
			PlotTheme\[Rule]"SmoothShading"
			]
		]
	];
ChemSurfacePlot[system_String,id_,f_,
	a___
	]:=
	With[{
		s=ChemSurface[system,id],
		ops=
			Sequence@@
				Normal@
					With[{op=Association@{
						ColorFunction\[Rule]({ColorData["TemperatureMap"]@#,Opacity[.65]}&),
						a
						}},
						If[FreeQ[op[ColorFunction],_Opacity],
							With[{cf=op[ColorFunction]},
								Append[op,ColorFunction\[Rule](Flatten@{cf@#,Opacity[.65]}&)]
								],
							op
							]
						]
			},
		Replace[
			ChemSurfacePlot[s,
				If[FreeQ[Hold[f],Point],
					f,
					AtomsetPointCompile[system,id,
						f
						]
					],
				ops
				],
			p:Except[_ChemSurfacePlot]:>
				Show[
					p,
					ChemView[system,id]
					]
			]
		];
ChemSurfacePlot[ChemObject[system_,id_],a__]:=
	ChemSurfacePlot[system,id,a];
ChemSurfacePlot~SetAttributes~HoldRest;*)


Options[ChemSurfacePlot]=
	Join[
		Options@SliceDensityPlot3D,
		Options@ChemSurface,{
		Quiet->True
		}];
ChemSurfacePlot[
	function_,
	surface_?RegionQ,
	ops:OptionsPattern[]
	]:=
	With[{m=MinMax@MeshCoordinates@surface},
		With[{
			drops=
				Sequence@@
					FilterRules[{ops,
						ColorFunction->ColorData["TemperatureMap"],
						Boxed->False,
						Axes->False
						},
					Options@SliceDensityPlot3D]
			},
			With[{h=
				Hold@
					SliceDensityPlot3D[function@{x,y,z},surface,
						{x,First@m,Last@m},
						{y,First@m,Last@m},
						{z,First@m,Last@m},
						drops
						]
				},
				If[OptionValue@Quiet//TrueQ,
					Quiet[ReleaseHold@h,CompiledFunction::cfta],
					ReleaseHold@h
					]
				]
			]
		];
ChemSurfacePlot[f_,
	obj_?ChemObjectQ,
	ops:OptionsPattern[]]:=
	With[{
		s=
		ChemSurface[obj,
			FilterRules[{ops},Options@ChemSurface]],
		opacity=
			Lookup[
				FilterRules[{ops},
					Opacity],
				Opacity,
				.85]
			},
		With[{
			pf=
				If[FreeQ[Hold[f],$ChemCompilePoint|$ChemCompileObject],
					f,
					Replace[Unevaluated[f],{
						c_ChemPointCompile:>
							c[obj],
						_:>
							Replace[ChemPointCompile[f],{
								c:Except[_CompiledFunction]:>
									c[obj]
								}]
						}]
					],
			pops=
				Sequence@@
					Replace[
						FilterRules[
							{
								ops,
								ColorFunction->ColorData["TemperatureMap"]
								},
							Options@ChemSurfacePlot],
						(ColorFunction->v_):>
							With[{cfOld=Replace[v,{_String|_Integer:>ColorData[v]}]},
								ColorFunction->
									(Directive[
										cfOld@#,
										Opacity[opacity]
										]&)
								],
						1]
			},
			Replace[
				ChemSurfacePlot[pf,s,pops],
				p:Except[_ChemSurfacePlot]:>
					Show[p,ChemView[obj]]
				]
			]
		];
ChemSurfacePlot~SetAttributes~HoldFirst;


chemAnimationTime=
	(_Times?(MatchQ[_Integer])|_Integer|_List|\[Infinity]);
chemAnimationObjs=
	ChemManyPattern|_Symbol?(MatchQ[ChemManyPattern])|
		{((_Symbol?(MatchQ[ChemObjAllPattern]))|ChemManyPattern)..};


ChemAnimate//ClearAll;
Options[ChemAnimate]=
	Join[
		Options@ListAnimate,{
		Prolog->{},
		Epilog->{},
		"AnimationTime"->10.,
		"ChemViewOptions"->{}
		}];
ChemAnimate[
	cmd_,
	steps:chemAnimationTime:10,
	ops:OptionsPattern[]]:=
	With[{
		frames=
			Join[
				Flatten@{OptionValue@Prolog},
				If[MatchQ[steps,_Integer|\[Infinity]],{cmd},{}],
				With[{
					start=Now,
					anmQ=
						Quantity[
							Replace[OptionValue@"AnimationTime",Except[_?NumericQ]->0],
							"Seconds"]
						},
					If[steps===\[Infinity],
						Reap[
							While[Now-start<anmQ,
								Sow@cmd
								]
							][[2,1]],
						Table[
							If[Now-start<anmQ,
								cmd,
								Nothing
								],
							steps
							]
						]
					],
				Flatten@{OptionValue@Epilog}
				]},
		Interpretation[
			ListAnimate[frames,
				FilterRules[{ops},Options@ListAnimate]],
			frames
			]
		];
ChemAnimate[
	obj:chemAnimationObjs,
	mutate_,
	steps:chemAnimationTime:10,
	ops:OptionsPattern[]]:=
	With[{cvops=
		Sequence@@
			Flatten@{OptionValue@"ChemViewOptions"}
			},
		ChemAnimate[
			mutate@obj;
			ChemView[obj,cvops],
			steps,
			ops,
			Prolog->{ChemView[obj,cvops]}
			]
		];
SyntaxInformation[ChemAnimate]=
	{
		"ArgumentsPattern"->{_,_.,_.,OptionsPattern[]},
		"LocalVariables"->{Table,{2,3}}
		};
ChemAnimate~SetAttributes~HoldAll;


ChemSaveAnimation[file_,
	frames_List|Interpretation[_,frames_List],
	ops:OptionsPattern[]]:=
	With[{images=
		Rasterize[#,"Image",FilterRules[{ops},Options@Rasterize]]&/@
			frames
			},
		With[{dims=ImageDimensions@First@images},
   	 Export[file,
   	 	ImageResize[ColorConvert[#, "RGB"], dims] & /@ images,
   	 	ops
   	 	]
    	]
    ]


ZMatrixStringPattern1=
	((StartOfLine|Whitespace)~~LetterCharacter..~~(Whitespace|EndOfLine));
ZMatrixStringPattern2=
	((StartOfLine|Whitespace)~~LetterCharacter..~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~(Whitespace|EndOfLine));
ZMatrixStringPattern3=
	((StartOfLine|Whitespace)~~LetterCharacter..~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~(Whitespace|EndOfLine));
ZMatrixStringPattern4=
	((StartOfLine|Whitespace)~~LetterCharacter..~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~Whitespace~~
		(DigitCharacter..)~~Whitespace~~NumberString~~(Whitespace|EndOfLine));


ChemDataZMatrixStringPattern=
	ZMatrixStringPattern1|
	(ZMatrixStringPattern1~~ZMatrixStringPattern2)|
	(ZMatrixStringPattern1~~ZMatrixStringPattern2~~ZMatrixStringPattern3)|
	(ZMatrixStringPattern1~~ZMatrixStringPattern2~~
		ZMatrixStringPattern3~~(ZMatrixStringPattern4..));


MolTableLineStringPattern1=
	(StartOfLine|Whitespace)~~LetterCharacter..~~
		Whitespace~~NumberString~~
		Whitespace~~NumberString~~
		Whitespace~~NumberString;
MolTableLineStringPattern2=
	(
		(StartOfLine|Whitespace)~~NumberString~~
		Whitespace?(Not@*StringContainsQ["\n"])~~NumberString~~
		Whitespace?(Not@*StringContainsQ["\n"])~~NumberString~~
		Whitespace?(Not@*StringContainsQ["\n"])~~LetterCharacter..~~
		Except["\n"]..
		);


ChemDataMolTableStringPattern=
	(
		((MolTableLineStringPattern1~~(Whitespace|"")~~EndOfLine)..)|
		((MolTableLineStringPattern2~~(Whitespace|"")~~EndOfLine)..)
		);


BondLineStringPattern=
	(
		(StartOfLine|Whitespace)~~DigitCharacter..~~
			Whitespace~~DigitCharacter..~~(Except["\n"]...)
		);


ChemDataBondBlockStringPattern=
	(BondLineStringPattern~~EndOfLine)..;


chemImportZMatrix[table_]:=
	With[{chunks=
		SequenceCases[SplitBy[table,MatchQ@{_String,___}],
			s:{ {{_String,___},___},{{_Integer,___},___} }|{{{_String,___},___}}:>
				Join@@s
			]},
		Table[
			With[{
				a=ChemUtilsGenerateMolTable@Cases[t,{_String,___}],
				b=Cases[t,{_Integer,_Integer,_Integer}|{_Integer,_Integer}]
				},
				Join[
					{{Length@a,Length@b}},
					a,
					b
					]
				],
			{t,chunks}
			]
		];


chemImportMolTable[string_String]:=
	chemImportMolTableString/@
		Select[
			StringSplit[string,
				"$$$$"
				],
			StringContainsQ["V2000"|"V3000"]
			];
chemImportMolTable[l_List]:=
	chemImportMolTableList/@
		DeleteCases[{"$$$$"}]@
			Split[
				l,
				MatchQ[{"$$$$"}]
				];


chemMolImportAtoms[stringChunks:{__String}]:=
	With[{chunks=
		StringTake[stringChunks,{
			{1,10},(*Positions*)
			{11,20},
			{21,30},
			{31,34}(*Element*)(*
			{34,-1}(*Rest*)*)
			}]
		},
		{
			StringTrim@#[[4]],
			ToExpression@Take[#,3]
			(*,
			ImportString[#[[5]],"Table"]*)
			}&/@chunks
		];
chemMolImportBonds[stringChunks:{__String}]:=
	With[{chunks=
		StringTake[stringChunks,{
			{1,3},
			{4,6},
			{7,9}(*,
			{10,-1}*)
			}]
		},
		ToExpression@chunks[[All,;;3]]
		];
basicDigitPattern=
	(
		("  "~~DigitCharacter)|
		(" "~~DigitCharacter)|
		DigitCharacter
		);
chemImportMolTableString[s_String]:=
	With[{blockChunks=
		Join[
			StringCases[
				s,{
				StartOfString~~id:(Except["\n"]..):>
					{"Props","ID"->id},
				StartOfString~~(Except["\n"]..)~~"\n"~~
					"  "~~name:(Except["\n"]..):>
					{"Props","IDTag"->name},
				(StartOfLine~~nums:((basicDigitPattern)~~
					(Except["\n"]..))~~("V2000"|"V3000")):>
					{"Numbers",ToExpression@StringTake[nums,{{1,3},{4,6}}]},
				(
					"> <"~~prop:Except[">"]..~~">"~~val:Except["<"]..~~"\n\n":>	
						RuleCondition[
							{"Props",
								StringJoin@
									(
										(
											Switch[#,
												(*
										Replace isn't capturing the variable appropriately here for 
										who knows what reason
										*)
												"pubchem",
													Nothing,
												"id",
													"ID",
												"rmsd",
													"RMSD",
												"cid",
													"CID",
												"mmff94",
													"MMFF94",
												"sid",
													"SID",
												_,
													ToUpperCase[StringTake[#,1]]<>
														StringTake[#,{2,-1}]
												]
											)&/@ToLowerCase@StringSplit[prop,"_"]
										)->
										Replace[
											DeleteCases[{}]@ImportString[val,"Table"],{
											{{i_}}:>i,
											l:{{_}..}:>Flatten[l]
											}]
									},
							True
							]
					)
				}],
			StringCases[
				StringSplit[s,
					(StartOfLine~~((basicDigitPattern)~~
						(Except["\n"]..))~~("V2000"|"V3000"))|
					"M "
					][[2]],{
				l:(StartOfLine~~("  -"|"   ")~~Except["\n"]..~~"\n"):>
					If[StringLength@l>=30,
						{"Atoms",l},
						l
						],
				l:(
					StartOfLine~~(
						("  "~~DigitCharacter)|
						(" "~~DigitCharacter)|
						DigitCharacter
						)~~Except["\n"]..~~"\n"):>
						If[StringLength@l>=9,
							{"Bonds",l},
							l
							]
				}]
			]},
			With[{data=KeySort@GroupBy[blockChunks,First->Last]},
				{
					Join[
						data["Numbers"],
						chemMolImportAtoms[data["Atoms"]],
						chemMolImportBonds[data["Bonds"]]
						],
					data["Props"]
					}
				]
		];


ChemImport::molst="Unable to find beginning of MolTable block";
chemImportMolTableList[table_List]:=
	Block[{$atomBondCount={\[Infinity],\[Infinity]}},
		Replace[
			Reap[
				Replace[table,{
					{atomCount_,bondCount_,___,"V2000"|"V3000"}:>
						With[{ab=
							If[atomCount>999,
								FromDigits/@
									Partition[IntegerDigits@atomCount,UpTo[3]],
								{atomCount,bondCount}
								]
							},
							Sow@"START";
							Sow@ab
							],
					{crd1_Real,crd2_Real,crd3_Real,elm_String,massDifference_,
						charge_,hCount_,stereoFlag_,hCount2_,__,
						aMap_,invRet_,exactChg_}:>
						Sow@{elm,{crd1,crd2,crd3}},
					{atom1_Integer,atom2_Integer,bondType_Integer,otherShit___}:>
						Sow@
							If[atom1>999,
								Append[
									With[{try1=
										FromDigits/@
											Partition[IntegerDigits@atom1,UpTo[3]]
										},
										If[AnyTrue[try1,#>First@$atomBondCount&],
											FromDigits@*Reverse/@
												Partition[Reverse@IntegerDigits@atom1,
													UpTo[3]]
											]
										],
									atom2
									],
								{atom1,atom2,bondType}
								],
					{"M","END"}:>
						Sow@"END",
					{">",s_String?(StringMatchQ["<*>"])}:>
						Sow["PROP"->s],
					e_:>Sow@e
					},
					1]
				][[2]],
				{
					e:Except[{{___,"START",___}}]:>(
						Print@e;
						Message[ChemImport::molst];
						$Failed
						),
					e_:>(parseMolTable@First@e)
					}
				]
		];


parseMolTable[atomList:{___,"START",__}]:=
	SequenceCases[atomList,
		{
			id_:None,
			idTag_:None,
			___,
			"START",bits:Shortest@__,"END",p___}:>
			{
				{
					bits
					},
				Join[
					{
						"ID"->id,
						"IDTag"->idTag
						},
					Map[Last@First@#->Rest[#]]&/@
						Block[{flag=True},
							Split[{p},
								Function[
									If[MatchQ[#,"PROP"->_],
										flag=Not@flag
										];
									flag
									]
								]
							]
					]
				}	
		];


getElemColors[]:=
	Replace[
		$elemsByColor,
		Except[_Association]:>
			($elemsByColor=
				DeleteCases[
					AssociationMap[
						ElementData[#,"IconColor"]&,
						ChemTools`Private`$ChemElements//Keys
						],
					$Failed
					]
				)
		];
elemByColor[c_]:=
	With[{elems=getElemColors[]},
		SelectFirst[
			Keys@elems,
			Replace[elems[#],{
				ec_?ColorQ:>
					(ColorDistance[ec,c]<.1),
				_->False
				}]||
			Replace[ColorData["Atoms"][#],{
				ec_?ColorQ:>
					(ColorDistance[ec,c]<.1),
				_->False
				}]&,
			"X"
			]
		];


graphics3DGetAtoms[{color_,crds__}]:=
	With[{e=elemByColor@color},
		Map[{e,#}&,{crds}]
		];


graphics3DGetBonds[{origCrds_,atomCrds_}]:=
	With[{bondCrds=Replace[origCrds,(l_List->_):>l,1]},
		With[{pairs=
			DeleteDuplicatesBy[Sort]@*Join@@
				Replace[bondCrds,{
					{
						a_?(Norm[First@Nearest[atomCrds,#]-#<.1]&),
						b_?(Norm[First@Nearest[atomCrds,#]-#<.1]&)
						}:>
						With[{
							a1=First@Nearest[atomCrds,a,1],
							a2=First@Nearest[atomCrds,b,1]
							},
							If[a1==a2,
								Nothing,
								{{a1,a2}}
								]
							],
					{a_,b_}:>
						Join[
							Cases[bondCrds,
								{a,i:Except[b]}|{i:Except[b],a}:>{b,i}
								],
							Cases[bondCrds,
								{i:Except[a],b}|{b,i:Except[a]}:>{a,i}
								]
							]
						},
					1]
				},
			(*Append[#,1]&/@*)
				Select[
					pairs,
					AllTrue[#,MemberQ[atomCrds,#]&]&
					]
			]
		];


graphicsComplexImport[gc_]:=
	With[{
		coords=First@gc,
		objs=Cases[gc[[2]],_RGBColor|_Sphere|_Ball|_Cylinder,\[Infinity]]},
		With[{
			balls=
				SequenceCases[objs,
					{_RGBColor,(_Sphere|_Ball)..},
					\[Infinity]],
			sticks=
				SequenceCases[objs,
					{_RGBColor,(_Cylinder)..},
					\[Infinity]
					]
			},
			With[{
				atoms=
					Join@@Map[
							graphics3DGetAtoms@*
								ReplaceAll[ (Sphere|Ball)[p_,___]:>p ],
							balls
							]},
				{
					atoms,
					graphics3DGetBonds@{
						Cases[sticks,
							Cylinder[{i_Integer,j_Integer},___]:>
								{i,j}
							,\[Infinity]],
						Last/@atoms
						}
					}/.i_Integer:>coords[[i]]
				]
			]
		];


graphicsImportSpheresBallsAndCylinders[objs_]:=
	With[{objSet=
		Cases[objs,_RGBColor|_Sphere|_Ball|_Cylinder,\[Infinity]]
		},
		With[{
			balls=
				SequenceCases[objSet,
					{_RGBColor,(_Sphere|_Ball)..},
					\[Infinity]],
			sticks=
				Cases[
					ReplaceAll[objSet,
						l:{___,_Cylinder,___}:>
							SplitBy[l,
								MatchQ[_Cylinder]
								]
						],{
					Except[_Cylinder]...,
					c:__Cylinder|{__Cylinder},
					Except[_Cylinder]...
					}:>
						Flatten@{c},\[Infinity]]
			},
			With[{
					atoms=
						Join@@Map[
								graphics3DGetAtoms@*
									ReplaceAll[ (Sphere|Ball)[p_,___]:>p ],
								balls
								]},
					{
						atoms,
						graphics3DGetBonds@{
							Map[
								FirstCase[#,
									p:{{__?NumericQ},{__?NumericQ}}:>
										(p),
									Nothing,
									\[Infinity]
									]&,
								sticks
								],
							Last/@atoms
							}
						}
					]
				]
			];


chemImportGraphics3D[data_Graphics3D]:=
	With[{as=
		Replace[FirstCase[data,_GraphicsComplex,None,\[Infinity]],{
			None:>
				graphicsImportSpheresBallsAndCylinders@data,
			gc_:>
				graphicsComplexImport@gc
			}]
		},
		List@
			Join[
				With[{m=
					Replace[
						Replace[(Norm@*Subtract@@@Last@as),{
							{}->0,
							m:{__}:>Mean@m
							}],
						i_?(#>0&):>
							Floor@Log10@i
						]},
						If[m>0,
							Map[{First@#,Last@#/10^m}&,First@as],
							First@as
							]
					],
				With[{aps=Last/@First@as},
					Sort@
						Map[
							First@First@Position[aps,#]&,
							Last@as,
							{2}]
					]
				]
		];


(*chemImportGraph[data_Graph]:=
	With[{
		nodes=VertexList@data,
		c=Options[data,VertexStyle],
		w=Normal@WeightedAdjacencyGraph@data},
		Vertex coordinates would have to be explicitly specified, though.
		
		];*)


chemImport[
	system:_String|ChemObject[_]|Automatic:Automatic,
	atomSets_List
	]:=
	With[{sys=Replace[system,Automatic:>$ChemDefaultSystem]},
		Replace[
			CreateAtomset[sys,#]&/@atomSets//Flatten,{
			{}->None,
			{a_}:>a
			}]
		];


ChemImport::noobj=
	"Unable to construct ChemObject check input file or contact me";
ChemImportString[
	system:ChemSysPattern|Automatic:Automatic,
	string_String,
	format:"MolTable"|"ZMatrix"]:=
	Switch[format,
		"MolTable",
			chemImport[system,
				chemImportMolTable@string],
		"ZMatrix",
			chemImport[system,
				chemImportZMatrix@ImportString[string,"Table"]]
		];
ChemImportString[
	system:ChemSysPattern|Automatic:Automatic,
	string_String,
	Optional[Automatic,Automatic]]:=
	With[{attempts=
		If[StringContainsQ[string,"V2000"|"V3000"],
			{"MolTable","ZMatrix"},
			{"ZMatrix","MolTable"}
			]
		},
		Replace[
			ChemImportString[system,string,First@attempts],{
			Except[_ChemObject|{__ChemObject}]:>
				Replace[
					Quiet@
						ChemImportString[system,string,Last@attempts],
					e:Except[_ChemObject|{__ChemObject}]:>(
						Message[ChemImport::noobj];
						$Failed
						)
					]
			}]
		]


ChemImport[
	system:ChemSysPattern|Automatic:Automatic,
	file:_File|_String?FileExistsQ,
	format:"MolTable"|"ZMatrix"|Automatic:Automatic]:=
	With[{form=
		Replace[format,
			Automatic:>
				Switch[FileExtension@file,
					"mol"|"sdf",
						"MolTable",
					"gjf",
						"ZMatrix",
					_,
						Automatic
					]
				]
			},
		ChemImportString[system,Import[file,"Text"],form]
		];


ChemImport[
	system:ChemSysPattern|Automatic:Automatic,
	file:_URL|_String?(URLParse[#]["Scheme"]=!=None&),
	format:"MolTable"|"ZMatrix"|Automatic:Automatic]:=
	With[{f=URLDownload@file},
		If[FileExistsQ@f,
			ChemImport[system,f,format],
			$Failed
			]
		];	


ChemImport::no3d=
	"No 3D structure found for identifier ``. Attempting to use a 2D structure instead";
ChemImport::nostr=
	"No structure found for identifier ``";
ChemImport[
	system:ChemSysPattern|Automatic:Automatic,
	structure:
		_PubChemCompound|
		_PubChemSubstance|
		_Integer|
		Entity["Chemical",_]|
		_String?(
			Not@FileExistsQ@#&&
			Not@StringContainsQ[#,"\n"|$PathnameSeparator]
			&),
	format:"MolTable"|"ZMatrix"|Automatic:Automatic]:=
	Replace[
		Replace[
			Quiet[ChemDataLookup[structure,"SDFFiles"],ServiceExecute::serrormsg],
			$Failed:>(
				Message[ChemImport::no3d, structure];
				ChemDataLookup[structure,"2DStructures",
					"Overwrite"->True]
				)
			],{
		mol_String:>
			ChemImportString[system,mol,"MolTable"],
		mols:{__String}:>
			Map[ChemImportString[system,#,"MolTable"]&,mols],
		_:>(Message[ChemImport::nostr,structure];$Failed)
		}];


ChemImport[
	system:ChemSysPattern|Automatic:Automatic,
	data_Graphics3D
	]:=
	chemImport[system,chemImportGraphics3D@data];


(*ChemImport[
	system:ChemSysPattern|Automatic:Automatic,
	data_Graph
	]:=
	chemImport[system,chemImportGraph@data];*)


$ChemImportableTypes=
	(
		_Graphics3D|_String|_Integer|Entity["Chemical",_]|
		_File|_URL|
		_PubChemCompound|_PubChemSubstance
		);


ChemImport[system:ChemSysPattern|Automatic:Automatic,
	data:{$ChemImportableTypes..}
	]:=
	ChemImport[system,#]&/@data;


ChemImport[
	system:ChemSysPattern|Automatic:Automatic,
	s_Symbol?(Not@*MatchQ[$ChemImportableTypes|{$ChemImportableTypes..}])
	]:=
	(s=ChemImport[system,SymbolName[Unevaluated[s]]]);
ChemImport[system:ChemSysPattern|Automatic:Automatic,
	s_?(MatchQ[$ChemImportableTypes|{$ChemImportableTypes..}]),
	o___
	]:=
	ChemImport[system,s,o];
ChemImport[
	a___
	]/;!TrueQ[$ChemImportInImport]:=
	Block[{$ChemImportInImport=True},
		With[{l={a}},
			ChemImport@@l
			]
		]


ChemImport~SetAttributes~HoldFirst;


End[];



