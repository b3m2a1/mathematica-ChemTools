(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Subsubsection::Closed:: *)
(*Inertial Stuff*)



ChemComputeInertialTensor::usage=
	"Returns the inertial tensor for a collection of masses and positions";
ChemComputeInertialEigensystem::usage=
	"Returns the inertial eigensystem for a collection of masses and positions";
ChemComputeInertialSystem::usage=
	"Returns the A, B, and C constants and axes";
ChemComputeRotorType::usage=
	"Returns the type of molecular rotor that best resembles the collection of atoms";


(* ::Subsubsection::Closed:: *)
(*Cartesian Stuff*)
 


ChemComputeCoordinateBounds::usage=
	"The bounding box of a collection of atoms";
ChemComputeCenter::usage="Center of a set of atoms";
ChemComputeCenterOfMass::usage="COM of a set of atoms";


(* ::Subsubsection::Closed:: *)
(*Alignment Transforms*)



ChemComputeAlignmentTransform::usage=
	"Arbitrary geometric transform for perfoming alignments";
ChemComputeAxisAlignmentTransform::usage=
	"Alignment transform mapping points";


Begin["`Private`"];


(* ::Subsection:: *)
(*Structural Utils*)



(* ::Subsubsection::Closed:: *)
(*ChemComputeInertialTensor*)



ChemComputeInertialTensor//Clear


ChemComputeInertialTensor[masses_List, positions_List]:=
	Total@
		MapThread[
			With[{m=#1,x=#2[[1]],y=#2[[2]],z=#2[[3]]},
				m*{ 
					{y^2+z^2,-x*y,-x*z},
					{-x*y,x^2+z^2,-y*z},
					{-x*z,-y*z,x^2+y^2}
				}]&,
			{masses,positions}
			];
ChemComputeInertialTensor[massPositions:{{_Real, _List, ___},___}]:=
	ChemComputeInertialTensor[massPositions[[All,1]], massPositions[[All,2]]];
ChemComputeInertialTensor[
	massPositions:{{_String, _List, ___},___}
	]:=
	ChemComputeInertialTensor[
		QuantityMagnitude@ChemDataLookup[massPositions[[All, 1]], "Mass"],
		massPositions[[All, 2]]
		]


(* ::Subsubsection::Closed:: *)
(*InertialEigensystem*)



ChemComputeInertialEigensystem[args__]:=
	Replace[ChemComputeInertialTensor[args],
		tensor:{_List,_List,_List}:>
			With[{eig=Eigensystem@tensor},
				With[{ord=Ordering@First@eig},
					{eig[[1,ord]],eig[[2,ord]]}
					]
				]
		];


(* ::Subsubsection::Closed:: *)
(*InertialSystem*)



inertConversion=
	Block[{$ChemDataSourcesDontCacheFlag=True},
		QuantityMagnitude@
			ChemDataLookup[
				"InertialConstant",
				"UnitConversions"
				]
		];


ChemComputeInertialSystem[{{ia_,ib_,ic_},{ax_,bx_,cx_}}]:=
	<|
		"A"->Replace[ia,{0|0.->\[Infinity],e_:>inertConversion/e}],
		"B"->Replace[ib,{0|0.->\[Infinity],e_:>inertConversion/e}],
		"C"->Replace[ic,{0|0.->\[Infinity],e_:>inertConversion/e}],
		"AAxis"->ax,
		"BAxis"->bx,
		"CAxis"->cx,
		"Units"->Quantity[1,"Megahertz"]
		|>;
ChemComputeInertialSystem[e__]:=
	ChemComputeInertialSystem@ChemComputeInertialEigensystem[e]


(* ::Subsubsection::Closed:: *)
(*Center*)



ChemComputeCenter[atoms_]:=
	Mean@Map[Last,atoms];


(* ::Subsubsection::Closed:: *)
(*CenterOfMass*)



ChemComputeCenterOfMass[masses_,positions_]:=
	Mean@WeightedData[positions,masses];
ChemComputeCenterOfMass[atoms:{{_Real,_},___}]:=
	ChemComputeCenterOfMass[First/@atoms,Last/@atoms];
ChemComputeCenterOfMass[atoms:{{_String,_},___}]:=
	ChemComputeCenterOfMass@
		Map[{QuantityMagnitude@ChemDataLookup[First@#,"AtomicMass"],Last@#}&,
			atoms];


(* ::Subsubsection::Closed:: *)
(*RotorType*)



ChemComputeRotorType[Ic_?NumericQ,Ib_?NumericQ,Ia_?NumericQ]:=
	If[Ia<10^-5,
		"Linear",
		With[{ac=Ic/Ia,ab=Ib/Ia,bc=Ic/Ib},
			Which[
				Max@{ac,ab,bc}<2,
					"Spherical",
				ab<2,
					"Oblate",
				bc<2,
					"Prolate",
				True,
					None
				]
			]
		];
ChemComputeRotorType[{{Ia_?NumericQ,Ib_?NumericQ,Ic_?NumericQ},_}]:=
	ChemComputeRotorType[Ia,Ib,Ic];
ChemComputeRotorType[a:{{_Real,_List},___}]:=
	ChemComputeRotorType@ChemComputeInertialEigensystem[a];
ChemComputeRotorType[a:{{_String,_List},___}]:=
	ChemComputeRotorType@
		Map[{
			QuantityMagnitude@ChemDataLookup[First@#,"AtomicMass"],
			Last@#}&,a];


(* ::Subsubsection::Closed:: *)
(*Bounds*)



ChemComputeCoordinateBounds[
	atoms:{
		{_String,{_?NumericQ,_?NumericQ,_?NumericQ}}..
		},
	padding:_?NumericQ:0
	]:=
	Module[{
		rads=
			QuantityMagnitude/@
				UnitConvert[ChemDataLookup[First/@atoms,"Radius"],"Angstroms"],
		pos=Last/@atoms,
		moves=Tuples[{1,-1},3]
		},
		pos=
			Flatten[
				MapThread[
					With[{
						base=#*moves,
						p=#2
						},
						p+#&/@base
						]&,{
					rads+padding,
					pos
					}],
				1
				];
		CoordinateBounds@pos
		];


(* ::Subsubsection::Closed:: *)
(*AxisAlignmentTransform*)



ChemComputeAxisAlignmentTransform//Clear


axisReplacements=
	{
		"X"->{1,0,0},
		-"X"->{-1,0,0},
		"Y"->{0,1,0},
		-"Y"->{0,-1,0},
		"Z"->{0,0,1},
		-"Z"->{0,0,-1}
		};


axisPatternBase=
	"X"|"Y"|"Z"|{_?NumericQ,_?NumericQ,_?NumericQ};
axisPattern=axisPatternBase|-axisPatternBase;


ChemComputeAxisAlignmentTransform[
	a:(axisPattern->axisPattern),
	b:(axisPattern->axisPattern)|None:None,
	point:axisPattern:{0,0,0}
	]:=
	With[{
		rotation1=
			Replace[a,
				(ax1_->ax2_):>
					Replace[
						{ax1,ax2},
						axisReplacements,
						1]
				],
		center=
			Replace[point,
				axisReplacements
				],
		rotation2=
			Replace[b,
				(ax1_->ax2_):>
					Replace[{ax1,ax2},
						axisReplacements,
						1]
				]
		},
		Replace[b,
		{	
				(ax1_->ax2_):>
					With[
						{
							t1=
								If[MatchQ[rotation1, {_List,_List}],
									If[MatrixRank@rotation1==2,
										RotationTransform[rotation1, center],
										Identity
										],
									Identity
									]
							},
						With[{
							t2=
								With[{r2=t1@rotation2[[1]]},
									RotationTransform[
										VectorAngle[
											r2-
												Projection[
													r2,
													rotation1[[2]]
													],
											rotation2[[2]]
											],
										rotation1[[2]],
										center
										]
									]
							},
							If[t1===Identity,
								t2,
								Simplify@Composition[t2,t1]
								]
							]
						],
				_->(* just need to set up a single rotation *)
					Replace[rotation1,
						{u_,v_}:>
							Which[
								MatrixRank@{u,v}==2,
									RotationTransform[{u,v},center],
								u==-v,
									(*
								Need a better way to handle this. 
								Should maybe be some form of inversion? 
								*)
									RotationTransform[{u,v},center],
								True,
									None
								]
						]
				}
			]
	]


ChemComputeAxisAlignmentTransform[
	elSet:{{_String, _List, ___}, ___},
	a:(("A"|"B"|"C"|axisPattern)->("A"|"B"|"C"|axisPattern)),
	b:(("A"|"B"|"C"|axisPattern)->("A"|"B"|"C"|axisPattern))|None:None,
	point:"Center"|"CenterOfMass"|axisPattern:{0,0,0}
	]:=
	With[{is=ChemComputeInertialSystem[elSet]},
		ChemComputeAxisAlignmentTransform[
			a/.{
				"A":>is["AAxis"],
				"B":>is["BAxis"],
				"C":>is["CAxis"]
				},
			b/.{
				"A":>is["AAxis"],
				"B":>is["BAxis"],
				"C":>is["CAxis"]
				},
			Replace[point,
				{
					"Center":>ChemComputeCenter[elSet],
					"CenterOfMass":>ChemComputeCenterOfMass[elSet]
					}
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*AlignmentTransform*)



ChemComputeAlignmentTransform//Clear


pt="X"|"Y"|"Z"|{_?NumericQ,_?NumericQ,_?NumericQ};


ChemComputeAlignmentTransform[
	a:{Repeated[pt,3]}->
		b:{Repeated[pt,3]}
	]:=
	With[{
		pos=Replace[Join[a,b],{"X"->{1,0,0},"Y"->{0,1,0},"Z"->{0,0,1}},1]
		},
		Simplify@
			Composition[
				ChemComputeAxisAlignmentTransform[
					pos[[1]]-pos[[2]]->pos[[4]]-pos[[5]],
					pos[[1]]-pos[[3]]->pos[[4]]-pos[[6]],
					pos[[4]]
					],
				TranslationTransform[pos[[4]]-pos[[1]]]
				]
		];
ChemComputeAlignmentTransform[
	a:{{_?StringQ|_?NumericQ,{_?NumericQ,_?NumericQ,_?NumericQ}},___}->
		b:{{_?StringQ|_?NumericQ,{_?NumericQ,_?NumericQ,_?NumericQ}},___}
	]:=
	With[{
		sys1=
			ChemComputeInertialSystem[a],
		com1=
			ChemComputeCenterOfMass[a],
		sys2=
			ChemComputeInertialSystem[b],
		com2=
			ChemComputeCenterOfMass[b]
		},
		ChemComputeAlignmentTransform[
			{com1,com1+sys1["AAxis"],com2+sys1["BAxis"]}->
				{com2,com2+sys2["AAxis"],com2+sys2["BAxis"]}
			]
		];


End[];



