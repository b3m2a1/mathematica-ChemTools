(* ::Package:: *)

(* Autogenerated Package *)

(* ::Subsubsection::Closed:: *)
(*Inertial Stuff*)



ChemComputeInertialTensor::usage=
  "Returns the inertial tensor for a collection of masses and positions";
ChemComputeInertialEigensystem::usage=
  "Returns the inertial eigensystem for a collection of masses and positions";
ChemComputeInertialSystem::usage=
  "Returns the A, B, and C constants and axes";
ChemComputeRotorType::usage=
  "Returns the type of molecular rotor that best resembles the collection of atoms";


(* ::Subsubsection::Closed:: *)
(*Cartesian Stuff*)
 


ChemComputeCoordinateBounds::usage=
  "The bounding box of a collection of atoms";
ChemComputeCenter::usage="Center of a set of atoms";
ChemComputeCenterOfMass::usage="COM of a set of atoms";


(* ::Subsubsection::Closed:: *)
(*Alignment Transforms*)



ChemComputeAlignmentTransform::usage=
  "Arbitrary geometric transform for perfoming alignments";
ChemComputeAxisAlignmentTransform::usage=
  "Alignment transform mapping points";


Begin["`Private`"];


(* ::Subsection:: *)
(*Structural Utils*)



(* ::Subsubsection::Closed:: *)
(*ChemComputeInertialTensor*)



ChemComputeInertialTensor//Clear


ChemComputeInertialTensor[masses_List, positions_List]:=
  Total@
    MapThread[
      With[{m=#1,x=#2[[1]],y=#2[[2]],z=#2[[3]]},
        m*{ 
          {y^2+z^2,-x*y,-x*z},
          {-x*y,x^2+z^2,-y*z},
          {-x*z,-y*z,x^2+y^2}
        }]&,
      {masses,positions}
      ];
ChemComputeInertialTensor[massPositions:{{_Real, _List, ___},___}]:=
  ChemComputeInertialTensor[massPositions[[All,1]], massPositions[[All,2]]];
ChemComputeInertialTensor[
  massPositions:{{_String, _List, ___},___}
  ]:=
  ChemComputeInertialTensor[
    QuantityMagnitude@ChemDataLookup[massPositions[[All, 1]], "Mass"],
    massPositions[[All, 2]]
    ]


(* ::Subsubsection::Closed:: *)
(*InertialEigensystem*)



ChemComputeInertialEigensystem[args__]:=
  Replace[ChemComputeInertialTensor[args],
    tensor:{_List,_List,_List}:>
      With[{eig=Eigensystem@tensor},
        With[{ord=Ordering@First@eig},
          {eig[[1,ord]],eig[[2,ord]]}
          ]
        ]
    ];


(* ::Subsubsection::Closed:: *)
(*InertialSystem*)



inertConversion=
  Block[{$ChemDataSourcesDontCacheFlag=True},
    QuantityMagnitude@
      ChemDataLookup[
        "InertialConstant",
        "UnitConversions"
        ]
    ];


ChemComputeInertialSystem[{{ia_,ib_,ic_},{ax_,bx_,cx_}}]:=
  <|
    "A"->Replace[ia,{0|0.->\[Infinity],e_:>inertConversion/e}],
    "B"->Replace[ib,{0|0.->\[Infinity],e_:>inertConversion/e}],
    "C"->Replace[ic,{0|0.->\[Infinity],e_:>inertConversion/e}],
    "AAxis"->ax,
    "BAxis"->bx,
    "CAxis"->cx,
    "Units"->Quantity[1,"Megahertz"]
    |>;
ChemComputeInertialSystem[e__]:=
  ChemComputeInertialSystem@ChemComputeInertialEigensystem[e]


(* ::Subsubsection::Closed:: *)
(*Center*)



ChemComputeCenter[atoms_]:=
  Mean@Map[Last,atoms];


(* ::Subsubsection::Closed:: *)
(*CenterOfMass*)



ChemComputeCenterOfMass[masses_,positions_]:=
  Mean@WeightedData[positions,masses];
ChemComputeCenterOfMass[atoms:{{_Real,_},___}]:=
  ChemComputeCenterOfMass[First/@atoms,Last/@atoms];
ChemComputeCenterOfMass[atoms:{{_String,_},___}]:=
  ChemComputeCenterOfMass@
    Map[{QuantityMagnitude@ChemDataLookup[First@#,"AtomicMass"],Last@#}&,
      atoms];


(* ::Subsubsection::Closed:: *)
(*RotorType*)



ChemComputeRotorType[Ic_?NumericQ,Ib_?NumericQ,Ia_?NumericQ]:=
  If[Ia<10^-5,
    "Linear",
    With[{ac=Ic/Ia,ab=Ib/Ia,bc=Ic/Ib},
      Which[
        Max@{ac,ab,bc}<2,
          "Spherical",
        ab<2,
          "Oblate",
        bc<2,
          "Prolate",
        True,
          None
        ]
      ]
    ];
ChemComputeRotorType[{{Ia_?NumericQ,Ib_?NumericQ,Ic_?NumericQ},_}]:=
  ChemComputeRotorType[Ia,Ib,Ic];
ChemComputeRotorType[a:{{_Real,_List},___}]:=
  ChemComputeRotorType@ChemComputeInertialEigensystem[a];
ChemComputeRotorType[a:{{_String,_List},___}]:=
  ChemComputeRotorType@
    Map[{
      QuantityMagnitude@ChemDataLookup[First@#,"AtomicMass"],
      Last@#}&,a];


(* ::Subsubsection::Closed:: *)
(*Bounds*)



ChemComputeCoordinateBounds[
  atoms:{
    {_String,{_?NumericQ,_?NumericQ,_?NumericQ}}..
    },
  padding:_?NumericQ:0
  ]:=
  Module[{
    rads=
      QuantityMagnitude/@
        UnitConvert[ChemDataLookup[First/@atoms,"Radius"],"Angstroms"],
    pos=Last/@atoms,
    moves=Tuples[{1,-1},3]
    },
    pos=
      Flatten[
        MapThread[
          With[{
            base=#*moves,
            p=#2
            },
            p+#&/@base
            ]&,{
          rads+padding,
          pos
          }],
        1
        ];
    CoordinateBounds@pos
    ];


(* ::Subsubsection::Closed:: *)
(*AxisAlignmentTransform*)



ChemComputeAxisAlignmentTransform//Clear


axisReplacements=
  {
    "X"->{1,0,0},
    -"X"->{-1,0,0},
    "Y"->{0,1,0},
    -"Y"->{0,-1,0},
    "Z"->{0,0,1},
    -"Z"->{0,0,-1}
    };


axisPatternBase=
  "X"|"Y"|"Z"|{_?NumericQ,_?NumericQ,_?NumericQ};
axisPattern=axisPatternBase|-axisPatternBase;


ChemComputeAxisAlignmentTransform[
  a:(axisPattern->axisPattern),
  b:(axisPattern->axisPattern)|None:None,
  point:axisPattern:{0,0,0}
  ]:=
  Module[
    {
      rotation1,
      center,
      rotation2
      },
    rotation1=
      Replace[
        List@@a,
        axisReplacements,
        1];
    center=
      Replace[point,
        axisReplacements
        ];
    rotation2=
      Replace[b,
        (ax1_->ax2_):>
          Replace[
            {ax1,ax2},
            axisReplacements,
            1]
        ];
    If[b=!=None,
      Module[
        {
          n,
          t1, t2, r2, p1, p2, c1, 
          d1x, d1y, d2x, d2y, ang
          },
        t1=
          If[MatchQ[rotation1, {_List, _List}],
            If[MatrixRank@rotation1==2,
              RotationTransform[rotation1, center],
              Identity
              ],
            Identity
            ];
        n=rotation1[[2]];
        p1=rotation2[[2]]-Projection[rotation2[[2]], n];
        r2=t1@rotation2[[1]];
        p2=r2-Projection[r2, n];
        If[Norm[p1]>10^-5&&Norm[p2]>10^-5,
          (* We create the plane axis system, call p1 the x axis, take the y axis, dot things in *)
          c1=Cross[p1, n];
          d1x=Norm[p1]; d1y=0;
          d2x=Dot[p1, p2]; d2y=Dot[c1, p2];
          ang=
            ArcTan[d1y, d1x]-ArcTan[d2y, d2x];
          t2=
            RotationTransform[
              ang,
              rotation1[[2]],
              center
              ],
          t2=Identity
          ];
        If[t1===Identity,
          t2,
          Simplify@Composition[t2,t1]
          ]
        ],
      Replace[rotation1,
        {u_,v_}:>
          Which[
            MatrixRank@{u,v}==2,
              RotationTransform[{u,v},center],
            u==-v,
              (*
						Need a better way to handle this. 
						Should maybe be some form of inversion? 
						*)
              RotationTransform[{u,v},center],
            True,
              None
            ]
        ]
      ]
    ]


ChemComputeAxisAlignmentTransform[
  elSet:{{_String, _List, ___}, ___},
  a:(("A"|"B"|"C"|axisPattern)->("A"|"B"|"C"|axisPattern)),
  b:(("A"|"B"|"C"|axisPattern)->("A"|"B"|"C"|axisPattern))|None:None,
  point:"Center"|"CenterOfMass"|axisPattern:{0,0,0}
  ]:=
  With[{is=ChemComputeInertialSystem[elSet]},
    ChemComputeAxisAlignmentTransform[
      a/.{
        "A":>is["AAxis"],
        "B":>is["BAxis"],
        "C":>is["CAxis"]
        },
      b/.{
        "A":>is["AAxis"],
        "B":>is["BAxis"],
        "C":>is["CAxis"]
        },
      Replace[point,
        {
          "Center":>ChemComputeCenter[elSet],
          "CenterOfMass":>ChemComputeCenterOfMass[elSet]
          }
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*AlignmentTransform*)



ChemComputeAlignmentTransform//Clear


pt="X"|"Y"|"Z"|{_?NumericQ,_?NumericQ,_?NumericQ};


ChemComputeAlignmentTransform[
  a:{Repeated[pt,3]}->
    b:{Repeated[pt,3]}
  ]:=
  With[{
    pos=Replace[Join[a,b],{"X"->{1,0,0},"Y"->{0,1,0},"Z"->{0,0,1}},1]
    },
    Simplify@
      Composition[
        ChemComputeAxisAlignmentTransform[
          pos[[1]]-pos[[2]]->pos[[4]]-pos[[5]],
          pos[[1]]-pos[[3]]->pos[[4]]-pos[[6]],
          pos[[4]]
          ],
        TranslationTransform[pos[[4]]-pos[[1]]]
        ]
    ];
ChemComputeAlignmentTransform[
  a:{{_?StringQ|_?NumericQ,{_?NumericQ,_?NumericQ,_?NumericQ}},___}->
    b:{{_?StringQ|_?NumericQ,{_?NumericQ,_?NumericQ,_?NumericQ}},___}
  ]:=
  With[{
    sys1=
      ChemComputeInertialSystem[a],
    com1=
      ChemComputeCenterOfMass[a],
    sys2=
      ChemComputeInertialSystem[b],
    com2=
      ChemComputeCenterOfMass[b]
    },
    ChemComputeAlignmentTransform[
      {com1,com1+sys1["AAxis"],com2+sys1["BAxis"]}->
        {com2,com2+sys2["AAxis"],com2+sys2["BAxis"]}
      ]
    ];


End[];



