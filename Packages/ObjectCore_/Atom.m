(* ::Package:: *)


(* ::Title:: *)
(*AtomsetUtils Package*)

(* ::Text::GrayLevel[.5]:: *)
(*Autogenerated ChemTools package*)

chemAtomProps[
	element:_String|Automatic:Automatic,
	mass:_?NumberQ|_Quantity|Automatic:Automatic,
	position:
		{_?NumberQ|_Quantity,_?NumberQ|_Quantity,_?NumberQ|_Quantity}|
		_QuantityArray|Automatic:Automatic,
	others___Rule
	]:=
	With[{e=Replace[element,Automatic->"H"]},
		With[{iq=ChemDataIsotopeQ@e},
			With[{props=
				DeleteCases[{
					"Element"->
						ChemDataLookup[e,"Symbol"],
					"Mass"->
						ChemDataLookup[e,"Mass"],
					"Position"->position,
					"NeutronNumber"->
						If[iq,
							ChemDataLookup[e,"NeutronNumber",IsotopeData],
							Automatic
							]},
					_->Automatic]},
				Flatten@{props,others}
				]
			]
	];


CreateAtom[sys:chemSys|Automatic:Automatic,
	specs:{
		{__Rule}..
		}]:=
	ChemAdd[Replace[sys,Automatic:>$ChemDefaultSystem],
		"Atom",
		Sequence@@specs
		];


CreateAtom[sys:chemSys|Automatic:Automatic,
	element:_String|Automatic:Automatic,
	mass:_?NumberQ|_Quantity|Automatic:Automatic,
	position:
		{_?NumberQ|_Quantity,_?NumberQ|_Quantity,_?NumberQ|_Quantity}|
		_QuantityArray|Automatic:Automatic,
	others___Rule
	]:=
	CreateAtom[sys,List@chemAtomProps[element,mass,position,others]];
CreateAtom[sys:chemSys|Automatic:Automatic,
	props:{
		{
			Optional[_String|Automatic,Automatic],
			Optional[_?NumberQ|_Quantity|Automatic,Automatic],
			Optional[
			{_?NumberQ|_Quantity,_?NumberQ|_Quantity,_?NumberQ|_Quantity}|
			_QuantityArray|Automatic,Automatic],
			___Rule
			}...
		}]:=
		With[{config=chemAtomProps@@@props},
			CreateAtom[sys,config]
			];


AtomIsotopeQ[obj:chemObj]:=
	MatchQ[ChemGet[obj,"NeutronNumber"],_Integer];
AtomIsotopeQ[objV:chemObjV]:=
	MatchQ[_Integer]/@ChemGet[objV,"NeutronNumber"];


AtomMove[obj:chemObjAll,
	{x_,y_,z_},
	mode:"Set"|"Add":"Add"
	]:=
	If[mode==="Set",
		ChemSet[obj,"Position",{x,y,z}],
		ChemIncrement[obj,"Position",{x,y,z}]
		];


AtomRotate[obj:chemObjAll,
	theta:_?NumericQ,
	axis:{_,_,_}:{0,0,1},
	point:{_,_,_}:{0,0,0}]:=
	AtomTransform[obj,
		RotationTransform[theta,axis,point]];


AtomTransform[obj:chemObjAll,transform_]:=
	ChemMutate[obj,"Position",transform]


AtomCanBondQ[obj:chemObj,obj_,___]:=
	False;
AtomCanBondQ[obj:chemObj,ob2:chemObj,btype_:1]:=
	(MatchQ[btype,_String]||#+#2-2*btype>=0)&@@
		ChemGet[Flatten@{obj,ob2},"Valence"];
AtomCanBondQ[obj:chemObj,obv:chemObjV,btype_:1]:=
	Apply[
		!MatchQ[btype,_?NumberQ]||#+#2-2*btype>=0&,
		Partition[
			Riffle[Rest@#,First@#]&ChemGet[Flatten@{obj,obv},"Valence"],
			2]
		];
AtomCanBondQ[objv:chemObjV,ob2:chemObj,btype_:1]:=
	With[{v=ChemGet[Append[objv,ob2],"Valence"]},
		{(MatchQ[btype,_String]||#+#2-2*btype>=0)}&@@@
			Partition[Riffle[Most@v,Last@v],2]
		];
AtomCanBondQ[objv:chemObjV,obv:chemObjV,btype_:1]:=
	With[{v=ChemGet[Join[objv,obv],"Valence"]},
		(MatchQ[btype,_String]||#+#2-2*btype>=0)&@@@
			Partition[Riffle[Take[v,Length@objv],#],2]&/@
				Take[v,Length@obv]
		];


AtomAddBond[a:chemObjAll,b:chemObj]:=(
	ChemAddReference[a,b];
	ChemAppendTo[a,"Bonds",b];
	);


AtomCreateBond[a1:chemObj,a2:chemObj,
	btype_:1,
	check:True|False:True,
	specs:(_Rule|_RuleDelayed)...]:=
	If[(!check)||AtomCanBondQ[a1,a2,btype],
		With[{b=CreateBond[a1,a2,btype,specs]},
			BondForm[b,False];
			b
			],
		$Failed
		];


AtomRemoveBond[a:chemObjAll,b:chemObj]:=(
	ChemRemoveReference[a,b];
	ChemDeleteFrom[a,"Bonds",b];
	);


AtomGetBonds[a:chemObj,pat:Except[_List]]:=
	With[{p=Replace[pat,Except[_ChemObject]->ChemObject[First@a,pat]]},
		With[{bonds=ChemGet[a,"Bonds"]},
			Pick[bonds,
				MemberQ[DeleteCases[#,a],p]&/@
					ChemGet[bonds,"Atoms"]
				]
			]
		];
AtomGetBonds[a:chemObj,ps_List]:=
	With[{
		bonds=ChemGet[a,"Bonds"]
		},
		Intersection[bonds,#]&/@
			ChemGet[ps,"Bonds",{}]
		];
AtomGetBonds[atoms:chemObjV,ps_List]:=
	With[{
		bondList=ChemGet[atoms,"Bonds"],
		bonds2=ChemGet[ps,"Bonds"]
		},
		Table[
			Intersection[bonds,#]&/@bonds2,
			{bonds,bondList}
			]
		];


AtomBondedQ[a:chemObj,b:chemObj]:=
	AtomGetBonds[a,b]=!={};
AtomBondedQ[a:chemObj,b:chemObjV]:=
	#=!={}&/@AtomGetBonds[a,b];
AtomBondedQ[a:chemObjV,b:chemObjV]:=
	Map[#=!={}&]/@AtomGetBonds[a,b];


AtomBreakBond[a:chemObj,b:chemObj]:=
	If[ChemInstanceQ[b,"Bond"],
		BondBreak[b],
		Replace[AtomGetBonds[a,b],{
			{bd_,___}:>BondBreak@bd,
			_->$Failed
			}]
		];


AtomValenceChoices[a:chemObjAll]:=
	ChemDataLookup[
		ChemGet[a,"Element"],
		"ElementValences"];


AtomValence[obj:chemObj]:=
	First@ChemGet[obj,"MaxValence"]-
		Total@Map[
			Replace[Except[_?NumberQ]:>0],
			ChemGet[ChemGet[obj,"Bonds"],"Type"]
			];
AtomValence[obj:chemObjV]:=
	First/@ChemGet[obj,"MaxValence"]-
		Total/@Map[
			Replace[#,Except[_?NumberQ]:>{0},1]&,
			ChemGet["Type"]/@ChemGet[obj,"Bonds"]
			];


AtomHybridization[obj:chemObj]:=
	With[{
		mv=ChemGet[obj,"MaxValence"],
		bd=
			Replace[
				ChemGet[ChemGet[obj,"Bonds"],"Type"],
				Except[_?NumericQ]:>
					0,
				1]},	
		Replace[Select[mv,Total@bd<=#&&#<=4&],{
			{v_,___}:>
				Switch[v-Total@bd,
					0,
						Switch[v-Length@bd,
							0,
								"sp3",
							1,
								"sp2",
							2,
								"sp",
							_,
								Missing["NonTetrahedral"]
							],
					_,
						Missing["NonTetrahedral"]
						],
			{}->
				Missing["NonTetrahedral"]
			}]
		];
AtomHybridization[obj:chemObjV]:=
	With[{
		mvV=ChemGet[obj,"MaxValence"],
		bdV=
			Map[
				Replace[
					#,
					Except[_?NumericQ]:>
						0,
					1]&,
				ChemGet[ChemGet[obj,"Bonds"],"Type"]
				]},	
		MapThread[
			With[{mv=#,bd=#2},
				Replace[Select[mv,Total@bd<=#&&#<=4&],{
					{v_,___}:>
						Switch[v-Total@bd,
							0,
								Switch[v-Length@bd,
									0,
										"sp3",
									1,
										"sp2",
									2,
										"sp",
									_,
										Missing["NonTetrahedral"]
									],
							_,
								Missing["NonTetrahedral"]
								],
					{}->
						Missing["NonTetrahedral"]
					}]
				]&,{
			mvV,
			bdV
			}]
		];


AtomColor[obj:chemObjAll]:=
	With[{baseColors=Flatten@{ChemGet[obj,"Color"]}},
		If[MemberQ[baseColors,Except[_?ColorQ]],
			With[{colors=
				Flatten@{ChemDataLookup[ChemGet[obj,"Element"],"AtomColors"]}
				},
				MapThread[If[ColorQ@#,#,#2]&,{
					baseColors,
					colors
					}]
				],
			baseColors
			]
		]//If[ListQ@obj,#,First@#]&


With[{co=chemObj,cv=chemObjV,ca=chemObjAll},
	AtomColor/:
		HoldPattern[Set[AtomColor[obj_?(MatchQ[co])],color_]]:=
			ChemSet[obj,"Color",color];
	AtomColor/:
		HoldPattern[SetDelayed[AtomColor[obj_?(MatchQ[co])],color_]]:=
			ChemSetDelayed[obj,"Color",color];
	AtomColor/:
		HoldPattern[Set[AtomColor[obj_?(MatchQ[cv])],color:Except[_List]]]:=
			(
				ChemSet[obj,"Color",color]
				);
	AtomColor/:
		HoldPattern[SetDelayed[AtomColor[objV:_?(MatchQ[cv])],color:Except[_List]]]:=
			ChemSetDelayed[objV,"Color",color];
	AtomColor/:
		HoldPattern[Set[AtomColor[objV_?(MatchQ[cv])],color_List]]:=
			ChemThreadSet[objV,"Color",color];
	AtomColor/:
		HoldPattern[SetDelayed[AtomColor[objV_?(MatchQ[cv])],color_List]]:=
			ChemThreadSetDelayed[objV,"Color",color];
	AtomColor/:
		HoldPattern[Unset[AtomColor[obj_?(MatchQ[ca])]]]:=
			Set[AtomColor[obj],Automatic]
	];


AtomPartialCharge[obj:chemObjAll]:=
	ChemGet[obj,"PartialCharge",0.];


With[{co=chemObj,cv=chemObjV,ca=chemObjAll},
	AtomPartialCharge/:
		HoldPattern[Set[AtomPartialCharge[obj_?(MatchQ[co])],charge_]]:=
			ChemSet[obj,"PartialCharge",charge];
	AtomPartialCharge/:
		HoldPattern[SetDelayed[AtomPartialCharge[obj_?(MatchQ[co])],charge_]]:=
			ChemSetDelayed[obj,"PartialCharge",charge];
	AtomPartialCharge/:
		HoldPattern[Set[AtomPartialCharge[obj_?(MatchQ[cv])],charge:Except[_List]]]:=
			(
				ChemSet[obj,"PartialCharge",charge]
				);
	AtomPartialCharge/:
		HoldPattern[SetDelayed[AtomPartialCharge[objV:_?(MatchQ[cv])],charge:Except[_List]]]:=
			ChemSetDelayed[objV,"PartialCharge",charge];
	AtomPartialCharge/:
		HoldPattern[Set[AtomPartialCharge[objV_?(MatchQ[cv])],charge_List]]:=
			ChemThreadSet[objV,"PartialCharge",charge];
	AtomPartialCharge/:
		HoldPattern[SetDelayed[AtomPartialCharge[objV_?(MatchQ[cv])],charge_List]]:=
			ChemThreadSetDelayed[objV,"PartialCharge",charge];
	AtomPartialCharge/:
		HoldPattern[Unset[AtomPartialCharge[obj_?(MatchQ[ca])]]]:=
			Set[AtomPartialCharge[obj],Automatic]
	];


AtomGraph[obj:chemObj|chemObjV,
	edge:UndirectedEdge|DirectedEdge:UndirectedEdge]:=
	With[{atoms=
		Select[
			ChemGet[
				DeleteDuplicates@Flatten@
					ChemGet[obj,"Bonds"],
				"Atoms"
				],
			AllTrue[#,
				MatchQ[Alternatives@@Flatten@{obj}]]&
			]
		},
		Block[{atomGraphOrdering=<||>},
			With[{a=
				If[KeyMemberQ[atomGraphOrdering,First@#],
					Reverse@#,
					#]},
				atomGraphOrdering[First@a]=Null;
				edge@@a
				]&/@atoms//Graph
			]
		];


atomGraphEvents[basevs_,bs_,as_,DepthFirstScan]:=
	With[{evs=
		Merge[
			Replace[Flatten@{basevs},{
				(k:("BackEdge"|"FrontierEdge"|
					"ForwardEdge"|"CrossEdge")->f_):>
					k->(f[#/.bs]&),
				({k:"BackEdge"|"FrontierEdge"|
					"ForwardEdge"|"CrossEdge",
					c:chemObj}->f_):>
					(If[MatchQ[#/.bs,c],f[c]]&),
				({k_,c:chemObj}->f_):>
					k->(If[MatchQ[#,c],f[c]]&),
				(c:chemObj->f_):>
					If[MemberQ[c,as],
						Thread[
							{"DiscoverVertex",
								"UnvisitedVertex","VisitedVertex",
								"PrevisitVertex","PostvisitVertex"}->
								(If[MatchQ[#,c],f[c]]&)
							],
						Thread[
							{"BackEdge","FrontierEdge",
								"ForwardEdge","CrossEdge"}->
								 (If[MatchQ[#/.bs,c],f[c]]&)
							]
						]
				},1],
			Replace[f:{__}:>
				(Through[f[#]]&)
				]
			]},
		evs
		];


atomGraphEvents[basevs_,bs_,as_,BreadthFirstScan]:=
	Merge[
		Replace[Flatten@{basevs},{
			(k:("FrontierEdge"|"CycleEdge")->f_):>
				k->(f[#/.bs]&),
			({k:("FrontierEdge"|"CycleEdge"),
				c:chemObj}->f_):>
				(If[MatchQ[#/.bs,c],f[c]]&),
			({k_,c:chemObj}->f_):>
				k->(If[MatchQ[#,c],f[c]]&),
			(c:chemObj->f_):>
				If[MemberQ[as,c],
					Thread[
						{"DiscoverVertex",
							"UnvisitedVertex","VisitedVertex",
							"PrevisitVertex","PostvisitVertex"}->
							(If[MatchQ[#,c],f[c]]&)
						],
					Thread[
						{"FrontierEdge","CycleEdge"}->
							(If[MatchQ[#/.bs,c],f[c]]&)
						]
					]
			},
			1],
		Replace[f:{__}:>
			(Through[f[#]]&)
			]
		];


AtomGraphEvents[obj:chemObjAll,
	mode:BreadthFirstScan|DepthFirstScan:BreadthFirstScan,
	events_:{}
	]:=
	With[{g=AtomGraph[obj]},
		With[{
			as=VertexList@g,
			bs=EdgeList@g/.e:(a_<->b_):>(
				(e|Reverse@e)->First@AtomGetBonds[a,b]
				),
			basevs=
				Flatten@events
			},
			atomGraphEvents[basevs,bs,as,mode]
			]
		];


AtomGraphScan[
	obj:chemObjAll,
	startingNode:chemObj|None:None,
	mode:BreadthFirstScan|DepthFirstScan|Automatic:Automatic,
	events_:{}]:=
	With[{scanF=
		Replace[mode,
			Automatic:>
				If[
					FreeQ[events,
						("BackEdge"|"FrontierEdge"|
							"ForwardEdge"|"CrossEdge")],
					BreadthFirstScan,
					DepthFirstScan
					]
				]},
		If[startingNode===None,
			scanF[AtomGraph@obj,
				AtomGraphEvents[obj,scanF,events]
				],
			scanF[AtomGraph@obj,startingNode,
				AtomGraphEvents[obj,scanF,events]
				]
			]
		]


Options[AtomGraphic]={
	"AtomicRadius"->Automatic,
	"RadiusScaling"->.15
	};
AtomGraphic[obj:chemObjAll,ops:OptionsPattern[]]:=
	With[{
		color=AtomColor@obj,
		position=ChemGet[obj,"Position"],
		radius=
			Replace[
				OptionValue@"AtomicRadius",
				Automatic:>(
					OptionValue@"RadiusScaling"*
						QuantityMagnitude@
							UnitConvert[ChemGet[obj,"Radius"],"Angstroms"]
					)
				]
		},
		If[ListQ@obj,	
			MapThread[
				{#,Disk[#2[[;;2]],#3]}&,{
				color,
				position,
				radius
				}],
			{color,Disk[position[[;;2]],radius]}
			]
		];


Options[AtomGraphic3D]=
	Options[AtomGraphic];
AtomGraphic3D[obj:chemObjAll,ops:OptionsPattern[]]:=
	With[{
		color=AtomColor[obj],
		position=ChemGet[obj,"Position"],
		radius=
			Replace[
				OptionValue@"AtomicRadius",
				Automatic:>(
					OptionValue@"RadiusScaling"*
						QuantityMagnitude@UnitConvert[ChemGet[obj,"Radius"],"Angstroms"]
					)
				]
		},
		If[ListQ@obj,	
			MapThread[
				{#,Sphere[#2,#3]}&,{
				color,
				position,
				Take[Flatten@ConstantArray[radius,Length@obj],
					Length@obj
					]
				}],
			{color,Sphere[position,radius]}
			]
		];



