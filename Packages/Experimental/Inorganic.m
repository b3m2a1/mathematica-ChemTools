(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Subsubsection::Closed:: *)
(*Character Table *)



(*CharacterTable::usage="Storage class for character table data";*)
CharacterTableParse::usage=
	"Parses raw character table data";
CharacterTableData::usage="Looks up char table data";
CharacterTableSymmetryFunctions::usage=
	"Determines the functions that describe the symmetry classes";
CharacterTableSymmetryFunctionsFormatted::usage="";


CharacterTableRepresentationMatrices::usage=
	"Builds representation matrices for a given basis set";
CharacterTableRepresentationMatricesIrreducibleBlocks::usages="";
CharacterTableMatrixIrreducibleRepresentations::usage=
	"Finds the irreducible representations *in an already reduced matrix*";
CharacterTableMatrixIrreducibleRepresentationCharacters::usage="";
CharacterTableIrreducibleRepresentationData::usage="";
CharacterTableDirectProduct::usage="";
CharacterTableGenerate::usage="";


CharacterTableReducibleRepresentationsList::usage=
	"";
CharacterTableReducibleRepresentationsGrid::usage=
	"Formats a grid for the reducible reps";


CharacterTableTotalRepresentation::usage=
	"Computes the total of a representation list";
CharacterTableReduceRepresentation::usage=
	"Reduces a reducible representation in a character table's irreps";


CharacterTableFormatReducedRepresentation::usage=
	"Displays an association of irreps as a sum";


CharacterTableModeRepresentations::usage=
	"Represents the translational, vibrational, and rotational irreps";


CharacterTableFindIrreducibleRepresentation::usage="";


CharacterTableSymmetryAdaptedProjectionList::usage=
	"Applies a SALC-type projection"
CharacterTableSALCs::usage=
	"Generates the symmetry adapted linear combinations of whatever coordinates are supplied";
CharacterTableSALCModes::usage=
	"Turns SALCs into sums";
CharacterTableFormatSALCs::usage=
	"Formats SALCs for readbility";


CharacterTableActiveIrreducibleRepresentations::usage=
	"Extracts the active irreps for a type of spectroscopy";


(* ::Subsubsection::Closed:: *)
(*Vibrational Conversions*)



ChemUtilsVibrationalCoordinates::usage=
	"Determines bend-stretch-wag coordinates for a collection of atoms";
AtomsetVibrationalCoordinates::usage=
	"Determines bend-stretch-wag coordinates for an atomset";
ChemUtilsVibrationalCoordinateGraphics::usage=
	"Generates graphics for the vibrational coordinates";


(* ::Subsubsection::Closed:: *)
(*Vibrational Analysis*)



AtomsetVibrationalAnalysis::usage=
	"A kitchen sink function for vibrational analyses";


(* ::Subsubsection::Closed:: *)
(*ElectronConfiguration*)



ElectronConfiguration::usage=
	"Symbolic wrapper for an electron configuration";
(*ElectronOrbital::usage=
	"Symbolic wrapper for an orbital inside an electron configuration";*)
ElectronConfigurationData::usage=
	"Returns a collection of properties for a configuration";
ElectronConfigurationCrystalField::usage=
	"A wrapper representing a crystal field, changing how the configuration is read";
ElectronConfigurationGraphics::usage=
	"Plots an electron configuration";
ElectronConfigurationEdit::usage=
	"Tweaks an electron configuration";
ElectronConfigurationMoveElectrons::usage=
	"Moves electrons in an electron configuration";
ElectronConfigurationAddElectrons::usage=
	"Adds electrons to a configuration";
ElectronConfigurationEnumerate::usage=
	"";
ElectronConfigurationDeleteEmptyOrbitals::usage=
	"";
ElectronConfigurationCollapseOrbitals::usage=
	"";
ElectronConfigurationValenceConfiguration::usage=
	"Returns the valence electron configuration";
ElectronConfigurationOptimize::usage=
	"Moves electrons to the lowest energy configuration";


(* ::Subsubsection::Closed:: *)
(*TanabeSugano*)



TanabeSuganoData::usage="Extracts the Tanabe-Sugano data for a d-electron count";
TanabeSuganoDiagram::usage="A Tanabe-Sugano diagram for the given d-electron count";
TanabeSuganoDiagramInteractive::usage="An interactive Tanabe-Sugano Diagram";
TanabeSuganoSCCData::usage="Single-configurational coordinate diagram data";
TanabeSuganoSCCDiagram::usage="Single-configurational coordinate diagram";
TanabeSuganoSCCMultiDiagram::usage="Combo diag";
TanabeSuganoSCCDiagramInteractive::usage="Interactive SCC - TS diag";


(* ::Subsubsection::Closed:: *)
(*CorrelationTables*)



CorrelationTableData::usage="";
CorrelationTableFormatted::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*CharacterTableParse*)



(* ::Subsubsection::Closed:: *)
(*URL Import*)



(*normalizeCTName[ct_]:=
	Replace[
		Capitalize@ToLowerCase@
			StringDelete[
				StringJoin@ReplaceAll[ct,Subscript|SubscriptBox\[Rule]List],
				Whitespace
				],
		HoldPattern[Capitalize[s_]]:>
			ToUpperCase[StringTake[s,1]]<>StringDrop[s,1]
		]*)


(*CharacterTableURL[ct_]:=
	Switch[ct,
		"T",
			"http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=900&option=4",
		"Th",
			"http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=901&option=4",
		"O",
			"http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=903&option=4",
		_,
			TemplateApply[
				"http://www.webqc.org/printable-symmetrypointgroup-ct-``.html",
				ToLowerCase@ct
				]
		]*)


(*CharacterTableRawData[ct_String?(StringContainsQ["/"])]:=
	If[StringStartsQ[ct, "http://www.webqc.org/"(*|"http://symmetry.jacobs-university.de"*)], 
		CharacterTableCleanRawData, 
		Identity
		]@
		Map[
			If[StringStartsQ[ct, "http://www.webqc.org/"|"http://symmetry.jacobs-university.de"],
				Map[
					StringDelete[
						StringJoin@
							System`Convert`HTMLImportDump`SymbolicXML2Text@#,
						Except["\n", Whitespace]
						]&,
					ReplaceAll[#[[3]],
						{
							XMLElement["img",{"src"\[Rule]"/pics/epsilon.gif"},{}]\[Rule]"\[CurlyEpsilon]",
							XMLElement["img",{"src"\[Rule]"/pics/sigma.gif"},{}]\[Rule]"\[Sigma]"
							}
						]
					]&,
				Identity
				],
			Cases[
						Import[ct,{"HTML","XMLObject"}],
						XMLElement["table", __],
						\[Infinity]
						][[
				Which[
					StringStartsQ[ct, "http://www.webqc.org/"],
						Sequence@@{2, 3},
					StringStartsQ[ct, "http://symmetry.jacobs-university.de"],
						Sequence@@{2, 3},
					True,
						All
					]
				]]
			];
CharacterTableRawData[ct_]:=
		CharacterTableRawData@CharacterTableURL@ct*)


(*CharacterTableCleanRawData[tdata_]:=
	Module[{
		trueTab=
			ConstantArray[None,
				Length@tdata+
					Length@Select[Rest@tdata, StringContainsQ["\n"][#[[2]]]&]
				],
		rowFillCounter=2,
		splitRow,
		boxLen=Length@tdata[[1]]
		},
		trueTab[[1]]=tdata[[1]];
		Map[
			If[StringContainsQ["\n"][#[[2]]],
				splitRow=StringSplit[#,"\n"]&/@#;
				With[{maxLen=Max@Append[Map[Length,splitRow],0]},
					Do[
						(* populate the final row *)
						trueTab[[rowFillCounter++]]=
							Map[
								(* check how many elements it has *)
								Switch[Length[#],
									maxLen,
										#[[i]],
									1,
										#[[1]]<>ToString[i],
									_,
										Null
									]&,
							Take[PadRight[splitRow, boxLen, ""], boxLen]
							],
						{i, maxLen}
						]
					],
				trueTab[[rowFillCounter++]]=
					PadRight[#, boxLen, ""]
				]&,
			Rest@tdata
			];
		trueTab
		]*)


(*If[!AssociationQ@$CharacterTables, $CharacterTables=<||>];
CharacterTableImport[ct_]:=
	With[{nm=normalizeCTName@ct},
		Lookup[$CharacterTables,nm,
			$CharacterTables[nm]=
				<|
					"PointGroup"\[Rule]nm,
					"SymmetryClasses"\[Rule]#[[1, 2;;Length[#] ]],
					"IrreducibleRepresentations"\[Rule]
						#[[2;;, 1 ]],
					"CharacterTable"->
						Map[Quiet[Check[ToExpression[#],#]]&, #[[2;;, 2;;Length[#] ]]],
					"Others"->
						AssociationThread[
							#[[1, 1+Length[#];; ]],
							Transpose@#[[2;;, 1+Length[#];; ]]
							]
					|>&@CharacterTableRawData@nm
			]
		]*)


(* ::Subsubsection::Closed:: *)
(*PG Ent*)



CharacterTablePointGroupEnt[ct_]:=
	Entity["FiniteGroup",
		{
			"CrystallographicPointGroup", 
			$pointGroupMap@
				normalizeCTName@ct
			}
		]


$CharacterTableKeys=
	{
		"PointGroup",
		"SymmetryClasses",
		"IrreducibleRepresentations",
		"CharacterTable",
		"LinearFunctions",
		"NonLinearFunctions"
		};


$pointGroupEntityMap=
	<|
		"C1"->1,"Ci"->2,"C2"->3,"Cs"->4,"C2h"->5,"D2"->6,"C2v"->7,
		"D2h"->8,"C4"->9,"S4"->10,"C4h"->11,"D4"->12,"C4v"->13,
		"D2d"->14,"D4h"->15,"C3"->16,"S6"->17,"D3"->18,"C3v"->19,
	 "D3d"->20,"C6"->21,"C3h"->22,"C6h"->23,"D6"->24,"C6v"->25,
		"D3h"->26,"D6h"->27,"T"->28,"Th"->29,"O"->30,
		"Td"->31,"Oh"->32,"Ih"->"Icosahedral"
		|>;


(* ::Subsubsection::Closed:: *)
(*CharacterTable Object*)



$charTables=
	{
		"Cs","Ci","C1","C2","C3","C4","C5","C6","C7","C8",
		"D2","D3","D4","D5","D6",
		"C2h","C3h","C4h","C5h","C6h",
		"C2v","C3v","C4v","C5v","C6v","Civ",
		"D2d","D3d","D4d","D5d","D6d",
		"D2h","D3h","D4h","D5h","D6h","D8h","Dih",
		"S4","S6","S8",
		"T","Th","Td",
		"O","Oh",
		"I","Ih",
		"K","Kh"
		};


CharacterTableGrid[data_]:=
	Grid[
		Prepend[
			Prepend[
				data["SymmetryClasses"][[All, "Formatted"]],
				data["PointGroup", "Formatted"]
				]
			]@
		MapThread[
			Prepend,
			{
				data["CharacterTable"],
				data["IrreducibleRepresentations"][[All, "Formatted"]]
				}
			],
		Alignment->Right,
		Dividers->{{2->Black},{2->Black}}
		];


CharacterTable[data_Association][k__]:=
	data[k]
CharacterTable[pg_String]:=
	CharacterTable@$ChemCharacterTables[pg];
CharacterTable/:Normal[CharacterTable[data_Association]]:=
	data;
CharacterTable/:Part[CharacterTable[data_Association], i__]:=
	Replace[{i},{
		{s_String}:>
			CharacterTableData[CharacterTable@data,
				{"IrreducibleRepresentation", s},
				"Vector"
				],
		{s_String, e__}:>
			CharacterTableData[CharacterTable@data,
				{"IrreducibleRepresentation", s},
				"Vector"
				][[e]],
		_:>
			data["CharacterTable"][[i]]
		}];
CharacterTable/:Dataset[CharacterTable[data_Association]]:=
	Dataset@data;


Format[CharacterTable[data_Association]]:=
	RawBoxes@TemplateBox[
		ToBoxes/@{data, CharacterTableGrid[data]},
		"CharacterTable",
		InterpretationFunction:>
			Function[
				RowBox@{"CharacterTable","[",#,"]"}
				],
		DisplayFunction:>
			Function[
				StyleBox[
					RowBox@{
						"CharacterTable",
						"[",
						PanelBox[
							#2,
							Appearance->{
								"Default"->
									FrontEnd`FileName[{"Typeset", "SummaryBox"}, "Panel.9.png"]
								}
							],
						"]"
						},
					ShowStringCharacters->False
					]
				],
		Editable->False,
		Selectable->False
		];


(* ::Subsubsection::Closed:: *)
(*Char Tab Data Import*)



charTabImportExcel[f_]:=
MapThread[
#->
Check[
DeleteCases[{"","",__,__Real?(FractionalPart[#]>0&),___}]@
Rest@SplitBy[#2,MatchQ[{""..}]][[3]],
$Failed
]&,
Rest/@
Import[f,
{"XLS",{"Sheets","Data"}}
]
]//Association;


(*Global`map=charTabImportExcel["~/Downloads/ed300281d_si_001.xls"];*)


(* ::Subsubsection::Closed:: *)
(*CharacterTableParsePointGroup*)



CharacterTableParsePointGroup[pgBase_String]:=
	With[{pg= StringDelete[pgBase, Whitespace]},
		With[{
			pgMain=
				First@
					StringReplace[StringReplace[pg,{"i"->"\[Infinity]", Whitespace->""}],
						t:LetterCharacter~~
						n:(DigitCharacter...|"\[Infinity]")~~
						modifiers___:>
						<|
							"ID"->StringDelete[pg, Whitespace],
							"Type"->t,
							"Order"->
								If[StringLength[n]>0,
									ToExpression[n],
									None
									],
							"Modifier"->modifiers
							|>
						]
				},
			Append[pgMain,
				"Formatted"->
				Style[
					With[{
							t=pgMain["Type"],
							o=pgMain["Order"],
							m=pgMain["Modifier"]
							},
						If[o=!=None||StringLength[m]>0,
							Subscript[t,
								Row@{Replace[o,None:>Sequence@@{}],m}
								],
							t
							]
						],
					ShowStringCharacters->False
					]
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableParseSymmetryClass*)



CharacterTableParseSymmetryClass//Clear


CharacterTableParseSymmetryClass[cl_String]:=
	With[{
			coreData=
				First@
					StringReplace[StringDelete[#, Whitespace],
						{
							StartOfString~~(counts:DigitCharacter...)~~t:Except[DigitCharacter]~~
								n:(DigitCharacter...|"\[Infinity]")~~
									modifiers___~~EndOfString:>
							<|
							"Type"->t,
							"ID"->#,
							"Order"->
								If[StringLength@n>0,
									ToExpression@
										If[StringLength@n>1&&StringTake[n, {-1}]=!="0",
											StringTake[n,{1, -2}],
											n
											],
									1
									],
							"Degree"->
								If[StringLength@n>1&&StringTake[n, {-1}]=!="0",
									ToExpression@StringTake[n,{-1}],
									1
									],
							"Count"->
								If[StringLength@counts>0,
									ToExpression[counts],
									1
									],
							"Orientation"->
								If[StringStartsQ[modifiers, ("h"|"v"|"d")],
									StringTake[modifiers, {1}],
									""
									],
							"Modifier"->
								If[StringMatchQ[modifiers,"(=*"],
									"",
									If[StringStartsQ[modifiers, ("h"|"v"|"d")],
										StringTake[modifiers, {2,-1}],
										modifiers
										]
									]
							|>
							}
						]
			},
		Append[coreData,
			"Formatted"->
				Style[
					Row@{
						coreData["Count"]*
						Replace[
							{
								Replace[coreData["Orientation"],
									""->coreData["Order"]
									],
								coreData["Degree"]
								},
							{
								{1,1}:>coreData["Type"],
								{1,n_}:>Superscript[coreData["Type"],n],
								{n_,1}:>Subscript[coreData["Type"],n],
								{n_,m_}:>Superscript[Subscript[coreData["Type"],n],m]
								}
							],
						coreData["Modifier"]
						},
					ShowStringCharacters->False
					]
			]
		]&@StringDelete[cl, Whitespace];
CharacterTableParseSymmetryClass~SetAttributes~Listable


(* ::Subsubsection::Closed:: *)
(*CharacterTableParseIrreducibleRepresentation*)



CharacterTableParseIrreducibleRepresentation//Clear


iCharacterTableParseIrreducibleRepresentation[ir_String]:=
		With[{
				coreData=
					First@
						StringReplace[#,
							{
								t:Except[DigitCharacter]~~
								index:(DigitCharacter...|"\[Infinity]")~~
								parity:"g"|"u"|""~~
								modifiers___:>
								<|
									"ID"->#,
									"Type"->t,
									"Index"->
									If[StringLength@index>0,
										ToExpression@index,
										0
										],
									"Parity"->parity,
									"Modifier"->modifiers
									|>
								}
							]
				},
			Append[coreData,
				"Formatted"->
					Style[
						Row@{
							Replace[
								{
									coreData["Index"],
									coreData["Parity"]
									},
								{
									{0,""}:>coreData["Type"],
									{0,n_}:>Subscript[coreData["Type"],n],
									{n_,0}:>Subscript[coreData["Type"],n],
									{n_,m_}:>Subscript[coreData["Type"],Row@{n,m}]
									}
								],
							coreData["Modifier"]
							},
						ShowStringCharacters->False,
						StripOnInput->False
						]
				]
			]&@StringDelete[ir, Whitespace];
CharacterTableParseIrreducibleRepresentation[s_String]:=
	Module[
		{
			split=
				StringTrim/@
					StringSplit[
						StringReplace[s, "-"~~k:Except[DigitCharacter]:>"-1"<>k],
						"+"
						]
			},
		split=
			Replace[
				StringSplit[split, 
					StartOfString~~n:NumberString:>ToExpression@n
					],
				{i_}:>{1, i},
				1
				];
		split=
			Replace[split,
				{n_, i_String}:>
					{n, iCharacterTableParseIrreducibleRepresentation[i]},
				1
				];
		If[Length[split]==1&&split[[1,1]]===1,
			split[[1,2]],
			Replace[split, {1, i_}:>i, 1]
			]
		];
CharacterTableParseIrreducibleRepresentation~SetAttributes~Listable


(* ::Subsubsection::Closed:: *)
(*CharacterTableParseTable*)



CharacterTableParseTable[pgData_Association, 
	ct:{__List}, 
	cl_List
	]:=
	Quiet@
		Map[
			Map[
				If[StringQ@#,
					Replace[
						With[{clean=
							FixedPoint[
								StringReplace[{
										"\.bd"->"(1/2)",
										"\[CurlyEpsilon]":>TemplateApply["Exp[2*Pi*I/``]",pgData["Order"]],
										"*"->"\[Conjugate]",
										"cos"~~arg:Except["+"]..:>
											"Cos["<>arg<>"]",
										"\[CapitalPhi]"->"\[FormalCapitalPhi]"
										}],
								#
								]
							},
							Check[
								ToExpression@clean,
								Echo[clean]
								]
							],
						r_?NumberQ:>IntegerPart[r]
						],
					If[NumberQ[#],
						IntegerPart@#,
						#
						]
					]&
				],
			 ct[[2;;, 4;;UpTo[3+Length@ cl]]]
			];


CharacterTableParseLinearFunctions[ct:{__List}, cl_List]:=
	Map[
		DeleteCases[Null]@
		Map[
			Replace[{
				l:{__String}:>
					Quiet[Check[ToExpression[If[Length@l>1,l,l[[1]]]],Print[l]]]
				}]
			]@
		StringSplit[
			StringTrim[
				StringReplace[
					StringReplace[#,{
						"Rx"->"\[FormalCapitalR][\[FormalX]]",
						"Ry"->"\[FormalCapitalR][\[FormalY]]",
						"Rz"->"\[FormalCapitalR][\[FormalZ]]",
						"x"->" \[FormalX]",
						"y"->" \[FormalY]",
						"z"->" \[FormalZ]"
						}],{
					e:Except[WhitespaceCharacter|"+"|"("]~~"2":>e<>"^2"
					}],
				((Whitespace|"")~~("("|")")~~(Whitespace|""))
				],
			","
			]&
		]@
	StringCases[
		Map[
			If[Length[#]>3+Length@ cl,
				#[[3+Length@ cl+1]],
				""
				]&,
			Rest@ct
			],
		s:Shortest[("("~~__~~")")|(__~~(","|EndOfString))]:>
			StringTrim[s,","]
		]


CharacterTableParseNonlinearFunctions[ct:{__List}, cl_List]:=
	Map[
		DeleteCases[Null]@
		Map[
			Replace[{
				l:{__}:>
					Quiet[Check[ToExpression[If[Length@l>1,l,l[[1]]]],Print[l]]]
				}]
			]@
		StringSplit[
			StringTrim[
				StringReplace[
					StringReplace[#,{
						"Rx"->"\[FormalCapitalR][\[FormalX]]",
						"Ry"->"\[FormalCapitalR][\[FormalY]]",
						"Rz"->"\[FormalCapitalR][\[FormalZ]]",
						"x"->" \[FormalX]",
						"y"->" \[FormalY]",
						"z"->" \[FormalZ]"
						}],{
					e:Except[WhitespaceCharacter|"+"|"("]~~"2":>e<>"^2"
					}],
				((Whitespace|"")~~("("|")")~~(Whitespace|""))
				],
			","
			]&
		]@
	StringCases[
		Map[
			If[Length[#]>3+Length@cl+1,
				#[[3+Length@cl+2]],
				""
				]&,
			Rest@ct
			],
		s:Shortest[("("~~__~~")")|(__~~(","|EndOfString))]:>
			StringTrim[s,","]
		]


CharacterTableImportExcel[ds_Association]:=
	Map[
		Check[
			With[{
				ct=#,
				pg=#[[1,3]],
				pgData=CharacterTableParsePointGroup[#[[1,3]]],
				cl=
					TakeWhile[#[[1,4;;]],
						#=!=""&
						],
				ir=
					With[{i=#[[2;;, 3 ]]},
						ReplacePart[i,
							Map[
								#[[1]]->i[[#[[1]]-1]]&,
								Position[i,""]
								]
							]
						]
				},
				<|
				"PointGroup"->
					pgData,
				"SymmetryClasses"->
					CharacterTableParseSymmetryClass[cl],
				"IrreducibleRepresentations"->
					CharacterTableParseIrreducibleRepresentation[ir],
				"CharacterTable"->
					CharacterTableParseTable[pgData, ct, cl],
				"LinearFunctions"->
					CharacterTableLinearFunctions[ct, cl],
				"NonLinearFunctions"->
					CharacterTableNonlinearFunctions[ct, cl]
					|>
				],
			<||>
			]&,
		ds
		];


(*Global`ctabs=charTabExcelClean[Global`map];*)


(* ::Subsubsection::Closed:: *)
(*CharacterTableParse*)



$CharacterTableParseObjects=
	<|
		"PointGroup"->
			CharacterTableParsePointGroup,
		"SymmetryClass"->
			CharacterTableParseSymmetryClass,
		"IrreducibleRepresentation"->
			CharacterTableParseIrreducibleRepresentation,
		"Table"->
			CharacterTableParseTable,
		"LinearFunctions"->
			CharacterTableParseLinearFunctions,
		"NonlinearFunctions"->
			CharacterTableParseNonlinearFunctions
		|>


CharacterTableParse//Clear


CharacterTableParse[k_?(KeyMemberQ[$CharacterTableParseObjects,#]&), "Function"]:=
	$CharacterTableParseObjects[k];
CharacterTableParse[k_?(KeyMemberQ[$CharacterTableParseObjects,#]&), a__]:=
	With[{f=$CharacterTableParseObjects[k]},
		With[{r=f[a]},
			r/;Head[r]=!=f
			]
		];
CharacterTableParse[k_?(KeyMemberQ[$CharacterTableParseObjects,#]&)][a__]:=
	CharacterTableParse[k, a]


CharacterTableParse~
	PackageAddAutocompletions~
	{Keys[$CharacterTableParseObjects], {"Function"}}


(* ::Subsection:: *)
(*Character Table Data*)



(* ::Subsubsection::Closed:: *)
(*CharacterTableData*)



CharacterTableData[ct_String]:=
	CharacterTable[ct];
CharacterTableData[ct_CharacterTable]:=
	ct;
CharacterTableData[ct:_String|_CharacterTable,
	prop:Alternatives@@$CharacterTableKeys
	]:=
	CharacterTableData[ct][prop];
CharacterTableData[ct:_String|_CharacterTable,
	{"IrreducibleRepresentation"|"IR", irrep:_String|_Integer}
	]:=
	With[{coredata=CharacterTableData[ct]},
		With[{irpos=
			Switch[irrep,
				_Integer,
					irrep,
				_String,
					FirstPosition[
						coredata["IrreducibleRepresentations"][[All, "ID"]], 
						irrep,
						$Failed
						][[1]],
				_,
					$Failed
				]
			},
			<|
				"PointGroup"->coredata["PointGroup"],
				"Data"->
					coredata["IrreducibleRepresentations"][[irpos]],
				"Vector"->
					coredata["CharacterTable"][[irpos]],
				"LinearFunctions"->
					coredata["LinearFunctions"][[irpos]],
				"NonLinearFunctions"->
					coredata["NonLinearFunctions"][[irpos]]
				|>/;Length[coredata["IrreducibleRepresentations"]]>=irpos
			]
		];
CharacterTableData[ct:_String|_CharacterTable,
	{"SymmetryClass"|"SC", sc:_String|_Integer}
	]:=
	With[{coredata=CharacterTableData[ct]},
		With[{scpos=
			Switch[sc,
				_Integer,
					sc,
				_String,
					FirstPosition[
						coredata["SymmetryClasses"][[All, "ID"]], 
						sc,
						$Failed
						][[1]],
				_,
					$Failed
				]
			},
			<|
				"PointGroup"->
					coredata["PointGroup"],
				"Data"->
					coredata["SymmetryClasses"][[scpos]],
				"Vector"->
					coredata["CharacterTable"][[scpos]]
				|>/;Length[coredata["SymmetryClasses"]]>=scpos
			]
		];


$CharacterTableThingProps=
	{
		"PointGroup",
		"Vector",
		"SymmetryClass",
		"IrreducibleRepresentation",
		"Data",
		"LinearFunctions",
		"NonLinearFunctions"
		};
CharacterTableData[ct:_String|_CharacterTable,
	{p:"IrreducibleRepresentation"|"IR"|"SymmetryClass"|"SC", thing:_String|_Integer},
	prop:Alternatives@@$CharacterTableThingProps|
		{Alternatives@@$CharacterTableThingProps,__String}
	]:=
	With[{base=CharacterTableData[ct, {p, thing}]},
		base@@Flatten[{prop}]/;AssociationQ@base
		]


PackageAddAutocompletions["CharacterTableData",
	{
		$charTables, 
		Join[$CharacterTableKeys, 
			{"SymmetryClass", "IrreducibleRepresentation"}
			],
		$CharacterTableThingProps
		}
	]


(* ::Subsubsection::Closed:: *)
(*CharacterTableFindIrreducibleRepresentation*)



CharacterTableFindIrreducibleRepresentation[
	ct_,
	key_->crit_
	]:=
	Pick[
		CharacterTableData[ct,"IrreducibleRepresentations"],
		crit/@
			CharacterTableData[ct, key]
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableActiveIrreducibleRepresentations*)



CharacterTableActiveIrreducibleRepresentations[ct_, "Infrared"]:=
	CharacterTableFindIrreducibleRepresentation[
		ct,
		"LinearFunctions"->Function@MemberQ[#,\[FormalX]|\[FormalY]|\[FormalZ],2]
		]


CharacterTableActiveIrreducibleRepresentations[ct_, "Raman"]:=
	CharacterTableFindIrreducibleRepresentation[
		ct,
		"NonLinearFunctions"->Function[Length[Flatten[#]]>0]
		]


CharacterTableActiveIrreducibleRepresentations[ct_, "Microwave"]:=
	CharacterTableFindIrreducibleRepresentation[
		ct,
		"LinearFunctions"->Function@MemberQ[#, \[FormalCapitalR][\[FormalX]]|\[FormalCapitalR][\[FormalY]]|\[FormalCapitalR][\[FormalZ]], 2]
		]


PackageAddAutocompletions[
	CharacterTableActiveIrreducibleRepresentations,
	{None, {"Infrared", "Raman", "Microwave"}}
	]


(* ::Subsection:: *)
(*Vibrational Coordinates*)



(* ::Subsubsection::Closed:: *)
(*Determining Coordinates*)



(* ::Text:: *)
(*The idea here is to take a number of atoms, index them, and rewrite the positions as either 2-tuples (stretch), 3-tuples (bend), or 4-tuples (wag)

These are simply a vector, angle, and dihedral angle, similar to what may be supplied to a z-matrix

The primary thing that needs to be determined is what the stretches should be.  Angles and dihedrals will be determined relative to the components of the stretches.

There should be one fewer stretch, bend, and wag coordinate, than atoms, as there will always be an implicitly fixed atom. This leads to 3n-3 coordinates. Degeneracy of coordinates should then be checked.*)



ravelUnwraveledIndex[n_, len_]:=
	{ Floor[(n-1)/len], Mod[n, len] };


(*deleteDegenerateStretches[str_]:=
	;*)


(* ::Text:: *)
(*To delete degenerate bends, we take our collection of bends, b = {{a11, a12, a13}, {a21, a22, a23}, ...} and remove any {ai1, ai2, ai3} such that  there is some {aj1, aj2, aj3} where aj2 = ai2 and either aj1 = ai1 or an3 = ai3 and {ai1, ai2, aj3} or {aj1, ai2, ai3} is in b*)



deleteDegenerateBends[bends_]:=
	DeleteDuplicates[bends,
		MatchQ[#, {#2[[1]], #2[[2]], _}|{_, #2[[2]], #2[[3]]}]&&
			MemberQ[bends, {#2[[1]], #2[[2]], #[[3]]}|{#[[1]], #2[[2]], #2[[3]]}]&
		];


(* ::Text:: *)
(*To delete degenerate wags, we simply delete by the wagging coordinate*)



deleteDegenerateWags[wags_]:=
	DeleteDuplicatesBy[wags, First];


ChemUtilsVibrationalCoordinates//Clear


ChemUtilsVibrationalCoordinates[
	atoms:{__},
	bonds:{{_,_}...}:{}
	]:=
	Module[
		{
			requiredCoordinates=
				3*Length[atoms]-3,
			atomNum=Length[atoms],
			stretches=
				Take[
					Sort@DeleteDuplicates[Sort/@bonds],
					UpTo[Length[atoms]]
					],
			stretchGraph,
			center,
			bends,
			wags
			},
		(* The stretching coordinates should always be provided by the bonds *)
		(*If[Length@stretches<atomNum,
			stretches=
				Take[
					Join[
						stretches,
						DeleteCases[
							Subsets[atoms,{2}]
							(*Inefficient, sure, but this whole system isn't built for anything big enough to crush this*), 
							Alternatives@@stretches
							]
						],
					atomNum
					]
			];*)
		stretchGraph=Graph[UndirectedEdge@@@stretches];
		center=VertexList[stretchGraph][[Last@Ordering@VertexDegree@stretchGraph]];
		bends=
			Join@@
				Map[
					Insert[#,2]/@
						Subsets[
							Rest@
								VertexOutComponent[stretchGraph, #, 1],
							{2}
							]&,
					VertexList[stretchGraph]
					];
		bends=
			deleteDegenerateBends@
				If[Length[bends]>0&&ListQ@bends[[1, 1]],
					SortBy[bends, #[[1]]-#[[2]]==-(#[[3]]-#[[2]])&],
					bends
					];
		(*wags=
			Join@@
				Map[
					Prepend[#]/@
						Subsets[
							Rest@
								VertexOutComponent[stretchGraph, #, 1],
							{3}
							]&,
					VertexList[stretchGraph]
					];
		wags=deleteDegenerateWags@wags;*)
		<|
			"Center"->center,
			"Stretches"->stretches,
			"Bends"->bends(*,
			"Wags"->wags*)
			|>
		];


vibrationalCoordinateKeys=
	"Coordinates"|"CoordinatesIndexed"|"Values";


ChemUtilsVibrationalCoordinates[
	atoms:{{_,_,_}..},
	bonds:{{_,_}...}:{},
	return:vibrationalCoordinateKeys|All|{vibrationalCoordinateKeys..}:All
	]:=
	Module[
		{
			order=
				Ordering@
					With[{center=Mean[atoms]},
						Norm[#-center]&/@atoms
						],
			sortedAts,
			orderMap,
			coords,
			coordsTrue,
			doKeys=
				Replace[Flatten@List@return, 
					{All}->
						 {"Coordinates", "CoordinatesIndexed", "Values"}
					 ]
			},
		sortedAts=
			atoms[[order]];
		orderMap=
			MapIndexed[
				#2[[1]]->#&,
				order
				];
		coordsTrue=
			ChemUtilsVibrationalCoordinates[
				sortedAts,
				Map[atoms[[#]]&,
					SortBy[bonds, Map[Position[order, #]&]]
					]
				];
		coords=
			coordsTrue/.
				MapThread[
					Rule,
					{
						sortedAts,
						order
						}
					];
			<|
				If[MemberQ[doKeys, "CoordinatesIndexed"],
					"CoordinatesIndexed"->
						coords,
					Sequence@@{}
					],
				If[MemberQ[doKeys, "Coordinates"],
					"Coordinates"->
						(coords/.MapIndexed[#2[[1]]->#&, atoms]),
					Sequence@@{}
					],
				If[MemberQ[doKeys, "Values"],
					"Values"->
						<|
							"Stretches"->
								Map[
									ChemUtilsVibrationalCoordinateFunction["Stretches"]@
										atoms[[#]]&,
									coords["Stretches"]
									],
							"Bends"->
								Map[
									ChemUtilsVibrationalCoordinateFunction["Bends"]@
										atoms[[#]]&,
									coords["Bends"]
									](*,
							"Wags"->
								Map[
									ChemUtilsVibrationalCoordinateFunction["Wags"]@
										atoms[[#]]&,
									coords["Wags"]
									]*)
							|>,
					Sequence@@{}
					]
				|>
			]


AtomsetVibrationalCoordinates//Clear


AtomsetVibrationalCoordinates[
	as:ChemObjPattern,
	return:vibrationalCoordinateKeys|All|"Functions"|
		{(vibrationalCoordinateKeys|"Functions")..}:All
	]:=
	With[{ats=ChemGet[as, "Atoms"]},
		ChemUtilsVibrationalCoordinates[
				ChemGet[ChemGet[as, "Atoms"], "Position"],
				AtomsetBondsIndexed[as][[All,;;2]],
				return
				]
		]


(* ::Subsubsection::Closed:: *)
(*Coordinate Functions*)



ChemUtilsVibrationalCoordinateFunction["Stretches", {pt1_, pt2_}]:=
	pt2-pt1;
ChemUtilsVibrationalCoordinateFunction["Stretches"][{pt1_, pt2_}]:=
	ChemUtilsVibrationalCoordinateFunction["Stretches", {pt1, pt2}];
ChemUtilsVibrationalCoordinateFunction["Bends", {pt1_, pt2_, pt3_}]:=
	VectorAngle[pt1-pt2, pt3-pt2];
ChemUtilsVibrationalCoordinateFunction["Bends"][{pt1_, pt2_, pt3_}]:=
	ChemUtilsVibrationalCoordinateFunction["Bends", {pt1, pt2, pt3}];
ChemUtilsVibrationalCoordinateFunction["Wags", {pt1_, pt2_, pt3_, pt4_}]:=
	Projection[
		pt1,
		Cross[pt3-pt2, pt4-pt2]
		];
ChemUtilsVibrationalCoordinateFunction["Wags"][{pt1_, pt2_, pt3_, pt4_}]:=
	ChemUtilsVibrationalCoordinateFunction["Wags", {pt1, pt2, pt3, pt4}];


(* ::Subsubsection::Closed:: *)
(*Coordinate Visualizations*)



(* ::Text:: *)
(*Pulled from here: https://mathematica.stackexchange.com/a/10958/38205*)



ClearAll[sjoerdSplineCircle];
sjoerdSplineCircle[m_List,r_,angles_List: {0,2 \[Pi]}]:=
	Module[{seg,\[Phi],start,end,pts,w,k},
		{start,end}=Mod[angles//N,2 \[Pi]];
If[end<=start,end+=2 \[Pi]];
seg=Quotient[end-start//N,\[Pi]/2];
\[Phi]=Mod[end-start//N,\[Pi]/2];
If[seg==4,seg=3;\[Phi]=\[Pi]/2];
pts=
			r RotationMatrix[start].#&/@
				Join[
					Take[{{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}}, 2 seg+1],
					RotationMatrix[seg \[Pi]/2].#&/@{{1,Tan[\[Phi]/2]},{Cos[\[Phi]],Sin[\[Phi]]}}];
If[Length[m]==2,
			pts=m+#&/@pts,
			pts=m+#&/@Transpose[Append[Transpose[pts],ConstantArray[0,Length[pts]]]]
			];
w=Join[Take[{1,1/Sqrt[2],1,1/Sqrt[2],1,1/Sqrt[2],1},2 seg+1],{Cos[\[Phi]/2],1}];
k=Join[{0,0,0},Riffle[#,#]&@Range[seg+1],{seg+1}];
BSplineCurve[pts,SplineDegree->2,SplineKnots->k,SplineWeights->w]
		]/;Length[m]==2||Length[m]==3


Options[sjoerdCircleFromPoints] = {arc -> False};

sjoerdCircleFromPoints[m : {q1_, q2_, q3_}, OptionsPattern[]] :=
Module[{
		c, r, \[Phi]1, \[Phi]2, p1, p2, p3, h, 
    rot =
    	With[{crs=Normalize[Cross[#1 - #2, #3 - #2]]},
	    	Which[
	    		Abs[crs]=={0,0,1},
		    		IdentityMatrix[3],
	    		crs=={0,0,-1},
	    			-IdentityMatrix[3],
	    		True,
	    			RotationMatrix[{{0, 0, 1}, crs}]
	    		]
				] &},
  {p1, p2, p3} = {q1, q2, q3}.rot[q1, q2, q3];
  h = p1[[3]];
  {p1, p2, p3} = {p1, p2, p3}[[All, ;; 2]];
  {c, r} = List @@ Circumsphere[{p1, p2, p3}];
  \[Phi]1 = ArcTan @@ (p3 - c);
  \[Phi]2 = ArcTan @@ (p1 - c);
  c = Append[c, h];
  If[OptionValue[arc] // TrueQ,
    MapAt[Function[{p}, rot[q1, q2, q3].p] /@ # &, sjoerdSplineCircle[c, r, {\[Phi]1, \[Phi]2}], {1}],
    MapAt[Function[{p}, rot[q1, q2, q3].p] /@ # &, sjoerdSplineCircle[c, r], {1}]
  ]
] /; MatrixQ[m, NumericQ] && Dimensions[m] == {3, 3}


ChemUtilsVibrationalCoordinateGraphicsObject//Clear


ChemUtilsVibrationalCoordinateGraphicsObject[
	"Stretches",
	i_Integer,
	{p1_List, p2_List},
	scaling_:1
	]:=
	{
		Red,
		Text[
			Subscript["r", i], 
			Mean@{p1, p2}
			],
		Black,
		If[scaling>=0, Nothing,
		 	Arrowheads[
				{{.02,0},{-.02,1}},
				Appearance->"Projected"
				]
			],
		Arrow[
			Map[Mean[{p2, p1}]+#&,
				(scaling/2)*{
					(p1-p2), (p2-p1)
					}
				]
			]
		};
ChemUtilsVibrationalCoordinateGraphicsObject[
	"Bends",
	i_Integer,
	{p1:{Repeated[_?NumericQ,{3}]}, p2_, p3_},
	scaling_:1
	]:=
	{
		Text[
			Subscript["\[Theta]", i], 
			Mean@{
				.5*Normalize[p1-p2], 
				.5*Normalize[p3-p2]
				}+p2
			],
		Red,
		Line[{p2, .5*Normalize[p1-p2]+p2}],
		Line[{p2, .5*Normalize[p3-p2]+p2}],
		If[scaling>=0, Nothing,
		 	Arrowheads[
				{{.02,0},{-.02,1}},
				Appearance->"Projected"
				]
			],
		Arrow@
		sjoerdCircleFromPoints[
			{
				.25*Normalize[p1-p2]+p2, 
				.25*Normalize[Mean[{p1-p2, p3-p2}]]+p2,
				.25*Normalize[p3-p2]+p2
				},
			arc->True
			]
		};
ChemUtilsVibrationalCoordinateGraphicsObject[
	k_,
	l:{{__List}..}
	]:=
	MapIndexed[
		ChemUtilsVibrationalCoordinateGraphicsObject[k, #2[[1]], #]&, 
		l
		]


ChemUtilsVibrationalCoordinateGraphics//Clear


ChemUtilsVibrationalCoordinateGraphics[
	crds_Association,
	show_:("Stretches"|"Bends")
	]:=
	{
		Arrowheads[
			{{-.02,0},{.02,1}},
			Appearance->"Projected"
			],
		If[MatchQ[show, _Plus],
			List@@show/.{
				HoldPattern@Times[s_, \[FormalR][i_]]:>
					ChemUtilsVibrationalCoordinateGraphicsObject["Stretches",
							i,
							crds["Coordinates", "Stretches"][[i]],
							s
							],
				HoldPattern@\[FormalR][i_]:>
					ChemUtilsVibrationalCoordinateGraphicsObject["Stretches",
							i,
							crds["Coordinates", "Stretches"][[i]]
							],
				HoldPattern@Times[s_, \[FormalTheta][i_]]:>
					ChemUtilsVibrationalCoordinateGraphicsObject["Bends",
							i,
							crds["Coordinates", "Bends"][[i]],
							s
							],
				HoldPattern@\[FormalTheta][i_]:>
					ChemUtilsVibrationalCoordinateGraphicsObject["Bends",
							i,
							crds["Coordinates", "Bends"][[i]]
							]
				},
			KeyValueMap[
				Switch[#,
					show,
						ChemUtilsVibrationalCoordinateGraphicsObject[#,
							#2
							],
					_,
						Sequence@@{}
					]&,
				crds["Coordinates"]
				]
			]
		};


(* ::Subsection:: *)
(*Representations*)



(* ::Subsubsection::Closed:: *)
(*CharacterTableSymmetryFunctions*)



CharacterTableSymmetryFunctions[ct_, sops_]:=
	Module[{
		rots=sops["Elements","RotationAxes"],
		rotClassOrder=
			Apply[Join,
				Association@
					Thread[
						sops["Elements","RotationAxes"][[#]]->Length[#]
						]&/@
					sops["Classes", "RotationAxes"]
				],
		rotClasses=
			Apply[Join,
				Association@
					With[{
						fns=Lookup[sops["Functions","RotationAxes"],#],
						idx=sops["Elements","RotationAxes"][[#]]
						},
						Map[#->fns&,idx]
					]&/@
					sops["Classes", "RotationAxes"]
				],
		rotClassesElements=
			Apply[Join,
				Association@
					With[{
						idx=sops["Elements","RotationAxes"][[#]]
						},
						Map[#->idx&,idx]
					]&/@
					sops["Classes", "RotationAxes"]
				],
		planes=sops["Elements", "SymmetryPlanes"],
		planeClassOrder=
			Apply[Join,
				Association@
					Thread[
						sops["Elements","SymmetryPlanes"][[#]]->Length[#]
						]&/@
					sops["Classes", "SymmetryPlanes"]
				],
		planeClasses=
			Apply[Join,
				Association@
					With[{
						fns=Lookup[sops["Functions","SymmetryPlanes"],#],
						idx=sops["Elements","SymmetryPlanes"][[#]]
						},
						Map[#->fns&,idx]
					]&/@
					sops["Classes", "SymmetryPlanes"]
				],
		planeClassesElements=
			Apply[Join,
				Association@
					With[{
						idx=sops["Elements","SymmetryPlanes"][[#]]
						},
						Map[#->idx&,idx]
					]&/@
					sops["Classes", "SymmetryPlanes"]
				],
		screws=sops["Elements", "ScrewAxes"],
		screwClassOrder=
			Apply[Join,
				Association@
					Thread[
						sops["Elements","ScrewAxes"][[#]]->Length[#]
						]&/@
					sops["Classes", "ScrewAxes"]
				],
		screwClasses=
			Apply[Join,
				Association@
					With[{
						fns=Lookup[sops["Functions","ScrewAxes"],#],
						idx=sops["Elements","ScrewAxes"][[#]]
						},
						Map[#->fns&,idx]
					]&/@
				sops["Classes", "ScrewAxes"]
				],
		screwClassesElements=
			Apply[Join,
				Association@
					With[{
						idx=sops["Elements","ScrewAxes"][[#]]
						},
						Map[#->idx&,idx]
					]&/@
					sops["Classes", "ScrewAxes"]
				],
		center=sops["Elements", "Center"],
		elemListing=
			<|
				"RotationAxes"->{},
				"SymmetryPlanes"->{},
				"ScrewAxes"->{}
				|>,
		primaryAxis,
		secondaryAxis,
		ind,
		cur
		},
		rots=
			First/@SortBy[MapIndexed[#->First@#2&, rots],
				Last@FirstPosition[sops["Classes", "RotationAxes"], #[[2]]]&
				];
		planes=
			First/@SortBy[MapIndexed[#->First@#2&, planes],
				Last@FirstPosition[sops["Classes", "SymmetryPlanes"], #[[2]]]&
				];
		screws=
			First/@SortBy[MapIndexed[#->First@#2&, screws],
				Last@FirstPosition[sops["Classes", "ScrewAxes"], #[[2]]]&
				];
		primaryAxis=
			Normalize[
				MaximalBy[
					MaximalBy[rots, First][[All, 2]],
					#[[3]]&
					][[1]]-center
				];
		secondaryAxis=
			SelectFirst[
				Map[#-center&, SortBy[rots, First][[All,2]]],
				.4<(Mod[VectorAngle[#, primaryAxis], \[Pi]]/\[Pi])<.6&
				];
		If[!ListQ@secondaryAxis,
			secondaryAxis=
				SelectFirst[
					Map[
						Cross[#[[1]]-center, #[[2]]-center]&,
						planes
						],
					.1<(Mod[VectorAngle[#, primaryAxis], \[Pi]]/\[Pi])<.9&
					];
			If[!ListQ@secondaryAxis,
				secondaryAxis=
					SelectFirst[
						Map[#-center&, SortBy[rots, First][[All,2]]],
						.1<(Mod[VectorAngle[#, primaryAxis], \[Pi]]/\[Pi])<.9&
						];
				If[!ListQ@secondaryAxis,
					secondaryAxis=
						Cross[primaryAxis, {1, 0, 0}];
					If[Norm[secondaryAxis]<.1, 
						secondaryAxis=
							Cross[primaryAxis, {0, 1, 0}]
						]
					],
				secondaryAxis-=Projection[secondaryAxis, primaryAxis]
				]
			];
		secondaryAxis=Normalize[secondaryAxis];
		AssociationMap[
			Switch[#["Type"],
				"E",
					<|
						"Functions"->{ScalingTransform[{1, 1, 1}, center]},
						"Element"->None
						|>,
				"i",
					<|
						"Functions"->{ScalingTransform[{-1, -1, -1}, center]},
						"Element"->center
						|>,
				"C",
						ind=
							With[{c=#["Count"]},
								FirstPosition[
									rots,
									{
										#["Order"]*#["Degree"], 
										Which[
											StringContainsQ[#["Modifier"],"x"],
												{_?(Abs[#]>.001&), __?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"y"],
												{_?(Abs[#]<.001&),_?(Abs[#]>.001&),_?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"z"],
												{__?(Abs[#]<.001&),_?(Abs[#]>.001&)},
											True,
												_
											]
										}?(rotClassOrder[#]===c&), 
									{$Failed}
									][[1]]
								];
						If[ind===$Failed,
							Replace[
								FirstCase[
									With[{c=#["Count"]},
										Reverse@
											SortBy[sops["Elements", "RotationAxes"], 
												Abs[#["Order"]-c]&
												]
										],
									{
										o_/;Mod[o, #["Order"]*#["Degree"] ]==0,
										Which[
											StringContainsQ[#["Modifier"],"x"],
												{_?(Abs[#]>.001&), __?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"y"],
												{_?(Abs[#]<.001&),_?(Abs[#]>.001&),_?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"z"],
												{__?(Abs[#]<.001&),_?(Abs[#]>.001&)},
											True,
												_
											]
										}, 
									$Failed
									],
								r:{_,_}:>
									With[{els=rotClassesElements@r},
										If[els[[1,1]]==#["Order"]*#["Degree"],
											<|
												"Functions"->rotClasses[els[[1]]],
												"Element"->els
												|>,
											With[{o=#["Order"], d=#["Degree"]},
												<|
													"Functions"->
														Map[
																RotationTransform[
																	2.\[Pi]/(o*d),
																	#[[2]],
																	center
																	]&, 
																els
																],
													"Element"->
														Map[{o, #[[2]]}&, els]
													|>
												]
											]
										]
								],
							cur=
								<|
									"Functions"->rotClasses[rots[[ind]]],
									"Element"->First@rotClassesElements@rots[[ind]]
									|>;
							rots=DeleteCases[rots,Alternatives@@rotClassesElements@rots[[ind]]];
							cur
							],
				"\[Sigma]",
						Switch[{#["Orientation"], #["Modifier"]},
							{_, _?(StringContainsQ["xy"])},
								ind=
									With[{c=#["Count"]},
										FirstPosition[
											planes,
											{Repeated[{_,_,_?(Abs[#]<.0001&)}, {2}]}?(planeClassOrder[#]===c&),
											{1}
											][[1]]
										],
							{_, _?(StringContainsQ["xz"])},
								ind=
									With[{c=#["Count"]},
										FirstPosition[
											planes,	
											{Repeated[{_,_?(Abs[#]<.0001&),_}, {2}]}?(planeClassOrder[#]===c&),
											{1}
											][[1]]
										],
							{_, _?(StringContainsQ["yz"])},
								ind=
									With[{c=#["Count"]},
										FirstPosition[
											planes,
											{Repeated[{_?(Abs[#]<.0001&),_,_}, {2}]}?(planeClassOrder[#]===c&),
											{1}
											][[1]]
										],
							{"h", _},
								ind=
									With[{c=#["Count"]},
										FirstPosition[
											planes,
											{pt1:{_,_,_}, pt2_}/;(
												planeClassOrder[{pt1, pt2}]===c&&
												With[{
													n=Norm[primaryAxis],
													v=Cross[pt1-center, pt2-center]
													},
													Abs[primaryAxis.v/(n*Norm[v])]
													]/2.\[Pi]
												)>.8,
											{1}
											][[1]]
										],
							_,
								ind=
									FirstPosition[
										With[{c=#["Count"]},
											Select[planes, planeClassOrder[#]===c&]
											],	
										{{_,_,_}, _},
										{1}
										][[1]]
							];
						cur=
							<|
								"Functions"->planeClasses[planes[[ind]]],
								"Element"->First@planeClassesElements@planes[[ind]]
								|>;
						planes=DeleteCases[planes,Alternatives@@planeClassesElements@planes[[ind]]];
						cur,
				"S",
					ind=
						With[{c=#["Count"]},
							FirstPosition[
								screws,
								{
									#["Order"]*#["Degree"], 
									Which[
										StringContainsQ[#["Modifier"],"x"],
											{_?(Abs[#]>.001&), __?(Abs[#]<.001&)},
										StringContainsQ[#["Modifier"],"y"],
											{_?(Abs[#]<.001&),_?(Abs[#]>.001&),_?(Abs[#]<.001&)},
										StringContainsQ[#["Modifier"],"z"],
											{__?(Abs[#]<.001&),_?(Abs[#]>.001&)},
										True,
											_
										]
									}?(screwClassOrder[#]===c&), 
								{$Failed}
								][[1]]
							];
						If[ind===$Failed,
							Replace[
								FirstCase[Reverse@SortBy[sops["Elements", "ScrewAxes"], #["Order"]],
									{
										o_/;Mod[o, #["Order"]*#["Degree"] ]==0,
										Which[
											StringContainsQ[#["Modifier"],"x"],
												{_?(Abs[#]>.001&), __?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"y"],
												{_?(Abs[#]<.001&),_?(Abs[#]>.001&),_?(Abs[#]<.001&)},
											StringContainsQ[#["Modifier"],"z"],
												{__?(Abs[#]<.001&),_?(Abs[#]>.001&)},
											True,
												_
											]
										}, 
									$Failed
									],
								r:{_,_}:>
									With[{els=screwClassesElements@r},
										If[els[[1,1]]==#["Order"]*#["Degree"],
											<|
												"Functions"->screwClasses[els[[1]]],
												"Element"->els
												|>,
											With[{o=#["Order"], d=#["Degree"]},
												<|
													"Functions"->
														Map[
															Simplify@Composition[
																RotationTransform[
																	2.\[Pi]/(o*d),
																	#[[2]],
																	center
																	],
																ReflectionTransform[
																	#[[2]],
																	center
																	]
																]&, els],
													"Element"->
														Map[{o, #[[2]]}&, els]
													|>
												]
											]
										]
								],
							cur=
								<|
									"Functions"->screwClasses[screws[[ind]]],
									"Element"->First@screwClassesElements@screws[[ind]]
									|>;
							screws=DeleteCases[screws, Alternatives@@screwClassesElements@screws[[ind]]];
							cur
							]
				]&,
			ct["SymmetryClasses"]
			]//Prepend[
						#,
						"SourceElements"->
							<|
								"Center"->sops["Elements", "Center"], 
								"PrincipalAxes"->
									{
										secondaryAxis,
										Normalize@Cross[primaryAxis, secondaryAxis],
										primaryAxis
										}
								|>
						]& 
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableSymmetryFunctionsFormatted*)



CharacterTableSymmetryFunctionsFormatted[symFs_]:=
	Dataset@
		Map[Replace[{{l_}:>l, l_List:>MatrixForm[l]}]]@
		KeyMap[Key["Formatted"]]@
		KeyDrop[symFs, {"SourceElements"}]


(* ::Subsubsection::Closed:: *)
(*charTabRepLinearSolve*)



charTabRepLinearSolve[mx_,
	b_,
	pick_,
	i_
	]:=
	Which[
		b==mx[[i]],
			ReplacePart[ConstantArray[0,Length[mx]], i->1],
		AnyTrue[mx, Norm[b-#]<.05&],
			Normalize[Boole[Norm[b-#]<.05]&/@mx],
		AnyTrue[mx, Norm[b+#]<.05&],
			Normalize[-Boole[Norm[b+#]<.05]&/@mx],
		True,
			ReplacePart[
				ConstantArray[0, Length[mx]],
				Thread[
					Position[pick, True][[All, 1]]->
						Quiet@
							Check[
								LinearSolve[Transpose@Pick[mx, pick], b],
								LeastSquares[Transpose@Pick[mx, pick], b]
								]
					]
				]
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableRepresentationMatrices*)



$charTableDOrbitalRep=
	{
		<|
			"Points"->{{1,0,0}, {0, 1, 0},{-1, 0, 0}, {0, -1, 0}},
			"Direction"->Apply[Cross[#,#2]&]
			|>,(* dx2-y2 *)
		<|
			"Points"->{{0,0,1}, {1,1,0},{0,0,-1}},
			(*I'm making this multi-dimensional to dinstinguish it from a p-oribtal*)
			"Direction"->Function[{1,1,Abs[#[[1,3]]]}]
			|> (* dz2 *),
		<|
			"Points"->{{1,1,0}, {1,- 1, 0},{-1,-1,0}, {-1, 1, 0}},
			"Direction"->Apply[Cross[#,#2]&]
			|> (* dxy *),
		<|
			"Points"->{{1,0,1}, {1,0, -1},{-1,0,-1}, {-1,0, 1}},
			"Direction"->Apply[Cross[#,#2]&]
			|> (* dxz *),
		<|
			"Points"->{{0,1,1}, {0,1, -1},{0,-1,-1}, {0,-1, 1}},
			"Direction"->Apply[Cross[#,#2]&]
			|> (* dyz *)
		};
$charTablePOrbitalRep=
	Map[
		<|
			"Points"->{#},
			"Direction"->First
			|>&,
		IdentityMatrix[3]
		];


CharacterTableRepresentationMatrix[
	fn_,
	center_,
	sourceElement_,
	coords_
	]:=
	With[
		{
			axisAlign=
				FirstCase[Lookup[coords, "AxisAlign", None],
					_List,
					None
					],
			shift=
				TrueQ@
					FirstCase[Lookup[coords, "CenterShift", False],
						True|False,
						False
						],
			pts=
				MapThread[
					Replace[#, 
						Except[_List]:>
							#2["Points"]
						]&,
					{
						Lookup[coords, "TestPoints"],
						coords
						}
					],
			dirs=
				Lookup[coords, "Direction"]
			},
		With[
			{
				newPts=
					If[ListQ@axisAlign,
						charTableAxisSysToElementTransform[
							center, 
							axisAlign, 
							sourceElement
							][If[shift, Map[#+center&, pts], pts]],
						If[shift, Map[#+center&, pts], pts]
						]
				},
			With[
				{
					oldDirs=
						MapThread[
							#2@#&,
							{
								newPts,
								dirs
								}
							],
					newDirs=
						MapThread[
							#2@Map[fn, #]&,
							{
								newPts,
								dirs
								}
							],
					dimensions=
						Length/@newPts
					},
			MapIndexed[
				With[{d=dimensions[[ #2[[1]] ]], i=#2[[1]]},
					charTabRepLinearSolve[
						oldDirs,
						#,
						MatchQ[d]/@dimensions,
						i
						]
					]&,
				newDirs
				]
			]
		]
	];


CharacterTableRepresentationMatrices[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:charTableRepListCoordVecPat
	]:=
	Map[
		CharacterTableRepresentationMatrix[
			#["Functions"][[1]],
			mapping["SourceElements", "Center"],
			#["Element"],
			coords
			]&,
		KeyDrop[mapping, {"SourceElements"}]
		]


CharacterTableRepresentationMatrices[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	"POrbitals"
	]:=
	CharacterTableRepresentationMatrices[
		mapping,
		Map[
			Join[
				<|
					"AxisAlign"->{0,0,1},
					"CenterShift"->True
					|>,
				#
				]&,
			$charTablePOrbitalRep
			]
		];
CharacterTableRepresentationMatrices[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	"DOrbitals"
	]:=
	CharacterTableRepresentationMatrices[
		mapping,
		Map[
			Join[
				<|
					"AxisAlign"->{0,0,1},
					"CenterShift"->True
					|>,
				#
				]&,
			$charTableDOrbitalRep
			]
		];


(* ::Subsubsection::Closed:: *)
(*CharacterTableRepresentationMatricesIrreducibleBlocks*)



CharacterTableRepresentationMatricesIrreducibleBlocks[mxes_]:=
	ConnectedComponents@*WeightedAdjacencyGraph@*ReplaceAll[0->\[Infinity]]/@mxes//
		Flatten[#, 1]&//SortBy[Length]//Reverse//
			DeleteDuplicatesBy[First]//DeleteDuplicatesBy[Last]//SortBy[First]


(* ::Subsubsection::Closed:: *)
(*CharacterTableMatrixIrreducibleRepresentations*)



(* ::Text:: *)
(*We\[CloseCurlyQuote]ll do this via a Graph because it just makes life easy*)



CharacterTableMatrixIrreducibleRepresentations//Clear


CharacterTableMatrixIrreducibleRepresentations[mxes:{__List}]:=
	With[
		{
			blocks=
				CharacterTableRepresentationMatricesIrreducibleBlocks[mxes]
				},
		Table[
			Map[mx[[#, #]]&, blocks],
			{mx, mxes}
			]
		];
CharacterTableMatrixIrreducibleRepresentations[els_Association]:=
	AssociationThread[
		Keys[els],
		CharacterTableMatrixIrreducibleRepresentations[Values[els]]
		]


CharacterTableMatrixIrreducibleRepresentationCharacters[els_Association]:=
	Map[Tr]/@CharacterTableMatrixIrreducibleRepresentations[els]


(* ::Subsubsection::Closed:: *)
(*CharacterTableIrreducibleRepresentationData*)



characterTableFormatIrrep[base_]:=
	With[
		{
			assoc=
				Join[
					<|
						"Parity"->"",
						"Modifier"->"",
						"Index"->""
						|>,
					base
					]
				},
		Join[
			<|
				"ID"->assoc["Type"]<>ToString@assoc["Index"]<>assoc["Parity"]<>assoc["Modifier"]
				|>,
			assoc,
			<|
				"Formatted"->
						Style[
								Row@{
									Replace[
										{
											assoc["Index"],
											assoc["Parity"]
											},
										{
											{0,""}:>assoc["Type"],
											{0,n_}:>Subscript[assoc["Type"],n],
											{n_,0}:>Subscript[assoc["Type"],n],
											{n_,m_}:>Subscript[assoc["Type"],Row@{n,m}]
											}
										],
									assoc["Modifier"]
									},
								ShowStringCharacters->False,
								StripOnInput->False
								]
				|>
			]
		]


CharacterTableIrreducibleRepresentationData[
	dim_,
	symClasses_,
	chars_
	]:=
	With[
		{
			principleAxis=
				First@
					MaximalBy[Select[symClasses, #["Type"]=="C"&], #["Order"]&]
			},
		Reap[
			"Type"->"A"//Sow;
			MapThread[	
				Function[
					If[#==principleAxis,
						Which[#2==1, "Type"->"A"//Sow, #2==-1, "Type"->"B"//Sow]
						];
					If[
						(#["Type"]=="C"&&#["Order"]==2&&#["Modifier"]!="")||
							(#["Type"]=="\[Sigma]"&&#["Modifier"]=="d"),
						Which[
							#2==1,
								"Index"->1//Sow,
							#2==-1,
								"Index"->2//Sow
							]
						];
					If[#["Type"]=="i",
						Which[
							#2==1,
								"Parity"->"g"//Sow,
							#2==-1,
								"Parity"->"u"//Sow
							]
						];
					If[(#["Type"]=="\[Sigma]"&&#["Modifier"]=="h"),
						Which[
							#2==1,
								"Modifier"->"'"//Sow,
							#2==-1,
								"Modifier"->"''"//Sow
							]
						]
					],
				{
					symClasses,
					Sign@chars
					}
				];
			Switch[dim,
				2,
					"Type"->"E"//Sow,
				3,
					"Type"->"T"//Sow,
				4,
					"Type"->"G"//Sow,
				5,
					"Type"->"H"//Sow
				]
			][[2]]//Flatten//Association//characterTableFormatIrrep
		]


(* ::Subsubsection::Closed:: *)
(*characterTableIrrepOrdering*)



characterTableIrrepOrdering[irreps_]:=
	Ordering[
		Switch[#["Type"],
			"A",
				0,
			"B",
				10,
			"E",
				20,
			"T",
				30,
			_,	
				0
			]+
		Switch[#["Index"],
			1,
				0,
			2,
				1,
			_,	
				0
			]+
		Switch[#["Parity"],
			"g",
				0,
			"u",
				100,
			_,	
				0
			]+
		Switch[#["Modifier"],
			"'",
				0,
			"''",
				1000,
			_,	
				0
			]&/@irreps
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableGenerate*)



CharacterTableGenerate[mxes_Association]:=
	Module[
		{
			reps=CharacterTableMatrixIrreducibleRepresentations@mxes,
			symClasses,
			chars,
			irreps,
			order
			},
		symClasses=Keys[reps];
		chars=Transpose@Map[Map@Tr]@Values@reps;
		irreps=
			MapThread[
				CharacterTableIrreducibleRepresentationData[
					#,
					symClasses,
					#2
					]&,
				{
					#[[All, 1]],
					#[[All, 2]]
					}&@
				DeleteDuplicatesBy[
					Thread@
						{
							Length/@reps[[1]],
							chars
							},
					Last
					]
				];
		order=characterTableIrrepOrdering@irreps;
		CharacterTable@
			<|
					"PointGroup"-><|"Formatted"->"??"|>,
					"CharacterTable"->DeleteDuplicates[chars][[order]],
					"SymmetryClasses"->symClasses,
					"IrreducibleRepresentations"->irreps[[order]]
					|>
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableReducibleRepresentationsList*)



(* ::Text:: *)
(*
Need a method to handle the problem of building a representation for a collection of coordinates, P,
with a collection of symmetry elements, S

We just need a matrix that represents S... 
i.e. find some A such that A.P = S(P) where S(P) = ( S(p1), S(p2), S(p3), ...), where S(p1) is represented as a coefficient vector in P
*)



CharacterTableReducibleRepresentationsList//Clear


charTableRepListCoordVecPat=
	{KeyValuePattern[{
		"Points"|"TestPoints"->_List,
		"Direction"->_
		}]..};
charTableRepListCoordPat=
	{{_?NumericQ,_,_}..}|Automatic;


charTableAxisSysToElementTransform//Clear


charTableAxisSysToElementTransform[
	center_,
	ax:{_?NumericQ, _, _},
	{n_Integer, l_List}
	]:=
	With[{v1=l-center, a=ax},
		If[Abs[Normalize[v1].a]>.9,
			Identity,
			RotationTransform[{v1, a}]
			]
		];
charTableAxisSysToElementTransform[
	center_,
	{ax1:{_, _, _}, ax2:{_, _, _}},
	{n_Integer, l_List}
	]:=
	With[
		{
			t1=
				charTableAxisSysToElementTransform[center, ax1, l]
			},
		t1
		];
charTableAxisSysToElementTransform[
	center_,
	ax:{_?NumericQ, _, _},
	{pt1_List, pt2_List}
	]:=
	With[{v1=Cross[pt1-center, pt2-center], a=ax},
		If[Abs[Normalize[v1].a]>.9,
			Identity,
			RotationTransform[{v1, a}]
			]
		];
charTableAxisSysToElementTransform[
	center_,
	{ax1:{_, _, _}, ax2:{_, _, _}},
	l:{pt1_List, pt2_List}
	]:=
	With[
		{
			t1=
				charTableAxisSysToElementTransform[center, ax1, l]
			},
		Simplify@Composition[
			Quiet@Check[
				RotationTransform[{
					t1@ax2, 
					pt1
					}],
				RotationTransform[{
					t1@ax2, 
					pt2
					}]
				],
			t1
			]
		];
charTableAxisSysToElementTransform[
	center_,
	ax1:{_?NumericQ, _, _},
	l:{pt1_List, pt2_List, pt3_List}
	]:=
	With[{v1=pt3, a=ax1},
		If[Abs[Normalize[v1].a]>.9,
			Identity,
			RotationTransform[{v1, a}]
			]
		];
charTableAxisSysToElementTransform[
	center_,
	{ ax1:{_?NumericQ, _, _}, ax2:{_?NumericQ, _, _}},
	l:{pt1_List, pt2_List, pt3_List}
	]:=
	With[
		{
			t1=
				charTableAxisSysToElementTransform[center, ax1, l]
			},
		Simplify@
			Composition[
				RotationTransform[{
					t1@ax2, 
					pt2
					}],
				t1
				]
		];
charTableAxisSysToElementTransform[
	center_,
	{ ax1:{_?NumericQ, _, _}, ax2:{_?NumericQ, _, _}, ax3:{_?NumericQ, _, _}},
	l:{pt1_List, pt2_List, pt3_List}
	]:=
	With[
		{
			t1=
				charTableAxisSysToElementTransform[center, {ax1, ax2}, l]
			},
		Simplify@
			Composition[
				RotationTransform[{
					t1@ax3, 
					pt1
					}],
				t1
				]
		];
charTableAxisSysToElementTransform[___]:=Identity


charTableRepCharacter[
	center_,
	corePt_, 
	testPts_,
	dirF_,
	op_
	]:=
	With[
		{
			oldpt=corePt,
			olddir=dirF@testPts,
			newpt=op[corePt],
			newdir=dirF[op/@testPts],
			cutOff=.1*Norm[corePt-center]
			},
			Which[
				(* Point moved *)
				Not[
					And@@
						MapThread[
							#2-cutOff<=#<=#2+cutOff&,
							{newpt,oldpt}
							]
					],
					0,
				(* Norm is 0 so we can't project *)
				Norm[newdir]*Norm[olddir]==0,
					If[Norm[newdir]+Norm[olddir]<.1,
						1,
						0
						],
				True,
					newdir.olddir/(Norm[newdir]*Norm[olddir])
				]
		]


CharacterTableReducibleRepresentationsList[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coordsAndVecs:charTableRepListCoordVecPat
	]:=
	GroupBy[First->Last]@Flatten@
		MapIndexed[
			With[
				{
					primax=
						mapping["SourceElements", "PrincipalAxes"],
					anc=
						Lookup[#, "AnchorPoint",
							Mean@#["Points"]
							],
					test=
						Lookup[#, "TestPoints",
							#["Points"]
							], 
					i=#2[[1]],
					dir=#["Direction"],
					axisAlign=Lookup[#, "AxisAlign", None],
					shift=Lookup[#, "CenterShift", False],
					center=mapping["SourceElements", "Center"]
					},
					Lookup[#, "Label", anc]->
						Table[
							With[
								{
									testTrue=
										If[ListQ@axisAlign,
											charTableAxisSysToElementTransform[
												center, 
												primax, 
												m["Element"]
												][If[TrueQ@shift, Map[#+center&, test], test]],
											If[TrueQ@shift, Map[#+center&, test], test]
											]
									},
								charTableRepCharacter[
									center,
									anc,
									testTrue,
									dir,
									m["Functions"][[1]]
									]
								],
							{m, Values@KeyDrop[mapping, {"SourceElements"}]}
							]
				]&,
			coordsAndVecs
			];


charTableCoordPat={({_?NumericQ, _, _}|{{_?NumericQ, _, _}..})..};


CharacterTableReducibleRepresentationsList[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:{{_,_,_}..},
	Optional["Cartesian", "Cartesian"]
	]:=
	CharacterTableReducibleRepresentationsList[
		mapping,
		Flatten@Table[
			Map[
				<|
					"AnchorPoint"->c,
					"TestPoints"->{#},
					"Direction"->First,
					"AxisAlign"->{{0,0,1}, {0, 1, 0}},
					"CenterShift"->True
					|>&,
				IdentityMatrix[3]
				],
			{c, coords}
			]
		];
CharacterTableReducibleRepresentationsList[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:{{_,_,_}..},
	"POrbitals"
	]:=
	CharacterTableReducibleRepresentationsList[
		mapping,
		Flatten@Table[
			Map[
				<|
					"AnchorPoint"->c,
					"TestPoints"->#["Points"],
					"Direction"->#["Direction"],
					"AxisAlign"->{0,0,1},
					"CenterShift"->True
					|>&,
				$charTablePOrbitalRep
				],
			{c, coords}
			]
		];
CharacterTableReducibleRepresentationsList[
	mapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:{{_,_,_}..},
	"DOrbitals"
	]:=
	CharacterTableReducibleRepresentationsList[
		mapping,
		Flatten@Table[
			Map[
				<|
					"AnchorPoint"->c,
					"TestPoints"->#["Points"],
					"Direction"->#["Direction"],
					"AxisAlign"->{0,0,1},
					"CenterShift"->True
					|>&,
				$charTableDOrbitalRep
				],
			{c, coords}
			]
		];
CharacterTableReducibleRepresentationsList[
	ct_, 
	sops_Association?(KeyMemberQ["Elements"]),
	coords:{{_,_,_}..},
	which:"Cartesian"|"POrbitals"|"DOrbitals":"Cartesian"
	]:=
	CharacterTableReducibleRepresentationsList[
		CharacterTableSymmetryFunctions[ct, sops],
		coords,
		which
		];
CharacterTableReducibleRepresentationsList[
	ct_, 
	sops_Association?(KeyMemberQ["Elements"]),
	coordsAndVecs:charTableRepListCoordVecPat
	]:=
	CharacterTableReducibleRepresentationsList[
		CharacterTableSymmetryFunctions[ct, sops],
		coordsAndVecs
		];
CharacterTableReducibleRepresentationsList[
	args__,
	coords_Association?(KeyMemberQ["Coordinates"]),
	which:("Stretches"|"Bends"|{("Stretches"|"Bends")..}):
		{"Stretches", "Bends"}
	]:=
	With[{
		bleh=
			Join@@
				MapThread[
					With[{type=#2},
						Map[
							<|
								"AnchorPoint"->Mean[#],
								"TestPoints"->#,
								"Direction"->ChemUtilsVibrationalCoordinateFunction[type]
								|>&,
							#
							]
						]&,
					{
						Lookup[coords["Coordinates"], Flatten@List@which],
						Flatten@List@which
						}
					]
			},
		If[Length@bleh>0,
			CharacterTableReducibleRepresentationsList[args,bleh],
			{}
			]
		];


(* ::Subsubsection::Closed:: *)
(*CharacterTableReducibleRepresentationsGrid*)



CharacterTableReducibleRepresentationsGrid//Clear


charTableLabListPat=
	{(Except[_List|_Association]|{Except[_?NumericQ]..})..}


charTableDefaultLabels={{"x","y","z"}};


CharacterTableReducibleRepresentationsGrid[
	ct_,
	gamma_Association?(AllTrue[ListQ]@*Keys),
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	With[{grid=
		Panel@
			With[{
				core=
					MapIndexed[
						With[
							{
								l=#, 
								num=ToString@First@#2,
								labs=labels[[Mod[#2[[1]], Length[labels], 1]]]
								},
							MapThread[
								Prepend[#,
									If[StringQ@#2, Subscript[#2,num], #2]
									]&,
								{
									l,
									Take[
										Flatten@ConstantArray[labs, Length@l],
										Length@l
										]
									}]
							]&,
						Values@KeyDrop[gamma, Key@{"Grid"}]
						]
				},
				Style[
					Grid[
						Prepend[
							Flatten[core,1],
							Prepend[ct["SymmetryClasses"][[All,"Formatted"]], ""]
							]
						],
					ShowStringCharacters->False
					]
				]
		},
	Interpretation[
		grid,
		Append[gamma, {"Grid"}->grid]
		]
	];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coordAndVecs:charTableRepListCoordVecPat,
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			fmapping,
			coordAndVecs
			],
		labels
		];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords:{{Repeated[_?NumericQ, {3}]}..},
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			fmapping,
			coords
			],
		labels
		];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	symOps_Association?(KeyMemberQ["Elements"]),
	coordAndVecs:charTableRepListCoordVecPat,
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			CharacterTableSymmetryFunctions[ct, symOps],
			coordAndVecs
			],
		labels
		];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	symOps_Association?(KeyMemberQ["Elements"]),
	coords:{{___?NumericQ}..},
	labels:charTableLabListPat:charTableDefaultLabels
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			CharacterTableSymmetryFunctions[ct, symOps],
			coords
			],
		labels
		];
CharacterTableReducibleRepresentationsGrid[
	ct_,
	a___,
	coords_Association?(KeyMemberQ["Coordinates"]),
	which:("Stretches"|"Bends"|{("Stretches"|"Bends")..}):
		{"Stretches", "Bends"},
	labels:charTableLabListPat:{{"r","\[Theta]","\[CurlyPhi]"}}
	]:=
	CharacterTableReducibleRepresentationsGrid[
		ct,
		CharacterTableReducibleRepresentationsList[
			a,
			coords,
			which
			],
		labels
		];


(* ::Subsubsection::Closed:: *)
(*CharacterTableTotalRepresentation*)



CharacterTableTotalRepresentation//Clear


CharacterTableTotalRepresentation[
	gamma_Association
	]:=
	Round[Transpose[Join@@Values[gamma]]//Map[Total]];
CharacterTableTotalRepresentation[
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coordVecs:charTableRepListCoordVecPat
	]:=
	With[{r=CharacterTableReducibleRepresentationsList[fmapping, coordVecs]},
		If[Length@r>0,
			CharacterTableTotalRepresentation@r,
			{}
			]
		];
CharacterTableTotalRepresentation[
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords_List
	]:=
	CharacterTableTotalRepresentation@
		CharacterTableReducibleRepresentationsList[fmapping, coords];
CharacterTableTotalRepresentation[
	a__,
	coords_Association?(KeyMemberQ["Coordinates"]),
	which:("Stretches"|"Bends"|{("Stretches"|"Bends")..}):
		{"Stretches", "Bends"}
	]:=
	CharacterTableTotalRepresentation@
		CharacterTableReducibleRepresentationsList[a, coords, which];
CharacterTableTotalRepresentation[
	ct_,
	symOps_Association?(KeyMemberQ["Elements"]),
	b__
	]:=
	CharacterTableTotalRepresentation[
		CharacterTableSymmetryFunctions[ct, symOps],
		b
		];


(* ::Subsubsection::Closed:: *)
(*CharacterTableReduceRepresentation*)



CharacterTableReduceRepresentation//Clear


CharacterTableReduceRepresentationCoefficients[
	ctRows_List,
	symmClassCounts_,
	red_
	]:=
	(1/Total[symmClassCounts])*
		Map[
			Total@
				MapThread[
					Times,
					{
						symmClassCounts,
						red,
						#
						}
					]&,
			ctRows
			];


CharacterTableReduceRepresentation[
	characterRows_List,
	symmClassCounts_List,
	rep:{__Integer}
	]:=
	CharacterTableReduceRepresentationCoefficients[
		characterRows,
		symmClassCounts,
		rep
		];
CharacterTableReduceRepresentation[ct_CharacterTable, rep:{__Integer}]:=
	With[
		{
			characterRows=
				CharacterTableData[ct, "CharacterTable"],
			symmClassCounts=
				Lookup[CharacterTableData[ct, "SymmetryClasses"], "Count"],
			irreps=
				CharacterTableData[ct,"IrreducibleRepresentations"]
			},
		AssociationThread[
			irreps,
			CharacterTableReduceRepresentationCoefficients[
				characterRows,
				symmClassCounts,
				rep
				]
			]
		];
CharacterTableReduceRepresentation[ct_CharacterTable, {}]:={};
CharacterTableReduceRepresentation[s_String, rep:{___Integer}]:=
	CharacterTableReduceRepresentation[CharacterTableData[s], rep];
CharacterTableReduceRepresentation[ct_][rep:{___Integer}]:=
	CharacterTableReduceRepresentation[ct, rep];


(* ::Subsubsection::Closed:: *)
(*CharacterTableDirectProduct*)



CharacterTableDirectProduct[ct_, irs:{ir1_, irs2__}]:=
	With[{
		reps=
			Map[
				CharacterTableData[ct, {"IrreducibleRepresentation",#}, "Vector"]&,
				irs
				]},
		Times@@reps//CharacterTableReduceRepresentation[ct]
		]


(* ::Subsubsection::Closed:: *)
(*CharacterTableModeRepresentations*)



CharacterTableModeRepresentations[
	ct_,
	totalNuclearRep_Association
	]:=
	Module[
		{
			translations,
			rotations,
			vibrations
			},
		translations=
			Counts[
				Join@@
					Map[
						Pick[
							Keys@totalNuclearRep, 
							MemberQ[#]/@
								CharacterTableData[ct,"LinearFunctions"]
							]&,
						Join[
							{\[FormalX], \[FormalY], \[FormalZ]},
							Subsets[{\[FormalX], \[FormalY], \[FormalZ]}, {2, 3}]
							]
					]
				];
		rotations=
			Counts[
				Join@@
					Map[
						Pick[
							Keys@totalNuclearRep, 
							MemberQ[#]/@
								CharacterTableData[ct,"LinearFunctions"]
							]&,
						Join[
							{\[FormalCapitalR][\[FormalX]], \[FormalCapitalR][\[FormalY]], \[FormalCapitalR][\[FormalZ]]},
							Subsets[{\[FormalCapitalR][\[FormalX]], \[FormalCapitalR][\[FormalY]], \[FormalCapitalR][\[FormalZ]]}, {2,3}]
							]
					]
				];
		vibrations=
			Association@
				KeyValueMap[
					#->
						(#2 - ( Lookup[translations, #, 0] + Lookup[rotations, #, 0] ))&,
					totalNuclearRep
					];
		<|
			"Translations"->	
				translations,
			"Rotations"->
				rotations,
			"Vibrations"->
				vibrations
			|>
		];
CharacterTableModeRepresentations[
	ct_,
	redRep:{__Integer}
	]:=
	CharacterTableModeRepresentations[ct,
		CharacterTableReduceRepresentation[
			ct,
			redRep
			]
		];
CharacterTableModeRepresentations[
	ct_,
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coords_List
	]:=
	CharacterTableModeRepresentations[ct,
		CharacterTableReduceRepresentation[
			ct,
			CharacterTableTotalRepresentation[
				fmapping,
				coords
				]
			]
		];
CharacterTableModeRepresentations[
	ct_,
	fmapping_Association?(Not@*KeyMemberQ["Elements"]),
	coordVecs:charTableRepListCoordVecPat
	]:=
	CharacterTableModeRepresentations[ct,
		CharacterTableReduceRepresentation[
			ct,
			CharacterTableTotalRepresentation[
				fmapping,
				coordVecs
				]
			]
		];


(* ::Subsection:: *)
(*SALCs*)



(* ::Subsubsection::Closed:: *)
(*SymmetryAdaptedProjection*)



charTabIrrepDims=
	<|
		"A"->1,
		"B"->1,
		"E"->2,
		"T"->3
		|>;


CharacterTableSymmetryAdaptedProjectionList//Clear


$CharacterTableSALCRounding=.1


CharacterTableSymmetryAdaptedProjectionList[
	center_,
	symmetryFunctions_List,
	irrepRow_List,
	irrepDim_Integer,
	vec:{Repeated[_?NumericQ,{3}]},
	coords:{Repeated[{Repeated[_?NumericQ,{3}]},{1,\[Infinity]}]}
	]:=
	MapThread[
		If[ListQ@#,
			Sequence@@(#2*Through[#@(vec)]),
			#2*(#[vec])
			]&,
		{
			Take[symmetryFunctions, UpTo[Length[irrepRow]]],
			irrepRow
			}
		];


CharacterTableSymmetryAdaptedProjectionList[
	ct_CharacterTable,
	repsToTry:_String|{__String}|All,
	sMapping_Association,
	vec:{Repeated[_?NumericQ,{3}]},
	coords:{Repeated[{Repeated[_?NumericQ,{3}]},{1,\[Infinity]}]}
	]:=
	With[
		{
			irrepPos=
				If[repsToTry===All,
					All,
					Position[
						CharacterTableData[ct, "IrreducibleRepresentations"],
						_Association?(StringMatchQ[Alternatives@@Flatten@{repsToTry}]@*Key["ID"]),
						{1}
						][[All,1]]
					],
			irreps=
				CharacterTableData[ct, "IrreducibleRepresentations"],
			cTab=
				CharacterTableData[ct, "CharacterTable"],
			symmetryFunctions=
				Flatten@Lookup[
					Lookup[
						sMapping,
						CharacterTableData[ct, "SymmetryClasses"]
						],
					"Functions"
					]
			},
		MapThread[
			CharacterTableSymmetryAdaptedProjectionList[
				sMapping["SourceElements", "Center"],
				symmetryFunctions,
				#2,
				charTabIrrepDims[#["Type"]],
				vec,
				coords
				]&,
			{
				irreps[[irrepPos]],
				cTab[[irrepPos]]
				}
			]
		];
CharacterTableSymmetryAdaptedProjectionList[
	ct_CharacterTable,
	repsToTry:_String|{__String}|All,
	sMapping_Association,
	coords:{
		Repeated[{Repeated[_?NumericQ,{3}]},{1,\[Infinity]}]
		}
	]:=
	Map[
		CharacterTableSymmetryAdaptedProjectionList[
			ct,
			repsToTry,
			sMapping,
			#,
			coords
			]&,
		coords
		]


(* ::Subsubsection::Closed:: *)
(*SALCs*)



charTableSalcCoordsPat=
	{(_->{_,_,_})..};


salcsCommonReplacements=
	ReplaceAll@
		Table[
			With[{r=r},
				num_?(NumericQ[#]&&FractionalPart[#/r]<.0001&):>
					IntegerPart[num/r]*r
				],
			{
				r,
					1/DeleteCases[Map[Sqrt, Range[100]], _Integer]
				}
			]


CharacterTableSALCs//Clear


CharacterTableSALCs[
	ct_CharacterTable,
	repsToTry:_String|{__String}|All:All,
	sMapping_Association,
	testCoords:({{_,_,_}..}|Automatic):Automatic,
	coords:charTableSalcCoordsPat
	]:=
	With[
		{
			irreps=
				Map[
					CharacterTableSymmetryAdaptedProjectionList[
						ct,
						repsToTry,
						sMapping,
						#,
						coords[[All,2]]
						]&,
					Replace[testCoords,
						Automatic:>coords[[All,2]]
						]
					]//Transpose,
			coordSys=	
				coords[[All,2]],
			coordVars=
				coords[[All,1]]
			},
		Association@
			MapThread[
				#2->
					Replace[{i_}:>i]@
					Map[
						Dot[coordVars, #]&,
						DeleteDuplicates[
							MapIndexed[
								salcsCommonReplacements@
								Rationalize@
								Normalize@
								Round[
									Total@
										With[{lists=#, ind=#2[[1]]},
											Map[
												charTabRepLinearSolve[
													coordSys,
													#,
													ConstantArray[True, Length[coordSys]],
													ind
													]&,
												lists
												]
											],
									.001
									]&,
								#
								],
							#==-#2||#==#2&
							]
						]&,
				{
					irreps,
					If[repsToTry===All,
						CharacterTableData[ct, "IrreducibleRepresentations"],
						Select[
							CharacterTableData[ct, "IrreducibleRepresentations"],
							StringMatchQ[Alternatives@@Flatten@{repsToTry}]@*Key["ID"]
							]
						]
					}
				]
		];
CharacterTableSALCs[
	ct_CharacterTable,
	repsToTry:_String|{__String}|All:All,
	sMapping_Association,
	coords_Association?(KeyMemberQ["Coordinates"]),
	which:("Stretches"|"Bends"|{("Stretches"|"Bends")..}):
		{"Stretches", "Bends"}
	]:=
	DeleteCases[None]@
		AssociationMap[
			With[{crds=
				With[{type=Switch[#, "Stretches", \[FormalR], "Bends", \[FormalTheta], "Wags", \[FormalCurlyPhi]]},
						MapIndexed[
							type[#2[[1]]]->#&,
							Mean/@coords["Coordinates", #]
							]
						]
				},
				If[Length@crds>0,
					CharacterTableSALCs[
						ct,
						repsToTry,
						sMapping,
						crds
						],
					None
					]
				]&,
			DeleteDuplicates@Flatten@{which}
			]


(* ::Subsubsection::Closed:: *)
(*SALCModes*)



CharacterTableSALCModes[salcs_]:=
	AssociationThread[
		If[KeyMemberQ[salcs, "Stretches"],
			Keys@salcs["Stretches"],
			Keys@salcs
			],
		If[KeyMemberQ[salcs, "Stretches"],
			Plus@@@Transpose@Values@
				Map[
					Map[Replace[{l_,___}:>l]]@*Values,
					salcs
					],
			Map[
				Replace[{l_,___}:>l],
				Values@salcs
				]
			]
		]


(* ::Subsection:: *)
(*VMA*)



AtomsetVibrationalAnalysis//Clear


Options[AtomsetVibrationalAnalysis]=
	Join[
		{
			"VibrationalCoordinates"->Automatic,
			"ModeBreakdown"->True,
			"VibrationalBreakdown"->True,
			"SALCs"->True
			},
		Options[AtomsetSymmetryElements]
		];
AtomsetVibrationalAnalysis[as_,
	elFmt:_List?(Not@*OptionQ)|_Blank:_,
	ops:OptionsPattern[]
	]:=
	Module[
		{
			symEls=
				AtomsetSymmetryElements[as, 
					elFmt, 
					FilterRules[{ops}, Options@AtomsetSymmetryElements]
					],
			pg,
			ct,
			symFs,
			vibCrds,
			cartRepList,
			totalRep,
			totalRepModes,
			vibRepList,
			vibRep,
			salcs
			},
		pg=ChemUtilsPointGroup[symEls];
		ct=CharacterTableData[pg];
		symFs=
			CharacterTableSymmetryFunctions[ct, symEls];
		vibCrds=
			AtomsetVibrationalCoordinates[as, {"Coordinates"}];
		cartRepList=
			CharacterTableReducibleRepresentationsList[
					symFs, 
					ChemGet[ChemGet[as,"Atoms"], "Position"]
					];
		totalRep=
			CharacterTableTotalRepresentation[cartRepList];
		totalRepModes=
			CharacterTableModeRepresentations[ct,
				CharacterTableReduceRepresentation[ct, totalRep]
				];
		vibRepList=
			AssociationMap[
				CharacterTableReducibleRepresentationsList[
					symFs, vibCrds, #
					]&,
				{"Stretches", "Bends"}
				];
		vibRep=
			AssociationMap[
				CharacterTableReduceRepresentation[ct,
					CharacterTableTotalRepresentation[vibRepList[#]]
					]&,
				{"Stretches", "Bends"}
				];
		If[AnyTrue[vibRep["Bends"], Not@*IntegerQ],
			vibRep["Bends"]=
				Association@
					KeyValueMap[
						#->
							(#2-Lookup[vibRep["Stretches"], #, 0])&,
						totalRepModes["Vibrations"]
						]
			];
		vibRepList=
			AssociationMap[
				Map[
					CharacterTableReduceRepresentation[ct, Total[#]]&,
					vibRepList[#]
					]&,
				{"Stretches", "Bends"}
				];
		salcs=CharacterTableSALCs[ct, symFs, vibCrds];
		<|
			"PointGroup"->pg,
			"SymmetryElements"->symEls,
			"CharacterTable"->ct,
			"CharacterTableFunctions"->symFs,
			"VibrationalCoordinates"->vibCrds,
			"ReducibleRepresentations"->cartRepList,
			"TotalReducibleRepresentation"->totalRep,
			"ModeIrreducibleRepresentations"->totalRepModes,
			"VibrationalRepresentations"->vibRepList,
			"VibrationalIrreducibleRepresentations"->vibRep,
			"SALCs"->salcs,
			"SALCModes"->CharacterTableSALCModes[salcs]
			|>
		]


(* ::Subsection:: *)
(*Electron Configurations*)



(* ::Subsubsection::Closed:: *)
(*validOrbitalConfiguration*)



electronConfigOrbitalPat=
	(_ElectronOrbital|_ElectronCrystalFieldOrbital|_ElectronMolecularOrbital)?
		validOrbitalConfiguration


validOrbitalConfiguration//Clear


validOrbitalConfiguration[
	ElectronOrbital[KeyValuePattern[{"Type"->_, "Count"->_, "Level"->_}]]
	]:=
	True;
validOrbitalConfiguration[
	ElectronCrystalFieldOrbital[
		KeyValuePattern[{
			"Type"->_, "Count"->_, "Level"->_,
			"FieldType"->_, "FieldStrength"->_
			}]
		]
	]:=
	True;
validOrbitalConfiguration[
	ElectronMolecularOrbital[
		KeyValuePattern[{
			"Type"->_, "Count"->_, "Level"->_,
			"BondingOrbital"->_
			}]
		]
	]:=
	True
validOrbitalConfiguration[___]:=
	False


(* ::Subsubsection::Closed:: *)
(*ParseOrbitalConfiguration*)



iParseOrbitalConfigurationExplicit//Clear


(*
	Prep data to look like term[level, count, field]
	*)
iParseOrbitalConfigurationExplicit[s_]:=
	StringReplace[
		s,
		term:Except[WhitespaceCharacter]..
			~~"["~~n:Except[","]..~~
			","~~count:Except[","]..~~
			","~~field__~~
			"]":>
		With[
			{
				base=
					Join[
						<|
							"Level"->Replace[StringTrim@n, {"-"->"", e_:>ToExpression[n]}],
							"Count"->Replace[count, {"-"->"", e_:>ToExpression[e]}]
							|>,
						Which[
							StringStartsQ[term, "\[Sigma]"|"\[Pi]"|"\[Delta]"],
								<|
									"Type"->
										term,
									"BondingOrbital"->
										Not@StringContainsQ[term, "*"|"\[Conjugate]"]
									|>,
							StringMatchQ[term, "s"|"p"|"d"|"f"|"g"],
								<|
									"Type"->
										term
									|>,
							True,
							With[
								{
									ir=
										CharacterTableParseIrreducibleRepresentation[
											ToUpperCase@
												StringTake[term, 1]<>
													StringDrop[term, 1]
											]
									},
								<|
									"Type"->ir
									|>
								]
							]
					]
				},
			Join[
				base,
				Which[
					!StringMatchQ[field, "None"|"Auto"],
						<|
							"FieldType"->
								CharacterTableParsePointGroup[
									ToUpperCase@
											StringTake[#, 1]<>
												StringDrop[#, 1]
										&@StringSplit[field, "<"|">"][[1]]
									],
							"FieldStrength"->
								Which[
									StringContainsQ[field, ">"],
										"Weak",
									StringContainsQ[field, "<"],
										"Strong",
									True,
										Indeterminate
									]
							|>,
					field=="Auto",
						If[AssociationQ@base["Type"],
							Switch[base["Type", "ID"],
								(*"Eg"|"T2g",
									<|
										"FieldType"\[Rule]
											CharacterTableParsePointGroup["Oh"],
										"FieldStrength"->
											Indeterminate
										|>,*)
								_,
									<|
										"FieldType"->
											Indeterminate,
										"FieldStrength"->
											Indeterminate
										|>
								],
							<||>
							],
					True,
						<||>
					]
				]
			]
		];


ParseOrbitalConfigurationExplicit//Clear


PrepOrbitalConfigurationExplicit2[s_]:=
	StringReplace[s, 
		{
			"["~~t:Except[","]..~~"]":>
				"["<>t<>","<>"\"\""<>","<>"Auto"<>"]",
			"["~~t:Except[","]..~~","~~n:Except[","]..~~"]":>
				"["<>t<>","<>n<>","<>"Auto"<>"]"
			}
		];
PrepOrbitalConfigurationExplicit1[s_?(Not@*StringContainsQ["["])]:=
	StringReplace[s,
		n:DigitCharacter..~~
			term:Except[DigitCharacter]~~
			c:DigitCharacter...:>
		term<>"["<>n<>","<>Replace[c, ""->"\"\""]<>"]"
		];
PrepOrbitalConfigurationExplicit1[s_]:=s;
ParseOrbitalConfigurationExplicit[s_]:=
	iParseOrbitalConfigurationExplicit@
		PrepOrbitalConfigurationExplicit2[
			PrepOrbitalConfigurationExplicit1[s]
			];


ParseInternalElectronConfiguration[l_List]:=
	Flatten@MapIndexed[
		With[{n=#2[[1]]},
			MapThread[
				<|
					"Level"->n,
					"Type"->#2,
					"Count"->#
					|>&,
				{
					#,
					Take[{"s", "p", "d", "f", "g", "h", "i"},
						Length[#]
						]
					}
				]
			]&,
		l
		];
ParseOrbitalConfigurationImplicit[s_]:=
	ParseInternalElectronConfiguration@
		ChemDataLookup[StringTrim[s, "["|"]"], "ElectronConfiguration"];


ParseOrbitalConfiguration[s_]:=
	Replace[
		ParseOrbitalConfigurationExplicit[s],
		{
			StringExpression[a_Association]:>
				a,
			e_String:>
				Replace[
					ParseOrbitalConfigurationImplicit[e],
					{
						a:{__Association}:>
							a,
						_->$Failed
						}
					]
			}
		]


(* ::Subsubsection::Closed:: *)
(*Orbital*)



ElectronOrbital[s_String]:=
	Replace[
		ParseOrbitalConfiguration[s],
		{
			a_Association:>
				Which[
					KeyMemberQ[a, "FieldType"],
						ElectronCrystalFieldOrbital[a],
					KeyMemberQ[a, "BondingOrbital"],
						ElectronMolecularOrbital[a],
					True,
						ElectronOrbital[a]
					],
			a:{__Association}:>
				Thread[ElectronOrbital[a]]
			}];
ElectronOrbital[a_Association, b_Association]:=
	ElectronOrbital[Join[b,a]];
ElectronOrbital[a_Association][k__]:=
	a[k];
ElectronOrbital/:
	Normal[ElectronOrbital[a_Association]]:=a;
With[{
	eorb=
		Block[{Internal`$ContextMarks=True},
			ToString[ElectronOrbital]
			]
	},
	Format[
		ElectronOrbital[a:KeyValuePattern[{"Type"->_, "Count"->_, "Level"->_}]]
		]:=
		RawBoxes@
			TemplateBox[
				ToBoxes/@
					Join[
						Lookup[a, {"Level", "Type", "Count"}],
						{
							Lookup[a, 
								"Formatted", 
								If[AssociationQ@a["Type"],
									Lookup[a["Type"], "Formatted", a["Type"]],
									Lookup[a, "Type"]
									]
								]/.s_String:>ToLowerCase[s],
							a
							}],
				"ElectronOrbital",
				DisplayFunction->
					Function[
						StyleBox[
							RowBox[{
								#,
								"\[InvisibleSpace]",
								SuperscriptBox[#4,#3]
								}],
							ShowStringCharacters->False
							]
						],
				InterpretationFunction->
					Function[
						RowBox[{
							eorb,"[",
							ToBoxes@
								<|
									"Level"->RawBoxes@#,
									"Type"->RawBoxes@#2,
									"Count"->RawBoxes@#3
									|>,
							",",
							#5,
							"]"
							}]
						]
				]
	]


(* ::Subsubsection::Closed:: *)
(*electronOrbIDString*)



electronOrbIDString[orb_]:=
	TemplateApply["`level``id`",
		<|
			"level"->orb["Level"],
			"id"->Replace[orb["Type"], a_Association:>a["ID"]]
			|>
		]


(* ::Subsubsection::Closed:: *)
(*CystalFieldOrbital*)



ElectronCrystalFieldOrbital[a_Association, b_Association]:=
	ElectronCrystalFieldOrbital[Join[b,a]];
ElectronCrystalFieldOrbital[a_Association][k__]:=
	a[k];
ElectronCrystalFieldOrbital/:
	Normal[ElectronCrystalFieldOrbital[a_Association]]:=a;
With[{
	eorb=
		Block[{Internal`$ContextMarks=True},
			ToString[ElectronCrystalFieldOrbital]
			]
	},
	Format[
		ElectronCrystalFieldOrbital[
			a:KeyValuePattern[{
				"Type"->_,
				"Count"->_,
				"Level"->_,
				"FieldStrength"->_,
				"FieldType"->_
				}]
			]
		]:=
		RawBoxes@
			TemplateBox[
				ToBoxes/@
					Join[
						Lookup[a, {"Level", "Type", "Count"}],
						{
							If[AssociationQ@a["Type"],
								Lookup[a["Type"], "Formatted", a["Type"]],
								Lookup[a, "Type"]
								]/.s_String:>ToLowerCase[s],
							Replace[
								Lookup[a, "FieldType"],
								{
									Indeterminate->"",
									pg_Association:>pg["Formatted"]
									}
								],
							a
							}],
				"ElectronCrystalFieldOrbital",
				DisplayFunction->
					Function[
						StyleBox[
							SubscriptBox[
								RowBox[{
									#,
									"\[InvisibleSpace]",
									SuperscriptBox[#4,#3]
									}],
								#5
								],
							ShowStringCharacters->False
							]
						],
				InterpretationFunction->
					Function[
						RowBox[{
							eorb,"[",
							ToBoxes@
								<|
									"Level"->RawBoxes@#,
									"Type"->RawBoxes@#2,
									"Count"->RawBoxes@#3
									|>,
							",",
							#6,
							"]"
							}]
						]
				]
	]


(* ::Subsubsection::Closed:: *)
(*MolecularOrbital*)



ElectronMolecularOrbital[a_Association, b_Association]:=
	ElectronMolecularOrbital[Join[b,a]];
ElectronMolecularOrbital[a_Association][k__]:=
	a[k];
ElectronMolecularOrbital/:
	Normal[ElectronMolecularOrbital[a_Association]]:=a;
With[{
	eorb=
		Block[{Internal`$ContextMarks=True},
			ToString[ElectronMolecularOrbital]
			]},
	Format[
		ElectronMolecularOrbital[
			a:KeyValuePattern[{
				"Type"->_,
				"Count"->_,
				"Level"->_,
				"BondingOrbital"->_
				}]
			]
		]:=
		RawBoxes@
			TemplateBox[
				ToBoxes/@
					Join[
						Lookup[a, {"Level", "Type", "Count"}],
						{
							If[AssociationQ@a["Type"],
								Lookup[a["Type"], "Formatted", a["Type"]],
								Lookup[a, "Type"]
								]/.s_String:>ToLowerCase[s],
							If[a["BondingOrbital"], "\[InvisibleSpace]", "\[Conjugate]"],
							a
							}],
				"ElectronMolecularOrbital",
				DisplayFunction->
					Function[
						StyleBox[
							RowBox[{
								#,
								"\[InvisibleSpace]",
								SuperscriptBox[
									RowBox[{#4, #5}],
									#3
									]
								}],
							ShowStringCharacters->False
							]
						],
				InterpretationFunction->
					Function[
						RowBox[{
							eorb,"[",
							ToBoxes@
								<|
									"Level"->RawBoxes@#,
									"Type"->RawBoxes@#2,
									"Count"->RawBoxes@#3
									|>,
							",",
							#6,
							"]"
							}]
						]
				]
		]


(* ::Subsubsection::Closed:: *)
(*ElectronOrbitalEdit*)



ElectronOrbitalEdit[
	orb:electronConfigOrbitalPat,
	props_?OptionQ
	]:=
	Head[orb]@
		Join[
			Normal[orb],
			Association[props]
			]


(* ::Subsubsection::Closed:: *)
(*ElectronOrbitalLookup*)



ElectronOrbitalLookup[
	orb:electronConfigOrbitalPat,
	l_,
	d_
	]:=
	Lookup[Normal[orb], l, d]


(* ::Subsubsection::Closed:: *)
(*ElectronConfiguration*)



electronConfigurationVectorPattern=
	{
		(
			_ElectronOrbital|
			_ElectronCrystalFieldOrbital|
			_ElectronMolecularOrbital
			)?validOrbitalConfiguration..
		};


sortElectronConfiguration[l_List]:=
	SortBy[
		l,
		With[{
			lev=#["Level"], 
			b=#["BondingOrbital"],
			t=ToLowerCase@Replace[#["Type"], a_Association:>a["Type"]]
			},
			lev+
				If[!b//TrueQ,
					10-#,
					#
					]&[
					Switch[t,
						"s"|"\[Sigma]"|"a"|"b",
							0,
						"e",
							.5,
						"p"|"\[Pi]"|"t",
							1,
						"d"|"\[Delta]",
							2,
						"f",
							3,
						"g"|"h",
							4,
						_,
							0
						]
					]
			]&
		]


ElectronConfiguration//Clear


ElectronConfiguration[s_String]:=
	With[{
		eBase=ElectronOrbital/@StringSplit[s]//Flatten
		},
		ElectronConfiguration[
			sortElectronConfiguration[eBase]
			]/;AllTrue[eBase, validOrbitalConfiguration]
		];
ElectronConfiguration[TextCell[s_]]:=
	ElectronConfiguration[s];
ElectronConfiguration[s_String, ops_?OptionQ]:=
	ElectronConfiguration[ElectronConfiguration[s], ops];
ElectronConfiguration[
	l:electronConfigurationVectorPattern,
	ops_?OptionQ
	]:=
	ElectronConfiguration@
		Map[electronOrbitalEdit[#, ops]&, l];
ElectronConfiguration/:
	Part[
		ElectronConfiguration[l:electronConfigurationVectorPattern, a_],
		i_,
		r___
		]:=
	If[Length@{r}>0,
		l[[i]][r],
		l[[i]]
		];
ElectronConfiguration/:
	Normal[ElectronConfiguration[l:electronConfigurationVectorPattern]]:=
		(*Normal/@*)l;
ElectronConfiguration/:
	Map[f_, ElectronConfiguration[a_]]:=
		Map[f, a];
ElectronConfiguration/:
	MapIndexed[f_, ElectronConfiguration[a_]]:=
		MapIndexed[f, a];
ElectronConfiguration/:
	Select[ElectronConfiguration[a_], f_]:=
		Select[a, f];
ElectronConfiguration/:
	Cases[ElectronConfiguration[a_], p__]:=
		Cases[a, p];
ElectronConfiguration/:
	Fold[f_, s_, ElectronConfiguration[a_]]:=
		Fold[f, s, a];
Format[
	ElectronConfiguration[
		o:electronConfigurationVectorPattern
		]
	]:=
	RawBoxes@
		TemplateBox[
			ToBoxes/@o,
			"ElectronConfiguration",
			DisplayFunction->
				(StyleBox[RowBox[{"[", ##, "]"}], ShowStringCharacters->False]&),
			InterpretationFunction->
				Function[
					RowBox[
						Flatten@{
							"ElectronConfiguration","[","{",
							Riffle[
								Map[
									Lookup[Options[#, InterpretationFunction], InterpretationFunction]@@
										#[[1]]&,
									{##}
									],
								","
								],
							"}",
							"]"
							}
						]
					]
			]


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationEdit*)



ElectronConfigurationEdit[
	orb:electronConfigOrbitalPat,
	props:_Association|_?OptionQ
	]:=
	Head[orb]@
		Merge[{Normal@orb, props},
			Replace[{
				{p_, f_Function}:>f[p],
				{___, e_}:>e
				}]
			];
ElectronConfigurationEdit[
	ec_ElectronConfiguration,
	type_String,
	props_
	]:=
	ElectronConfiguration@
		Map[
			If[
				StringMatchQ[
					ToString[#["Level"]]<>
						Replace[#["Type"], a_Association:>a["ID"]], 
					type
					],
				ElectronConfigurationEdit[#, props],
				#
				]&,
			ec
			];
ElectronConfigurationEdit[
	ec_ElectronConfiguration,
	propTypes:_List?OptionQ
	]:=
	Fold[
		ElectronConfigurationEdit[
			#, 
			#2[[1]],
			#2[[2]]
			]&,
		ec,
		propTypes
		]


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationMoveElectrons*)



ElectronConfigurationMoveElectrons[
	ec_ElectronConfiguration,
	moveRules:_List?OptionQ
	]:=
	ElectronConfigurationEdit[ec,
		Flatten@Replace[moveRules,
			{
				(t1_String->t2_String):>
					{
						t1->{ "Count"->Function[Replace[#, ""->0]-1] },
						t2->{ "Count"->Function[Replace[#, ""->0]+1] }
						},
				(t1_String->{t2_String, n_Integer}):>
					{
						t1->{ "Count"->Function[Replace[#, ""->0]-n] },
						t2->{ "Count"->Function[Replace[#, ""->0]+n] }
						}
				},
			1
			]
		];
ElectronConfigurationMoveElectrons[
	ec_ElectronConfiguration,
	moveRules:_?OptionQ
	]:=
	ElectronConfigurationMoveElectrons[
		ec,
		Flatten@List@Normal@moveRules
		]


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationAddElectrons*)



ElectronConfigurationAddElectrons[
	ec_ElectronConfiguration,
	moveRules:_List?OptionQ
	]:=
	ElectronConfigurationEdit[ec,
		Flatten@Replace[moveRules,
			{
				(t1_String->n_):>
					{
						t1->{ "Count"->Function[Replace[#, ""->0]+n] }
						}
				},
			1
			]
		];
ElectronConfigurationAddElectrons[
	ec_ElectronConfiguration,
	moveRules:_?OptionQ
	]:=
	ElectronConfigurationAddElectrons[
		ec,
		Flatten@List@Normal@moveRules
		];
ElectronConfigurationAddElectrons[
	moveRules:_?OptionQ
	][ec_ElectronConfiguration]:=
	ElectronConfigurationAddElectrons[ec, moveRules]


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationDeleteEmptyOrbitals*)



ElectronConfigurationDeleteEmptyOrbitals[ec_ElectronConfiguration]:=
	ElectronConfiguration@Select[
		ec,
		#["Count"]>0&
		]


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationCollapseOrbitals*)



ElectronConfigurationCollapseOrbitals[
	ec_ElectronConfiguration
	]:=
	ElectronConfiguration@
		sortElectronConfiguration@
			Map[
				Head[#[[1]]]@
					ReplacePart[
						Normal[#[[1]]],
						"Count"->
							Total@Lookup[Normal/@#,"Count"]
						]&,
				GatherBy[
					Normal@ec,
					Lookup[Normal@#, {"Level", "Type"}]&
					]
				];


(* ::Subsubsection::Closed:: *)
(*orbitalDefaultEnergy*)



orbitalDefaultEnergyTypeCorrection[type_]:=
	.5*((orbitalTypeIndexed[type]-1)^2)


orbitalDefaultEnergyBondingCorrection[bo_, type_]:=	
	If[bo, Minus, Identity]@
		Switch[type,
			"\[Sigma]",
				2.5,
			"\[Pi]",
				1.5,
			"\[Delta]",
				.5,
			_,
				0
			];


orbitalDefaultEnergyFieldCorrection[type_, fieldType_, fieldStrength_]:=	
	Switch[{
		ToLowerCase@Replace[type, a_Association:>a["Type"]], fieldType, fieldStrength},
		{"e", "Oh", _},
			.5,
		{"t", "Oh", _},
			-1/3.,
		{"t", "Td", _},
			1/3.,
		{"e", "Td", _},
			-.5,
		_,
			0
		];


orbitalDefaultEnergyFunction[orb_]:=
	With[
		{
			l=Replace[orb["Level"], Except[_?NumericQ]->1],
			type=orb["Type"],
			bo=orb["BondingOrbital"],
			ft=Replace[orb["FieldType"], a_Association:>a["ID"]],
			fs=orb["FieldStrength"]
			},
		50*(1-1/(l)^.1)+
			Which[
				BooleanQ[bo],
					orbitalDefaultEnergyBondingCorrection[bo, type],
				StringQ[ft],
					orbitalDefaultEnergyFieldCorrection[type, ft, fs],
				True,
					orbitalDefaultEnergyTypeCorrection[type]
				]
		]


orbitalEnergy[orb_, default_:orbitalDefaultEnergyFunction]:=
	ElectronOrbitalLookup[orb,
		"EnergyFunction",
		default
		]@orb


(* ::Subsubsection::Closed:: *)
(*orbitalTypeIndexed*)



orbitalTypeIndexed[t_]:=
	Replace[t,
		{
			a_Association:>
				orbitalTypeIndexed[t["Type"]],
			s_String:>
				Switch[s,
					"A"|"s"|"\[Sigma]",
						1,
					"E"|"p"|"\[Pi]",
						2,
					"T"|"d"|"\[Delta]",
						3,
					"H"|"G"|"f",
						4,
					_,
						If[!LowerCaseQ[s],
							orbitalTypeIndexed[ToLowerCase[s]],
							With[{n=LetterNumber[t]},
								If[n>10,
									n-7,
									n-6
									]
								]
							]
					]
			}
	];
orbitalTypeFromIndex[i_Integer]:=
	Switch[i,
		1,
			"s",
		2,
			"p",
		3,
			"d",
		4,
			"f",
		_,
			FromLetterNumber@
				If[i>10,
					i+4,
					i+3
					]
			]


(* ::Subsubsection::Closed:: *)
(*orbitalTypeDegOrbitalCount*)



orbitalTypeDegOrbitalCount//Clear


orbitalTypeDegOrbitalCount[t_]:=
	Replace[
		Replace[t, s_String:>ToLowerCase[s]],
		{
			a_Association:>
				orbitalTypeDegOrbitalCount[a["Type"]],
			_String?(StringStartsQ["a"])->1,
			_String?(StringStartsQ["b"])->1,
			_String?(StringStartsQ["e"])->2,
			_String?(StringStartsQ["t"])->3,
			_String?(StringStartsQ["g"])->4,
			_String?(StringStartsQ["h"])->5,
			"\[Sigma]"->1,
			"\[Pi]"->3,
			"\[Delta]"->5,
			e:electronConfigOrbitalPat:>
				Replace[e["Degeneracy"],
					{
						d:Except[_Integer]:>
							Replace[d@e,
								Except[_Integer]:>
									orbitalTypeDegOrbitalCount[e["Type"]]
								]
						}
					],
			i_Integer:>
				1+2*(i-1),
			s_String:>
				orbitalTypeDegOrbitalCount[orbitalTypeIndexed[s]],
			o_ElectronOrbital:>
				orbitalTypeDegOrbitalCount[orbitalTypeIndexed@o["Type"]]
			}
		]


(* ::Subsubsection::Closed:: *)
(*electronConfigSpinCount*)



orbitalSpinCount[orb_]:=
	Abs[orbitalTypeDegOrbitalCount[orb]-orb["Count"]];
electronConfigSpinCount[ec_]:=
	Total@Map[orbitalSpinCount, ec]


(* ::Subsubsection::Closed:: *)
(*electronConfigTotalCount*)



electronConfigTotalCount[ec_]:=
	Total@
		Lookup[
			Normal/@Normal[ec],
			"Count"
			]


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationOptimize*)



ElectronConfigurationOptimize[ec_]:=
	Block[{eTot=electronConfigTotalCount[ec]},
		ElectronConfiguration@
			Map[
				With[{deg=orbitalTypeDegOrbitalCount[#]},
					With[
						{
							toAdd=
								Min@{2*deg, eTot}
							},
						eTot-=toAdd;
						ElectronOrbitalEdit[#,
							"Count"->toAdd
							]
						]
					]&,
				ec
				]
		]


(* ::Subsubsection::Closed:: *)
(*unfilledOrbitals*)



electronConfigUnfilledOrbitals[e_ElectronConfiguration]:=
	Select[
		AssociationMap[
			electronConfigUnfillillingCount,
			First@e
			],
		GreaterThan[0]
		];
electronConfigUnfillillingCount[e:electronConfigOrbitalPat]:=
	(2*orbitalTypeDegOrbitalCount[e["Type"]]-Replace[e["Count"], ""->0]);
electronConfigElectronArrangements[e:electronConfigOrbitalPat]:=
	Binomial[
		2*orbitalTypeDegOrbitalCount[e["Type"]],
		e["Count"]
		];


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationEnumerate*)



ElectronConfigurationEnumerate[
	base_ElectronConfiguration,
	enumerableCount_Integer
	]:=
	Module[
		{
			fillCounts=
				AssociationMap[
					electronConfigUnfillillingCount,
					Normal@base
					],
			unfillings,
			partitions
			},
		unfillings=
			Select[fillCounts,
				GreaterThan[0]
				];
		partitions=
			Flatten[
				Permutations@PadRight[#, Length@unfillings]&/@
					IntegerPartitions[enumerableCount, Length@unfillings],
				1
				];
		partitions=
			Select[partitions,
				AllTrue[Values@unfillings-#, GreaterEqualThan[0]]&
				];
		unfillings=
			Map[electronOrbIDString, Keys@unfillings];
		ElectronConfigurationAddElectrons[
			base,
			Thread[unfillings->#]
			]&/@partitions
		]


(* ::Subsubsection::Closed:: *)
(*microstates*)



electronConfigOrbMicrostates[e:electronConfigOrbitalPat]:=
	With[
		{
			o=e["Count"],
			d=orbitalTypeDegOrbitalCount[e]
			},
		With[{keys=Range[-Floor[d/2], Floor[d/2]]},
			Subsets[
				Flatten@Table[{n->1/2, n->-1/2},{n, keys}],
				{o}
				]
			]
		];
electronConfigMicrostates[e_ElectronConfiguration]:=
	Map[
		AssociationThread[Normal@e, #]&,
		Tuples@Map[electronConfigOrbMicrostates, e]
		]


(* ::Subsubsection::Closed:: *)
(*Angular Momenta and Term Symbols*)



orbSymmDirectProductTerm[keys_, vals_]:=
	With[
		{
			types=
				Flatten@MapThread[
					If[AssociationQ@#["Type"],
						ConstantArray[Lookup[#["Type"], "ID"], Length[#2]],
						Nothing
						]&,
					{keys, vals}
					],
			field=
				Flatten@DeleteCases[Indeterminate]@
					Lookup[
						Select[#["FieldType"]&/@keys, AssociationQ], 
						"ID"
						]
			},
		If[Length@types>0,
			If[Length[#]>0, Keys[#][[1]], Automatic]&@
				Select[
					CharacterTableDirectProduct[Replace[field,{ {f_,___}:>f, {}->"Oh"}],
						types
						],
					GreaterThan[0]
					],
			Automatic
		]
	]


electronConfigOrbAngMomenta[microstates_]:=
	With[
		{
			lStates=
				Map[
					Map[Total@*Keys],
					microstates
					],
			sStates=
				Map[
					Map[Total@*Values],
					microstates
					],
			possibleTerms=
				Map[
					With[
						{
							k=Keys[#],
							v=Values[#]
							},
						orbSymmDirectProductTerm[k, v]
						]&,
					microstates
					]
			},
		With[
			{
				lSums=
					Flatten[Total@*Values/@lStates],
				sSums=
					Flatten[Total@*Values/@sStates]
				},
			<|
				"OrbitalSpinMomentaStates"->
					Thread[
						possibleTerms->
							Transpose@{lSums, sSums}
						],
				"OrbitalAngularMomentum"->
					Max@lSums,
				"SpinAngularMomentum"->
					Max@sSums,
				"TotalAngularMomentum"->
					Max[lSums+sSums]
				|>
			]
		];


electronConfigTermSymbols//Clear


electronConfigTermSymbols[config_, ml_?NumericQ, ms_?NumericQ]:=
	With[{
		base=
			<|
				"TermSymbol"->
					Which[
						MatchQ[config, _ElectronCrystalFieldOrbital],
							config["Type"],
						AssociationQ[config],
							config,
						True,
							ToUpperCase@orbitalTypeFromIndex[ml+1]
						],
				"SpinState"->
					1+ms*2,
				"OrbitalState"->
					1+ml*2
				|>
		},
		Append[base,
			"Formatted"->
				Style[
					Row@{
						Superscript["", base["SpinState"]], 
						If[MatchQ[base["TermSymbol"], _Association],
							Replace[
								Lookup[Normal@config, "Formatted", base["TermSymbol"]],
								{
									a_Association:>
										Lookup[a, "Formatted", "Type"],
									Subscript[t_, l_]:>
										Subscript[ToUpperCase[t], l],
									s_String:>
										(ToUpperCase@StringTake[#,1]<>StringDrop[#,1]&)[s]
									}],
							base["TermSymbol"]
							]
						},
					ShowStringCharacters->False,
					StripOnInput->False
					]
			]
		];
electronConfigTermSymbols[conf_->vals_]:=
	electronConfigTermSymbols[
		conf,
		Sequence@@Abs@vals
		];
electronConfigTermSymbols[microstates_List]:=
	DeleteDuplicatesBy[
		electronConfigTermSymbols/@microstates,
		(*{#["TermSymbol"],*) #["SpinState"](*}*)&
		];


(* ::Subsubsection::Closed:: *)
(*Frontier Orbitals*)



electronConfigFrontierElectronCount[e_ElectronConfiguration]:=
	With[{
		c=
		MaximalBy[
			Select[
				Normal@e,
				MatchQ[
					ToLowerCase@Replace[#["Type"], a_Association:>a["ID"]], 
					"d"|"\[Delta]"|"eg"|"t2g"
					]&
				],
			#["Level"]&
			]
		},
	If[Length[c]>0,
		c[[1, "Count"]],
		0
		]
	];


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationData*)



ElectronConfigurationData[e_ElectronConfiguration]:=
	Module[
		{
			unfilled=electronConfigUnfilledOrbitals[e],
			microstates=electronConfigMicrostates[e],
			freeDenegeracies,
			momenta,
			terms,
			spin
			},
		freeDenegeracies=
			AssociationMap[
				electronConfigElectronArrangements, 
				Keys[unfilled]
				];
		momenta=
			electronConfigOrbAngMomenta[microstates];
		terms=
			electronConfigTermSymbols[momenta["OrbitalSpinMomentaStates"]];
		spin=electronConfigSpinCount[e];
		<|
			"UnfilledOrbitals"->
				unfilled,
			"Degeneracies"->
				freeDenegeracies,
			"Microstates"->
				microstates,
			"AngularMomenta"->
				momenta,
			"Terms"->
				terms,
			"UnpairedSpins"->
				spin
			|>
		]


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationGraphics*)



(* ::Subsubsubsection::Closed:: *)
(*Basic Orbital*)



ElectronConfigurationGraphicsObjects//Clear


ElectronConfigurationGraphicsObjects[
	"OrbitalLines",
	orb:electronConfigOrbitalPat,
	pos:{_, _}:{0, 0},
	lineSize_:.1, lineGap_:.025,
	arrowSize_. 1, arrowGap_:.025
	]:=
	Table[
		Line[
			Map[
				pos+{(n-1)*(lineSize+lineGap), 0}+#&,
				{{0,0},lineSize*{1, 0}}
				]
			],
		{n, orbitalTypeDegOrbitalCount[orb]}
		]


ElectronConfigurationGraphicsObjects[
	"ElectronArrows",
	orb:electronConfigOrbitalPat,
	pos:{_, _}:{0, 0},
	lineSize_:.1, lineGap_:.025,
	arrowSize_:.1, arrowGap_:.025
	]:=
	With[{
		ord=orbitalTypeDegOrbitalCount[orb]
		},
	Table[
		Arrow[
			If[n<0, Reverse, Identity]@
			Map[
				pos+{(Abs[n]-1)*(lineSize+lineGap), 0}+#&,
				{
					{If[n>0, .25, .75]*lineSize, arrowGap/4}, 
					{If[n>0, .25, .75]*lineSize, arrowSize+arrowGap/4}
					}
				]
			],
		{n, 
			Join[
				Range[Min@{orb["Count"], ord}],
				Range[
					-1,
					ord-orb["Count"],
					-1
					]
				]
			}
		]
		]


(* ::Subsubsubsection::Closed:: *)
(*Main*)



ElectronConfigurationGraphics//Clear


Options[ElectronConfigurationGraphics]=
	Join[
		{
			"ElectronArrowHeight"->.1,
			"ElectronArrowGap"->.05,
			"OrbitalLineWidth"->.1,
			"OrbitalLineGap"->.025,
			"EnergyFunction"->Automatic,
			"EnergyScaling"->.1
			},
		Options[Graphics]
		];
ElectronConfigurationGraphics[
	e_ElectronConfiguration,
	others:{}|Except[_?OptionQ]:{},
	ops:OptionsPattern[]
	]:=
	Module[
		{
			lineSize = OptionValue["OrbitalLineWidth"],
			lineGap  = OptionValue["OrbitalLineGap"],
			arrowSize= OptionValue["ElectronArrowHeight"],
			arrowGap = OptionValue["ElectronArrowGap"],
			ef       = 
				Replace[OptionValue["EnergyFunction"], 
					Automatic:>orbitalDefaultEnergyFunction
					],
			es=
				OptionValue["EnergyScaling"],
			enDegs,
			orbCents
			},
		enDegs=	
			Map[
				#->
					{es*orbitalEnergy[#, ef], orbitalTypeDegOrbitalCount[#]}&,
				e
				];
		enDegs=
			SortBy[#[[2, 1]]&]/@
				Gather[enDegs,
					Abs[#[[2, 1]]-#2[[2, 1]]]<arrowSize&
					];
		orbCents=
			Flatten@
				MapIndexed[
					With[{
						degs=#[[All, 2, 2]], 
						orbs=#[[All, 1]],
						engs=#[[All, 2, 1]],
						ind=#2[[1]]
						},
						Block[
							{
								xSpacing=0,
								xSpacingTmp,
								xAdd
								},
							MapIndexed[
								#->
									{
										xSpacingTmp=
											xSpacing;
										xAdd=
											Switch[orbs[[#2[[1]]]]["Type"],
												"eg"|"e",
													1/2,
												"\[Sigma]",
													2,
												"\[Pi]",
													1,
												_,
													0
												];
										xSpacing+=
											2*xAdd+degs[[#2[[1]]]];
										(xSpacingTmp+xAdd)*(lineSize+lineGap)+
											lineGap*(#2[[1]]-1),
										engs[[#2[[1]]]]+arrowGap*(ind-1)
										}&,
								orbs
								]
							]
						]&,
					enDegs
					];
		Graphics[
			{
				Arrowheads[.03],
				others,
				Map[
					With[{cent=#[[2]], orb=#[[1]]},
						Prepend[
							Text[
								ReplacePart[orb, {1, "Count"}->""],
								{lineGap, 0}+cent,
								{Left, Top}
								]
							]@
						Table[
							ElectronConfigurationGraphicsObjects[
								t,
								orb,
								{2.5*lineGap, 0}+cent,
								lineSize, lineGap,
								arrowSize, arrowGap
								],
							{t,
								{"OrbitalLines","ElectronArrows"}
								}
							]
						]&,
					orbCents
					]
				},
			FilterRules[
				{ops},
				Options@Graphics
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Octahedral Field*)



ElectronConfigurationCrystalField[
	fieldType:"Tetrahedral"|"Octahedral":"Octahedral",
	fieldStrength:"Weak"|"Strong":"Weak"
	][e_]:=
	ElectronConfigurationCrystalField[e,
		fieldType,
		fieldStrength
		];
ElectronConfigurationCrystalField[
	e_ElectronConfiguration,
	fieldType:"Tetrahedral"|"Octahedral":"Octahedral",
	fieldStrength:"Weak"|"Strong":"Weak"
	]:=
	ElectronConfiguration@
		Map[
			ElectronConfigurationCrystalField[#,
				fieldType,
				fieldStrength
				]&,
			e
			];
ElectronConfigurationCrystalField[
	e_ElectronOrbital,
	fieldType:"Octahedral",
	fieldStrength:"Weak"|"Strong"
	]:=
	If[e["Type"]==="d",
		Sequence@@Map[ElectronCrystalFieldOrbital]@
			If[fieldStrength==="Weak", Reverse, Identity]@
			{
				Join[
					Normal[e],
					<|
						"Type"->"eg",
						"Formatted"->Subscript["e","g"],
						"Count"->
							If[fieldStrength==="Weak",
								Max@{e["Count"]-6, 0},
								Min@{e["Count"],   4}
								],
						"FieldType"->fieldType,
						"FieldStrength"->fieldStrength
						|>
					],
				Join[
					Normal[e],
					<|
						"Type"->"t2g",
						"Formatted"->Subscript["t","2g"],
						"Count"->
							If[fieldStrength==="Weak",
								Min@{e["Count"],   6},
								Max@{e["Count"]-4, 0}
								],
						"FieldType"->fieldType,
						"FieldStrength"->fieldStrength
						|>
					]
				},
		ElectronCrystalFieldOrbital[
			Join[Normal[e],
				<|
					"FieldStrength"->fieldStrength,
					"FieldType"->fieldType
					|>]
			]
		];
ElectronConfigurationCrystalField[
	e_ElectronOrbital,
	fieldType:"Tetrahedral",
	fieldStrength:"Weak"|"Strong"
	]:=
	If[e["Type"]==="d",
		Sequence@@Map[ElectronCrystalFieldOrbital]@
			{
				Join[
					Normal[e],
					<|
						"Type"->"t2",
						"Formatted"->Subscript["t","2"],
						"Count"->
								Max@{e["Count"]-4, 0},
						"FieldStrength"->fieldStrength,
						"FieldType"->fieldType
						|>
					],
				Join[
					Normal[e],
					<|
						"Type"->"e",
						"Count"->
								Min@{e["Count"], 4},
						"FieldStrength"->fieldStrength,
						"FieldType"->fieldType
						|>
					]
				},
		ElectronCrystalFieldOrbital[
			Join[Normal[e], 
				<|
					"FieldStrength"->fieldStrength,
					"FieldType"->fieldType
					|>
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationValenceOrbitals*)



ElectronConfigurationValenceConfiguration[ec_ElectronConfiguration]:=
	With[{
		eLevels=
			Alternatives@@
				DeleteDuplicates@Lookup[
					Normal/@Keys@electronConfigUnfilledOrbitals[ec],
					"Level"
					]
			},
		ElectronConfiguration@
			Select[ec, 
				MatchQ[#["Level"], eLevels]&
				]
		]


(* ::Subsection:: *)
(*Molecular Orbital Diagrams*)



(* ::Subsubsection::Closed:: *)
(*$electronConfigurationHybridizationTypeMap*)



(* ::Text:: *)
(*This would obviously require some proper spatial awareness to do correctly. But I really don\[CloseCurlyQuote]t want to handle that. We could do some energetic arguments, though.*)



$electronConfigurationHybridizationTypeMap=
	KeyMap[Sort]@<|
		{"s"|"\[Sigma]", _}->"\[Sigma]",
		{"p"|"\[Pi]", "p"|"\[Pi]"|"\[Delta]"}->"\[Pi]",
		{"d"|"\[Delta]", "d"|"\[Delta]"}->"\[Delta]",
		_->None
		|>


(* ::Subsubsection::Closed:: *)
(*electronConfigurationHybridize*)



(* ::Text:: *)
(*To do this correctly will require some sense of directionality for \[Sigma], p, \[Pi], d, and \[Delta] orbitals. How to handle this effectively is still up in the air.*)



electronConfigurationLCAOs[e1_, eSet_]:=
	Module[
		{
			energies=
				orbitalEnergy/@eSet,
			coreE=
				orbitalEnergy@e1,
			eCoeffs
			},
		eCoeffs=Normalize[Abs[coreE-#]/Max[Abs@{coreE, #}]&/@energies];
		ElectronCombinationOrbital[
			<|
				
				|>
			]
		];
electronConfigurationHybridize[base_, mos_]:=
	Missing["NotImplemented"]


(* ::Subsubsection::Closed:: *)
(*ElectronConfigurationMOs*)



ElectronConfigurationMOs[
	base_ElectronConfiguration,
	others:_ElectronConfiguration|{__ElectronConfiguration}
	]:=Missing["NotImplemented"];


(* ::Subsection:: *)
(*Tanabe-Sugano Diagrams*)



(* ::Subsubsection::Closed:: *)
(*Tanabe-Sugano Data*)



TanabeSuganoData//Clear


TanabeSuganoData[dElectrons:Alternatives@@Range[2,8]]:=
	$ChemTanabeSuganoData[[dElectrons-1]];
TanabeSuganoData[ec_ElectronConfiguration]:=
	With[{els=electronConfigFrontierElectronCount[ec]},
		TanabeSuganoData[ec]/;2<=els<=8
		]


tanabeSuganoDataSelectors=
	(_String|_Integer|Key[_Integer]|{_String|_Integer, Key[_Integer]});
tanabeSuganoDataSecondPat=
	{tanabeSuganoDataSelectors..}|All


tanabeSuganoKeyMatches[pats_, data_]:=
	Block[
		{
			matchesCounts=AssociationMap[0&, pats]
			},
		MapIndexed[
			With[{v=#, i=#2[[1]]},
				If[
					AnyTrue[pats,
						Replace[
							{
								k_Key:>
									MatchQ[Key[i], k],
								s_?StringPattern`StringPatternQ:>
									StringMatchQ[v["ID"], s],
								i:Except[{_, _Key}]:>
									MatchQ[v["Degeneracy"], i],
								p:{s_?StringPattern`StringPatternQ, k_Key}:>
									StringMatchQ[v["ID"], s]&&
										MatchQ[Key[++matchesCounts[p]], k],
								p:{e_, k_Key}:>
									MatchQ[v["Degeneracy"], e]&&
										MatchQ[Key[++matchesCounts[p]], k]
								}
							]
						],
					v,
					Nothing
					]
				]&,
			Keys@data
			]
		]


TanabeSuganoData[
	rawData_Association,
	selection:tanabeSuganoDataSecondPat
	]:=
	Replace[
			Replace[selection,
				{
					{All}->All,
					{a___, All, b___}:>
						If[Length@{a,b}>0,
							Flatten@{a,b},
							All
							]
					}
				],
			{
				All:>rawData,
				l_List:>
					With[
						{
							data=Take[rawData, {3, -1}],
							header=Take[rawData, 2]
							},
						With[
							{
								k=tanabeSuganoKeyMatches[l, data]
								},
							Join[
								header,
								AssociationThread[
									k,
									Lookup[data, Key/@k]
									]
							]
						]
					]
				}
			];
TanabeSuganoData[
	dSpec_,
	selection:tanabeSuganoDataSecondPat
	]:=
	With[{dats=TanabeSuganoData[dSpec]},
		TanabeSuganoData[dats, selection]/;AssociationQ[dats]
		];
TanabeSuganoData[
	dSpec_,
	selection:tanabeSuganoDataSelectors
	]:=
	TanabeSuganoData[dSpec, {selection}]


(* ::Subsubsection::Closed:: *)
(*Tanabe-Sugano Diagram*)



TanabeSuganoDiagram//Clear


Options[TanabeSuganoDiagram]=
	Join[
		Options[ListLinePlot],
		{
			"MarkerStyle"->Automatic
			}
		];
TanabeSuganoDiagram[
	spec_,
	selection:tanabeSuganoDataSecondPat:All,
	linePos:
		Except[
			tanabeSuganoDataSelectors,
			{_?NumericQ|None, _?NumericQ|None}|_?NumericQ|None
			]:{None, None},
	ops:OptionsPattern[]
	]:=
	Module[
		{
			data=
				TanabeSuganoData[
					Replace[spec, 
						Except[_Association]:>TanabeSuganoData[spec]
						], 
					selection
					],
			params
			},
		{data, params}=
			{KeyDrop[data, "Parameters"], data["Parameters"]};
		ListLinePlot[
			Map[Transpose[{data[[1]], #}]&, Rest@Values@data],
			ops,
			If[!MatchQ[linePos, None|{None, None}],
				Epilog->
					{
						Replace[
							OptionValue@"MarkerStyle",
							Automatic:>Directive[GrayLevel[.65]]
							],
						Switch[linePos,
							{_?NumericQ, None}|_?NumericQ,
								Line[{{linePos, 0}, {linePos, Max@Flatten@Rest@Values@data}}],
							{None, _?NumericQ},
								Line[{{0, linePos}, {Max@data[[1]], linePos}}],
							{_?NumericQ, _?NumericQ},
								{
									Line[{{linePos, 0}, {linePos, Max@Flatten@Rest@Values@data}}],
									Line[{{0, linePos}, {Max@data[[1]], linePos}}]
									}
							]
						},
				Sequence@@{}
				],
			AspectRatio->Full,
			Ticks->None,
			PlotLabel->
				If[OptionValue[Ticks]===True,
					TemplateApply[
						"d: `d` B: `B` C: `C`",
						params
						],
					TemplateApply[
						"d: `d`",
						params
						]
					],
			PlotLegends->
				Map[Key["Formatted"], Rest@Keys[data]],
			PlotRange->{0,All},
			GridLines->Automatic,
			GridLinesStyle->Directive@@{Thin,LightGray, Dashed},
			ImageSize->Medium,
			LabelStyle->{Background->White},
			AxesLabel->
				{
					First[Keys[data]]["Formatted"],
					RawBoxes@FractionBox["\"E\"", " \"B\"", "Beveled"->True]
					}
			]/;AssociationQ[data]
	];
TanabeSuganoDiagram[
	spec_,
	selection:tanabeSuganoDataSelectors,
	linePos:
		Except[
			tanabeSuganoDataSecondPat|tanabeSuganoSelectors,
			{_?NumericQ|None, _?NumericQ|None}|None|_?NumericQ
			]:{None, None},
	ops:OptionsPattern[]
	]:=
	TanabeSuganoDiagram[spec, {selection}, linePos, ops]


(* ::Subsubsection::Closed:: *)
(*Tanabe-Sugano Interactive*)



TanabeSuganoDiagramInteractive//Clear


Options[TanabeSuganoDiagramInteractive]=
	Options[TanabeSuganoDiagram];
TanabeSuganoDiagramInteractive[
	rawData_:Association,
	ops:OptionsPattern[]
	]:=
DynamicModule[
	{
		selection,
		data,
		heads,
		sel1,max,
		yLinePoint,linePoint=0,
		maxX,repSym
		},
	selection={All};
	sel1=All;
	max=Max[Cases[Flatten@Values@data,_?NumberQ]];
	With[{L=Length@data},
		{
			{
			{
				Slider[Dynamic@yLinePoint,{0,max},Appearance->"Vertical"],
				Dynamic@
					Replace[	
						TanabeSuganoDiagram[data, selection, ops],
						dg_Graphics:>
							Show[
								dg,
								ListLinePlot[{
									{{linePoint,0},{linePoint,max}},
									{{0,yLinePoint},{maxX,yLinePoint}},
									{{linePoint,yLinePoint}}
									},
									PlotStyle->{{Thin,Black},{Thin,Black},{Black}},
									Joined->True
									]
								]
						]
					},
			{Null,Slider[Dynamic@linePoint,{0,maxX},ImageSize->Large]},
			{Null,Row@{" Line Position: ",Dynamic@NumberForm[{linePoint,yLinePoint},3]}}
			}//Grid[#,Alignment->Left]&//Framed[Panel[#,Background->White]]&,
		Slider[Dynamic[If[sel1===All,1,sel1],((sel1=#;
				selection=
				If[selection[[1]]===sel1,selection,
					ReplacePart[DeleteCases[selection,sel1],1->sel1]
					])&)],{1,L,1}],
			{Control@{{selection,{All},""},{{All}->"  All  "},ControlType->SetterBar},
				Row[(Table[
						With[{rmin=1+5*(i-1),rmax=Min@{5*i,L}},
							Control@{
								{selection, {All}, ""},
								TogglerBar[#,
									Map[
										#["ID"]->#["Formatted"],
										Keys[data][[rmin;;rmax]]
										],
									Appearance->"Vertical"
									]&}
							],
						{i,Floor[L/5]}]~Append~
					If[Mod[L,5]=!=0,
						With[{rmin=1+L-Mod[L,5],rmax=L},
							Control@{{selection,{All},""},
								TogglerBar[#,
									Map[
										#["ID"]->#["Formatted"],
										Keys[data][[rmin;;rmax]]
										],
									Appearance->"Vertical"
									]&}
							],Null]
						),BaselinePosition->Top]
				}//Column[#,Alignment->Center]&
			}//Column[#,Dividers->{None,{2->{Black,Thick}}}]&//Panel//Deploy
			]
		];


(* ::Subsubsection::Closed:: *)
(*TanabeSuganoSCCDiagram*)



Options[TanabeSuganoSCCData]=
	{
		Scaled->3
		};
TanabeSuganoSCCData[
	dSpec_, sel_,dq_,
	ops:OptionsPattern[]
	]:=
	Module[
		{
			parabolaParams,
			basedata=
				TanabeSuganoData[dSpec, sel],
			parabolaSlopes,
			parabolaHeights,
			parabolaCenters,
			parabolaData,
			scaling=Replace[OptionValue[Scaled], Except[_?NumericQ]->3]
			},
			parabolaParams=
				First/@
					Nearest[
						Thread[basedata[[2]]->#],
						Range[dq-1,dq+1]
						]&/@Take[basedata, 3;;];
			parabolaSlopes=
				Mean@{#[[3]]-#[[2]],#[[2]]-#[[1]]}&/@parabolaParams;
			parabolaHeights=#[[3]]&/@parabolaParams;
			parabolaCenters=
				dq-#/(2*scaling)&/@parabolaSlopes;
			Join[
				Merge[{parabolaHeights,parabolaCenters},Identity],
				<|
					"Scaling"->scaling
					|>
				]
		];
Options[TanabeSuganoSCCDiagram]=
	Join[
		Options[Plot],
		Options[TanabeSuganoSCCData]
		];
TanabeSuganoSCCDiagram[
	dSpec_, sel_, dq_,
	qRange:{_?NumericQ, _?NumericQ}:{-20,20},
	ops:OptionsPattern[]
	]:=
	With[
		{
			parabolaData=
				TanabeSuganoSCCData[dSpec, sel, dq, 
					FilterRules[{ops}, Options@TanabeSuganoSCCData]
					]},
		Plot[
			Evaluate[
				With[{s=parabolaData["Scaling"]},
					Table[
						dats[[1]]+s (Q-dats[[2]])^2-s (dq-dats[[2]])^2,
						{dats, Values@KeySelect[parabolaData, AssociationQ]}
						]
					]
				],
			{Q, dq+qRange[[1]], dq+qRange[[2]]},
			Sequence@@FilterRules[
				{
					ops,
					PlotLegends->Lookup[Select[AssociationQ]@Keys@parabolaData, "Formatted"],
					AxesLabel->{"\!\(\*SubscriptBox[\(Q\), SubscriptBox[\(A\), \(1\[InvisibleSpace]g\)]]\)", "E"},
					Ticks->{False, False},
					PlotRange->{0,50},
					AxesOrigin->{dq+Mean@qRange,0}
					},
				Options@Plot
				]//Evaluate
			]
		]


(* ::Subsubsection::Closed:: *)
(*TanabeSuganoSCCDiagramInteractive*)



Options[TanabeSuganoSCCMultiDiagram]=
	Options[TanabeSuganoSCCDiagram]
TanabeSuganoSCCMultiDiagram[dSpec_, sel_, dqb_, ops:OptionsPattern[]]:=
	Show[
		TanabeSuganoDiagram[dSpec,sel, 1. dqb, 
			FilterRules[{ops}, Options@TanabeSuganoDiagram]
			],
		First@TanabeSuganoSCCDiagram[3,sel,dqb,
			{-50-dqb, 50-dqb},
			FilterRules[{ops}, Options@TanabeSuganoSCCDiagram]
			]
		]


TanabeSuganoSCCDiagramInteractive[dSpec_, sel_, ops:OptionsPattern[]]:=
	Manipulate[
		Show[
			TanabeSuganoDiagram[dSpec,sel,1. dqb],
			TanabeSuganoSCCDiagram[3,sel,dqb,
				{-dqb, 50-dqb},
				ops,
				Scaled->s
				]
			],
		{
			{	
					dqb,
					21, 
					Style[
						RawBoxes@FractionBox["\"\[CapitalDelta]\"","\"B\"", "Beveled"->True], 
						ShowStringCharacters->False
						]
					},
				0,50},
		{{s,1, "Parabola Width"},2,.001}
		]


(* ::Subsection:: *)
(*CorrelationTables*)



correlationTableDataLoad[]:=
	If[!AssociationQ[$CorrelationTableKeys], 
		PackageAddAutocompletions[#, 
			$CorrelationTableKeys=
				{
					Sort@
						Map[#ID&,
							Keys[$ChemCorrelationTables]
							], 
					Sort@DeleteDuplicates@
						Map[#ID&, Flatten[Values[Keys/@$ChemCorrelationTables]]]
					}
			]&/@{CorrelationTableData, CorrelationTableFormatted}
		]


CorrelationTableData//Clear


CorrelationTableData[k_]:=
	With[{d=KeySelect[$ChemCorrelationTables, StringMatchQ[#ID, k]&]},
		correlationTableDataLoad[];
		d/;AssociationQ[d]&&Length[d]>0
		];
CorrelationTableData[k_, k2_]:=
	With[{d=CorrelationTableData[k]},
		With[
			{
				d2=
					Select[
						Map[KeySelect[StringMatchQ[#ID, k2]&], d],
						Length[#]>0&
						]
				},
			d2/;Length[d2]>0
			]/;AssociationQ[d]&&Length[d]>0
		];
CorrelationTableData[k_, k2_, i_]:=
	With[{d=CorrelationTableData[k, k2]},
		With[
			{
				d2=
					Select[
						Map[
							Select[Map[KeySelect[StringMatchQ[#ID, i]&]], Length[#]>0&],
							d
							],
						Length[#]>0&
						]
				},
			d2/;Length[d2]>0
			]/;AssociationQ[d]&&Length[d]>0
		];


correlationTableFormatIrrep[e_]:=
	Replace[l_List:>Plus@@l]@
		Replace[#, {n_Integer,s_}:>Row@{n,"\[ThinSpace]", s}, 2]&@
		ReplaceAll[a_Association:>a["Formatted"]]@e;
correlationTableFormatMap[l_Association]:=
	Map[
		correlationTableFormatIrrep,
		KeyMap[Key["Formatted"], l]
		];
correlationTableFormatAll[l_]:=
	Map[
		correlationTableFormatMap,
		KeyMap[Key["Formatted"], l]
		]


CorrelationTableFormatted//Clear


correlationTableApplyFormatting[d_, d2_, i_]:=
	Grid[
		Prepend[
			Transpose@
				Prepend[
					Values[Values/@d2],
					Keys@d2[[1]]
					],
			Prepend[Keys[d2], Keys[d][[i, "Formatted"]] ]
			],
		Alignment->Left,
		Dividers->{{2->Gray},{2->Gray}},
		Background->{{1->GrayLevel[.95]}, {1->GrayLevel[.95]}},
		Frame->True,
		FrameStyle->Gray
		]


CorrelationTableFormatted[k__]:=
	With[{d=CorrelationTableData[k]},
		Column@
			MapIndexed[
				With[{d2=correlationTableFormatAll[#]},
					correlationTableApplyFormatting[d, d2, #2[[1]]]
					]&,
				Values@d
				]/;AssociationQ[d]
		];
(*CorrelationTableFormatted[k_, v_]:=
	With[{d=CorrelationTableData[k]},
		With[
			{
				d2=KeySelect[d, #ID\[Equal]v&]
				},
			correlationTableApplyFormatting[
				d2,
				correlationTableFormatAll[d2[[1]]]
				]/;Length[d2]>0
			]/;AssociationQ[d]
		];
CorrelationTableFormatted[k_, v_, i_]:=
	With[{d=CorrelationTableData[k, v]},
		correlationTableFormatIrrep[d]/;Head[d]=!=CorrelationTableData
		]*)


(* ::Subsection:: *)
(*Formatting*)



CharacterTableFormatReducedRepresentation[irrepAssoc_]:=
	Interpretation[
		Total@KeyValueMap[#["Formatted"]*#2&, irrepAssoc],
		irrepAssoc
		]


charTableFormalDemapping=
	<|
		\[FormalR]->"r",\[FormalTheta]->"\[Theta]",\[FormalCurlyPhi]->"\[CurlyPhi]",
		\[FormalS]->"s",\[FormalP]->"p",\[FormalD]->"d",
		\[FormalSigma]->"\[Sigma]",\[FormalPi]->"\[Pi]",\[FormalDelta]->"\[Delta]",
		\[FormalX]->"x",\[FormalY]->"y",\[FormalZ]->"z"
		|>


CharacterTableFormatSALCs[salcs_, irrepSelection_:All]:=
	With[
		{
			realSalcs=
				salcs/.{
				(k:Alternatives@@Keys[charTableFormalDemapping])[i_Integer]:>
					Style[Subscript[charTableFormalDemapping[k],i],
						ShowStringCharacters->False
						]
				}
			},
		If[KeyMemberQ[salcs, "Stretches"],
			Map[
				If[ListQ@irrepSelection,
					AssociationThread[
						Lookup[irrepSelection,"Formatted"],
						Map[MatrixForm]@Lookup[#,irrepSelection]
						],
					Map[Map[MatrixForm]@*KeyMap[Key@"Formatted"]]@salcs
					]&,
				realSalcs
				],
			If[ListQ@irrepSelection,
				AssociationThread[
					Lookup[irrepSelection,"Formatted"],
					Map[MatrixForm]@Lookup[realSalcs,irrepSelection]
					],
				Map[MatrixForm]@*KeyMap[Key@"Formatted"]@realSalcs
				]
			]
		]//Dataset


End[];



