(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*Grid Tools*)



(* ::Text:: *)
(*
	Grid functions should all take an option specifying the axis for the operation
*)



(* ::Subsubsection::Closed:: *)
(*Constructors*)



ConstructCoordinateGrid;
CoordinateGridObjectQ;


(* ::Subsubsection::Closed:: *)
(*Parts*)



GridPart::usage=
  "Applies part to a wavefunction";
GridKeyPart::usage=
  "Applies key lookup to a coordinate grid";
GridSlice::usage=
  "Slices at level n";


(* ::Subsubsection::Closed:: *)
(*Structural*)



GridPoints::usage=
  "Flattens down to the coordiante points";
GridTransform::usage=
  "Applies a transformation to the coordinates points, maintaining ordering";
GridTranspose::usage=
  "Takes a transpose of coordinates in the grid";
GridPermute::usage=
  "Permutes coordinates in the grid";
GridSort::usage=
  "Sorts a set of coordinates";
GridSubgrids::usage=
  "Pulls all subgrids out of the grid";
GridJoin::usage=
  "Tries to intelligently join two grids";
GridScale::usage="";
GridShift::usage="";


(* ::Subsubsection::Closed:: *)
(*Misc*)



GridIndexFromStrides::usage="Might be in the wrong place...";
GridStridesToIndex::usage="Might be in the wrong place...";
GridPointRestructure::usage="Bloop";
GridSmoothSort::usage="";
GridPointSmoothOrdering::usage=""


(* ::Subsubsection::Closed:: *)
(*Properties*)



GridDimension::usage=
  "";
GridDimensions::usage=
  "";
GridPointNumber::usage=
  "";
GridMeshSpacings=
  "Only makes sense for regularly sampled grids";
GridRegularlySampledQ=
  "";


(* ::Subsubsection::Closed:: *)
(*Functions*)



GridMap::usage=
  "Maps a function over the grid";
GridCreateMapFunction::usage=
  "Builds a GridFunctionObject by mapping over the grid";


(* ::Subsubsection::Closed:: *)
(*Mindless*)



GridBoundingBox::usage="";
GridBounds::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*Constructor*)



(* ::Subsubsection::Closed:: *)
(*ConstructGrid*)



(* ::Subsubsubsection::Closed:: *)
(*validateGridData*)



validateGridData[grid_]:=
  (*Developer`PackedArrayQ[grid]&&*)(* handled in cleanGridData *)
    Module[
      {
        d=Depth[grid],
        dim=Dimensions[grid],
        dn
        },
      If[d<=2,
        PackageRaiseException[
          Automatic,
          "grid data has insufficient depth to be valid"
          ]
        ];
      If[!(
        dn=grid[[Sequence@@ConstantArray[1, d-2]]];
        Length@dn==d-2
        ),
        PackageRaiseException[
          Automatic,
          "grid depth and grid dimension don't match"
          ],
        True
        ]
      ]


(* ::Subsubsubsection::Closed:: *)
(*cleanGridData*)



cleanGridData//Clear
cleanGridData[g_List]:=
  With[{base=Developer`ToPackedArray@N@g},
    If[!Developer`PackedArrayQ[base],
      base;
      PackageRaiseException[
        Automatic,
        "Grid data cannot be packed"
        ]
      ];
    If[Depth@base==2,
      Transpose@{base},
      base
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*ConstructCoordinateGrid*)



ConstructCoordinateGrid//Clear
ConstructCoordinateGrid[grid_List]:=
  With[{g=cleanGridData@grid},
    If[validateGridData[g],
      <|"Grid"->g|>,
      <|$Failed->True|> (* requires Association return to throw the error *)
      ]
    ];
ConstructCoordinateGrid[CoordinateGridObject[a_]?CoordinateGridObjectQ]:=
  a;
ConstructCoordinateGrid[a_Association]:=
  a;


(* ::Subsection:: *)
(*I am stupid*)



(* ::Subsubsection::Closed:: *)
(*GridObjectModify*)



GridObjectModify[g_, fn_]:=
  InterfaceModify[
    CoordinateGridObject,
    g,
    MapAt[
      fn,
      #, 
      "Grid"
      ]&
    ];


(* ::Subsection:: *)
(*Grid Parts*)



(* ::Subsubsection::Closed:: *)
(*CoordinateGridPart*)



GridPart[c:CoordinateGridObject[a_], p__]:=
  If[AllTrue[{p}, IntegerQ], Identity, CoordinateGridObject]@
    a[["Grid", p]]


(* ::Subsubsection::Closed:: *)
(*CoordinateGridKeyPart*)



GridKeyPart[c:CoordinateGridObject[a_], sel__]:=
  a[sel]


(* ::Subsection:: *)
(*Structural*)



(* ::Subsubsection::Closed:: *)
(*GridPoints*)



GridPoints[grid_List]:=
  Module[{d=Depth[grid]},
    Which[
      d>3,
        Flatten[grid, d-3],
      d==3,
        grid,
      d==2,
        List/@grid,
      d==1,
        PackageRaiseException["Grid",
          "Grid `` has depth 1...?",
          grid
          ]
      ]
    ];
GridPoints[grid_]:=
  GridPoints@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridTransform*)



GridTransform[grid_List, tf_]:=
  Module[{d=Depth[grid]},
    Which[
      d>3,
        Map[tf, grid, {d-2}],
      d==3,
        Map[tf, grid],
      d==2,
        Map[tf, List/@grid],
      d==1,
        PackageRaiseException["Grid",
          "Grid `` has depth 1...?",
          grid
          ]
      ]
    ];
GridTransform[grid_, tf_]:=
  InterfaceModify[
    CoordinateGridObject,
    grid,
    MapAt[
      GridTransform[#, tf]&,
      #, 
      "Grid"
      ]&
    ];


(* ::Subsubsection::Closed:: *)
(*GridTranspose*)



GridTranspose[g_, spec___]:=
  GridObjectModify[g, Transpose[#, spec]&]


(* ::Subsubsection::Closed:: *)
(*GridPermute*)



iGridPermute[g_List, newIndices_]:=
  Module[{newGrid, newInds},
    If[GridDimension@g=!=Length@newIndices,
      PackageRaiseException[
        "Can't perform permutation `` on grid of dimension ``",
        newIndices,
        GridDimension@g
        ]
      ];
    If[Sort@newIndices=!=Range[Length@newIndices],
      PackageRaiseException[
        "Permutation `` loses coordinates ``",
        newIndices,
        Sort@
          Complement[Range[Length@newIndices], newIndices]
        ]
      ];
    newInds=Ordering@newIndices;
    newGrid=Transpose[g, newInds];
    Part[newGrid,
      Sequence@@
        Append[
          ConstantArray[All, Length@newInds], 
          newIndices
          ]
      ]
    ];
GridPermute[g_List, newIndices_]:=
  PackageExceptionBlock["GridPermute"]@
    iGridPermute[g, newIndices];
GridPermute[g_CoordinateGridObject, newIndices_]:=
  PackageExceptionBlock["GridPermute"]@
    InterfaceModify[
      CoordinateGridObject,
      g,
      MapAt[
        GridPermute[#, newIndices]&,
        #, 
        "Grid"
        ]&
      ]


(* ::Subsubsection::Closed:: *)
(*GridSlice*)



GridSlice[g_List, n__Integer]:=
  Part[
    g,
    n,
    Sequence@@
      Append[
        ConstantArray[All, 
          Depth[g]-(2+Length[{n}])], 
          1+Length[{n}];;
          ]
    ];
GridSlice[g_, n__Integer]:=
  GridObjectModify[g, GridSlice[#, n]&];


(* ::Subsubsection::Closed:: *)
(*GridSort*)



GridSort[g_List, fns_]:=
  ArrayReshape[SortBy[GridPoints@g, fns], Dimensions[g]];
GridSort[g_List]:=
  ArrayReshape[Sort[GridPoints@g], Dimensions[g]];
GridSort[g_, fn___]:=
  GridObjectModify[
    g,
    GridSort[#, fn]&
    ];


(* ::Subsubsection::Closed:: *)
(*GridPointRestructure*)



GridPointRestructure[grid_List, sortBy_:None]:=
  Module[
    {
      dims=Dimensions[grid],
      pts=GridPoints[grid]
      }, 
    pts=
      Developer`ToPackedArray@
        If[sortBy=!=None, SortBy[pts, sortBy], Sort[pts]];
    Developer`ToPackedArray@ (*just to be safe...*)
      ArrayReshape[pts, dims]
    ]


(* ::Subsubsection::Closed:: *)
(*GridSmoothSort*)



(* ::Text:: *)
(*
	Sorts a grid in a smooth fashion so that when flattened there are no jumps
*)



GridSmoothSort[grid_List, sortBy_:None]:=
  Module[
    {
      dim=Dimensions[grid],
      restructured=GridPointRestructure[grid, sortBy]
      },
    Fold[
      With[{n=#2},
        MapIndexed[
          If[EvenQ[#2[[n]]], Reverse, Identity][#]&,
          #,
          {n}
          ]
        ]&,
      restructured,
      Range[Length[dim]-2]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*GridPointSmoothOrdering*)



(* ::Text:: *)
(*
	Provides a smooth gridpoint based reordering method. You gotta specify the grid sorting order but beyond that not much to do...
*)



GridPointSmoothOrdering[grid_List, sortBy_:None]:=
  Module[
    {
      gpos=GridPoints[grid],
      gridReordering=GridSmoothSort[grid, sortBy]
      },
    Flatten@
      Lookup[PositionIndex[gpos], GridPoints[gridReordering]]
    ];
GridPointSmoothOrdering[grid_, sortBy_:None]:=
  GridPointSmoothOrdering[grid["Grid"], sortBy];


(* ::Subsubsection::Closed:: *)
(*GridSubgrids*)



(* ::Text:: *)
(*
	This is probably the wrong name but we\[CloseCurlyQuote]ll roll with it for now...
*)



GridSubgrids[grid_List]:=
  Module[{dim=GridDimension[grid]},
    Map[
      Part[
        grid,
        Sequence@@
          Join[
            ConstantArray[1, #-1],
            {All},
            ConstantArray[1, dim-#],
            {#}
            ]
        ]&,
      Range[dim]
      ]
    ];
GridSubgrids[grid_]:=
  GridSubgrids[Normal@grid]


(* ::Subsubsection::Closed:: *)
(*GridProduct*)



(* ::Text:: *)
(*
	How exactly this should be done isn\[CloseCurlyQuote]t entirely clear... We want the Cartesian product of all of the passed grids but the dimension of each passed grid is unspecified...
	One way to handle this would be do decompose each grid into its subgrids and Cartesian product over those... but some of the passed grids might not be product grids to start out with...
	We\[CloseCurlyQuote]ll start out by trying a Map at the deepest nesting level of an Outer product grid, recursing until we have the deepest grid nesting level...?
	No need--it\[CloseCurlyQuote]s already handled by Outer
*)



GridProduct[grids__List]:=
  Outer[Join, 
    grids,
    Sequence@@
    Map[Depth[#]-2&, {grids}]
    ];
GridProduct[grids__CoordinateGridObject]:=
  GridProduct@@
    Map[#["Grid"]&, grids]


(* ::Subsubsection::Closed:: *)
(*GridJoin*)



GridJoin[grids__List]:=
  Module[{dims=Dimensions/@{grids}},
    If[Length@DeleteDuplicates[Rest/@dims]>1,
      PackageRaiseException[Automatic,
        "Grids with dimensions `` can't be joined",
        dims
        ]
      ];
    Join[grids]
    ];
GridJoin[grid1_CoordinateGridObject, grids__CoordinateGridObject]:=
  Module[{gs=#["Grid"]&/@{grids}},
    GridObjectModify[
      grid1,
      GridJoin[#, Sequence@@gs]&
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*GridScale*)



GridScale//Clear
GridScale[grid_List, n_]:=
  If[NumericQ[n],
    n*grid,
    GridMap[#*n&, grid]
    ];
GridScale[grid_CoordinateGridObject, scaling_]:=
  GridObjectModify[
    grid,
    GridScale[#, scaling]&
    ]


(* ::Subsubsection::Closed:: *)
(*GridShift*)



GridShift//Clear
GridShift[grid_List, n_]:=
  If[NumericQ[n],
    n+grid,
    GridMap[#+n&, grid]
    ];
GridShift[grid_CoordinateGridObject, shift_]:=
  GridObjectModify[
    grid,
    GridShift[#, shift]&
    ]


(* ::Subsection:: *)
(*Misc*)



(* ::Subsubsection::Closed:: *)
(*GridIndexFromStrides*)



GridIndexFromStrides[strides:{__Integer}, inds_]:=
  Module[
    {
      accstr,
      stride=strides,
      ind=inds-1,
      moddable,
      modres
      },
    accstr=
      N@
        Append[
          Reverse@FoldList[Times,strides[[-1;;2;;-1]]],
          1
          ];
    moddable=If[ListQ@inds,Map[ind/#&, accstr], ind/accstr];
    modres=1+Mod[Floor[moddable], stride];
    If[ListQ@inds, Transpose, Identity]@modres
    ]


(* ::Subsubsection::Closed:: *)
(*GridStridesToIndex*)



GridStridesToIndex[strides:{__Integer}, inds_]:=
  Module[
    {
      accstr,
      stride=strides,
      ind=inds-1
      },
    accstr=
      Append[
        Reverse@FoldList[Times, strides[[-1;;2;;-1]]],
        1
        ];
    ind.accstr+1
    ]


(* ::Subsection:: *)
(*Properties*)



(* ::Subsubsection::Closed:: *)
(*GridDimensions*)



GridDimensions[grid_List]:=
  Dimensions[grid][[;;-2]];
GridDimensions[grid_]:=
  GridDimensions@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridDimension*)



GridDimension[grid_List]:=
  Dimensions[grid][[-1]];
GridDimension[grid_]:=
  GridDimension@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridDepth*)



GridDepth[grid_List]:=
  GridDepth[grid]-1;
GridDepth[grid_]:=
  GridDepth@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridPointNumber*)



GridPointNumber[g_]:=
  Times@@GridDimensions[g];


(* ::Subsection:: *)
(*Functions*)



(* ::Text:: *)
(*
	Oh wait dis exis already wen i make GridTransform...
*)



GridMap[f_, g_List]:=
  Map[f, g, {Depth[g]-2}];
GridMap[f_, g_]:=
  GridMap[f, g["Grid"]];


GridCreateMapFunction[f_, g_]:=
  With[{map=GridMap[f, g]},
    GridFunctionObject[g, map]
    ];


(* ::Subsection:: *)
(*Mindless*)



GridBounds[g_List]:=
  CoordinateBounds[g];
GridBoundingBox[g_List]:=
  CoordinateBoundingBox[g];
GridBounds[g_]:=
  GridBounds[g["Grid"]];
GridBoundingBox[g_List]:=
  GridBoundingBox[g["Grid"]];


End[];



