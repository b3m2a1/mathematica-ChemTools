(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*Grid Tools*)



(* ::Text:: *)
(*
	Grid functions should all take an option specifying the axis for the operation
*)



(* ::Subsubsection::Closed:: *)
(*Constructors*)



ConstructCoordinateGrid;
CoordinateGridObjectQ;


(* ::Subsubsection::Closed:: *)
(*Parts*)



GridPart::usage=
  "Applies part to a wavefunction";
GridKeyPart::usage=
  "Applies key lookup to a coordinate grid";
GridSlice::usage=
  "Slices at level n";


(* ::Subsubsection::Closed:: *)
(*Structural*)



GridPoints::usage=
  "Flattens down to the coordiante points";
GridTransform::usage=
  "Applies a transformation to the coordinates points, maintaining ordering";
GridSort::usage=
  "";
GridTranspose::usage=
  "Takes a transpose of coordinates in the grid";
GridPermute::usage=
  "Permutes coordinates in the grid";


(* ::Subsubsection::Closed:: *)
(*Properties*)



GridDimension::usage=
  "";
GridDimensions::usage=
  "";
GridPointNumber::usage=
  "";
GridMeshSpacings=
  "Only makes sense for regularly sampled grids";
GridRegularlySampledQ=
  "";


(* ::Subsubsection::Closed:: *)
(*Functions*)



GridMap::usage=
  "Maps a function over the grid";
GridCreateMapFunction::usage=
  "Builds a GridFunctionObject by mapping over the grid";


(* ::Subsubsection::Closed:: *)
(*Mindless*)



GridBoundingBox::usage="";
GridBounds::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*Constructor*)



(* ::Subsubsection::Closed:: *)
(*ConstructGrid*)



(* ::Subsubsubsection::Closed:: *)
(*validateGridData*)



validateGridData[grid_]:=
  (*Developer`PackedArrayQ[grid]&&*)(* handled in cleanGridData *)
    Module[
      {
        d=Depth[grid],
        dim=Dimensions[grid],
        dn
        },
      If[d<=2,
        PackageRaiseException[
          Automatic,
          "grid data has insufficient depth to be valid"
          ]
        ];
      If[!(
        dn=grid[[Sequence@@ConstantArray[1, d-2]]];
        Length@dn==d-2
        ),
        PackageRaiseException[
          Automatic,
          "grid depth and grid dimension don't match"
          ],
        True
        ]
      ]


(* ::Subsubsubsection::Closed:: *)
(*cleanGridData*)



cleanGridData//Clear
cleanGridData[g_List]:=
  With[{base=Developer`ToPackedArray@N@g},
    If[!Developer`PackedArrayQ[base],
      base;
      PackageRaiseException[
        Automatic,
        "Grid data cannot be packed"
        ]
      ];
    If[Depth@base==2,
      Transpose@{base},
      base
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*ConstructCoordinateGrid*)



ConstructCoordinateGrid//Clear
ConstructCoordinateGrid[grid_List]:=
  With[{g=cleanGridData@grid},
    If[validateGridData[g],
      <|"Grid"->g|>,
      <|$Failed->True|> (* requires Association return to throw the error *)
      ]
    ];
ConstructCoordinateGrid[CoordinateGridObject[a_]?CoordinateGridObjectQ]:=
  a;
ConstructCoordinateGrid[a_Association]:=
  a;


(* ::Subsection:: *)
(*I am stupid*)



(* ::Subsubsection::Closed:: *)
(*GridObjectModify*)



GridObjectModify[g_, fn_]:=
  InterfaceModify[
    CoordinateGridObject,
    g,
    MapAt[
      fn,
      #, 
      "Grid"
      ]&
    ];


(* ::Subsection:: *)
(*Grid Parts*)



(* ::Subsubsection::Closed:: *)
(*CoordinateGridPart*)



GridPart[c:CoordinateGridObject[a_], p__]:=
  If[AllTrue[{p}, IntegerQ], Identity, CoordinateGridObject]@
    a[["Grid", p]]


(* ::Subsubsection::Closed:: *)
(*CoordinateGridKeyPart*)



GridKeyPart[c:CoordinateGridObject[a_], sel__]:=
  a[sel]


(* ::Subsection:: *)
(*Structural*)



(* ::Subsubsection::Closed:: *)
(*GridPoints*)



GridPoints[grid_List]:=
  Module[{d=Depth[grid]},
    Which[
      d>3,
        Flatten[grid, d-3],
      d==3,
        grid,
      d==2,
        List/@grid,
      d==1,
        PackageRaiseException["Grid",
          "Grid `` has depth 1...?",
          grid
          ]
      ]
    ];
GridPoints[grid_]:=
  GridPoints@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridTransform*)



GridTransform[grid_List, tf_]:=
  Module[{d=Depth[grid]},
    Which[
      d>3,
        Map[tf, grid, {d-2}],
      d==3,
        Map[tf, grid],
      d==2,
        Map[tf, List/@grid],
      d==1,
        PackageRaiseException["Grid",
          "Grid `` has depth 1...?",
          grid
          ]
      ]
    ];
GridTransform[grid_, tf_]:=
  InterfaceModify[
    CoordinateGridObject,
    grid,
    MapAt[
      GridTransform[#, tf]&,
      #, 
      "Grid"
      ]&
    ];


(* ::Subsubsection::Closed:: *)
(*GridPermute*)



iGridPermute[g_List, newIndices_]:=
  Module[{newGrid},
    If[GridDimension@g=!=Length@newIndices,
      PackageRaiseException[
        "Can't perform permutation `` on grid of dimension ``",
        newIndices,
        GridDimension@g
        ]
      ];
    If[Sort@newIndices=!=Range[Length@newIndices],
      PackageRaiseException[
        "Permutation `` loses coordinates ``",
        newIndices,
        Sort@
          Complement[Range[Length@newIndices], newIndices]
        ]
      ];
    newGrid=Transpose[g, newIndices];
    Part[newGrid,
      Sequence@@
        Append[
          ConstantArray[All, Depth[g]-2], 
          newIndices
          ]
      ]
    ];
GridPermute[g_List, newIndices_]:=
  PackageExceptionBlock["GridPermute"]@
    iGridPermute[g, newIndices];
GridPermute[g_CoordinateGridObject, newIndices_]:=
  PackageExceptionBlock["GridPermute"]@
    InterfaceModify[
      CoordinateGridObject,
      g,
      MapAt[
        GridPermute[#, newIndices]&,
        #, 
        "Grid"
        ]&
      ]


(* ::Subsubsection::Closed:: *)
(*GridSlice*)



GridSlice[g_List, n__Integer]:=
  Part[
    g,
    n,
    Sequence@@
      Append[
        ConstantArray[All, 
          Depth[g]-(2+Length[{n}])], 
          1+Length[{n}];;
          ]
    ];
GridSlice[g_, n__Integer]:=
  GridObjectModify[g, GridSlice[#, n]&];


(* ::Subsection:: *)
(*Properties*)



(* ::Subsubsection::Closed:: *)
(*GridDimensions*)



GridDimensions[grid_List]:=
  Dimensions[grid][[;;-2]];
GridDimensions[grid_]:=
  GridDimensions@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridDimension*)



GridDimension[grid_List]:=
  Dimensions[grid][[-1]];
GridDimension[grid_]:=
  GridDimension@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridDepth*)



GridDepth[grid_List]:=
  GridDepth[grid]-1;
GridDepth[grid_]:=
  GridDepth@grid["Grid"];


(* ::Subsubsection::Closed:: *)
(*GridPointNumber*)



GridPointNumber[g_]:=
  Times@@GridDimensions[g];


(* ::Subsection:: *)
(*Functions*)



GridMap[f_, g_List]:=
  Map[f, g, {Depth[g]-2}];
GridMap[f_, g_]:=
  GridMap[f, g["Grid"]];


GridCreateMapFunction[f_, g_]:=
  With[{map=GridMap[f, g]},
    GridFunctionObject[g, map]
    ];


(* ::Subsection:: *)
(*Mindless*)



GridBounds[g_List]:=
  CoordinateBounds[g];
GridBoundingBox[g_List]:=
  CoordinateBoundingBox[g];
GridBounds[g_]:=
  GridBounds[g["Grid"]];
GridBoundingBox[g_List]:=
  GridBoundingBox[g["Grid"]];


End[];



