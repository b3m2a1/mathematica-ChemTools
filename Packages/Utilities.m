(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemDataAtomQ::usage="Returns true for atom or isotope strings";
ChemDataIsotopeQ::usage="Returns true for isotope strings";


ChemHQuantumNumbers::usage=
	"Gives quantum numbers for an orbital configuration";
ChemHAngularWavefunction::usage=
	"Returns the angular part of the orbital wavefunction";
ChemHRadialWavefunction::usage=
	"Computes the radial part of the orbital wavefunction";
ChemHOrbital::usage=
	"Computes the input orbital";
ChemHOrbitalPlot::usage="Plots the orbital";


ChemHOrbitalSurface::usage="Computes the surface of a H orbital";
ChemHOrbitalVolume::usage="Computes the volume of an H orbital";


ChemUtilsDetectMolFormat::usage=
	"Detects a molecule format";
ChemUtilsGenerateZMatrix::usage=
	"Turns a list of atom-coordiante pairs into a ZMatrix";
ChemUtilsGenerateMolTable::usage=
	"Turns a ZMatrix into a list of atoms-coordinate pairs";
ChemUtilsGenerateMolRules::usage="Generates rules for a MOL file";
ChemUtilsGenerateMolString::usage="Converts atom list into MOL or SDF string";


ChemUtilsBondMatrix::usage=
	"Converts a bond list into a bond matrix";
ChemUtilsBondList::usage=
	"Converts a bond matrix into a bond list";
ChemUtilsGuessBonds::usage=
	"Attempts to resolve the bonding structure of a collection of atoms";


ChemUtilsInertialEigensystem::usage=
	"Returns the inertial eigensystem for a collection of masses and positions";
ChemUtilsInertialSystem::usage=
	"Returns the A, B, and C constants and axes";
ChemUtilsRotorType::usage=
	"Returns the type of molecular rotor that best resembles the collection of atoms";


ChemUtilsCoordinateBounds::usage=
	"The bounding box of a collection of atoms";
ChemUtilsCenter::usage="Center of a set of atoms";
ChemUtilsCenterOfMass::usage="COM of a set of atoms";


ChemUtilsIsotopologues::usage=
	"Figures out all possible isotopologues and abundances of a given atomset";


ChemUtilsSymmetryElements::usage=
	"Finds all the symmetry elements of a collection of atoms";


ChemUtilsSymmetryGraphics::usage=
	"Plots a collection of symmetry elements";
ChemUtilsInertialSymmetry::usage=
	"Finds symmetry elements relative to the ABC axes";
ChemUtilsPointGroup::usage=
	"Guesses the point group of the collection of atoms";


ChemUtilsAxisAlignmentTransform::usage=
	"Alignment transform mapping points";


Begin["`Private`"];


ChemDataIsotopeQ[s_String]:=
	ChemDataSource[s]===IsotopeData;
ChemDataAtomQ[s_String]:=
	MatchQ[ChemDataSource[s],
		ElementData|IsotopeData|"CustomAtoms"
		];
ChemDataIsotopeQ[__]:=False


(* ::Subsection:: *)
(*H-Orbitals*)



ChemHQuantumNumbers[primary_String,sub_String:""]:=
	Replace[
		{ToLowerCase@primary,ToLowerCase@sub},{
			{"s",""}->{0,0},
			{"p","x"}->{1,-1},
			{"p","z"|""}->{1,0},
			{"p","y"}->{1,1},
			{"d","xy"}->{2,-2},
			{"d","xz"}->{2,-1},
			{"d","z"|""}->{2,0},
			{"d","yz"}->{2,1},
			{"d","x-y"}->{2,2},
			{"f","z"|""}->{3,0},
			_->$Failed
			}
		]


sphericalHarmonic[{l_Integer,m_Integer:0}]:=
	If[l>=0,
		With[{s=SphericalHarmonicY[l,m,#,#2]},
			(s&)
			],
		With[{s=SphericalHarmonicY[-l,-m,#,#2]},
			(-s&)
			]
		];


harmonicCombination[k:_Real|_Complex:1,harmonics__List]:=
	With[{f=k*(
		Total@(
			Table[sphericalHarmonic[h][#,#2],{h,{harmonics}}])/Sqrt@Length@{harmonics})
			},
		f&
		];


angularWavefunction[l_,m_]:=
	Which[
		m>0,
			harmonicCombination[{l,-m},-{l,m}],
		m==0,
			sphericalHarmonic[{l,m}],
		m<0,
			harmonicCombination[{l,-m},{l,m}]
		];


ChemHAngularWavefunction[l_Integer,m_Integer]:=
	angularWavefunction[l,m];
ChemHAngularWavefunction[l_String,m_String:""]:=
	angularWavefunction@@ChemHQuantumNumbers[l,m];


bohrRadius=
	QuantityMagnitude@UnitConvert[Quantity["BohrRadius"],"Angstroms"];


radialWavefunction[n_,l_,Z_Integer:1]:=
	Evaluate[
		(Sqrt[(n-l-1)!/(2*n*((n+l)!)^3)])*
		((2Z/(n*bohrRadius))^(l+3/2))*
		(#^l)Exp[-Z#/(n*bohrRadius)]*
		LaguerreL[n+l-1,2l+1,2Z #/(n*bohrRadius)]
		]&


ChemHRadialWavefunction[n_Integer,l_Integer,Z_Integer:1]:=
	radialWavefunction[n,l,Z];
ChemHRadialWavefunction[l_String,m_String:"",Z_Integer:1]:=
	radialWavefunction@@
		Replace[ChemHQuantumNumbers[l,m],{a_,b_}:>{a+1,a,Z}];


ChemHOrbital[n:_Integer|Automatic:Automatic,l_Integer,m_Integer]:=
	With[{qn=Replace[n,Automatic->l+1]},
		With[{
			f=radialWavefunction[qn,l][#],
			f2=angularWavefunction[l,m][#2,#3]},
			f*f2&
			]
		];
ChemHOrbital[n_:Automatic,l_String,m_String:""]:=
	ChemHOrbital[n,Sequence@@ChemHQuantumNumbers[l,m]];


ChemHOrbitalPlot[
	{n_,m_,l_},
	densityCutoff:_Real|Automatic:Automatic,
	DensityPlot3D,
	radial:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
	azimuthal:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
	polar:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
	o:OptionsPattern[Options@DensityPlot3D]]:=
	With[{c2s=
		CoordinateTransform["Cartesian"->"Spherical",{#,#2,#3}],
		rRange=Replace[radial,Automatic:>{0,n+1.25}],
		qRange=Replace[azimuthal,Automatic->{0,2\[Pi]}],
		jRange=Replace[polar,Automatic->{0,\[Pi]}]},
	With[{
		f=ChemHOrbital[n,m,l]@@(c2s&[\[Rho],\[Theta],\[CurlyPhi]]),
		rf=With[{r=Last@rRange},(#\[Element]Ball[{0,0,0},r]&)],
		opf=
			If[densityCutoff=!=Automatic,
				(If[#>densityCutoff,1,0]&),
				(If[#<.5,#/2,Mean@{#,1},Mean@{#,0}]&)
				]},
		DensityPlot3D[
			Abs[f]^2,
			Evaluate@
				If[rRange[[1]]==0&&qRange=={0,2\[Pi]}&&jRange=={0,\[Pi]},
					With[{r=Last@rRange},
						{\[Rho],\[Theta],\[CurlyPhi]}\[Element]Ball[{0,0,0},r]],
					Sequence@@
						{
							{\[Rho],-Last@rRange,Last@rRange},
							{\[Theta],-Last@qRange,Last@qRange},
							{\[CurlyPhi],-Last@jRange,Last@jRange}
							}
				],
			o,
			PlotRange->All,
			Boxed->False,
			(*RegionFunction\[Rule]rf,*)
			OpacityFunction->opf,
			Axes->False,
			AxesOrigin->{0,0,0}
			MeshFunctions->(Function/@c2s)
			]
		]
		];


ChemHOrbitalPlot[
		{n_,m_,l_},
		contourValue:_Real|Automatic:Automatic,
		ContourPlot3D,
		radial:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
		azimuthal:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
		polar:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
		o:OptionsPattern[Options@ContourPlot3D]
		]:=
	With[{c2s=
		CoordinateTransform["Cartesian"->"Spherical",{#,#2,#3}],
		rRange=Replace[radial,Automatic:>{0,n+1.25}],
		qRange=Replace[azimuthal,Automatic->{0,2\[Pi]}],
		jRange=Replace[polar,Automatic->{0,\[Pi]}]},
	With[{
		rf=With[{r=Last@rRange},(#\[Element]Ball[{0,0,0},r]&)],
		f=ChemHOrbital[n,m,l]@@(c2s&[\[Rho],\[Theta],\[CurlyPhi]])
		},
		Quiet@ContourPlot3D[
			Evaluate@
				If[contourValue===Automatic,
					Abs[f]^2,
					Abs[f]^2==contourValue
					],
			{\[Rho],-Last@rRange,Last@rRange},
			{\[Theta],-Last@qRange,Last@qRange},
			{\[CurlyPhi],-Last@jRange,Last@jRange},
			o,
			Contours->1,
			Lighting->"Neutral",
			ContourStyle->Directive[Hue[.5,.4,.3],Specularity[White,500]],
			PlotPoints->20,
			PlotRange->All,
			Boxed->False,
			Axes->False,
			AxesOrigin->{0,0,0},
			MeshFunctions->(Function/@c2s),
			MeshStyle->None
			]
		]
		];


ChemHOrbitalPlot[
		{n_,m_,l_},
		cutoff:_Real:.0005,
		Optional[RegionPlot3D,RegionPlot3D],
		radial:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
		azimuthal:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
		polar:{_?NumericQ,_?NumericQ}|Automatic:Automatic,
		o:OptionsPattern[Options@ContourPlot3D]
		]:=
	With[{c2s=
		CoordinateTransform["Cartesian"->"Spherical",{#,#2,#3}],
		rRange=Replace[radial,Automatic:>{0,n+1.25}],
		qRange=Replace[azimuthal,Automatic->{0,2\[Pi]}],
		jRange=Replace[polar,Automatic->{0,\[Pi]}]},
	With[{
		rf=With[{r=Last@rRange},(#\[Element]Ball[{0,0,0},r]&)],
		f=ChemHOrbital[n,m,l]@@(c2s&[\[Rho],\[Theta],\[CurlyPhi]])
		},
		Quiet@RegionPlot3D[
			Abs[f]^2>cutoff,
			{\[Rho],-Last@rRange,Last@rRange},
			{\[Theta],-Last@qRange,Last@qRange},
			{\[CurlyPhi],-Last@jRange,Last@jRange},
			o,
			Lighting->"Neutral",
			PlotStyle->Directive[Hue[.5,.4,.3],Specularity[White,500]],
			PlotPoints->20,
			PlotRange->All,
			Boxed->False,
			Axes->False,
			AxesOrigin->{0,0,0},
			MeshFunctions->(Function/@c2s),
			MeshStyle->None
			]
		]
		];


ChemHOrbitalPlot[s__String,a:Except[_String]...]:=
	ChemHOrbitalPlot[
		Replace[ChemHQuantumNumbers[s],
			{l_,m_}:>{l+1,l,m}],
		a
		];


ChemHOrbitalSurface[{n_,l_,m_},cutoff_Real:.001]:=
	ChemSurface@ChemHOrbitalPlot[{n,l,m},cutoff,RegionPlot3D];
ChemHOrbitalSurface[l_String,m_String:"",cutoff_Real:.001]:=
	ChemSurface@ChemHOrbitalPlot[l,m,cutoff,RegionPlot3D];


ChemHOrbitalVolume[s_?RegionQ]:=
	Quantity[
		With[
			{coords = MeshCoordinates[s]},
			With[{
				compiledDotCross=
					Compile[{{abc,_Integer,1}},
						coords[[ abc[[1]] ]].
								Cross[coords[[ abc[[2]] ]], coords[[ abc[[3]] ]]]
						]
					},
				(MeshCells[s, 2]/.Polygon[g_List] :> compiledDotCross@g)
					//Total
				]/6
			],
		"Angstroms"^3
		];


ChemHOrbitalVolume[s__]:=
	ChemHOrbitalVolume@
		ChemHOrbitalSurface[s];	


(* ::Subsection:: *)
(*Conversion Utils*)



ChemUtilsDetectMolFormat[s_String]:=
	Which[
		StringStartsQ[s,"InChI"],
			"InChI",
		Length@StringCases[s,"\n"]===0,
			"SMILES",
		Length@StringCases[s,"M  END"]===1,
			"MOL",
		Length@StringCases[s,"M  END"]>1,
			"SDF",
		StringStartsQ[StringTrim[s], LetterQ..~~"\n"],
			"ZMatrix",
		True,
			$Failed
		];
ChemUtilsDetectMolFormat[l_List]:=
	Switch[l,
		{
			Optional[{_Integer,_Integer},{0,0}],
			{_String,_List,___}..,
			{_Integer,_Integer,___}...
			},
			"MOL",
		{
			{_String},
			{_String, _Integer, __?NumericQ}...
			},
			"ZMatrix",
		{
			Repeated[{
				Optional[{_Integer,_Integer},{0,0}],
				{_String,_List,___}..,
				{_Integer,_Integer,___}...
				}]
			},
			"SDF",
		{
			Repeated[_->{__List}]
			},
			"SDFRules",
		{
			Repeated[_->_List]
			},
			"MOLRules",
		_,
			$Failed
		]


zmNorm=
	Function[{crd1,crd2},
		Norm[crd2-crd1]
		];
zmVAngle=
	Function[{crd1,crd2,crd3},
		VectorAngle[
			crd2-crd3,
			crd2-crd1
			]*180/\[Pi]
		];
zmDAngle=
	Function[{crd1,crd2,crd3,crd4},
		With[{caxis=crd3-crd2},
			VectorAngle[
				Cross[crd4-crd3,caxis],
				Cross[crd2-crd1,-caxis]
				]*180/\[Pi]
			]
		];


zmatrixEntry[atom_,previousAtoms_]:=
	Switch[Length@previousAtoms,
		0,
			{First@atom},
		1,
			{First@atom,
				1,zmNorm[
						Last@atom,
						Last@previousAtoms[[-1]]
						]
				},
		2,
			{First@atom,
				2,zmNorm[
						Last@atom,
						Last@previousAtoms[[-1]]
						],
				1,zmVAngle[
						Last@atom,
						Last@previousAtoms[[-1]],
						Last@previousAtoms[[-2]]
						]
				},
		_,
			{First@atom,
				Length@previousAtoms,
					zmNorm[
						Last@atom,
						Last@previousAtoms[[-1]]
						],
				Length@previousAtoms-1,
					zmVAngle[
						Last@atom,
						Last@previousAtoms[[-1]],
						Last@previousAtoms[[-2]]
						],
				Length@previousAtoms-2,
					zmDAngle[
						Last@atom,
						Last@previousAtoms[[-1]],
						Last@previousAtoms[[-2]],
						Last@previousAtoms[[-3]]
						]
				}
		];


ChemUtilsGenerateZMatrix[atoms_List]:=
	MapIndexed[zmatrixEntry[#,Take[atoms,First@#2-1]]&,atoms]


molTableNormed=
	Function[{crd1,crd2,norm},
		crd1+norm*Normalize[crd2-crd1]
		];
molTableVAngled=
	Function[{crd1,crd2,rv,angle},
		crd1+RotationMatrix[angle,rv].(crd2-crd1)
		];
molTableDAngled=
	Function[{crd1,crd2,crd3,angle},
		With[{caxis=crd2-crd1},
			crd1+RotationMatrix[angle,Cross[caxis,(crd3-crd1)]].(caxis)
			]
		];


molTableEntry[line_,previousAtoms_]:=
	Switch[Length@previousAtoms,
		0,
			{line[[1]],
				{0.,0.,0.}
				},
		1,
			{line[[1]],
				With[{crd1=previousAtoms[[line[[2]],2]],n=line[[3]]},
					crd1+{0,0,n}
					]
				},
		2,
			{line[[1]],
				With[{
					crd1=previousAtoms[[line[[2]],2]],n=line[[3]],
					crd2=previousAtoms[[line[[4]],2]],a=line[[5]]},
					crd1+n*Normalize[RotationMatrix[a,{1,0,0}].(crd2-crd1)]
					]
				},
		_,
			{line[[1]],
				With[{
					crd1=previousAtoms[[line[[2]],2]],n=line[[3]],
					crd2=previousAtoms[[line[[4]],2]],a=line[[5]],
					crd3=previousAtoms[[line[[6]],2]],d=line[[7]]},
						crd1+
							n*Normalize[
									RotationMatrix[d,(crd2-crd1)].
										RotationMatrix[a,Cross[(crd2-crd1),(crd3-crd1)]].
											(crd2-crd1)
									]
					]
					
				}
		];


ChemUtilsGenerateMolTable[zmMatrix:{{_String},___List}]:=
	Fold[Append[#,molTableEntry[#2,#]]&,{},zmMatrix]


ChemUtilsGenerateMolRules[
	molTable:{
		Optional[{_Integer,_Integer},{0,0}],
		atoms:{_String,_List,___}..,
		bonds:{_Integer,_Integer,___}...
		}
	]:=
	{
		"VertexTypes"->{atoms}[[All,1]],
		"VertexCoordinates"->{atoms}[[All,2]],
		"EdgeRules"->
			Rule@@@{bonds}[[All,;;2]],
		"EdgeTypes"->
			Replace[{bonds}[[All,-1]],
				{
					1->"Single",
					2->"Double",
					3->"Triple",
					_->"Single"
					},
				1
				],
		"FormalCharges"->
			Replace[{atoms},{{_,_,_,c_}:>c,_->0},1]
		}


ChemUtilsGenerateMolRules[
	molTables:{
		Repeated@
			{
				Optional[{_Integer,_Integer},{0,0}],
				{_String,_List,___}..,
				{_Integer,_Integer,___}...
				}
		}
	]:=
	Thread[
		{"VertexTypes","VertexCoordinates",
			"EdgeTypes","EdgeRules","FormalCharges"}->
		Lookup[
			ChemUtilsGenerateMolRules/@molTables,
			{"VertexTypes","VertexCoordinates",
				"EdgeTypes","EdgeRules","FormalCharges"}
			]
		]


ChemUtilsGenerateMolRules[
	zm_List?(ChemUtilsDetectMolFormat[#]==="ZMatrix"&)
	]:=
	ChemUtilsGenerateMolRules@
		ChemUtilsGenerateMolTable[zm]


ChemUtilsGenerateMolString[
	molTable:
		{
			Optional[{_Integer,_Integer},{0,0}],
			{_String,_List,___}..,
			{_Integer,_Integer,___}...
			}
	]:=
	StringDelete[
		StartOfLine~~
			"Created with the Wolfram Language : www.wolfram.com"
			~~EndOfLine
		]@
		ExportString[
			ChemUtilsGenerateMolRules[molTable],
			{"MOL","Rules"}
			];
ChemUtilsGenerateMolString[
	molTables:{
		Repeated@
			{
				Optional[{_Integer,_Integer},{0,0}],
				{_String,_List,___}..,
				{_Integer,_Integer,___}...
				}
		}
	]:=
	StringDelete[
		StartOfLine~~
			"Created with the Wolfram Language : www.wolfram.com"
			~~EndOfLine
		]@
		ExportString[
			ChemUtilsGenerateMolRules[molTables],
			{"SDF","Rules"}
			]
ChemUtilsGenerateMolString[
	zm_List?(ChemUtilsDetectMolFormat[#]==="ZMatrix"&)
	]:=
	StringDelete[
		StartOfLine~~
			"Created with the Wolfram Language : www.wolfram.com"
			~~EndOfLine
		]@
		ExportString[
			ChemUtilsGenerateMolRules@zm,
			{"MOL","Rules"}
			];
ChemUtilsGenerateMolString[
	mol_List?(OptionQ[#]&&ChemUtilsDetectMolFormat[#]==="MOLRules"&)
	]:=
	StringDelete[
		StartOfLine~~
			"Created with the Wolfram Language : www.wolfram.com"
			~~EndOfLine
		]@
		ExportString[mol,{"MOL","Rules"}];
ChemUtilsGenerateMolString[
	mol_List?(OptionQ[#]&&ChemUtilsDetectMolFormat[#]==="SDFRules"&)
	]:=
	StringDelete[
		StartOfLine~~
			"Created with the Wolfram Language : www.wolfram.com"
			~~EndOfLine
		]@
		ExportString[mol,{"SDF","Rules"}];


(* ::Subsection:: *)
(*Structural Utils*)



ChemUtilsInertialTensor[masses_List,positions_List]:=
	Total@MapThread[
		With[{m=#1,x=#2[[1]],y=#2[[2]],z=#2[[3]]},
			m*{ 
				{y^2+z^2,-x*y,-x*z},
				{-x*y,x^2+z^2,-y*z},
				{-x*z,-y*z,x^2+y^2}
			}]&,{masses,positions}
		];
ChemUtilsInertialTensor[massPositions:{{_Real,_List},___}]:=
	ChemUtilsInertialTensor[massPositions[[All,1]],massPositions[[All,2]]];
ChemUtilsInertialTensor[massPositions:{{_String,_List},___}]:=
	ChemUtilsInertialTensor@
		Map[{QuantityMagnitude@ChemDataLookup[First@#,"AtomicMass"],Last@#}&,massPositions];


ChemUtilsInertialEigensystem[args__]:=
	Replace[ChemUtilsInertialTensor[args],
		tensor:{_List,_List,_List}:>
			With[{eig=Eigensystem@tensor},
				With[{ord=Ordering@First@eig},
					{eig[[1,ord]],eig[[2,ord]]}
					]
				]
		];


inertConversion=
	Block[{$ChemDataSourcesDontCacheFlag=True},
		QuantityMagnitude@
			ChemDataLookup[
				"InertialConstant",
				"UnitConversions"
				]
		];
ChemDataLookup["InertialConstant","UnitConversions"]=.


ChemUtilsInertialSystem[{{ia_,ib_,ic_},{ax_,bx_,cx_}}]:=
	<|
		"A"->Replace[ia,{0|0.->\[Infinity],e_:>inertConversion/e}],
		"B"->Replace[ib,{0|0.->\[Infinity],e_:>inertConversion/e}],
		"C"->Replace[ic,{0|0.->\[Infinity],e_:>inertConversion/e}],
		"AAxis"->ax,
		"BAxis"->bx,
		"CAxis"->cx,
		"Units"->Quantity[1,"Megahertz"]
		|>;
ChemUtilsInertialSystem[e__]:=
	ChemUtilsInertialSystem@ChemUtilsInertialEigensystem[e]


ChemUtilsCenter[atoms_]:=
	Mean@Map[Last,atoms];


ChemUtilsCenterOfMass[masses_,positions_]:=
	Mean@WeightedData[positions,masses];
ChemUtilsCenterOfMass[atoms:{{_Real,_},___}]:=
	ChemUtilsCenterOfMass[First/@atoms,Last/@atoms];
ChemUtilsCenterOfMass[atoms:{{_String,_},___}]:=
	ChemUtilsCenterOfMass@
		Map[{QuantityMagnitude@ChemDataLookup[First@#,"AtomicMass"],Last@#}&,
			atoms];


ChemUtilsRotorType[Ic_?NumericQ,Ib_?NumericQ,Ia_?NumericQ]:=
	If[Ia<10^-5,
		"Linear",
		With[{ac=Ic/Ia,ab=Ib/Ia,bc=Ic/Ib},
			Which[
				Max@{ac,ab,bc}<2,
					"Spherical",
				ab<2,
					"Oblate",
				bc<2,
					"Prolate",
				True,
					None
				]
			]
		];
ChemUtilsRotorType[{{Ia_?NumericQ,Ib_?NumericQ,Ic_?NumericQ},_}]:=
	ChemUtilsRotorType[Ia,Ib,Ic];
ChemUtilsRotorType[a:{{_Real,_List},___}]:=
	ChemUtilsRotorType@ChemUtilsInertialEigensystem[a];
ChemUtilsRotorType[a:{{_String,_List},___}]:=
	ChemUtilsRotorType@
		Map[{
			QuantityMagnitude@ChemDataLookup[First@#,"AtomicMass"],
			Last@#}&,a];


ChemUtilsCoordinateBounds[
	atoms:{
		{_String,{_?NumericQ,_?NumericQ,_?NumericQ}}..
		},
	padding:_?NumericQ:0
	]:=
	Module[{
		rads=
			QuantityMagnitude/@
				UnitConvert[ChemDataLookup[First/@atoms,"Radius"],"Angstroms"],
		pos=Last/@atoms,
		moves=Tuples[{1,-1},3]
		},
		pos=
			Flatten[
				MapThread[
					With[{
						base=#*moves,
						p=#2
						},
						p+#&/@base
						]&,{
					rads+padding,
					pos
					}],
				1
				];
		CoordinateBounds@pos
		];


ChemUtilsAxisAlignmentTransform//Clear


axisPattern=
	"X"|"Y"|"Z"|{_?NumericQ,_?NumericQ,_?NumericQ};


ChemUtilsAxisAlignmentTransform[
	a:(axisPattern->axisPattern),
	b:(axisPattern->axisPattern)|None:None,
	point:axisPattern:{0,0,0}
	]:=
	With[{
		rotation1=
			Replace[a,
				(ax1_->ax2_):>
					Replace[{ax1,ax2},{
						"X"->{1,0,0},
						"Y"->{0,1,0},
						"Z"->{0,0,1}
						},
						1]
				],
		center=
			Replace[point,
				{
					"X"->{1,0,0},
					"Y"->{0,1,0},
					"Z"->{0,0,1}
					}
				]
		},
		Replace[b,{
			(ax1_->ax2_):>
				With[{
					t1=
						If[MatchQ[rotation1,{_List,_List}],
							If[MatrixRank@rotation1==2,
								RotationTransform[rotation1,center],
								Identity
								],
							Identity
							]
					},
					With[{
						t2=
							RotationTransform[
								{t1@First@#,Last@#}&@
									Replace[{ax1,ax2},
										{
											"X"->{1,0,0},
											"Y"->{0,1,0},
											"Z"->{0,0,1}
											},
										1],
								center
								]
						},
						If[t1===Identity,
							t2,
							Simplify@Composition[t2,t1]
							]
						]
					],
			_->
				Replace[rotation1,
					{u_,v_}:>
						Which[
							MatrixRank@{u,v}==2,
								RotationTransform[{u,v},center],
							u==-v,
								(*
							Need a better way to handle this. 
							Should maybe be some form of inversion? 
							*)
								RotationTransform[{u,v},center],
							True,
								None
							]
					]
			}]
	]


ChemUtilsAlignmentTransform//Clear


pt="X"|"Y"|"Z"|{_?NumericQ,_?NumericQ,_?NumericQ};


ChemUtilsAlignmentTransform[
	a:{Repeated[pt,3]}->
		b:{Repeated[pt,3]}
	]:=
	With[{
		pos=Replace[Join[a,b],{"X"->{1,0,0},"Y"->{0,1,0},"Z"->{0,0,1}},1]
		},
		Simplify@
			Composition[
				ChemUtilsAxisAlignmentTransform[
					pos[[1]]-pos[[2]]->pos[[4]]-pos[[5]],
					pos[[1]]-pos[[3]]->pos[[4]]-pos[[6]],
					pos[[4]]
					],
				TranslationTransform[pos[[4]]-pos[[1]]]
				]
		];
ChemUtilsAlignmentTransform[
	a:{{_?StringQ|_?NumericQ,{_?NumericQ,_?NumericQ,_?NumericQ}},___}->
		b:{{_?StringQ|_?NumericQ,{_?NumericQ,_?NumericQ,_?NumericQ}},___}
	]:=
	With[{
		sys1=
			ChemUtilsInertialSystem[a],
		com1=
			ChemUtilsCenterOfMass[a],
		sys2=
			ChemUtilsInertialSystem[b],
		com2=
			ChemUtilsCenterOfMass[b]
		},
		ChemUtilsAlignmentTransform[
			{com1,com1+sys1["AAxis"],com2+sys1["BAxis"]}->
				{com2,com2+sys2["AAxis"],com2+sys2["BAxis"]}
			]
		];


(* ::Subsection:: *)
(*Misc Utils*)



ChemUtilsIsotopologues[atoms_List,
	abundanceMin_:.0000000001
	]:=
	With[{
		reps=
			Replace[atoms,
				{
					{el_?(Not@*ChemDataIsotopeQ),p_}:>
						Map[{el,p}->{Last@#,p}&,
							Pick[#,
								#>=abundanceMin&/@
									ChemDataLookup[#,"IsotopeAbundance",IsotopeData]
								]&@ChemDataLookup[el,None,IsotopeData]
							],
					_->Nothing
					},
				1]
		},
		Reverse@Sort@Select[
			AssociationMap[
				Times@@Map[ChemDataLookup[First@#,"IsotopeAbundance",IsotopeData]&,#]&,
				Map[atoms/.#&,Tuples@reps]
				],
			#>abundanceMin&
			]
		];


(* ::Subsection:: *)
(*Bonding Utils*)



(* ::Subsubsection::Closed:: *)
(*BondMatrix*)



ChemUtilsBondMatrix[list_]:=
	With[{atoms=#[[;;2]]&/@list},
		Table[
			If[i==j,
				0,
				FirstCase[list,{i_,j_,v_}:>v,0]
				],
			{i,Max@atoms},{j,Max@atoms}
			]
		];


(* ::Subsubsection::Closed:: *)
(*BondList*)



ChemUtilsBondList[mx_]:=
	Replace[
		Select[
			Position[mx,_?(#>0&)],
				First@#<Last@#&
				],
		{i_,j_}:>{i,j,mx[[i,j]]},
		1];


(* ::Subsubsection::Closed:: *)
(*GuessBonds*)



guessBondsAdjustRowUp[i_,mx_,inRange_,valences_]:=
Block[{
		bondingMatrix=mx,
		valenceTotals=Total/@mx
		},
		Do[
			If[inRange[[i,j]],
				If[
					AnyTrue[
						Replace[valences[[i]],v_Integer:>{v}],
						valenceTotals[[i]]<#&]
						&&
					AnyTrue[
						Replace[valences[[j]],v_Integer:>{v}],
						valenceTotals[[j]]<#&],
					If[mx[[i,j]]<3,
						bondingMatrix[[i,j]]=bondingMatrix[[j,i]]=
							mx[[i,j]]+1;
						valenceTotals[[j]]++;
						valenceTotals[[i]]++;
						]
					]
				],
			{j,
				Reverse@
					SortBy[
						Range[Length@mx],
						Replace[valences[[i]],{v_,_}:>v,1]
						]}
			];
		bondingMatrix
		];


guessBondsAdjustRowDown[i_,mx_,inRange_,valences_]:=
	Block[{
		bondingMatrix=mx,
		valenceTotal=Total@mx[[i]],
		valence=valences[[i]]
		},
		Do[
			If[
				mx[[i,j]]>0&&
				AnyTrue[
					Replace[valences[[j]],v_Integer:>{v}],
					valenceTotal+mx[[i,j]]>#&],
				With[{diff=valenceTotal+mx[[i,j]]-valence},
					valenceTotal-=diff;
					bondingMatrix[[i,j]]=bondingMatrix[[j,i]]=
						mx[[i,j]]-diff
					]
				],
			{j,
				SortBy[
					Range[Length@mx],
					Replace[valences[[i]],{v_,_}:>v,1]
					]}
			];
		bondingMatrix
		];


guessBondsAdjustBondingMatrix[mx_,inRange_,valences_,order_]:=
	Block[{bondingMatrix=mx},
		Do[
			With[{
				vt=Total@mx[[i]],
				vals=Replace[valences[[i]],v_Integer:>{v}]},
				Which[
					AnyTrue[vals,vt==#&],
						Null,
					vt>First@Nearest[vals,vt],
						bondingMatrix=
							guessBondsAdjustRowDown[i,bondingMatrix,inRange,valences],
					vt<First@Nearest[vals,vt],
						bondingMatrix=
							guessBondsAdjustRowUp[i,bondingMatrix,inRange,valences]
					]
				],
			{i,
				Replace[order,{
					True->
						Range[Length@mx,1,-1],
					False->
						Length@mx
					}]}
			];
		bondingMatrix
		];


guessBondsCheckBondingMatrix[mx_,inRange_,valences_,goal_]:=
	MapThread[
		If[MatchQ[#2,_Integer],
			Total@#==#2,
			MemberQ[#2,Total@#]
			]&,
		{mx,valences}];


guessBondsDetermineBondsStep[mx_,
	inRange_,valences_,goal_,order_]:=
	With[{bm=guessBondsAdjustBondingMatrix[mx,inRange,valences,order]},
		If[Not@*And@@guessBondsCheckBondingMatrix[bm,inRange,valences,goal],
			Block[{
				bondingMatrix=bm,
				vs=
					guessBondsCheckBondingMatrix[bm,inRange,valences,goal]
				},
				If[mx==bm,
					Do[
						If[!vs[[i]],
							Replace[Flatten@Position[inRange[[i]],True],
								c:{__}:>
								Replace[
									DeleteDuplicates@
										Map[Sort]@
											Apply[Join]@
												Map[
													Thread[{#,
														DeleteCases[
															Flatten@Position[inRange[[#]],True],
															i]
														}]&,
													c
													],
									p:{__}:>
										With[{pair=RandomChoice@p},
											bondingMatrix[[Sequence@@pair]]=
												bondingMatrix[[Sequence@@Reverse@pair]]=0
											]
										]
								]
							],
						{i,Length@vs}
						];
					];
				"Continue"->{
					bondingMatrix,
					vs
					}
				],
			"Final"->bm
			]
		];


guessBonds[atoms_,tol_,iters_,multiValent_,goal_,log_]:=
	With[{
		inRange=
			Table[
				i!=j&&
				Norm[Subtract@@(Last@atoms[[#]]&/@{i,j})]<=
					With[{d=
						ChemDataLookup[
							{First@atoms[[i]],First@atoms[[j]],1},
							"BondDistances"]},
						d+Replace[tol,Scaled[p_]:>d*p]
						],
				{i,Length@atoms},
				{j,Length@atoms}
				],
		valences=
			With[{v=First@ChemDataLookup[First@#,"ElementValences"]},
				Replace[multiValent,{
					r:{(_Rule|_RuleDelayed)..}|_Association:>
						Prepend[
							Lookup[multiValent,First@#,{}],
							v],
					_->v
					}]
				]&/@atoms
		},
		If[log,
			Map[
				Replace[{
					("Continue"->{m_,___}):>m,
					("Final"->m_):>m
					}]
				]@*
				Map[
					Replace[{f___,l:("Final"->_),___}:>{f,l}]
					],
			Replace[{
				("Continue"->{m_,___}):>m,
				("Final"->m_):>m
				}]
			]@
			If[log,NestList,Nest][
				Replace[{
					("Continue"->{m1_,vs_}):>
						guessBondsDetermineBondsStep[
							m1,inRange,valences,goal,
							SortBy[Range[Length@m1],
								Switch[vs[[#]],True,1,False,0]&
								]
							],
					("Final"->m_):>
						("Final"->m),
					m_:>
						guessBondsDetermineBondsStep[m,inRange,valences,goal,False]
					}],
				ReplaceAll[inRange,{True->1,False->0}],
				iters
				]	
		];


Options[ChemUtilsGuessBonds]={
	MaxIterations->10,
	Tolerance->.075,
	"Charge"->0,
	"PriorityFunction"->(Switch[First@#,"H",0,"C",1,_,2]&),
	"LogSteps"->False,
	"MultiValences"->None,
	"MakeBondLists"->True
	};
ChemUtilsGuessBonds[
	sourceAtoms:{{_String,{__?NumericQ}}..},
	ops:OptionsPattern[]]:=
	With[{
		atoms=SortBy[sourceAtoms,OptionValue@"PriorityFunction"],
		tol=OptionValue@Tolerance,
		iters=OptionValue@MaxIterations,
		goal=
			Replace[OptionValue@"Charge",{
				r_Real:>Ceiling@r,
				Except[_Integer]->1
				}],
		log=TrueQ@OptionValue@"LogSteps",
		multi=
			Replace[OptionValue@"MultiValences",{
				Automatic:>
					Map[ChemDataLookup[First@#,"ElementValences"]&,
						sourceAtoms
						]
				}],
		makeLists=OptionValue@"MakeBondLists"
		},
		If[log,
			<|
				"Atoms"->atoms,
				"Bonds"->
					If[makeLists===False,
						#,
						ChemUtilsBondList@#
						]
				|>&/@
					guessBonds[atoms,tol,iters,multi,goal,log],
			<|
				"Atoms"->atoms,
				"Bonds"->
					If[makeLists===False,
						guessBonds[atoms,tol,iters,multi,goal,log],
						ChemUtilsBondList@
							guessBonds[atoms,tol,iters,multi,goal,log]
						]
				|>
			]
		]


(* ::Subsection:: *)
(*Symmetry Utils*)



(* ::Subsubsection::Closed:: *)
(*symmetricPointQ*)



(* ::Text:: *)
(*Might be worth having a symmetry tester for each group*)



symmetricPointQ=
	Compile[
		{
			{p, _Real, 1},
			{opos, _Real, 1},
			{positions, _Real, 2},
			{tol, _Real}
			},
		Block[
			{
				flag=False,
				idx=1,
				len=Length@positions
				},
			While[
				idx<=len&&
					Not[
						flag=
							p[[1]]-tol<=positions[[idx, 1]]<=p[[1]]+tol&&
							p[[2]]-tol<=positions[[idx, 2]]<=p[[2]]+tol&&
							p[[3]]-tol<=positions[[idx, 3]]<=p[[3]]+tol
						],
				idx++
				];
			flag
			]
		];


(* ::Subsubsection::Closed:: *)
(*symmetryOperationQ*)



symmetryOperationQ[transform_, pts_List, tol_]:=
	AllTrue[pts,
		With[
			{
				tp=transform@#
				},
			ListQ@tp&&(symmetricPointQ[tp, #, pts, tol])
			]&
		];
symmetryOperationQ[transform_,grps_Association,tol_]:=
	AllTrue[grps,
		symmetryOperationQ[transform, #, tol]&
		]


(* ::Subsubsection::Closed:: *)
(*InversionCenterQ*)



inversionTransform[point_]:=
	AffineTransform@{ScalingMatrix[{-1,-1,-1}],2*point}


ChemUtilsInversionCenterQ[ 
	groups_, tol:(_?NumericQ|Automatic):Automatic]:=
		symmetryOperationQ[
			Minus,
			groups,
			Replace[tol, Automatic:>$ChemSymmetryTolerance]
			];


(* ::Subsubsection::Closed:: *)
(*uniqueAxesQ*)



uniqueAxesQComp=
	Compile[{{center, _Real, 1}, {p, _Real, 1}, {q, _Real, 1}, {tol, _Real}},
		With[{n1=#/Norm[#]&@p-center,n2=#/Norm[#]&@q-center},
			Norm[n1-n2]>tol&&
				Norm[n1+n2]>tol
			]
		];
uniqueAxesQ[center_, p_,q_]:=
	uniqueAxesQComp[center,p,q, $ChemSymmetryUniquenessThreshold];
uniqueAxesQ[center_][p_,q_]:=
	uniqueAxesQComp[center,p,q];


(* ::Subsubsection::Closed:: *)
(*RotationAxisOrderComp*)



(*ChemUtilsRotationAxisOrderComp:=
	With[
		{
			symmetricPointQ=symmetricPointQ,
			uniqueAxesQ=uniqueAxesQComp,
			rawRotationTransformationFunction=
				rawRotationTransformationFunction
			},
		Compile[
			{
				{point1, _Real, 1},
				{point2, _Real, 1},
				{positions, _Real, 2},
				{grps, _Integer, 1},
				{linFlag, _Integer},
				{tol, _Real}
				},
			If[linFlag===1,
				If[
					uniqueAxesQ[point1, positions[[1]], point2]||
						uniqueAxesQ[point1, positions[[-1]], point2],
					1,
					-1
					],
				Block[{
					groupOrdering = Ordering[grps],
					returnOrder=1
					},
						Do[
							Block[
								{
									flag=True,
									i=1,j=1,
									newpts,
									oldpts
									},
								While[i\[LessEqual]Length[grps]&&flag,
									With[{grp=Take[positions, {Total@grps[[;;i-1]], grps[[i]]}]},
										j=1;
										While[j\[LessEqual]grps[[i]]&&flag,
											flag=symmetricPointQ[
												rawRotationTransformationFunction[
													grp[[j]],
													2.\[Pi]/o,
													point2,
													point1
													],
												grp[[j]],
												grp,
												tol
												];
											j++
											]
										];
									i++
									];
								If[flag,
									returnOrder=o;
									Break[]
									]
								],
							{o, grps}
							];
					returnOrder
					]
				]
			]
		];*)


(* ::Subsubsection::Closed:: *)
(*RotationAxisOrder*)



rotationTransform[order_,  point_]:=
	RotationTransform[2.\[Pi]/order, point];
rotationTransform[point_][order_]:=
	rotationTransform[order,point];


ChemUtilsRotationAxisOrder//Clear


ChemUtilsRotationAxisOrder[
	point_,
	groups_,
	linearQ:True|False:False,
	tol:_?NumericQ|Automatic:Automatic
	]:=
	If[linearQ,
		If[
			uniqueAxesQComp[groups[[1,1]], point]||
				uniqueAxesQComp[groups[[1,-1]], point],
			1,
			\[Infinity]
			],
		With[{es=SortBy[groups, Length]},
			With[{
				ret=
					Do[
						If[
							symmetryOperationQ[
								rotationTransform[o, point],
								groups,
								Replace[tol, Automatic:>$ChemSymmetryTolerance]
								],
							Return[o]
							],
						{o, Length@es[[-1]], 2, -1}
						]
					},
				If[ret>1//TrueQ,
					ret,
					1
					]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*perpendicularAxisQ*)



perpendicularAxisQ[center_,p_,{q1_,q2_}]:=
	Not@uniqueAxesQ[center,p,Cross[q1-center,q2-center]];
perpendicularAxisQ[center_,p_][q_]:=
	perpendicularAxisQ[center,p,q];


(* ::Subsubsection::Closed:: *)
(*anyPerpendicular*)



anyPerpPlane[center_,axes_,planes_]:=
	AnyTrue[planes,
		With[{plane=#},
			AnyTrue[axes,perpendicularAxisQ[center,#,plane]&]
			]&
		];
anyPerpPlane[center_,axes_][planes_]:=
	anyPerpPlane[center,axes,planes];


(* ::Subsubsection::Closed:: *)
(*ScrewAxisOrderComp*)



(*ChemUtilsScrewAxisOrderComp:=
	With[
		{
			symmetricPointQ=symmetricPointQ,
			uniqueAxesQ=uniqueAxesQComp,
			rawRotationReflectionTransformationFunction=
				rawRotationReflectionTransformationFunction
			},
		Compile[
			{
				{point1, _Real, 1},
				{point2, _Real, 1},
				{positions, _Real, 2},
				{grps, _Integer, 1},
				{tol, _Real}
				},
				Block[{
					groupOrdering = Ordering[grps],
					returnOrder=1
					},
						Do[
							Block[
								{
									flag=True,
									i=1,j=1,
									newpts,
									oldpts
									},
								While[i\[LessEqual]Length[grps]&&flag,
									With[{grp=Take[positions, {Total@grps[[;;i-1]], grps[[i]]}]},
										j=1;
										While[j\[LessEqual]grps[[i]]&&flag,
											flag=symmetricPointQ[
												rawRotationReflectionTransformationFunction[
													grp[[j]],
													2.\[Pi]/o,
													point2,
													point1
													],
												grp[[j]],
												grp,
												tol
												];
											j++
											]
										];
									i++
									];
								If[flag,
									returnOrder=o;
									Break[]
									]
								],
							{o, grps}
							];
					returnOrder
					]
				]
		];*)


(* ::Subsubsection::Closed:: *)
(*ScrewAxisOrder*)



screwTransform[order_, axisPoint_]:=
	Composition[
		rotationTransform[order, axisPoint],
		ReflectionTransform[axisPoint]
		]//Simplify;
screwTransform[axisPoint_][order_]:=
	screwTransform[order,axisPoint]


ChemUtilsScrewAxisOrder[
	point_,
	groups_,
	tol:_?NumericQ|Automatic:Automatic
	]:=
	With[{es=SortBy[groups, Length]},
		With[{
			ret=
				Do[
					If[
						symmetryOperationQ[
							screwTransform[o, point],
							groups,
							Replace[tol, Automatic:>$ChemSymmetryTolerance]
							],
						Return[o]
						],
					{o, Length@groups[[-1]], 3, -1}
					]
				},
			If[ret>0//TrueQ,
				ret,
				0
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*InertialSymmetry*)



ChemUtilsInertialSymmetry[c_,axes_,atoms_,toler:_?NumericQ|Automatic:Automatic]:=
	With[{tol=Replace[toler, Automatic:>$ChemSymmetryTolerance]},
		<|
			"CenterSymmetric"->ChemUtilsInversionCenterQ[c,atoms,tol],
			"ARotationOrder"->ChemUtilsRotationAxisOrder[{c,c+axes[[1]]},atoms,tol],
			"BRotationOrder"->ChemUtilsRotationAxisOrder[{c,c+axes[[2]]},atoms,tol],
			"CRotationOrder"->ChemUtilsRotationAxisOrder[{c,c+axes[[3]]},atoms,tol],
			"ABSymmetric"->ChemUtilsPlaneOfSymmetryQ[{c,c+axes[[1]],c+axes[[2]]},atoms,tol],
			"ACSymmetric"->ChemUtilsPlaneOfSymmetryQ[{c,c+axes[[1]],c+axes[[3]]},atoms,tol],
			"BCSymmetric"->ChemUtilsPlaneOfSymmetryQ[{c,c+axes[[2]],c+axes[[3]]},atoms,tol],
			"AScrewOrder"->
				ChemUtilsScrewAxisOrder[{c,c+axes[[1]]},atoms,tol],
			"BScrewOrder"->
				ChemUtilsScrewAxisOrder[{c,c+axes[[2]]},atoms,tol],
			"CScrewOrder"->
				ChemUtilsScrewAxisOrder[{c,c+axes[[3]]},atoms,tol]
			|>
		];
ChemUtilsInertialSymmetry[atoms_,tol:_?NumericQ|Automatic:Automatic]:=
	With[{
		c=ChemUtilsCenterOfMass@atoms,
		axes=Lookup[ChemUtilsInertialSystem@atoms,{"AAxis","BAxis","CAxis"}]
		},
		ChemUtilsInertialSymmetry[c,axes,atoms,
			Replace[tol, Automatic:>$ChemSymmetryTolerance]]
		];


(* ::Subsubsection::Closed:: *)
(*symmetryTestPosition*)



$chemSymmEscapeArray=
	RandomReal[{-.5,.5},3];


(*enumeratePositionsIter:=
	enumeratePositionsIter=With[{$chemSymmEscapeArray=$chemSymmEscapeArray},
	enumeratePositionsIter=
		Compile[{{positions, _Real, 2},{n, _Integer}, {plen, _Integer}},
			With[
				{
					i=1+Floor[(n-1)/plen],
					j=Mod[n, plen, 1]
					},
				If[i>j,
					$chemSymmEscapeArray,
					Mean[{
						positions[[i]],
						positions[[j]]
						}]
					]
				]
			]
	];
symmetryTestPosition[center_, positions_, n_]:=
	enumeratePositionsIter[positions, n, Length@positions];
symmetryTestPositionCount[center_, positions_]:=
	Length@positions^2;*)


uniquePointsQComp=
	Compile[{{pt1,_Real,1},{pt2,_Real,1}, {tol,_Real}},
		Norm[pt1-pt2]>tol
		]
uniquePointsQ[pt1_List, pt2_]:=
	uniquePointsQComp[pt1, pt2, $ChemSymmetryUniquenessThreshold];
uniquePointsQ[___]:=False


(*enumeratePlanesIter1:=enumeratePlanesIter1=With[{
	$chemSymmEscapeArray=$chemSymmEscapeArray,
	uniquePointsQComp=uniquePointsQComp,
	$ChemSymmetryUniquenessThreshold=$ChemSymmetryUniquenessThreshold,
	enumeratePositionsIter=enumeratePositionsIter
	},
		Compile[{
			{center, _Real, 1}, {positions, _Real, 2},
			{n, _Integer}, {plen, _Integer}
			},
			With[
				{
					i=1+Floor[(n-1)/(plen^2)],
					j=Mod[n, plen^2, 1]
					},
				If[i>=j,
					{$chemSymmEscapeArray, $chemSymmEscapeArray},
					With[{pt1=enumeratePositionsIter[positions, i, plen]},
						If[(
								pt1!=$chemSymmEscapeArray&&
								uniquePointsQComp[pt1, center,$ChemSymmetryUniquenessThreshold]
								)//TrueQ,
							With[{pt2=enumeratePositionsIter[positions, j, plen]},
								If[(
									pt2!=$chemSymmEscapeArray&&
									uniquePointsQComp[pt2, center, $ChemSymmetryUniquenessThreshold]
									)//TrueQ,
									{pt1, pt2},
									{$chemSymmEscapeArray, $chemSymmEscapeArray}
									]
								],
							{$chemSymmEscapeArray, $chemSymmEscapeArray}
							]
						]
					]
				]
			]
		];*)


(*enumerateAxesIter:=enumerateAxesIter=With[{
	$chemSymmEscapeArray=$chemSymmEscapeArray,
	uniquePointsQComp=uniquePointsQComp,
	$ChemSymmetryUniquenessThreshold=$ChemSymmetryUniquenessThreshold,
	enumeratePositionsIter=enumeratePositionsIter,
	enumeratePlanesIter=enumeratePlanesIter
	},
	Compile[{
		{center, _Real, 1}, {positions, _Real, 2},
		{n, _Integer}, {plen, _Integer}
		},
		With[{p=
			If[n<=plen^2,
				enumeratePositionsIter[positions, n, plen],
				With[{s=enumeratePlanesIter[center, positions, n - plen]},
					If[s=!=$chemSymmEscapeArray,
						center+Cross[s[[1]]-center, s[[2]]-center],
						$chemSymmEscapeArray
						]
					]
				]
				},
			If[uniquePointsQComp[p,center,$ChemSymmetryUniquenessThreshold],
				p, 
				$chemSymmEscapeArray
				]
			]
		]
	];
symmetryTestAxis[center_, positions_, n_]:=
	enumerateAxesIter[center, positions, n, Length@positions];
symmetryTestAxisCount[positions_]:=
	Length@positions^4+Length@positions*)


(*enumeratePlanesIter2:=
	enumeratePlanesIter2=With[
	{
		$chemSymmEscapeArray=$chemSymmEscapeArray,
		uniquePointsQComp=uniquePointsQComp,
		$ChemSymmetryUniquenessThreshold=$ChemSymmetryUniquenessThreshold,
		enumerateAxesIter=enumerateAxesIter
		},
		Compile[{
			{center, _Real, 1}, {positions, _Real, 2},
			{n, _Integer}, {plen, _Integer}
			},
			With[
				{
					i=1+Floor[(n-1)/(plen^2)],
					j=Mod[n, (plen^2), 1]
					},
					With[{pt1=enumerateAxesIter[center, positions, i + plen^2, plen]},
						If[
							(
								pt1!=$chemSymmEscapeArray&&
								uniquePointsQComp[pt1, center, $ChemSymmetryUniquenessThreshold]
								)//TrueQ,
							With[{pt2=enumerateAxesIter[center, positions, j, plen]},
								If[
									(
										pt2!=$chemSymmEscapeArray&&
										uniquePointsQComp[pt2, center, $ChemSymmetryUniquenessThreshold]
										)//TrueQ,
									{pt1, pt2},
									{$chemSymmEscapeArray, $chemSymmEscapeArray}
									]
								],
							{$chemSymmEscapeArray, $chemSymmEscapeArray}
							]
						]
					]
			]
		];
enumeratePlanesIter=
	With[{
		enumeratePlanesIter1=enumeratePlanesIter1,
		enumeratePlanesIter2=enumeratePlanesIter2
		},
		Compile[
			{
				{center, _Real, 1}, {positions, _Real, 2},
				{n, _Integer}, {plen, _Integer}
				},
			If[ n <= plen^4,
				enumeratePlanesIter1[center, positions, n, plen],
				enumeratePlanesIter2[center, positions, n, plen]
				]
			]
		];
symmetryTestPlane[center_, positions_, n_]:=
	With[{len=Length@positions},
		If[ n <= len^4,
			enumeratePlanesIter[center, positions, n, len],
			enumeratePlanesIter2[center, positions, n, len]
			]
		];
symmetryTestPlaneCount[positions_]:=
	Length@positions^4+Length@positions^4;*)


(*enumerateRotationAxesCompiled:=enumerateRotationAxesCompiled=With[
	{
		$chemSymmEscapeArray=$chemSymmEscapeArray,
		uniquePointsQComp=uniquePointsQComp,
		uniqueAxesQComp=uniqueAxesQComp,
		$ChemSymmetryUniquenessThreshold=$ChemSymmetryUniquenessThreshold,
		enumerateAxesIter=enumerateAxesIter,
		enumeratePlanesIter=enumeratePlanesIter,
		ChemUtilsRotationAxisOrderComp=ChemUtilsRotationAxisOrderComp
		},
		Compile[
			{
				{center, _Real, 1},
				{positions, _Real, 2},
				{groups, _Integer, 1},
				{totalCount, _Integer},
				{linearFlag, _Integer},
				{tol, _Real}
				},
		Block[
			{
				triedAxes=
					Table[$chemSymmEscapeArray,totalCount],
				successOrders=
					Table[-1,totalCount],
				linearQ=linearFlag===1,
				j,
				allTrueFlag
				},
			Do[
				triedAxes[[n]]=enumerateAxesIter[center, positions, n];
				If[triedAxes[[n]]=!=$chemSymmEscapeArray,
						allTrueFlag=True;
						If[j=1;
								While[j<n&&allTrueFlag,
									allTrueFlag=(
										triedAxes[[j]]===$chemSymmEscapeArray||
										uniqueAxesQComp[
											center,
											triedAxes[[j]], 
											triedAxes[[n]],
											$ChemSymmetryUniquenessThreshold
											]
										);
									j++
									];
								allTrueFlag,
							With[{
								o=
									ChemUtilsRotationAxisOrderComp[
										center,
										triedAxes[[n]],
										positions,
										groups,
										linearFlag,
										tol
										]
									},
								If[o>1,
									successOrders[[n]]=
										o
									]
								]
							];
						],
					{n, totalCount}
					];
			Thread[{
				Select[successOrders, #>1&],
				Pick[triedAxes, #>1&/@successOrders]
				}]
			]
		]
	];*)


(*enumerateSymmetryPlanesCompiled:=enumerateSymmetryPlanes=With[
	{
		$chemSymmEscapeArray=$chemSymmEscapeArray,
		uniquePointsQComp=uniquePointsQComp,
		uniqueAxesQComp=uniqueAxesQComp,
		$ChemSymmetryUniquenessThreshold=$ChemSymmetryUniquenessThreshold,
		enumerateAxesIter=enumerateAxesIter,
		enumeratePlanesIter=enumeratePlanesIter,
		ChemUtilsPlaneOfSymmetryQComp=ChemUtilsPlaneOfSymmetryQComp
		},
		Compile[
			{
				{center, _Real, 1},
				{positions, _Real, 2},
				{groups, _Integer, 1},
				{totalCount, _Integer},
				{tol, _Real}
				},
			Block[
				{
					triedPlanes=
						Table[{$chemSymmEscapeArray, $chemSymmEscapeArray}, totalCount],
					triedNorms=
						Table[$chemSymmEscapeArray, totalCount],
					testPlane,
					testNorm,
					plen=Length@positions,
					allTrueFlag,
					j=1
					},
				Do[
					testPlane=enumeratePlanesIter[center, positions, n, plen];
					If[testPlane=!={$chemSymmEscapeArray,$chemSymmEscapeArray},
						testNorm=
							triedNorms[[n]]=
									Cross[testPlane[[1]]-center, testPlane[[2]]-center];
						allTrueFlag=True;
						If[testPlane[[1]]!={0.,0.,0.}&&
							(
								j=1;
								While[j<n&&allTrueFlag,
									allTrueFlag=(
										triedNorms[[j]]===$chemSymmEscapeArray||
										uniqueAxesQComp[
											center,
											triedNorms[[j]], 
											testNorm,
											$ChemSymmetryUniquenessThreshold
											]
										);
									j++
									];
								allTrueFlag
								),
							If[
									ChemUtilsPlaneOfSymmetryQComp[
										center,
										testPlane[[1]],
										positions,
										groups,
										tol
										],
								triedPlanes[[n]]=
									testPlane
								]
							];
						],
					{n, totalCount}
					];
				Select[triedPlanes, 
					#=!={$chemSymmEscapeArray,$chemSymmEscapeArray}&
					]
				]
			]
	];*)


(*enumerateScrewAxes:=enumerateScrewAxes=With[
	{
		$chemSymmEscapeArray=$chemSymmEscapeArray,
		uniquePointsQComp=uniquePointsQComp,
		uniqueAxesQComp=uniqueAxesQComp,
		$ChemSymmetryUniquenessThreshold=$ChemSymmetryUniquenessThreshold,
		enumerateAxesIter=enumerateAxesIter,
		enumeratePlanesIter=enumeratePlanesIter,
		ChemUtilsScrewAxisOrderComp=ChemUtilsScrewAxisOrderComp
		},
		Compile[
			{
				{center, _Real, 1},
				{positions, _Real, 2},
				{groups, _Integer, 1},
				{totalCount, _Integer},
				{linearFlag, _Integer},
				{tol, _Real}
				},
		Block[
			{
				triedAxes=
					Table[$chemSymmEscapeArray,totalCount],
				successOrders=
					Table[-1,totalCount],
				linearQ=linearFlag===1,
				j,
				allTrueFlag
				},
			Do[
				triedAxes[[n]]=enumerateAxesIter[center, positions, n];
				If[triedAxes[[n]]=!=$chemSymmEscapeArray,
						allTrueFlag=True;
						If[j=1;
								While[j<n&&allTrueFlag,
									allTrueFlag=(
										triedAxes[[j]]===$chemSymmEscapeArray||
										uniqueAxesQComp[
											center,
											triedAxes[[j]], 
											triedAxes[[n]],
											$ChemSymmetryUniquenessThreshold
											]
										);
									j++
									];
								allTrueFlag,
							With[{
								o=
									ChemUtilsScrewAxisOrderComp[
										center,
										triedAxes[[n]],
										positions,
										groups,
										tol
										]
									},
								If[o>1,
									successOrders[[n]]=
										o
									]
								]
							];
						],
					{n, totalCount}
					];
			Thread[{
				Select[successOrders, #>1&],
				Pick[triedAxes, #>1&/@successOrders]
				}]
			]
		]
	];*)


(* ::Subsubsection::Closed:: *)
(*uniqueAxesQCompGen*)



uniqueAxesQCompGen[tolRough_]:=
	With[{tol=Mod[10*tolRough*Degree, \[Pi]]},
		Compile[{{p, _Real, 1}, {q, _Real, 1}},
			With[{arg=(p.q)/(Norm[p]*Norm[q])},
				Which[
					arg==-1,
						True,
					arg==1,
						True,
					True,
						With[{ang=ArcCos[arg]},
							tol<ang<\[Pi]-tol
							]
					]
				]
			]
		]


nonUniqueAxesQCompGen[tolRough_]:=
	With[{tol=Mod[10*tolRough*Degree, \[Pi]]},
		Compile[{{p, _Real, 1}, {q, _Real, 1}},
			With[{arg=(p.q)/(Norm[p]*Norm[q])},
				Which[
					arg==-1,
						True,
					arg==1,
						True,
					True,
						With[{ang=ArcCos[arg]},
							tol>ang||ang>\[Pi]-tol
							]
					]
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*uniquePlanesQCompGen*)



uniquePlanesQCompGen[center_, tolRough_]:=
	With[{tol=Mod[10*tolRough*Degree, \[Pi]]},
		Compile[{{src1, _Real, 2}, {src2, _Real, 2}},
			With[{
				p=Cross[src1[[1]], src1[[2]]],
				q=Cross[src2[[1]], src2[[2]]]
				},
				With[{arg=(p.q)/(Norm[p]*Norm[q])},
					Which[
						arg==-1,
							True,
						arg==1,
							True,
						True,
							With[{ang=ArcCos[arg]},
								tol<ang<\[Pi]-tol
								]
						]
					]
				]
			]
		]


nonUniquePlanesQCompGen[tolRough_]:=
	With[{tol=Mod[10*tolRough*Degree, \[Pi]]},
		Compile[{{src1, _Real, 2}, {src2, _Real, 2}},
			With[{
				p=Cross[src1[[1]], src1[[2]]],
				q=Cross[src2[[1]], src2[[2]]]
				},
				With[{arg=(p.q)/(Norm[p]*Norm[q])},
					Which[
						arg==-1,
							True,
						arg==1,
							True,
						True,
							With[{ang=ArcCos[arg]},
								tol>ang||ang>\[Pi]-tol
								]
						]
					]
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*enumeratePositions*)



$chemSymmIgnore=RandomReal[{-1,1}, 3];


enumeratePositionsCore=
	Compile[{{positions, _Real, 2}},
		Select[
			Table[
				With[
					{
						i=1+Floor[(n-1)/Length[positions]],
						j=Mod[n, Length[positions], 1]
						},
					If[i>j,
						$chemSymmEscapeArray,
						If[i==j,
							positions[[i]], 
							If[positions[[i]]=!=positions[[j]],
								Mean[{
									positions[[i]],
									positions[[j]]
									}],
								$chemSymmEscapeArray
								]
							]
						]
					],
				{n, Length@positions^2}
				],
			#=!=$chemSymmEscapeArray&
			]
		];
enumeratePositions[pts_]:=
	Replace[enumeratePositionsCached[{pts}],
		Except[_List]:>
			Set[
				enumeratePositionsCached[pts], 
				If[Length[pts]>0, enumeratePositionsCore[pts], {}]
				]
		]


(* ::Subsubsection::Closed:: *)
(*deleteDuplicatePlanes*)



deleteDuplicatePlanesPickSpec[tol_]:=
	Compile[
		{	{planes, _Real, 3} },
		Block[{
			vecs = Cross[#[[1]], #[[2]]]&/@planes,
			vecNorm,
			angs,
			order,
			angDiffs,
			angSel,
			tally=0.,
			normDiffs,
			flag=1,
			tolTrue=tol/100
			},
			Times@@
				Table[
					vecNorm=Norm@vecs[[i]];
					angs=
							Table[(vecs[[i]].vecs[[j]])/(vecNorm*Norm[vecs[[j]]]),
								{j, i+1, Length@vecs}
								];
					Join[
						Table[1, {doop,i}],
						If[1-tol<#, 0, 1]&/@Abs[angs]
						],
					{i, Length[vecs]}
					]
			]
		];
deleteDuplicatePlanes[planes_, tol_]:=
	If[Length[planes]>1,
		Pick[
			planes,
			deleteDuplicatePlanesPickSpec[tol]@planes,
			1
			],
		planes
		]


(* ::Subsubsection::Closed:: *)
(*enumeratePlanesSimple*)



enumeratePlanesEnumerator//Clear


enumeratePlanesEnumeratorComp=
	With[{
			$failed=$chemSymmEscapeArray
			},
		Compile[{{positions, _Real, 2}},
			Select[
				Flatten[
					Table[
						With[
							{
								i=1+Floor[(n-1)/Length[positions]],
								j=Mod[n, Length[positions], 1],
								i2=1+Floor[(m-1)/Length[positions]],
								j2=1+Floor[(m-1)/Length[positions]]
								},
							If[n>m||i>j||i2>j2,
								{$failed, $failed},
								With[{
									samp=
										{
											If[i==j,
												positions[[i]], 
												If[positions[[i]]=!=positions[[j]],
													Mean[{
														positions[[i]],
														positions[[j]]
														}],
													$failed
													]
												],
											If[i2==j2,
												positions[[i2]], 
												If[positions[[i]]=!=positions[[j]],
													Mean[{
														positions[[i2]],
														positions[[j2]]
														}],
													$failed
													]
												]
											}
										},
										If[samp[[1]]=!=samp[[2]],	
											samp,
											{$failed, $failed}
											]
										]
								]
							],
						{n, Length@positions^2},
						{m, Length@positions^2}
						],
					1
					],
				#[[1]]=!=$failed&&#[[2]]=!=$failed&
				]
			]
		];


enumeratePlanesEnumerator[pts_]:=
	With[{real=Select[pts, Norm[#]>0&]},
		If[Length@real>1,
			enumeratePlanesEnumeratorComp[real],
			{}
			]
		]


enumeratePlanesSimple[pts_, tol_]:=
	Replace[enumeratePlanesSimpleCached[{pts, tol}],
		Except[_List]:>
			Set[
				enumeratePlanesSimpleCached[{pts, tol}],
					With[{base=DeleteDuplicates@enumeratePlanesEnumerator[pts]},
						deleteDuplicatePlanes[
							base,
							tol
							]
						]
				]
		]


(* ::Subsubsection::Closed:: *)
(*enumeratePlanes optimized, broken version*)



(*enumeratePlanesSimple=
	With[{uniqueAxesQComp=uniqueAxesQComp},
		Compile[{{center, _Real, 1}, {positions, _Real, 2}, {tol, _Real}},
			Block[{
				coplanarPts=
					Table[
						0, 
						{m, Length[positions]^2}, 
						{n, Length[positions]^2}, 
						{o, Length[positions]^2}
						],
				coplanarFlag=False,
				p,
				ptsBag=Internal`Bag[Most@{0}]
				},
				Do[
					With[{
						(* This just computes the indices for each planar pt *)
						i1=1+Floor[(n-1)/Length[positions]],
						j1=Mod[n, Length[positions], 1],
						i2=1+Floor[(m-1)/Length[positions]],
						j2=Mod[m, Length[positions], 1],
						i3=1+Floor[(m-1)/Length[positions]],
						j3=Mod[m, Length[positions], 1]
						},
						(* Reduce the combinations to check *)
						If[m>n||i1>j1||i2>j2||i3>j3||
							(
								coplanarFlag = False;
								p=1;
								While[(!coplanarFlag)&&p<n,
									(* Check if there's anything point such that these are all coplanar *)
									coplanarFlag=
										(coplanarPts[[p, n, o]]>0)&&
											(coplanarPts[[p, m, o]]>0);
									p++
									];
								!coplanarFlag
								),
							-1,
						With[{
							p1=If[i1\[Equal]j1, positions[[i1]], Mean[{positions[[i1]], positions[[j1]]}]],
							p2=If[i2\[Equal]j2, positions[[i2]], Mean[{positions[[i2]], positions[[j2]]}]],
							p3=If[i3\[Equal]j3, positions[[i3]], Mean[{positions[[i3]], positions[[j3]]}]]
							},
							If[
								coplanarPts[[m, n, o]]=
									If[
										uniqueAxesQComp[
											center,
											Cross[p1-center, p2-center],
											Cross[p3-center, p2-center],
											tol
											],
										1,
										0
										],
								Internal`StuffBag[
									ptsBag,
									Internal`Bag[{Internal`Bag[p1],Internal`Bag[p2]}]
									],
								Internal`StuffBag[
									ptsBag,
									Internal`Bag[{Internal`Bag[p1],Internal`Bag[p2]}]
									];
								Internal`StuffBag[
									ptsBag,
									Internal`Bag[{Internal`Bag[p1],Internal`Bag[p3]}]
									];
								Internal`StuffBag[
									ptsBag,
									Internal`Bag[{Internal`Bag[p2],Internal`Bag[p3]}]
									];
								]
							]
						]
					],
					{n, Length@positions^2},
					{m, Length@positions^2},
					{o, Length@positions^2}
					];
				Internal`BagPart[ptsBag, All]
				]
			]
		]*)


(* ::Subsubsection::Closed:: *)
(*deleteDuplicateAxes*)



deleteDuplicateAxesInds[tol_]:=
	Compile[
		{	{vecs, _Real, 2} },
		Block[{
			pickedVecs,
			tally=0.,
			vecNorm,
			angs,
			order,
			reorder,
			angDiffs,
			angSel,
			flag=1,
			tolTrue=tol/100
			},
			Times@@
				Table[
					vecNorm=Norm@vecs[[i]];
					angs=
							Table[(vecs[[i]].vecs[[j]])/(vecNorm*Norm[vecs[[j]]]),
								{j, i+1, Length@vecs}
								];
					Join[
						Table[1, {o, i}],
						If[1-tol<Abs[#], 0, 1]&/@angs
						],
					{i, Length@vecs}
					]
			]
		];
deleteDuplicateAxes[axes_, tol_]:=
	With[{real=Select[axes, Norm[#]>tol&]},
		If[Length[real]>1,
			Pick[real,
				deleteDuplicateAxesInds[tol]@real,
				1],
			real
			]
		]


(* ::Subsubsection::Closed:: *)
(*deleteDuplicateRotationAxes*)



deleteDuplicateRotationAxes[axes_, tol_]:=
	With[{
		a=GroupBy[axes, First->Last, DeleteDuplicates]},
		Join@@
			KeyValueMap[
				Thread[{#, Pick[a[#], #2, 1]}]&,
				deleteDuplicateAxesInds[tol]/@a
				]
		]


(* ::Subsubsection::Closed:: *)
(*enumerateAxes*)



enumerateAxesNormals=
	Compile[{{p,_Real,3}},
		Map[Cross[#[[1]], #[[2]]]&, p]
		]


enumerateAxes[positions_, tol_]:=
	Replace[enumerateAxesCached[{positions, tol}],
		Except[_List]:>
			Set[
				enumerateAxesCached[{positions, tol}],
				With[{
					posReal=
						deleteDuplicateAxes[
							positions, 
							tol
							]
					},
					deleteDuplicateAxes[
						Join[
							enumeratePositions[posReal],
							With[{r=enumeratePlanesSimple[posReal, tol]},
								If[Length[r]>0,
									enumerateAxesNormals@r,
									{}
									]
								]
							],
						tol
						]
					]
				]
		]


(* ::Subsubsection::Closed:: *)
(*enumerateRotationAxes*)



enumerateRotationAxes[groups_,linearQ_, tol_, tol2_]:=
	Map[
		With[{o=ChemUtilsRotationAxisOrder[#, groups, linearQ, tol]},
			If[o>1,
				{o, #},
				Nothing
				]
			]&,
		deleteDuplicateAxes[
			Union@@Values@
				Map[
					Function[
						enumerateAxes[#, tol2]
						],
					groups
					],
			tol2
			]
		]


(* ::Subsubsection::Closed:: *)
(*enumerateSymmetryPlanes*)



enumeratePlanes[positions_, tol_]:=
	With[{axBase=enumerateAxes[positions, tol]},
		If[Length@axBase>1,
			enumeratePlanesSimple[
				enumerateAxes[positions, tol], 
				tol
				],
			{}
			]
		]


enumerateSymmetryPlanes[groups_,tol_,tol2_]:=
	Select[
		deleteDuplicatePlanes[
			Union@@Values@
				Map[
					enumeratePlanes[#, tol2]&,
					groups
					],
			tol2
			],
		ChemUtilsPlaneOfSymmetryQ[
			#,
			groups,
			tol
			]&
		]


(* ::Subsubsection::Closed:: *)
(*PlaneOfSymmetryQComp*)



(*ChemUtilsPlaneOfSymmetryQComp:=
	With[
		{
			symmetricPointQ=symmetricPointQ,
			rawReflectionTransformationFunction=rawReflectionTransformationFunction
			},
		Compile[
			{
				{point1, _Real, 1},
				{norm, _Real, 1},
				{positions, _Real, 2},
				{grps, _Integer, 1},
				{tol, _Real}
				},
				Block[{
					flag=True,
					i=1,j=1,
					newpts,
					oldpts
					},
					While[i\[LessEqual]Length[grps]&&flag,
						With[{grp=Take[positions, {Total@grps[[;;i-1]], grps[[i]]}]},
							j=1;
							While[j\[LessEqual]grps[[i]]&&flag,
								flag=symmetricPointQ[
									rawReflectionTransformationFunction[
										grp[[j]],
										norm,
										point1
										],
									grp[[j]],
									grp,
									tol
									];
								j++
								]
							];
						i++
						];
					flag
					]
				]
		];*)


(* ::Subsubsection::Closed:: *)
(*PlaneOfSymmetryQ*)



ChemUtilsPlaneOfSymmetryQ[
	norm_:{_,_,_},
	grps_,
	tol:_?NumericQ:0.000001
	]:=
	symmetryOperationQ[
		ReflectionTransform[norm],
		grps,
		tol
		];
ChemUtilsPlaneOfSymmetryQ[
	{point1_,point2_},
	grps_,
	tol:_?NumericQ:0.000001
	]:=
	ChemUtilsPlaneOfSymmetryQ[
		Cross[point1, point2],
		grps,
		tol
		]


(* ::Subsubsection::Closed:: *)
(*enumerateScrewAxes*)



enumerateScrewAxes[groups_,tol_,tol2_]:=
	Map[
		With[{o=ChemUtilsScrewAxisOrder[#, groups,tol]},
			If[o>0,
				{o, #},
				Nothing
				]
			]&,
		deleteDuplicateAxes[
			Union@@Values@
				Map[
					enumerateAxes[#, tol2]&,
					groups
					],
			tol2
			]
		]


(* ::Subsubsection::Closed:: *)
(*RawSymmetryElements*)



$ChemSymmetryTolerance=.01;
$ChemSymmetryUniquenessThreshold=.0001;


Options[ChemUtilsRawSymmetryElements]=
	{
		Tolerance->Automatic,
		"UniquenessThreshold"->Automatic
		};
ChemUtilsRawSymmetryElements[atoms_,
	ops:OptionsPattern[]
	]:=
	Block[{
		enumeratePositionsCached,
		enumeratePlanesSimpleCached,
		enumerateAxesCached,
		$ChemSymmetryTolerance=
			Replace[OptionValue[Tolerance],
				Except[_?NumericQ]->$ChemSymmetryTolerance],
		$ChemSymmetryUniquenessThreshold=
			Replace[OptionValue["UniquenessThreshold"],
				Except[_?NumericQ]->$ChemSymmetryUniquenessThreshold]
		},
		With[{
			center=
				Round[ChemUtilsCenter@atoms, $ChemSymmetryUniquenessThreshold],
			tol=
				$ChemSymmetryTolerance,
			tol2=
				$ChemSymmetryUniquenessThreshold
			},
			With[{
				axes=
					Last@ChemUtilsInertialEigensystem@atoms,
				groups=
					Map[#-center&]/@
						Round[
							GroupBy[atoms,First->Last],
							.0001
							],
				linear=
					ChemUtilsRotorType[atoms]==="Linear"
				},
				<|
					"Center"->
						center,
					"CenterSymmetric"->
						ChemUtilsInversionCenterQ[
							Select[
								Join@@Values@groups,
								Norm[#]>0&
								],
							tol
							],
					"RotationAxes"->
						Replace[
							enumerateRotationAxes[
								groups,
								ChemUtilsRotorType[
									MapThread[
										Thread@*List,
										{Keys[groups],Values[groups]}
										]
									]==="Linear",
								tol,
								tol2
								],
							{o_, v_}:>
								{o, v + center},
							1
							],
					"SymmetryPlanes"->
						Replace[
							enumerateSymmetryPlanes[
								groups,
								tol,
								tol2
								],
							{v1_, v2_}:>
								{v1+center, v2+center},
							1
							],
					"ScrewAxes"->
						Replace[
							enumerateScrewAxes[
								groups,
								tol,
								tol2
								],
							{o_,v_}:>
								{o, v+center},
							1
							]
					|>
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*SymmetryElementFunctions*)



ChemUtilsSymmetryElementFunction[
	"InversionCenter",
	center_
	]:=
	Minus;
ChemUtilsSymmetryElementFunction[
	"RotationAxes",
	center_,
	{order_, v_}
	]:=
	RotationTransform[2\[Pi]/order, v-center, center];
ChemUtilsSymmetryElementFunction[
	"SymmetryPlanes",
	center_,
	{v1_, v2_}
	]:=
	ReflectionTransform[
		Cross[v1-center, v2-center],
		center
		];
ChemUtilsSymmetryElementFunction[
	"ScrewAxes",
	center_,
	{order_, v_}
	]:=
	Composition[
		RotationTransform[2\[Pi]/order, v-center, center],
		ReflectionTransform[
			v,
			center
			]
		]//Simplify


ChemUtilsSymmetryElementFunctions[
	rawEls_Association?(KeyMemberQ["Center"])
	]:=
	Association@
	KeyValueMap[
		Switch[#,
			"CenterSymmetric",
				If[#2,
					"InversionCenter"->
						ChemUtilsSymmetryElementFunction["InversionCenter", rawEls["Center"]],
					Nothing
					],
			"RotationAxes",
				#->
					AssociationMap[
						ChemUtilsSymmetryElementFunction["RotationAxes",
							rawEls["Center"],
							#
							]&,
						#2
						],
			"SymmetryPlanes",
				#->
					AssociationMap[
						ChemUtilsSymmetryElementFunction["SymmetryPlanes",
							rawEls["Center"],
							#
							]&,
						#2
						],
			"ScrewAxes",
				#->
					AssociationMap[
						ChemUtilsSymmetryElementFunction["ScrewAxes",
							rawEls["Center"],
							#
							]&,
						#2
						],
			_,
				Nothing
			]&,
		rawEls
		];
ChemUtilsSymmetryElementFunctions[
	atoms_,tol:_?NumericQ|Automatic:Automatic
	]:=
	ChemUtilsSymmetryElementFunctions@
		ChemRawSymmetryElements[atoms, tol]


(* ::Subsubsection::Closed:: *)
(*SymmetryElementGrouping*)



ChemUtilsSymmetryElementGroup["RotationAxes",
	axes_,
	center_,
	fns_
	]:=
	ConnectedComponents[
		Graph@
			Flatten@{
				Map[#<->#&, axes],
				Table[
					With[{
						fpl=FixedPointList[f, a[[2]], Length[axes],
							 SameTest->(Norm[#1-#2]<1*^-1&)]
						},
						With[{
							order=a[[1]],
							newPt=#
							},
							Replace[
								SelectFirst[DeleteCases[axes,a],
									order==#[[1]]&&!uniqueAxesQ[center, newPt, #[[2]]]&,
									Nothing
									],
								l_List:>
									a<->l
								]
							]&/@fpl
						],
					{a, axes},
					{f, Flatten@Values@fns}
					]
					}
				];
ChemUtilsSymmetryElementGroup["ScrewAxes",
	axes_,
	center_,
	fns_
	]:=
	ConnectedComponents[
		Graph@
			Flatten@{
				Map[#<->#&, axes],
				Table[
					With[{
						fpl=
							FixedPointList[f, a[[2]], Length@axes,
								SameTest->(Abs[#1-#2]<1*^-1&)
								]
						},
						With[{
							order=a[[1]],
							newPt=#
							},
							Replace[
								SelectFirst[DeleteCases[axes,a],
									order==#[[1]]&&!uniqueAxesQ[center, newPt, #[[2]]]&,
									Nothing
									],
								l_List:>
									a<->l
								]
							]&/@fpl
						],
					{a, axes},
					{f, Flatten@Values@fns}
					]
					}
				];
ChemUtilsSymmetryElementGroup["SymmetryPlanes",
	axes_,
	center_,
	fns_
	]:=
	ConnectedComponents[
		Graph@Flatten@
			Join[
				Map[#<->#&, axes],
				Table[
					With[{
						fpl=
							FixedPointList[Map[f],a, Length@axes,
								SameTest->(Abs[#1-#2]<1*^-1&)
								]
						},
						With[{
							normal=
								center+Cross[#[[1]]-center,#[[2]]-center]
							},
							Replace[
								SelectFirst[DeleteCases[axes,a],
									!uniqueAxesQ[
										center,
										normal,
										center+Cross[#[[2]]-center,#[[1]]-center]
										]&,
									Nothing
									],
								l_List:>
									a<->l
								]
							]&/@fpl
						],
					{a, axes},
					{f, Flatten@Values@fns}
					]
				]
			];
ChemUtilsSymmetryElementGroup[_,k_,__]:=
	k;
ChemUtilsSymmetryElementGrouping[
	elems_,
	fns_,
	tol_:Automatic
	]:=
	Association@
		KeyValueMap[
			#->
				ChemUtilsSymmetryElementGroup[#, #2, elems["Center"], 
					Flatten@Values@KeyDrop[fns, "InversionCenter"]
					]&,
			KeyDrop[elems, {"Center","CenterSymmetric"}]
			]


(* ::Subsubsection::Closed:: *)
(*SymmetryElementExpandClass*)



axisCloseEnough[center_][{_, r1_}, {_, r2_}]:=
	With[{va=VectorAngle[r1-center, r2-center]},
		va > \[Pi]-(10.*Degree) || 10.*Degree > va
		]


ChemUtilsSymmetryApplyGroupElement[objAssoc_,
	k:"RotationAxes"|"ScrewAxes",
	data:{{_, _}, ___},
	fns_
	]:=
	Join@@
		KeyValueMap[
			Thread[
				{
					#,
					FixedPoint[
						deleteDuplicateAxes[
							Union[#, Join@@Map[Through[fns[#]]&, #]],
							$ChemSymmetryUniquenessThreshold
							]&,
						#2,
						Length@objAssoc[k]
						]
					}
				]&,
			GroupBy[data, First->Last]
			]


ChemUtilsSymmetryApplyGroupElement[objAssoc_,
	"SymmetryPlanes",
	data:{{_, _},___}, 
	fns_
	]:=
	FixedPoint[
		deleteDuplicatePlanes[
			Union[#,
				Join@@
					Map[
						Transpose@{
							Through[fns[#[[1]]]],
							Through[fns[#[[2]]]]
							}&,
						#
						]
					],
			$ChemSymmetryUniquenessThreshold
			]&,
		data,
		Length@objAssoc["SymmetryPlanes"]
		]


ChemUtilsSymmetryApplyGroupElement[_, _, d_, fn_]:=
	{d}


ChemUtilsSymmetryApplyGroup[objAssoc_, key_, data_, fns_]:=
	ChemUtilsSymmetryApplyGroupElement[objAssoc, key, data, 
		Flatten@Replace[Flatten@Values@fns, a_Association:>Values[a],1]
		]


ChemUtilsSymmetryElementExpandClass[objAssoc_, fns_]:=
	Association@
		KeyValueMap[
			#->
			Switch[#,
				"RotationAxes"|"ScrewAxes",
					If[Length[#2]>0,
						With[{
							a=
							GroupBy[
								ChemUtilsSymmetryApplyGroup[
									objAssoc,
									#,
									DeleteDuplicates@
										SortBy[
											Join@@
												Map[
													Prepend[#]@
													Table[
														{o, #[[2]]},
														{o, Power@@@FactorInteger[#[[1]]]}
														]&,
													#2
													],
											First
											],
									fns
									],
								First->Last,
								DeleteDuplicates
								]
							},
							Join@@
								With[{
									df=deleteDuplicateAxesInds[$ChemSymmetryUniquenessThreshold]
									},
									KeyValueMap[
										With[{
											real=
												Select[#2, Norm[#]>$ChemSymmetryUniquenessThreshold&]
											},
											Which[Length[real]>1,
												Thread[{#, Pick[real, df@real, 1]}],
												Length[real]===1,
													Thread[{#, real}],
												Length[#2]>0,
													{#, {0.,0.,0.}},
												True,
													{}
												]
											]&,
										a
										]
									]
							],
					#2
					],
				"SymmetryPlanes",
					With[{pl=
						Sort/@
							ChemUtilsSymmetryApplyGroup[objAssoc,
								#,
								#2,
								fns
								]
							},
						If[Length[pl]>1,
							deleteDuplicatePlanes[
								pl,
								$ChemSymmetryUniquenessThreshold
								],
							pl
							]
						],
				_,
					#2
				]&,
			objAssoc
			]


(* ::Subsubsection::Closed:: *)
(*SymmetryElements*)



Options[ChemUtilsSymmetryElements]=
	Join[
		Options[ChemUtilsRawSymmetryElements],
		{
			"ReturnFunctions"->True,
			"DetermineClasses"->True,
			"FullClasses"->True
			}
		];
ChemUtilsSymmetryElements[atoms_, ops:OptionsPattern[]]:=
	Module[
		{
			raw=
				ChemUtilsRawSymmetryElements[atoms,
					FilterRules[{ops}, Options@ChemUtilsRawSymmetryElements]
					],
			fns,
			fullClass,
			funcs=TrueQ@OptionValue["ReturnFunctions"],
			classes=TrueQ@OptionValue["DetermineClasses"],
			fullClasses=TrueQ@OptionValue["FullClasses"]
			},
		fns=ChemUtilsSymmetryElementFunctions@raw;
		fullClass=
			If[fullClasses,
				ChemUtilsSymmetryElementExpandClass[raw, fns],
				raw
				];
		If[funcs,
			fns=ChemUtilsSymmetryElementFunctions@fullClass
			];
		<|
			"Elements"->
				fullClass,
			"Classes"->
				If[classes,
					Association@
						KeyValueMap[
							#->
								ReplaceAll[#2,
									MapIndexed[#->#2[[1]]&, fullClass[#]]
									]&,
							ChemUtilsSymmetryElementGrouping[
								fullClass, 
								fns
								]
							],
					Missing["NotComputed"]
					],
			"Functions"->
				If[funcs,
					Association@
					KeyValueMap[
						#->
							If[#=!="InversionCenter",
								KeyMap[
									Replace[MapIndexed[#->#2[[1]]&, fullClass[#]]],
									#2
									],
								#2
								]&,
						fns
						],
					Missing["NotComputed"]
					]
			|>
		]


(* ::Subsubsection::Closed:: *)
(*orderCount*)



rotOrderCount[order_,axes_]:=
	Length@Select[axes, First@#==order&];
rotOrderCount[order_][axes_]:=
	rotOrderCount[order,axes];


(* ::Subsubsection::Closed:: *)
(*IdentifyPointGroup*)



ChemUtilsIdentifyPointGroup[
	center:{_?NumericQ,_?NumericQ,_?NumericQ},
	centerOfSymmetry:True|False:False,
	rotationAxesS:{{_Integer|\[Infinity],_List}...},
	symmetryPlanesS:{{_List,_List}...}:{},
	screwAxesS:{{_Integer|\[Infinity],_List}...}:{}
	]:=
	With[{
		rotationAxes=
			deleteDuplicateRotationAxes[
				Map[ReplacePart[#, 2->#[[2]]-center]&, rotationAxesS],
				$ChemSymmetryUniquenessThreshold
				],
		symmetryPlanes=
			deleteDuplicatePlanes[
				Map[Map[#-center&, #]&, symmetryPlanesS],
				$ChemSymmetryUniquenessThreshold
				],
		screwAxes=
			deleteDuplicateRotationAxes[
				Map[ReplacePart[#, 2->#[[2]]-center]&, screwAxesS], 
				$ChemSymmetryUniquenessThreshold
				]
		},
	If[AnyTrue[First/@rotationAxes,#==\[Infinity]&],
		(*Linear*)
		If[centerOfSymmetry,
			(*Inversion center*)
			"D\[Infinity]h",
			(*No inversion center*)
			"C\[Infinity]v"
			],
		(*Non-linear*)
		If[rotOrderCount[3, rotationAxes]>1,
			(*2+ unique C3 axes*)
			If[rotOrderCount[5,rotationAxes]>1,
				(*2+ unique C5 axes*)
				If[centerOfSymmetry,
					(*Inversion center*)
					"Ih",
					(*No inversion center*)
					"I"],
				(* <2 unique C5 axes*)
				If[rotOrderCount[4,rotationAxes]>1,
					(*2+ unique C4 axes*)
					If[centerOfSymmetry,
						(*Inversion center*)
						"Oh",
						(*No inversion center*)
						"O"],
					(* <2 unique C4 axes*)
					If[Length@symmetryPlanes>0,
						(*Has symmetry planes*)
						If[centerOfSymmetry,
							(*Inversion center*)
							"Th",
							(*No inversion center*)
							"Td"],
						(*No symmetry planes*)
						"T"
						]
					]
				],
			(* <2 unique C3 axes*)
			If[Length@rotationAxes>0,
				(*Any rotation axes*)
				With[{mAxes=MaximalBy[rotationAxes,First]},
				With[{n=First@First@mAxes,axes=Last/@mAxes},
				If[Length@Cases[rotationAxes,{2,_}]>=n,
					(*N distinct C2 axes*)
					If[anyPerpPlane[center, axes, symmetryPlanes],
						(*Horizontal reflection plane*)
						"D"<>ToString@n<>"h",
						If[Length@symmetryPlanes>=n,
							(*N+ planes of symmetry*)
							"D"<>ToString@n<>"d",
							(* <N planes of symmetry *)
							"D"<>ToString@n
							]
						],
					(* <N distinct C2 axes*)
					If[anyPerpPlane[center, axes, symmetryPlanes],
						(*Horizontal reflection plane*)
						"C"<>ToString@n<>"h",
						If[Length@symmetryPlanes>=n,
							(*N+ planes of symmetry*)
							"C"<>ToString@n<>"v",
							If[Length@Cases[screwAxes,{2*n,_}]>0,
								(*2N screw axis*)
								"S"<>ToString[2*n],
								"C"<>ToString@n
								]
							]
						]
					]
					]
					],
				(*No rotation axes*)
				If[Length@symmetryPlanes>0,
					"Cs",
					If[centerOfSymmetry,
						"Ci",
						"C1"
						]
					]
				]
			]
		]
	]


(* ::Subsubsection::Closed:: *)
(*PointGroup*)



ChemUtilsPointGroup[
	smels_Association
	]:=
	ChemUtilsIdentifyPointGroup@@
		Lookup[
			smels["Elements"],
			{
				"Center", 
				"CenterSymmetric",
				"RotationAxes",
				"SymmetryPlanes",
				"ScrewAxes"
				}
			];
Options[ChemUtilsPointGroup]=
	Options@ChemUtilsSymmetryElements;
ChemUtilsPointGroup[
	atoms:{{_String,__}..},
	ops:OptionsPattern[]
	]:=
	ChemUtilsPointGroup@
		ChemUtilsSymmetryElements[atoms, ops];


(* ::Subsubsection::Closed:: *)
(*Graphics*)



ChemUtilsSymmetryGraphicsObjects[
	symmEls_Association,
	boxSize_?NumericQ,
	OptionsPattern[]
	]:=
	With[{symm=symmEls["Elements"], m=boxSize, M=boxSize+.15},
		<|
			"InversionCenter"->
				If[symm["CenterSymmetric"],
					{Red,AbsolutePointSize@10,Point@symm["Center"]},
					{}
					],
			"RotationAxes"->
				{
					AbsoluteThickness[1],
					Map[
						With[{v=Normalize[Last@#-symm["Center"]]},
							Line@{symm["Center"]+v*M,symm["Center"]-v*M}
							]&,
						symm["RotationAxes"]
						]
					},
			"SymmetryPlanes"->
				Map[
					With[{n=Cross[symm["Center"]-First@#,symm["Center"]-Last@#],N=48},
						{
							Opacity[.25],
							Polygon@
								NestList[
									RotationTransform[2.\[Pi]/N,n,symm["Center"]],
									symm["Center"]+m*Normalize[symm["Center"]-First@#],
									N]
							}
						]&,
					symm["SymmetryPlanes"]
					],
			"ScrewAxes"->
				{
					Red,
					AbsoluteThickness[2],
					Dashed,
					Map[
						With[{v=Normalize[Last@#-symm["Center"]]},
							Line@{symm["Center"]+v*M,symm["Center"]-v*M}
							]&,
						symm["ScrewAxes"]	
						]
					}
			|>
		]


Options[ChemUtilsSymmetryGraphicsObjects]=
	Options[ChemUtilsSymmetryElements];
ChemUtilsSymmetryGraphicsObjects[
	atoms_?(Length[#]>=3&),
	ops:OptionsPattern[]
	]:=
	With[{
		symm=
			ChemUtilsSymmetryElements[atoms,
				"ReturnFunctions"->False,
				"DetermineClasses"->False,
				ops
				],
		m=.5+Max@
				Map[Abs,
					Thread@CoordinateBoundingBox[Last/@atoms]
					]},
		ChemUtilsSymmetryGraphicsObjects[symm,m]
		]


Options[ChemUtilsSymmetryGraphics]=
	Join[
		Options[Graphics3D],
		Options[ChemUtilsSymmetryGraphicsObjects]
		];
ChemUtilsSymmetryGraphics[
	symm_Association,
	boxSize_?NumericQ,
	types:
		"InversionCenter"|"RotationAxes"|"SymmetryPlanes"|"ScrewAxes"|
			{("InversionCenter"|"RotationAxes"|"SymmetryPlanes"|"ScrewAxes")..}:
		{"InversionCenter","RotationAxes","SymmetryPlanes","ScrewAxes"},
	ops:OptionsPattern[]
	]:=
	Graphics3D[
		Lookup[
			ChemUtilsSymmetryGraphicsObjects[symm,boxSize,
				Sequence@@FilterRules[{ops},Options@ChemUtilsSymmetryGraphicsObjects]
				],
			types
			],
		ops
		];
ChemUtilsSymmetryGraphics[
	atoms_List?(Length[#]>=3&),
	ops:OptionsPattern[]
	]:=
	With[{
		symm=ChemUtilsSymmetryElements@atoms,
		m=.5+Max@
				Map[Abs,
					Thread@CoordinateBoundingBox[Last/@atoms]
					]},
		ChemUtilsSymmetryGraphics[symm,m,ops]
		]
	


End[];



