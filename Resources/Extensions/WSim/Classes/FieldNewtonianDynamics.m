(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*Newtonian Dynamics*)



(* ::Text:: *)
(*
	Newtonian dynamics via velocity Verlet
*)



$FieldNewtDyn::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*Propagator*)



(* ::Subsubsection::Closed:: *)
(*FieldNewtDynPropC*)



(* ::Text:: *)
(*
	Compiled propagator to be used by the ND. Uses the velocity Verlet algorithm.
*)



FieldNewtDynPropC//Clear


GE=Compile`GetElement;


SetAttributes[compileHold, HoldAllComplete];
SetAttributes[moduleHold, HoldAllComplete];


FieldNewtDynPropC[field_, friction_]:=
	With[
		{
			GE=Compile`GetElement
			},
		Compile@@
			ReplaceAll[
				compileHold[
					{
						{initCoordsAndVels, _Real, 3},
						{tInit, _Real},  
						{dt, _Real},
						{tSteps, _Integer},
						{storeTraj, _Integer}
						},
					moduleHold[
						{
							totalCoords,
							realTraj,
							storedSteps,
							storedStepPointer=1,
							coordVec=initCoordsAndVels[[1]],
							coordVecOld,
							velVec=initCoordsAndVels[[2]],
							dispVec,
							disp,
							walkerDim,
							walkerNum,
							totT=tInit,
							fric,
							forceVal,
							velOld,
							wCoord
							},
						walkerNum=Length@coordVec;
						walkerDim=Dimensions[coordVec][[2]];
						realTraj=Min@{Max@{storeTraj, 1}, tSteps};
						storedSteps=
							Table[
								Ceiling[tSteps*i/realTraj], 
								{i, Min@{Max@{realTraj, 1}, tSteps}}
								];
						totalCoords=Table[initCoordsAndVels, {i, realTraj}];
						Do[
							coordVecOld=coordVec;
							Do[
								fric=friction[GE[coordVec, i], totT];
								velOld=GE[velVec, i];
								If[fric!=0, velOld*=(1.-fric)];
								wCoord=GE[coordVec, i];
								(* Compute the force on walker i *)
								forceVal=field[wCoord];
								(* Compute new position and velocity of walker *)
								wCoord=wCoord+dt*velOld+dt^2*forceVal/2;
								coordVec[[i]]=wCoord;
								velVec[[i]]=velOld+dt*(forceVal+field[wCoord])/2,
								{i, walkerNum}
								];
							totT+=dt;
							If[n==storedSteps[[storedStepPointer]],
								totalCoords[[storedStepPointer]]={coordVec, velVec};
								storedStepPointer++
								];,
							{n, tSteps}
							];
						totalCoords
						],
					CompilationOptions->
						{
							"InlineExternalDefinitions"->True
							},
					RuntimeOptions->
						{
							"CatchMachineOverflow"->False,
							"CatchMachineIntegerOverflow"->False,
							"CompareWithTolerance"->False,
							"EvaluateSymbolically"->False,
							"WarningMessages"->False
							},
					CompilationTarget->"C",
					Parallelization->True
					],
				moduleHold->Module
				]
		];


(* ::Subsubsection::Closed:: *)
(*FieldNewtDynPropFunc*)



FieldNewtDynPropFunc//Clear


FieldNewtDynPropFunc[obj_]:=
	Module[
		{
			field=obj["FieldForceFunction"],
			fric=obj["FrictionFunction"]
			},
		FieldNewtDynPropC[
			field,
			fric
			]
		]


(* ::Subsection:: *)
(*Defaults*)



(* ::Subsubsection::Closed:: *)
(*DistGen*)



FieldNewtDynDistGen[walkers_, devs_]:=
		Thread@NormalDistribution[0, devs];


(* ::Subsubsection::Closed:: *)
(*ProbFunc*)



FieldNewtDynProbFunc=
	Exp[-#]&


(* ::Subsubsection::Closed:: *)
(*WalkerValidate*)



FieldNewtDynWalkerValidate[walks_]:=
	MatchQ[walks, 
		{
			{{__?NumericQ}, ___List},
			{{__?NumericQ}, ___List}
			}
		]


(* ::Subsubsection::Closed:: *)
(*WalkerBoxFunction*)



FieldNewtDynWalkerBoxFunction[walks_]:=
	CoordinateBounds@Flatten[walks[[;; ;;2]], 1];


(* ::Subsubsection::Closed:: *)
(*Plot*)



(* ::Subsubsubsection::Closed:: *)
(*readjustPointPlot*)



readjustPointPlot[plot_]:=
ReplacePart[plot,
	1->
		With[
			{
				pts=
				Cases[
					plot[[1]],
					 {d___, Point[p_], ___}:>{Flatten[Directive[d], 1,  Directive], p[[1]]}, 
					Infinity
					]
				},
			{
				pts[[1, 1]],
				Point[pts[[All, -1]], 
					VertexColors->pts[[All, 1]]]
				}
			]
	]


(* ::Subsubsubsection::Closed:: *)
(*plotCostFunction*)



plotCostFunction//Clear


plotCostFunction[dim_, cbs_, cf_, t_, ops:OptionsPattern[]]:=
	Switch[dim,
		1,
			Plot[cf[{x}, t], {x, cbs[[1, 1]], cbs[[1, 2]]}, 
				Evaluate@FilterRules[
					Flatten@{
						Lookup[{ops}, "CostFunctionStyle", {}],
						PlotStyle->Directive[Dashed, Gray],
						ops
						},
					Options@Plot
					]
				],
		2,
			ContourPlot[
				cf[{x, y}, t], 
				{x, cbs[[1, 1]], cbs[[1, 2]]}, 
				{y, cbs[[2, 1]], cbs[[2, 2]]},
				Evaluate@
					FilterRules[
						Flatten@{
							Lookup[{ops}, "CostFunctionStyle", {}],
							ColorFunction->
								With[{cd=ColorData["M10DefaultGradient"]},
									Directive[Opacity[.25], cd[#]]&
									],
							ops
							},
						Options@ContourPlot
						]
				],
		3,
			ContourPlot3D[
				cf[{x, y, z}, t], 
				{x, cbs[[1, 1]], cbs[[1, 2]]}, 
				{y, cbs[[2, 1]], cbs[[2, 2]]},
				{z, cbs[[2, 1]], cbs[[2, 2]]},
				Evaluate[
					FilterRules[
						Flatten@{
							Lookup[{ops}, "CostFunctionStyle", {}],
							ColorFunction->
								With[{cd=ColorData["M10DefaultGradient"]},
									Directive[Opacity[.25], cd[#]]&
									],
							ops
							},
						Options@ContourPlot3D
						]
					]
				],
		_,
			$Failed
		]


(* ::Subsubsubsection::Closed:: *)
(*plotState*)



FieldNewtDynPlotState//Clear


FieldNewtDynPlotState[walkers_, cbs_, t_, obj_, ops:OptionsPattern[]]:=
	With[{dim=Length@walkers[[1, 1]](*, cf=obj["CostFunction"]*)},
		Show[(*
			plotCostFunction[dim, cbs, cf, t, ops],*)
			Switch[dim,
				1,
				readjustPointPlot@
					ListPlot[
						{{#[[1]], 1}}&/@walkers[[1]], 
						FilterRules[
							{
								ops,
								PlotRange->{1.01*cbs[[1]], {.8, 1.2}},
								Frame->True,
								Axes->False
								},
							Options@ListPlot
							]
						],
				2,
				readjustPointPlot@
					ListPlot[
						List/@walkers[[1]], 
						FilterRules[
							{
								ops,
								PlotRange->1.01*cbs,
								Frame->True,
								Axes->False,
								AspectRatio->Full
								},
							Options@ListPlot
							]
						],
				3,
				readjustPointPlot@
					ListPointPlot3D[
						List/@walkers[[1]], 
						FilterRules[
							{
								ops,
								PlotRange->1.01*cbs,
								BoxRatios->Automatic
								},
							Options@ListPointPlot3D
							]
						],
				_,
					Throw[$Failed]
				]
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*applyPlotTheming*)



applyPlotTheming[
	coreData_,
	baseFunction_,
	inheritFrom_,
	o:OptionsPattern[]
	]:=
	Module[
		{
			inheritBase=Flatten[{inheritFrom}][[1]],
			theme,
			premethod,
			method,
			defaultstyle,
			defaultcf,
			cf,
			opts,
			threeDFlag,
			ticks
			},
		opts = 
			Flatten @ {o};
		Quiet[
			theme = OptionValue[inheritFrom, opts, PlotTheme]
			];
		theme=Charting`ResolvePlotTheme[theme, inheritBase];
		Quiet[premethod =Quiet@ OptionValue[inheritBase, theme, Method]];
		premethod = Charting`ConstructMethod@ premethod;
		theme = FilterRules[theme, Except @ Method];
		theme =
			FilterRules[
				theme,
				Join@@Map[Options, Flatten[{inheritFrom}]]
				];
		opts = Flatten[{opts, theme}];
		method=Quiet@OptionValue[inheritFrom, opts, Method];
		method=
			Charting`parseMethod[
				Charting`ConstructMethod@method,
				premethod
				];
		{defaultstyle, defaultcf, cf, ticks} =
			Quiet @ 
				OptionValue[
					inheritFrom,
					Flatten @ {method, opts},
					{"DefaultPlotStyle", "DefaultColorFunction", ColorFunction, Ticks}
					];
		cf = Charting`customColorFunction[inheritBase, cf, defaultcf];
		threeDFlag = StringContainsQ[SymbolName[inheritBase], "3D"];
		If[Visualization`Utilities`TicksQ[ticks],
			ticks = 
				If[threeDFlag,
					Visualization`Utilities`TicksExpand3D,
					Visualization`Utilities`TicksExpand
					] @ ticks,
			ticks = 
				If[threeDFlag,
					Visualization`Utilities`TicksExpand3D,
					Visualization`Utilities`TicksExpand
					] @ Automatic
			];
		ticks =
			Visualization`Utilities`ScaleTicks[
				ConstantArray[
					{Identity, Identity},
					If[threeDFlag, 3, 2]
					],
				ticks
				];
		opts=
			Join[
				opts,
				{
					"DefaultPlotStyle"->defaultstyle,
					ColorFunction->cf,
					Ticks->ticks
					}
				];
		baseFunction[
			coreData,
			Charting`FilterGraphicsOptions[
				Flatten@{opts, Method->method},
				Options@baseFunction
				]
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*customArrows3D*)



Options[customArrows3D]=
	Join[
		Options[ListVectorPlot3D],
		Options[System`VectorPlotsDump`iListVectorPlot3D],
		Charting`$GraphicsExtraOptions
		];
customArrows3D[{coords_, vels_},  ops:OptionsPattern[]]:=
	Module[
		{
			velNorms=Norm/@vels, 
			velMax,
			boxSize=Max@{-(Subtract@@MinMax@CoordinateBounds[coords]), .001},
			defps=OptionValue["DefaultPlotStyle"],
			cf=
				Replace[
					Charting`customColorFunction[
						ListVectorPlot3D,
						OptionValue[VectorColorFunction],
						OptionValue["DefaultColorFunction"]
						],
					cd_ColorDataFunction:>(cd[#]&)
					],
			velVecs,
			ps,
			hackColorMap
			},
		velMax=Max@velNorms;
		ps=
			Charting`customVectorStyle[ 
				OptionValue[VectorStyle],
				defps,
				1
				][[1]];
		If[velMax!=0,
			velVecs=Thread[{coords, coords+vels*(boxSize/10/velMax)}];
			hackColorMap=
			If[cf===None,
				Nothing,
				Association@
					MapThread[
						#[[1]]->(cf@@Flatten[Prepend[##]])&,
						{
							If[OptionValue@VectorColorFunctionScaling,
								Rescale@velVecs,
								velVecs
								],
							If[OptionValue@VectorColorFunctionScaling,
								Rescale@velNorms,
								velNorms
								]
							}
						]
				],
			hackColorMap=
				AssociationMap[Nothing,  Rescale@coords]
			];
		Show[
			ListPointPlot3D[coords,
				FilterRules[
					Flatten@
						{
							ColorFunctionScaling->
								OptionValue@VectorColorFunctionScaling,
							ColorFunction->
								If[cf=!=None,
									With[{nf=Nearest[Keys@hackColorMap]},
										hackColorMap[nf[{#, #2, #3}][[1]]]&
										],
									cf
									],
							ops,
							PlotStyle->ps,
							BoxRatios->Automatic
							}, 
					Options@ListPointPlot3D
					]
				],
			If[velMax!=0,
				Graphics3D[
					MapThread[
						Flatten@*List,
						{
							Replace[Quiet@OptionValue[VectorScale],
								{
									Automatic:>
										Thread@Arrowheads[velNorms/velMax/25, Appearance->"Projected"],
									n:_?NumericQ:>
										ConstantArray[
											Arrowheads[n, Appearance->"Projected"],
											Length@velNorms
											],
									Scaled[n_]:>
										Thread@Arrowheads[n*velNorms/velMax, Appearance->"Projected"],
									{unitLen_, arat_}:>
										ConstantArray[
											Arrowheads[
												Replace[unitLen,
													{
														Tiny->.01,
														Small->.025,
														Medium->.035,
														Large->.05,
														n_?NumericQ:>velMax/n
														}
													]*arat,
												Appearance->"Projected"
												],
											Length@velNorms
											],
									{unitLen_, arat_, sFun_}:>
										MapThread[
											Arrowheads[
												sFun[Sequence@@#, #2]*
													Replace[unitLen,
														{
															Tiny->.01,
															Small->.025,
															Medium->.035,
															Large->.05,
															n_?NumericQ:>velMax/n
															}
														]*arat&, 
												Appearance->"Projected"
												],
											{
												velVecs,
												velNorms
												}
											],
									_:>
										ConstantArray[
											Arrowheads[Appearance->"Projected"],
											Length@velNorms
											]
									}
								],
							ConstantArray[ps,Length@velNorms],
							If[cf===None,
								Nothing,
								Values@hackColorMap
								],
							Thread[Arrow@velVecs]
							}
						],
					FilterRules[{ops}, Options@Graphics3D]
					],
				{}
				]
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*customArrows2D*)



Options[customArrows2D]=
	Join[
		Options[ListVectorPlot],
		Options[System`VectorPlotsDump`iListVectorPlot],
		Charting`$GraphicsExtraOptions
		];
customArrows[{coords_, vels_},  ops:OptionsPattern[]]:=
	Module[
		{
			velNorms=Norm/@vels, 
			velMax,
			boxSize=Max@{-(Subtract@@MinMax@CoordinateBounds[coords]), .001},
			defps=OptionValue["DefaultPlotStyle"],
			cf=
				Replace[
					Charting`customColorFunction[
						ListVectorPlot,
						OptionValue[VectorColorFunction],
						OptionValue["DefaultColorFunction"]
						],
					cd_ColorDataFunction:>(cd[#]&)
					],
			velVecs,
			ps,
			hackColorMap
			},
		velMax=Max@velNorms;
		ps=
			Charting`customVectorStyle[ 
				OptionValue[VectorStyle],
				defps,
				1
				][[1]];
		If[velMax!=0,
			velVecs=Thread[{coords, coords+vels*(boxSize/10/velMax)}];
			hackColorMap=
			If[cf===None,
				Nothing,
				Association@
					MapThread[
						#[[1]]->(cf@@Flatten[Prepend[##]])&,
						{
							If[OptionValue@VectorColorFunctionScaling,
								Rescale@velVecs,
								velVecs
								],
							If[OptionValue@VectorColorFunctionScaling,
								Rescale@velNorms,
								velNorms
								]
							}
						]
				],
			hackColorMap=
				AssociationMap[Nothing,  Rescale@coords]
			];
		Show[
			ListPlot[coords,
				FilterRules[
					Flatten@
						{
							ColorFunctionScaling->
								OptionValue@VectorColorFunctionScaling,
							ColorFunction->
								If[cf=!=None,
									With[{nf=Nearest[Keys@hackColorMap]},
										hackColorMap[nf[{#, #2, #3}][[1]]]&
										],
									cf
									],
							ops,
							PlotStyle->ps
							}, 
					Options@ListPlot
					]
				],
			If[velMax!=0,
				Graphics[
					MapThread[
						Flatten@*List,
						{
							Replace[Quiet@OptionValue[VectorScale],
								{
									Automatic:>
										Thread@Arrowheads[velNorms/velMax/25, Appearance->"Projected"],
									n:_?NumericQ:>
										ConstantArray[
											Arrowheads[n, Appearance->"Projected"],
											Length@velNorms
											],
									Scaled[n_]:>
										Thread@Arrowheads[n*velNorms/velMax, Appearance->"Projected"],
									{unitLen_, arat_}:>
										ConstantArray[
											Arrowheads[
												Replace[unitLen,
													{
														Tiny->.01,
														Small->.025,
														Medium->.035,
														Large->.05,
														n_?NumericQ:>velMax/n
														}
													]*arat,
												Appearance->"Projected"
												],
											Length@velNorms
											],
									{unitLen_, arat_, sFun_}:>
										MapThread[
											Arrowheads[
												sFun[Sequence@@#, #2]*
													Replace[unitLen,
														{
															Tiny->.01,
															Small->.025,
															Medium->.035,
															Large->.05,
															n_?NumericQ:>velMax/n
															}
														]*arat&, 
												Appearance->"Projected"
												],
											{
												velVecs,
												velNorms
												}
											],
									_:>
										ConstantArray[
											Arrowheads[Appearance->"Projected"],
											Length@velNorms
											]
									}
								],
							ConstantArray[ps,Length@velNorms],
							If[cf===None,
								Nothing,
								Values@hackColorMap
								],
							Thread[Arrow@velVecs]
							}
						],
					FilterRules[{ops}, Options@Graphics]
					],
				{}
				]
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*PlotVelocities*)



FieldNewtDynPlotVelocities//Clear


Options[FieldNewtDynPlotVelocities]=
	Options[ListVectorPlot3D];
FieldNewtDynPlotVelocities[{coords_, vels_}, cbs_, t_, obj_, ops:OptionsPattern[]]:=
	With[{dim=Length@vels[[1]]},
		Switch[
			dim,
			1,
				applyPlotTheming[
					{Thread[{Flatten@coords, 1.}], Thread[{Flatten@vels, 1}]},
					customArrows2D,
					{ListVectorPlot3D,System`VectorPlotsDump`iListVectorPlot3D},
					ops,
					PlotRange->{1.01*cbs[[1]], {.8, 1.2}}
					],
			2,
				applyPlotTheming[
					{coords, vels},
					customArrows2D,
					{ListVectorPlot3D,System`VectorPlotsDump`iListVectorPlot3D},
					ops,
					PlotRange->1.01*cbs
					],
			3,
				applyPlotTheming[
					{coords, vels},
					customArrows3D,
					{ListVectorPlot3D,System`VectorPlotsDump`iListVectorPlot3D},
					ops,
					PlotRange->1.01*cbs
					],
			_,
				Throw[$Failed]
			]
		]


(* ::Subsection:: *)
(*Specification*)



$FieldNewtDyn=
	<|
		"RequiredProperties"->
			{
				"FrictionFunction",
				"FieldForceFunction"
				},
		"PropagatorGenerator"->
			FieldNewtDynPropFunc,
		"FrictionFunction"->
			(0&),
		"WalkerValidationFunction"->
			FieldNewtDynWalkerValidate,
		"WalkerBoxFunction"->
			FieldNewtDynWalkerBoxFunction,
		"PlotFunction"->
			FieldNewtDynPlotState,
		"ExtraPlotFunctions"->
			{
				"PlotVelocities"->
					FieldNewtDynPlotVelocities
				}
		|>


End[];


$FieldNewtDyn



