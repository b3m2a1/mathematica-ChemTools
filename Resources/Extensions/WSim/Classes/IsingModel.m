(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*Ising MCMC*)



(* ::Text:: *)
(*
	An MCMC that performs as the pure original 2D Ising model
*)



$IsingMCMC::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*Propagator*)



(* ::Subsubsection::Closed:: *)
(*IsingPropC*)



(* ::Text:: *)
(*
	Compiled propagator to be used by the MCMC. 
	Essential enhancements by Henrik Schumacher:
		https://mathematica.stackexchange.com/a/174328/38205
*)



IsingPropC[states_, field_, prob_]:=
	Compile[
		{
			{initCoords, _Integer, 2},
			{tInit, _Real},  
			{dt, _Real},
			{tSteps, _Integer},
			{storeTraj, _Integer}
			},
		Module[
			{
				totalCoords,
				realTraj,
				storedSteps,
				storedStepPointer=1,
				coordMat=initCoords,
				proposedSteps,
				coordMat1,
				peMat,
				condProbs,
				totT=tInit,
				totE,
				potEl,
				gridNRows,
				gridNCols,
				giL, giLj,
				giM, giMj,
				gjL, gjLi,
				gjM, gjMi,
				posF,
				up, down,
				left, right,
				spinIJ, potElOld
				},
			(* number of steps to be used in the trajectory *)
			realTraj=Min@{Max@{storeTraj, 1}, tSteps};
			(* steps to be cached *)
			storedSteps=
				Table[
					Ceiling[tSteps*i/realTraj], 
					{i, Min@{Max@{realTraj, 1}, tSteps}}
					];
			(* preallocated trajectory block *)
			totalCoords=Table[initCoords, {i, realTraj}];
			gridNRows=Length@initCoords;
			gridNCols=Dimensions[initCoords][[2]];
			up = RotateLeft[Range[gridNRows]];
			down = RotateRight[Range[gridNRows]];
			left = RotateLeft[Range[gridNCols]];
			right = RotateRight[Range[gridNCols]];
			Do[
				peMat=
					(*calculate PE on the grid from nearest neighbors*)
					Table[
						giL = Compile`GetElement[up, i];
						giM = Compile`GetElement[down, i];
						Table[
							posF=field[i, j, totT];
							gjL = Compile`GetElement[left, j];
							gjM = Compile`GetElement[right, j];
							spinIJ=Compile`GetElement[coordMat, i, j];
							Times[
								-spinIJ,
									Plus[
										posF,
										Compile`GetElement[coordMat, giL, j],
										Compile`GetElement[coordMat, giM, j],
										Compile`GetElement[coordMat, i, gjL],
										Compile`GetElement[coordMat, i, gjM]
										]
								], 
							{j, gridNCols}
							], 
						{i, gridNRows}
						];
				(* create new spin matrix *)
				coordMat1=
					RandomChoice[
						states, 
						{gridNRows, gridNCols}
						];
				(* compute conditional probabilities for transition *)
				condProbs=RandomReal[{0, 1}, {gridNRows, gridNCols}];
				(* make new spin matrix from MH criterion *)
				Do[
						giL = Compile`GetElement[up, i];
						giM = Compile`GetElement[down, i];
						Do[
							posF=field[i, j, totT];
							gjL = Compile`GetElement[left, j];
							gjM = Compile`GetElement[right, j];
							spinIJ=Compile`GetElement[coordMat1, i, j];
							potEl=
								Times[
									-spinIJ,
									Plus[
										posF,
										Compile`GetElement[coordMat, giL, j],
										Compile`GetElement[coordMat, giM, j],
										Compile`GetElement[coordMat, i, gjL],
										Compile`GetElement[coordMat, i, gjM]
										]
									];
							(*
						For unknown reasons using GetElement crashes here...
						*)
							potElOld=peMat[[i, j]];
							If[
								Compile`GetElement[condProbs, i, j]<(
									prob[potEl, totT]/prob[potElOld, totT]
									), 
								coordMat[[i, j]]=Compile`GetElement[coordMat1, i, j]
								], 
							{j, gridNCols}
							], 
						{i, gridNRows}
						];
				totT+=dt;
				If[n==storedSteps[[storedStepPointer]],
					totalCoords[[storedStepPointer]]=coordMat;
					storedStepPointer++
					];,
				{n, tSteps}
				];
			totalCoords
			],
		CompilationOptions->
			{
				"InlineExternalDefinitions"->True
				},
		RuntimeOptions->"Speed",
		CompilationTarget->"C"
		]


(* ::Subsubsection::Closed:: *)
(*IsingPropFunc*)



IsingPropFunc[obj_]:=
	Module[
		{
			states=Replace[obj["States"], Except[{__Integer}]->{-1, 1}],
			ff=obj["FieldFunction"],
			prob=obj["ProbabilityFunction"]
			},
		IsingPropC[
			Floor@states,
			ff,
			prob
			]
		]


(* ::Subsection:: *)
(*Defaults*)



(* ::Subsubsection::Closed:: *)
(*ProbFunc*)



IsingProbFunc=
	Exp[-#]&


(* ::Subsubsection::Closed:: *)
(*WalkerValidate*)



IsingWalkerValidate[walks_]:=
	MatrixQ[walks, IntegerQ]


(* ::Subsubsection::Closed:: *)
(*Plot*)



IsingPlotFunction[walks_, cbs_, t_, obj_, ops:OptionsPattern[]]:=
	ArrayPlot[
		walks,
		ops,
		ColorRules->
			With[{states=obj["States"]},
				MapIndexed[#->GrayLevel[Rescale[#2[[1]], {1, Length@states}]]&, states]
				]
		]


(* ::Subsection:: *)
(*Specification*)



$IsingMCMC=
	<|
		"RequiredProperties"->
			{
				"FieldFunction",
				"ProbabilityFunction",
				"States"
				},
		"PropagatorGenerator"->
			IsingPropFunc,
		"WalkerValidationFunction"->
			IsingWalkerValidate,
		"ProbabilityFunction"->
			IsingProbFunc,
		"PlotFunction"->
			IsingPlotFunction,
		"States"->
			{-1, 1},
		"FieldFunction"->
			(0&)
		|>


End[];


$IsingMCMC



