(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*ExtendedIsing MCMC*)



(* ::Text:: *)
(*
	An MCMC that performs as an ExtendedIsing model
*)



$ExtendedIsingMCMC::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*Propagator*)



(* ::Subsubsection::Closed:: *)
(*ExtendedIsingPropC*)



(* ::Text:: *)
(*
	Compiled propagator to be used by the MCMC
*)



ExtendedIsingPropC[pot_, field_, states_, wrap_, nnRad_, prob_]:=
	Compile[
		{
			{initCoords, _Integer, 2},
			{tInit, _Real},  
			{dt, _Real},
			{tSteps, _Integer},
			{storeTraj, _Integer}
			},
		Module[
			{
				totalCoords,
				realTraj,
				storedSteps,
				storedStepPointer=1,
				coordMat=initCoords,
				proposedSteps,
				coordMat1,
				peMat,
				condProbs,
				totT=tInit,
				totE,
				potEl,
				gridNRows,
				gridNCols,
				giL, giLj,
				giM, giMj,
				gjL, gjLi,
				gjM, gjMi,
				spinIJ
				},
			(* number of steps to be used in the trajectory *)
			realTraj=Min@{Max@{storeTraj, 1}, tSteps};
			(* steps to be cached *)
			storedSteps=
				Table[
					Ceiling[tSteps*i/realTraj], 
					{i, Min@{Max@{realTraj, 1}, tSteps}}
					];
			(* preallocated trajectory block *)
			totalCoords=Table[initCoords, {i, realTraj}];
			gridNRows=Length@initCoords;
			gridNCols=Dimensions[initCoords][[2]];
			Do[
				peMat=
					(* calculate the PE on the grid *)
					Table[
						spinIJ=Compile`GetElement[coordMat, i, j];
						potEl=field[i, j, totT]*spinIJ;
						Do[
							Do[
								giL=i-(n-m); giLj=j+m;
								giM=i+(n-m); giMj=j-m;
								gjL=j-(n-m); gjLi=i+m;
								gjM=j+(n-m); gjMi=i-m;
								(* main motion *)
								If[wrap&&giL<1,         giL=gridNRows+giL];
								If[wrap&&giM>gridNRows, giM=giM-gridNRows];
								If[wrap&&gjL<1,         gjL=gridNCols+gjL];
								If[wrap&&gjM>gridNCols, gjM=gjM-gridNCols];
								(* sub motion *)
								If[wrap&&giLj>gridNCols, giLj=giLj-gridNCols];
								If[wrap&&giMj<1,         giMj=gridNCols+giMj];
								If[wrap&&gjLi>gridNRows, gjLi=gjLi-gridNRows];
								If[wrap&&gjMi<1,         gjMi=gridNRows+gjMi];
								potEl+=
									Plus[
										If[wrap||(giL>=1&&giLj<=gridNCols),
											pot[
												spinIJ, 
												Compile`GetElement[coordMat, giL, giLj],
												{i, j},
												{giL, giLj},  
												totT
												],
											0
											],
										If[wrap||(giM<=gridNRows&&giMj>=1),
											pot[
												spinIJ, 
												Compile`GetElement[coordMat, giM, giMj],
												{i, j},
												{giM, giMj},
												totT
												],
											0
											],
										If[wrap||(gjL>=1&&gjLi<=gridNRows),
											pot[
												spinIJ, 
												Compile`GetElement[coordMat, gjLi, gjL],
												{i, j},
												{gjLi, gjL},
												totT
												],
											0
											],
									If[wrap||(gjM<=gridNCols&&gjMi>=1),
										pot[
											spinIJ, 
											Compile`GetElement[coordMat, gjMi, gjM],
											{i, j},
											{gjMi, gjM},  
											totT
											],
										0
										]
									],
							{m, 0, n-1}
							],
						{n, nnRad}
						];
					potEl,
					{i, gridNRows},
					{j, gridNCols}
					];
				(* create new spin matrix *)
				coordMat1=
					RandomChoice[
						states, 
						{gridNRows, gridNCols}
						];
				(* compute conditional probabilities for transition *)
				condProbs=RandomReal[{0, 1}, {gridNRows, gridNCols}];
				(* update positions based on MH *)
				Do[
					spinIJ=Compile`GetElement[coordMat, i, j];
					potEl=field[i, j, totT]*spinIJ;
					Do[
						Do[
							giL=i-(n-m); giLj=j+m;
							giM=i+(n-m); giMj=j-m;
							gjL=j-(n-m); gjLi=i+m;
							gjM=j+(n-m); gjMi=i-m;
							(* main motion *)
							If[wrap&&giL<1,         giL=gridNRows+giL];
							If[wrap&&giM>gridNRows, giM=giM-gridNRows];
							If[wrap&&gjL<1,         gjL=gridNCols+gjL];
							If[wrap&&gjM>gridNCols, gjM=gjM-gridNCols];
							(* sub motion *)
							If[wrap&&giLj>gridNCols, giLj=giLj-gridNCols];
							If[wrap&&giMj<1,         giMj=gridNCols+giMj];
							If[wrap&&gjLi>gridNRows, gjLi=gjLi-gridNRows];
							If[wrap&&gjMi<1,         gjMi=gridNRows+gjMi];
							potEl+=
								Plus[
									If[wrap||(giL>=1&&giLj<=gridNCols),
										pot[
											spinIJ, 
											Compile`GetElement[coordMat, giL, giLj],
											{i, j},
											{giL, giLj},  
											totT
											],
										0
										],
									If[wrap||(giM<=gridNRows&&giMj>=1),
										pot[
											spinIJ, 
											Compile`GetElement[coordMat, giM, giMj],
											{i, j},
											{giM, giMj},
											totT
											],
										0
										],
									If[wrap||(gjL>=1&&gjLi<=gridNRows),
										pot[
											spinIJ, 
											Compile`GetElement[coordMat, gjLi, gjL],
											{i, j},
											{gjLi, gjL},
											totT
											],
										0
										],
								If[wrap||(gjM<=gridNCols&&gjMi>=1),
									pot[
										spinIJ, 
										Compile`GetElement[coordMat, gjMi, gjM],
										{i, j},
										{gjMi, gjM},  
										totT
										],
									0
									]
								],
						{m, 0, n-1}
						],
					{n, nnRad}
					];
				If[
					condProbs[[i, j]]<(
						prob[potEl, totT]/
						prob[peMat[[i, j]], totT]
						), 
					coordMat[[i, j]]=coordMat1[[i, j]]
					],
				{i, gridNRows},
				{j, gridNCols}
				];
				totT+=dt;
				If[n==storedSteps[[storedStepPointer]],
					totalCoords[[storedStepPointer]]=coordMat;
					storedStepPointer++
					];,
				{n, tSteps}
				];
			totalCoords
			],
		CompilationOptions->
			{
				"InlineExternalDefinitions"->True
				},
		RuntimeOptions->
			{
				"CatchMachineOverflow"->False,
				"CatchMachineIntegerOverflow"->False,
				"CompareWithTolerance"->False,
				"EvaluateSymbolically"->False,
				"WarningMessages"->False
				},
		CompilationTarget->"C"
		]


(* ::Subsubsection::Closed:: *)
(*ExtendedIsingPropFunc*)



ExtendedIsingPropFunc[obj_]:=
	Module[
		{
			pot=obj["InteractionFunction"],
			field=obj["FieldFunction"],
			states=Replace[obj["States"], Except[{__Integer}]->{-1, 1}],
			prob=obj["ProbabilityFunction"],
			pbd=obj["PeriodicBoundary"],
			nnRad=Replace[obj["NeighborRadius"], Except[_Integer]->1]
			},
		ExtendedIsingPropC[
			pot, 
			field,
			Floor@states,
			TrueQ@pbd,
			nnRad,
			prob
			]
		]


(* ::Subsection:: *)
(*Defaults*)



(* ::Subsubsection::Closed:: *)
(*ProbFunc*)



ExtendedIsingProbFunc=
	Exp[-#]&


(* ::Subsubsection::Closed:: *)
(*WalkerValidate*)



ExtendedIsingWalkerValidate[walks_]:=
	MatrixQ[walks, IntegerQ]


(* ::Subsubsection::Closed:: *)
(*Plot*)



ExtendedIsingPlotFunction[walks_, cbs_, t_, obj_, ops:OptionsPattern[]]:=
	ArrayPlot[
		walks,
		ops,
		ColorRules->
			With[{states=obj["States"]},
				MapIndexed[#->GrayLevel[Rescale[#2[[1]], {1, Length@states}]]&, states]
				]
		]


(* ::Subsection:: *)
(*Specification*)



$ExtendedIsingMCMC=
	<|
		"RequiredProperties"->
			{
				"InteractionFunction",
				"FieldFunction",
				"States",
				"ProbabilityFunction",
				"NeighborRadius",
				"PeriodicBoundary"
				},
		"PropagatorGenerator"->
			ExtendedIsingPropFunc,
		"WalkerValidationFunction"->
			ExtendedIsingWalkerValidate,
		"InteractionFunction"->
			Function[-#*#2],
		"FieldFunction"->
			Function[0.],
		"ProbabilityFunction"->
			ExtendedIsingProbFunc,
		"PlotFunction"->
			ExtendedIsingPlotFunction,
		"PeriodicBoundary"->True,
		"NeighborRadius"->1,
		"States"->{-1, 1}
		|>


End[];


$ExtendedIsingMCMC



