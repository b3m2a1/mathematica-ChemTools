(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*PES Walker MCMC*)



(* ::Text:: *)
(*
	An MCMC that will propagate over a PES
*)



$PESWalkerMCMC::usage="";


Begin["`Private`"];


(* ::Subsection:: *)
(*Propagator*)



(* ::Subsubsection::Closed:: *)
(*PESWalkerPropC*)



(* ::Text:: *)
(*
	Compiled propagator to be used by the MCMC
*)



SetAttributes[compileHold, HoldAllComplete]
SetAttributes[moduleHold, HoldAllComplete]


PESWalkerPropC[pot_, dists_, prob_]:=
	With[
		{
			distMap=
				Quiet@
					MapThread[
						RandomVariate[
							#, 
							{#2, walkerDim}
							]&, 
						Transpose@dists
						]
			},
		Compile@@
			ReplaceAll[
				compileHold[
					{
						{initCoords, _Real, 2},
						{tInit, _Real},  
						{dt, _Real},
						{tSteps, _Integer},
						{storeTraj, _Integer}
						},
					moduleHold[
						{
							totalCoords,
							realTraj,
							storedSteps,
							storedStepPointer=1,
							coordVec=initCoords,
							walkerDim=Length[initCoords[[1]]],
							proposedSteps,
							coordVec1,
							peVec,
							peVec1,
							condProbs,
							totT=tInit,
							totE
							},
						realTraj=Min@{Max@{storeTraj, 1}, tSteps};
						storedSteps=
							Table[
								Ceiling[tSteps*i/realTraj], 
								{i, Min@{Max@{realTraj, 1}, tSteps}}
								];
						totalCoords=Table[initCoords, {i, realTraj}];
						Do[
							peVec=If[Length[#]>0, Norm[#], #]&[pot[#, totT]]&/@coordVec;
							proposedSteps=
								Flatten[distMap, 1];
							coordVec1=coordVec+proposedSteps;
							peVec1=If[Length[#]>0, Norm[#], #]&[pot[#, totT]]&/@coordVec1;
							condProbs=RandomReal[{0, 1}, Length@coordVec];
							coordVec=
								MapThread[
									If[#5<(prob[#, totT]/prob[#2, totT]), #3, #4]&,
									{
										peVec1,
										peVec,
										coordVec1,
										coordVec,
										condProbs
										}
									];
							totT+=dt;
							If[n==storedSteps[[storedStepPointer]],
								totalCoords[[storedStepPointer]]=coordVec;
								storedStepPointer++
								];,
							{n, tSteps}
							];
						totalCoords
						],
					CompilationOptions->
						{
							"InlineExternalDefinitions"->True
							},
					RuntimeOptions->
						{
							"CatchMachineOverflow"->False,
							"CatchMachineIntegerOverflow"->False,
							"CompareWithTolerance"->False,
							"EvaluateSymbolically"->False,
							"WarningMessages"->False
							},
					CompilationTarget->"C",
					Parallelization->True
					],
			moduleHold->Module
			]
		]


(* ::Subsubsection::Closed:: *)
(*PESWalkerPropFunc*)



PESWalkerPropFunc[obj_]:=
	Module[
		{
			pot=obj["CostFunction"],
			distGen=obj["DistributionGenerator"],
			prob=obj["ProbabilityFunction"],
			walkers=obj["Walkers"],
			masses=Replace[obj["StandardDeviations"], Except[_?NumericQ|{__?NumericQ}]:>1],
			dists
			},
		dists=
			distGen[
				walkers, 
				Take[
					Flatten[ConstantArray[masses, Length@walkers], 1],
					Length@walkers
					]
				];
		PESWalkerPropC[
			pot, 
			Map[{#[[1]], Length@#}&, SplitBy[dists, Identity]], 
			prob
			]
		]


(* ::Subsection:: *)
(*Defaults*)



(* ::Subsubsection::Closed:: *)
(*DistGen*)



PESWalkerDistGen[walkers_, devs_]:=
		Thread@NormalDistribution[0, devs];


(* ::Subsubsection::Closed:: *)
(*ProbFunc*)



PESWalkerProbFunc=
	Exp[-#]&


(* ::Subsubsection::Closed:: *)
(*WalkerValidate*)



PESWalkerWalkerValidate[walks_]:=
	MatchQ[walks, {{__?NumericQ}, ___List}]


(* ::Subsubsection::Closed:: *)
(*Plot*)



(* ::Subsubsubsection::Closed:: *)
(*readjustPointPlot*)



readjustPointPlot[plot_]:=
ReplacePart[plot,
	1->
		With[
			{
				pts=
				Cases[
					plot[[1]],
					 {d___, Point[p_], ___}:>{Flatten[Directive[d],1,  Directive], p[[1]]}, 
					Infinity
					]
				},
			{
				pts[[1, 1]],
				Point[pts[[All, -1]], 
					VertexColors->pts[[All, 1]]]
				}
			]
	]


(* ::Subsubsubsection::Closed:: *)
(*plotCostFunction*)



plotCostFunction//Clear


plotCostFunction[dim_, cbs_, cf_, t_, ops:OptionsPattern[]]:=
	Switch[dim,
		1,
			Plot[cf[{x}, t], {x, cbs[[1, 1]], cbs[[1, 2]]}, 
				Evaluate@FilterRules[
					Flatten@{
						Lookup[{ops}, "CostFunctionStyle", {}],
						PlotStyle->Directive[Dashed, Gray],
						ops
						},
					Options@Plot
					]
				],
		2,
			ContourPlot[
				cf[{x, y}, t], 
				{x, cbs[[1, 1]], cbs[[1, 2]]}, 
				{y, cbs[[2, 1]], cbs[[2, 2]]},
				Evaluate@
					FilterRules[
						Flatten@{
							Lookup[{ops}, "CostFunctionStyle", {}],
							ColorFunction->
								With[{cd=ColorData["M10DefaultGradient"]},
									Directive[Opacity[.25], cd[#]]&
									],
							ops
							},
						Options@ContourPlot
						]
				],
		3,
			ContourPlot3D[
				cf[{x, y, z}, t], 
				{x, cbs[[1, 1]], cbs[[1, 2]]}, 
				{y, cbs[[2, 1]], cbs[[2, 2]]},
				{z, cbs[[2, 1]], cbs[[2, 2]]},
				Evaluate[
					FilterRules[
						Flatten@{
							Lookup[{ops}, "CostFunctionStyle", {}],
							ColorFunction->
								With[{cd=ColorData["M10DefaultGradient"]},
									Directive[Opacity[.25], cd[#]]&
									],
							ops
							},
						Options@ContourPlot3D
						]
					]
				],
		_,
			$Failed
		]


(* ::Subsubsubsection::Closed:: *)
(*plotState*)



PESWalkerPlotState//Clear


PESWalkerPlotState[walkers_, cbs_, t_, obj_, ops:OptionsPattern[]]:=
	With[{dim=Length@walkers[[1]], cf=obj["CostFunction"]},
		Show[
			plotCostFunction[dim, cbs, cf, t, ops],
			Switch[dim,
				1,
				readjustPointPlot@
					ListPlot[
						{{#[[1]], cf[#, t]}}&/@walkers, 
						FilterRules[
							{
								ops,
								PlotRange->{1.01*cbs[[1]], Automatic},
								Frame->True,
								Axes->False
								},
							Options@ListPlot
							]
						],
				2,
				readjustPointPlot@
					ListPlot[
						List/@walkers, 
						FilterRules[
							{
								ops,
								PlotRange->1.01*cbs,
								Frame->True,
								Axes->False
								},
							Options@ListPlot
							]
						],
				3,
					ListPointPlot3D[
						List/@walkers, 
						FilterRules[
							{
								ops,
								PlotRange->1.01*cbs
								},
							Options@ListPointPlot3D
							]
						],
				_,
					Throw[$Failed]
				]
			]
		]


(* ::Subsection:: *)
(*Specification*)



$PESWalkerMCMC=
	<|
		"RequiredProperties"->
			{
				"CostFunction",
				"DistributionGenerator",
				"ProbabilityFunction",
				"StandardDeviations"
				},
		"PropagatorGenerator"->
			PESWalkerPropFunc,
		"WalkerValidationFunction"->
			PESWalkerWalkerValidate,
		"ProbabilityFunction"->
			PESWalkerProbFunc,
		"DistributionGenerator"->
			PESWalkerDistGen,
		"PlotFunction"->
			PESWalkerPlotState,
		"StandardDeviations"->
			1
		|>


End[];


$PESWalkerMCMC



