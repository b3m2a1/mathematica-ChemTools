(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemDVRBegin[];


RadialDVRFormatGrid::usage="Formats the grid";
RadialDVRPoints::usage="Returns the radial DVR grid/array"
RadialDVRK::usage="Returns the radial DVR kinetic energy matrix"
RadialDVRV::usage="Returns the radial DVR potential energy matrix"
RadialDVRWavefunctions::usage="Returns the radial DVR Hamiltonian eigensystem"
RadialDVRPlot::usage="Plots a radial DVR eigensystem"


Begin["`Private`"];


RadialDVRFormatGrid[grid_,points_]:=grid;


RadialDVRPoints[
	points:{_Integer},
	X:{{_?NumericQ,_?NumericQ}}:{{0,10}}
	]:=
	Subdivide@@Flatten@{N@X,points-1}


Options[RadialDVRK]=
	{
		"Mass"->1,
		"HBar"->1,
		"ScalingFactor"->1,
		"UseExact"->False
		};
RadialDVRK[grid_,ops:OptionsPattern[]]:=
With[{rmin=Min@grid,rmax=Max@grid,points=Length@grid},
		With[
			{
				dr=(rmax-rmin)/(points-1),
				m=OptionValue@"Mass",
				\[HBar]=OptionValue@"HBar",
				scl=OptionValue@"ScalingFactor",
				ex=TrueQ@OptionValue@"UseExact"
				},
			With[
				{
					f=
						If[ex,
							scl*
								If[#==#2, 
									\[Pi]^2./3.-1/#^2,
									2./(#-#2)^2-2./(#+#2)^2
									]*
									(\[HBar]^2.(-1)^(#-#2))/(2.m dr^2)&,
							scl*
								If[#==#2, 
									\[Pi]^2./3.-1/#^2,
									2./(#-#2)^2-2./(#+#2)^2
									]*
									(\[HBar]^2.(-1)^(#-#2))/(2.m dr^2)&
							]
					},
				If[points>100000,
					ParallelTable[f[i,j],{i,points},{j,points}],
					Table[f[i,j],{i,points},{j,points}]
					]
				]
			]
		]


Options[RadialDVRV]={Function->(10*Power[1-Exp[-(#-2)],2]&)};
RadialDVRV[gridpoints_,ops:OptionsPattern[]]:=
With[{P=OptionValue[Function],X=gridpoints,p=Length@gridpoints},
	SparseArray[Band[{1,1}]->P/@X,{p,p}]
	];


Options[RadialDVRPlot]=
	DeleteDuplicatesBy[First]@
	Flatten@{
		"WavefunctionSelection"->Automatic,
		AxesOrigin->{0,0},
		Scaled->Automatic,
		"EnergyDigits"->3,
		"ZeroPointEnergy"->0,
		LabelingFunction->Automatic,
		"CutOff"->10^-5,
		Manipulate->True,
		PlotRange->Automatic,
		"SquareWavefunction"->False,
		FilterRules[Options[Plot],
			Except[AxesOrigin|PlotRange|LabelingFunction]]
		};
RadialDVRPlot[solutions_,grid_,potentialMatrix_,ops:OptionsPattern[]]:=
	Module[
		{\[CapitalLambda],X,\[Psi],
		scale=
			Replace[OptionValue[Scaled],
				Automatic:>
					Max@{1/10*Max[Abs/@MinMax[Flatten@potentialMatrix]], 10}
				],
		num=
			Replace[OptionValue["WavefunctionSelection"],
				Automatic:>If[TrueQ@OptionValue@Manipulate,All,5]
				],
		dataRange,
		potential=
			If[potentialMatrix//MatrixQ,
				Diagonal@potentialMatrix,
				potentialMatrix],
		squared=OptionValue@"SquareWavefunction",
		lf=Replace[OptionValue@LabelingFunction,{
				Automatic->(Row@{Subscript["\[Psi]",#1],": E=",#2}&),
				None->False}],
		plotWave,waveSet,Ec=OptionValue["CutOff"],
		wavePlot,potentialPlot,
		\[Lambda]Plot,plotRange
		},
		{\[CapitalLambda],X}=solutions;
		num=
			Replace[num,
				{
					All:>Range[1,Length[\[CapitalLambda]]],
					_List:>num,
					_Integer:>Range[1,num],
					_->1
					}];
		\[Psi][n_]:=MapThread[{#1,If[squared,#2^2,#2]}&,{grid,X[[n]]}];
		waveSet=\[Psi]/@num;
		dataRange=With[{\[CurlyPhi]=Select[Flatten[waveSet,1],Abs[#[[2]]]>=Ec&]},
					{Min[\[CurlyPhi][[All,1]]],Max[\[CurlyPhi][[All,1]]]}
					];
		plotWave[n_]:=
			With[{s={1,scale}, \[Lambda]={0,\[CapitalLambda][[n]]}},
				\[Lambda]+s*#&/@\[Psi][n]
				];
		waveSet=
			Select[#,Between[dataRange]@*First]&/@(plotWave/@num);
		wavePlot[sel_,lFunc_:lf]:=
			ListLinePlot[ 
				waveSet[[sel]],
				PlotRange->{
					Min@Append[waveSet[[sel,All,2]],0],
					Max@waveSet[[sel,All,2]]
					},
				PlotLegends->
					If[lFunc===False,
						None,
						(lFunc@@#)&/@
							Thread@{
								num[[ If[Length@sel===0,{sel},sel] ]],
								\[CapitalLambda][[ num[[ If[Length@sel===0,{sel},sel] ]] ]]
								}
						]
				];
		potentialPlot=
			ListLinePlot[
				Thread[{grid,potential}],
				PlotStyle->{Gray,Dashing[{.01,.025,.02,.025}]}
				];
		\[Lambda]Plot[sel_]:=
			ListLinePlot[
				Thread[{grid,#}],
				PlotStyle->{Red,Dotted}
				]&/@\[CapitalLambda][[ num[[sel]] ]];
		plotRange=Automatic;
			(*Replace[OptionValue@PlotRange,Automatic:>Max@Flatten@waveSet[[All,2]]];*)
		If[Length@num>1,
			If[OptionValue@Manipulate,
				With[{wp=wavePlot,N=num,
					lF=With[{f=lf[#1,#2]},f&],
					potPlot=potentialPlot,L=\[CapitalLambda],
					\[Lambda]P=\[Lambda]Plot,pR=plotRange},
				Manipulate[
					Show[
						wp[N[[i]],lF],
						{potPlot,\[Lambda]P[{i}]},
						FilterRules[{ops,PlotRange->pR},Options[Plot]]],
					{{i,1,""},1,Length@N,1}
					]
				],
				Show[wavePlot[All],
					{potentialPlot,\[Lambda]Plot[All]},
					FilterRules[{ops,PlotRange->plotRange},
						Options[Plot]]
					]
			],
			Show[wavePlot[All],
				{potentialPlot,\[Lambda]Plot[All]},
				FilterRules[{ops,PlotRange->plotRange},
					Options[Plot]]
				]
			]
	];


End[];


$RadialDVR=
	<|
		"Name"->"Radial 1D",
		"Dimension"->1,
		"FormatGrid"->RadialDVRFormatGrid,
		"PointLabels"->{("r"|"R"|"radial")},
		"Range"->{{0,10}},
		"Grid"->RadialDVRPoints,
		"KineticEnergy"->RadialDVRK,
		"PotentialEnergy"->RadialDVRV,
		"View"->RadialDVRPlot
		|>


ChemDVREnd[];


$RadialDVR



