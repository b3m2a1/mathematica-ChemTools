(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemDVRBegin[];


LegendreDVRFormatGrid::usage="Formats the grid";
LegendreDVRPoints::usage="The Legendre eigensystem";
LegendreDVRK::usage="The Legendre kinetic energy";
LegendreDVRV::usage="The Legendre potential energy";
LegendreDVRWavefunctions::usage="The Legendre wavefunctions";
LegendreDVRPlot::usage="The Legendre view function";


Begin["`Private`"];


LegendreDVRFormatGrid[grid_,points_]:=
	grid;


(*legX[i_,j_]:=
Integrate[LegendreP[i,Cos[\[Theta]]]*Cos[\[Theta]]*LegendreP[j,Cos[\[Theta]]]*Sin[\[Theta]],{\[Theta],0,\[Pi]}]
legT=ParallelTable[Integrate[LegendreP[i,Cos[\[Theta]]]*Cos[\[Theta]]*LegendreP[j,Cos[\[Theta]]]*Sin[\[Theta]],{\[Theta],0,\[Pi]}],{i,50},{j,50}];
FindSequenceFunction[MapIndexed[#[[First[#2]+1]]&,Most@legT],i]
Table[
With[{ip=i-1,jp=j-1},
(2 (1+jp))/(3+8 jp+4 jp^2)KroneckerDelta[i+1,j]+
(2 (1+ip))/(3+8 ip+4 ip^2)KroneckerDelta[i,j+1]
],
{i,50},
{j,50}
]//MatrixForm*)


(*LegendreDVRPoints[{\[Theta]Points_},r_]:=
	With[{eig=
		Eigensystem@
			Table[
				With[{ip=i-1,jp=j-1},
					2.(1+jp)/(3+8 jp+4 jp^2)*KroneckerDelta[i+1,j]+
					2.(1+ip)/(3+8 ip+4 ip^2)*KroneckerDelta[i,j+1]
					],
				{i,\[Theta]Points},
				{j,\[Theta]Points}
				]
		},
		eig[[All,Ordering[First@eig]]]
		]*)


LegendreDVRPoints[{\[Theta]Points_},r_]:=
	With[{eig=
		Eigensystem@
			Table[
				Sqrt[i^2/((-1 + 2*i)*(1 + 2.*i))]*KroneckerDelta[j, -1 + i] +
					Sqrt[(1 + i)^2/((3 + 2*i)*(1 + 2.*i))]*KroneckerDelta[j, 1 + i],
				{i,\[Theta]Points},
				{j,\[Theta]Points}
				]
		},
		eig[[All,Ordering[First@eig]]]
		]


Clear["LegendreDVRK"]
Options[LegendreDVRK]=
	{"\[HBar]"->1,"m"->1};
LegendreDVRK[eigensystem_,ops:OptionsPattern[]]:=
	With[
		{
			m=OptionValue["m"],\[HBar]=OptionValue@"\[HBar]",
			T=Last@eigensystem,\[CapitalLambda]=First@eigensystem
			},
		Replace[OptionValue@"\[HBar]",Except[_?NumericQ]->1.]*
			Dot[T,
				DiagonalMatrix@Array[(#-1)(#)&,Length[\[CapitalLambda]]],
				Transpose@T]+
				DiagonalMatrix@Map[m^2/(1-#^2)&,\[CapitalLambda]]
		]


Clear["LegendreDVRV"]
Options[LegendreDVRV]=
	{Function->Sin};
LegendreDVRV[eigensystem_,ops:OptionsPattern[]]:=
	With[
		{
			\[CapitalLambda]=First@eigensystem,T=Last@eigensystem,
			P=OptionValue[Function]},
		SparseArray[{i_,i_}:>P[ArcCos[\[CapitalLambda][[i]]]],{Length[\[CapitalLambda]],Length[\[CapitalLambda]]}]
		];


LegendreDVRWavefunctions[T_,V_]:=
	With[{S=#[[{1,2},Ordering[First@#]]]&@Eigensystem[T+V]},
		With[{phase=Sign@S[[2,1]]},
			{First@S,phase*#&/@Last@S}
			]
		];


Options[LegendreDVRPlot]=
	DeleteDuplicatesBy[
		Flatten@{
			FilterRules[Options[ListPolarPlot],Except[Joined|ColorFunction]],
			Labeled->True,
			"EnergyShift"->False,
			"WavefunctionSelection"->Automatic,
			"EnergyDigits"->3,
			"ShowPotential"->True,
			"SquareWavefunction"->False,
			Manipulate->True,
			ColorFunction->"BrightBands"
			},
		First];
LegendreDVRPlot[solutions_,gridpoints_,potentialmatrix_,ops:OptionsPattern[]]:=
	Module[
		{
			X,T,V=potentialmatrix,\[CapitalLambda],\[CapitalPsi],\[Psi],
			waveSet,wavePlot,potentialPlot,volEl,
			num=
				Replace[OptionValue["WavefunctionSelection"],
					Automatic:>If[OptionValue@Manipulate//TrueQ,All,5]
					]},
		{X,T}=gridpoints;
		{\[CapitalLambda],\[CapitalPsi]}=solutions;
		num=
			Which[
				num===All,
					Range[1,Length[\[CapitalLambda]]],
				MatchQ[num,_List],
					num,
				MatchQ[num,_Integer],
					Range[1,num],
				True,
					Range[1,Floor[Length[\[CapitalLambda]]/2]]
				];
		volEl[x_]:=
			Sqrt[1-x^2];
		\[Psi][n_]:=
			Reverse@SortBy[First]@
				With[
					{
						S=OptionValue["EnergyShift"],
						Q=TrueQ@OptionValue["SquareWavefunction"]
						},
					MapThread[
						{ArcCos@#,If[S,\[CapitalLambda][[n]],0]+If[Q,Power[#2,2],#2]}&,
						{X,\[CapitalPsi][[n]]}]
					];
		waveSet=\[Psi]/@num;
		wavePlot=
			MapThread[
				ListPolarPlot[#,
					PlotLegends->
						If[TrueQ@OptionValue[Labeled],
							Row[{
								Subscript["\[Psi]",ToString[#2]],
								": E=",
								Round[\[CapitalLambda][[#2]],1.0*10^(-1*OptionValue["EnergyDigits"])]
								}],
							None
							],
					ColorFunctionScaling->False,
					ColorFunction->
						With[{c=ColorData[OptionValue[ColorFunction]][#2/Length@num]},
							Function[{x,y,\[Theta],r},Darker[c,\[Theta]/(1.5\[Pi])]]
							],
					FilterRules[{
						ops
						},
						Options[ListPolarPlot]
						],
					Joined->True
				]&,{
				waveSet,
				num
				}];
		potentialPlot=
			If[TrueQ@OptionValue["ShowPotential"],
				With[{
					pset=
						With[{D=Diagonal[V],M=Max@Diagonal@V,m=Max[waveSet[[All,All,2]]]},
							Reverse@SortBy[First]@
								MapThread[
									{#1,Abs[m/M]#2}&,
									{X,D}
									]
							]},
					With[{p=1,M=Max[pset[[All,2]]],m=Min[pset[[All,2]]]},
						Graphics[{
							Arrowheads[Small],
							Table[
								{GrayLevel[Rescale[pset[[i,2]],{m,M},{0,.9}]],
									Arrow[-#2*{Sin[#1],Cos[#1]}&@@@Take[pset,{i,(i+1)}]]
									},
								{i,Floor[Length[pset]/p]-1}]
							}]
						]
					],
				{}];
		If[OptionValue[Manipulate],
			With[{
				wp=wavePlot,pp=potentialPlot},
				Manipulate[
					Show[wp[[n]],pp],
					{{n,1,"Wavefunction"},1,Length[wp],1}
					]
				],
			Show[Append[wavePlot,potentialPlot]]
			]
		]


End[];


$LegendreDVR=
	<|
		"Name"->"Legendre 1D",
		"Dimension"->1,
		"FormatGrid"->LegendreDVRFormatGrid,
		"PointLabels"->{("\[Theta]"|"theta"|"Theta"|"Azimuthal"|"azimuthal")},
		"Range"->{{0,\[Pi]}},
		"Grid"->LegendreDVRPoints,
		"KineticEnergy"->LegendreDVRK,
		"PotentialEnergy"->LegendreDVRV,
		"Wavefunctions"->LegendreDVRWavefunctions,
		"View"->LegendreDVRPlot
		|>


ChemDVREnd[];


$LegendreDVR



