(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemDVRBegin[];


SphericalDVRFormatGrid::usage=
	"Formats a grid appropriately for a DVR";
SphericalDVRPoints::usage=
	"Constructs the spherical DVR grid with the appropriate Legendre tranformation";
SphericalDVRK::usage=
	"Constructs the kinetic matrix";
SphericalDVRV::usage=
	"Constructs the potential energy matrix";
SphericalDVRWavefunctions::usage=
	"Computes the wavefunctions";
SphericalDVRWavefunctionGrid::usage=
	"Returns the wavefuntions on the DVR grid";
SphericalDVRPotentialObjectFunction::usage=
	"Returns a function to generate the potential plot object";
SphericalDVRWavefunctionPlotFunction::usage=
	"Returns a function to plot the wave function and potential";
SphericalDVRPlot::usage=
	"Plot function";
$SphericalDVR::usage=
	"The output class association";


(*SynchronousAdjustment::usage="(boolean) Option name for SphericalDVRPlot"
"PotentialPointSize"::usage="(graphics size specifier) Option name for SphericalDVRPlot"

"EnergyDigits"::usage="(integer) Option name for SphericalDVRPlot"
"Interactivity"::usage="(None,Less,Normal,More) Option name for SphericalDVRPlot"
"PotentialMode"::usage=
	"(True,False,Point,Line,'Dispersed',Blend) Option name for SphericalDVRPlot"
"PotentialColoring"::usage=
	"The coloring function to use for the potential";
"WavefunctionValueMin"::usage="(0<x<=1) Option name for SphericalDVRPlot"
"WavefunctionValueMax"::usage="(0<x<=1) Option name for SphericalDVRPlot"

"WavefunctionPointSize"::usage="(graphics size specifier) Option name for SphericalDVRPlot"
"WavefunctionStyle"::usage="(Point,Line) Option name for SphericalDVRPlot"
"ManipulatorStep"::usage="Option name for SphericalDVRPlot"
"WavefunctionSelection"::usage="(All,Integer,List) Option name for SphericalDVRPlot"
"RadialPointSelection"::usage="(All,Integer,List) Option name for SphericalDVRPlot"
"AzimuthalPointSelection"::usage="(All,Integer,List) Option name for SphericalDVRPlot"
"PolarPointSelection"::usage="(All,Integer,List) Option name for SphericalDVRPlot"
"ZeroPointEnergy"::usage="(Number) Option for SphericalDVRPlot"
"PotentialSelection"::usage="(All,Integer,'Radial','Azimuthal','Polar',List) Option name for SphericalDVRPlot"*)


(*"RotationalA"::usage="Specifies the A rotational constant for a PlanePointDVR"
"RotationalB"::usage="Specifies the B rotational constant for a PlanePointDVR"
"RotationalC"::usage="Specifies the C rotational constant for a PlanePointDVR"
"ReducedMass"::usage="Specifies the reduced mass of the complex"*)


(*"More"::usage="Option value for \"Interactivity\" in SphericalDVRPlot"
"Sparse"::usage="Option value for \"WavefunctionPointSize\" in SphericalDVRPlot"
"Blobby"::usage="Option value for \"WavefunctionPointSize\" in SphericalDVRPlot"
"Dense"::usage="Option value for \"WavefunctionPointSize\" in SphericalDVRPlot"
"Ultrafine"::usage="Option value for \"ManipulatorStep\" in SphericalDVRPlot"*)


ChemDVRNeeds/@{"LegendreDVR","MeyerDVR","RadialDVR"};


Begin["`Private`"];


sph2orth=Evaluate[FromSphericalCoordinates[{#,#2,#3}]]&;
orth2sph=Evaluate[ToSphericalCoordinates[{#,#2,#3}]]&


rIndex[rN_,\[Phi]N_,\[Theta]N_]:=
	Function[{i,j},
		With[{f=Function[k,1+Mod[Floor[(k-1)/\[Phi]N]+1,rN]]},
			{f[i],f[j]}
			]
		];
\[Phi]Index[rN_,\[Phi]N_,\[Theta]N_]:=
	Function[{i,j},
		With[{f=Function[k,1+Mod[k-1,\[Phi]N]]},
			{f[i],f[j]}
			]
		];
\[Theta]Index[rN_,\[Phi]N_,\[Theta]N_]:=
	Function[{i,j},
		With[{f=Function[k,1+Floor[(k-1)/(rN*\[Phi]N)]]},
			{f[i],f[j]}
			]
		]


SphericalDVRFormatGrid[grid_,points_:None]:=
	grid


SphericalDVRPoints[
	{rpoints_Integer,\[Theta]points_Integer,\[Phi]points_Integer},
	{
		rrange:{_?NumericQ,_?NumericQ}:{1,2},
		\[Theta]range:{_?NumericQ,_?NumericQ}:{0,\[Pi]},
		\[Phi]range:{_?NumericQ,_?NumericQ}:{0,2\[Pi]}
		}]:=
	With[{
		R=RadialDVRPoints[{rpoints},{rrange}],
		\[CapitalPhi]=MeyerDVRPoints[{\[Phi]points},{\[Phi]range}]
		},
		With[{LTransfANDgrid=
			#[[{1,2},Ordering@First@#]]&@LegendreDVRPoints[{\[Theta]points},{\[Theta]range}]},
			{
				Table[
					{r, \[Theta], \[Phi]},
					{r,R},{\[Phi],\[CapitalPhi]},{\[Theta],LTransfANDgrid[[1]]}
					],
				LTransfANDgrid[[2]]
				}
			]
	];


Options[SphericalDVRK]=
	DeleteDuplicatesBy[First]@
	Flatten[{
		"\[HBar]"->1,"m"->1,
		Options[LegendreDVRK],
		Options[RadialDVRK],
		Options[MeyerDVRK]}];
(*Clear["SphericalDVRK"]
	SphericalDVRK[grid_,ops:OptionsPattern[]]:=
		Module[
			{T,X,
				rX,\[Phi]X,\[Theta]X,
				rK,\[Phi]K,\[Theta]K,
				rN,\[Phi]N,\[Theta]N,
				rind,\[Phi]ind,\[Theta]ind,
				\[Delta]r,\[Delta]\[Phi],\[Delta]\[Theta],
				Kel,K
			},
			{X,T}=grid;
			X=Flatten[X,2];
			{rX,\[Phi]X,\[Theta]X}=DeleteDuplicates/@Array[X[[All,#]]&,3];
			rK=RadialDVRK[rX];\[Phi]K=MeyerDVRK[\[Phi]X];\[Theta]K=LegendreDVRK[{\[Theta]X,T}];
			{rN,\[Phi]N,\[Theta]N}=Length/@{rK,\[Phi]K,\[Theta]K};rind[i_,j_]:=With[{f=Function[k,1+Mod[Floor[(k-1)/\[Phi]N],rN]]},{f[i],f[j]}];\[Phi]ind[i_,j_]:=With[{f=Function[k,1+Mod[k-1,\[Phi]N]]},{f[i],f[j]}];
			\[Theta]ind[i_,j_]:=With[{f=Function[k,1+Floor[(k-1)/(rN*\[Phi]N)]]},{f[i],f[j]}];\[Delta]r[i_,j_]:=KroneckerDelta@@rind[i,j];\[Delta]\[Phi][i_,j_]:=KroneckerDelta@@\[Phi]ind[i,j];\[Delta]\[Theta][i_,j_]:=KroneckerDelta@@\[Theta]ind[i,j];Kel[i_,j_]:=(
				((\[Delta]\[Phi][i,j]*\[Delta]\[Theta][i,j])rK[[ Sequence@@rind[i,j] ]])+
				((\[Delta]r[i,j]*\[Delta]\[Theta][i,j])\[Phi]K[[ Sequence@@\[Phi]ind[i,j] ]])+
				((\[Delta]\[Phi][i,j]*\[Delta]r[i,j])\[Theta]K[[ Sequence@@\[Theta]ind[i,j] ]])
				);
			K=Array[Kel,{rN*\[Phi]N*\[Theta]N,rN*\[Phi]N*\[Theta]N}]
		]*)


Options[SphericalDVRV]=
	Flatten[{
		Function->Function[{r,\[Phi],\[Theta]},If[r<10^-10,1/r^2,-(1/r^2)]]
		}];
SphericalDVRV[gridpoints_,ops:OptionsPattern[]]:=
	With[
		{
			P=OptionValue[Function],
			X=
				{#1,#2,ArcCos[#3]}&@@@
					Cases[First@gridpoints,
						{_?NumericQ,_?NumericQ,_?NumericQ},\[Infinity]]//SortBy[Last]
			},
		SparseArray[Band[{1,1}]->P@@@X]
		]


SphericalDVRWavefunctions[T_,V_]:=
	With[{S=#[[{1,2},Ordering[First@#]]]&@Eigensystem[T+V]},
		With[{phase=Sign@S[[2,1]]},
			{First@S,phase*#&/@Last@S}
			]
		];


SphericalDVRWavefunctionGrid[gridAndT_,wfs_,___]:=
		With[{
		coreGridPoints=
			(Flatten[#, Depth[#]-3]&@gridAndT[[1]])
		},
		MapThread[
			#->Thread[{coreGridPoints,#2}]&,
			wfs
			]
		];


Options[SphericalDVRWavefunctionPlotFunction]=
	Flatten[{Verbose->False,AddTo->{},Options[Graphics3D]}];
SphericalDVRWavefunctionPlotFunction[(*Should have 16 arguments*)
	Gridpoints_,WavefunctionFunction_,EnergyLevelFunction_,
	PointColoringFunction_,PointFunction_,FieldPoints_,
	radialGridpoints_:None,angularGridpoints_:None,azimuthalGridpoints_:None,
	radialSelectionDefault_:All,
		angularSelectionDefault_:All,azimuthalSelectionDefault_:All,
	waveFunctionDigits_:10,boxSize_:None,
		pointSpec_:Small,axes_:{},ops:OptionsPattern[]]:=
	Module[{
		WavefunctionGraphics,X=Gridpoints,\[Psi]=WavefunctionFunction,
		\[CapitalLambda]=EnergyLevelFunction,coFunc=PointColoringFunction,pointFunc=PointFunction,
		verb=OptionValue@Verbose,epi=OptionValue@AddTo,
		sph2orth=
			Evaluate[CoordinateTransform["Spherical"->"Cartesian",{#,#2,#3}]]&,
		rX=radialGridpoints,\[Phi]X=angularGridpoints,\[Theta]X=azimuthalGridpoints},
		If[rX==None,rX=Gridpoints[[All,1]]];
		If[\[Phi]X==None,\[Phi]X=Gridpoints[[All,2]]];
		If[\[Theta]X==None,\[Theta]X=Gridpoints[[All,3]]];
		
		WavefunctionGraphics[
				wavefunctionNumber_,minimumValue_,maximumValue_,
				potentialBarLegend_:None,wavefunctionValueBarLegend_:None,
				colorFunction_:coFunc,
				showFieldPoints_:True,showWaveFunction_:True,
				radialSelection_:radialSelectionDefault,
				angularSelection_:angularSelectionDefault,
				azimuthalSelection_:azimuthalSelectionDefault,
				pointSize_:pointSpec,axThing_:axes,
				fieldPoints_:FieldPoints,verbose_:verb,epilog_:epi]:=
				With[{
					n=wavefunctionNumber,c=minimumValue,cs=maximumValue,
					pot=potentialBarLegend,
					wvv=wavefunctionValueBarLegend,cpF=showFieldPoints,grF=showWaveFunction,
					colorPoints=fieldPoints},
					Module[
						{
						\[Phi]=\[Psi][n],\[Lambda]=0,
						graphic,R=radialSelection,F=angularSelection,Q=azimuthalSelection,
						coP=
							With[{csn=If[cs===0,1,cs]},
								Function[x,colorFunction[Rescale[x,{0,csn}]]]],
						\[Psi]m=None,\[CapitalPsi]M=None,\[Psi]T=0
						},
						If[MemberQ[R,All],R=rX[[All]],R=rX[[R]]];
						If[MemberQ[F,All],F=\[Phi]X[[All]],F=\[Phi]X[[F]]];
						If[MemberQ[Q,All],Q=Sort[\[Theta]X][[All]],Q=Sort[\[Theta]X][[Q]]];
						graphic=
							Graphics3D[{
								If[TrueQ@cpF,
									{PointSize[Small],
										colorPoints[[2]]
									},
									{}],
								axThing,
								{Opacity[0],
									Line[boxSize{-{1,1,1},{1,1,1}}]
								},
								(*The actual wavefunction points*)
								If[Not@grF,
									{},
									With[{
										ps=Switch[pointSize,_?NumberQ,PointSize@pointSize,_,pointSize]
										},
										\[Psi]m=\[Infinity];\[CapitalPsi]M=-\[Infinity];\[Psi]T=0;
										Table[
											With[{p=\[CurlyPhi][[-1]]},\[Psi]m=Min[{\[Psi]m,p}];\[CapitalPsi]M=Max[{\[CapitalPsi]M,p}]];
											Which[
												(
													Not@MemberQ[R,\[CurlyPhi][[1]]]||
													Not@MemberQ[F,\[CurlyPhi][[2]]]||
													Not@MemberQ[Q,\[CurlyPhi][[3]]]
													),
													(*If the point shouldn't be displayed*)
													Null,
												Abs[\[CurlyPhi][[-1]]-\[Lambda]]>cs,
													(*If the wavefunction value is greater than the max there*)
													{Opacity[.5],ps,Black,Point[sph2orth@@\[CurlyPhi][[1;;3]]]},
												Abs[\[CurlyPhi][[-1]]-\[Lambda]]>=c,
													(*If the wavefunction value is greater than or equal to the minimum there*)
													{ps,coP[Abs[\[CurlyPhi][[-1]]-\[Lambda]]],pointFunc[\[CurlyPhi],\[Lambda]]},
												True,
													(*Otherwise have no point*)
													Null],
											{\[CurlyPhi],\[Phi]}]
										]
									],
								Replace[epilog,Graphics3D[l_]:>l]
								},
								(*Graphics options*)
								FilterRules[{ops},Except[AddTo|Verbose|Axes]],
								Axes->If[axThing==={},False,True]
								]//Legended[#,
										Panel[
											Column[{
												Row[{
													Subscript["E",ToString[n]],
													": ",1.*Round[\[CapitalLambda][n],10^(-waveFunctionDigits)]
													}],
												Row[{
													If[grF,Column[{"\[Psi]-value",wvv}],""],
													If[Not@TrueQ[pot==Null]&&cpF,Column[{" Potential",pot}],""]
													}],
												Row[{
													Row[{
														Subscript["\[Psi]","min"],
														NumberForm[\[Psi]m,waveFunctionDigits]
														}],
													Spacer[10],
													Row[{Subscript["\[Psi]","max"],NumberForm[\[CapitalPsi]M,waveFunctionDigits]}]
													}]
												},
												Dividers->Center]
												]
										]&
						]
					];
		WavefunctionGraphics
		];


$cont=$Context;


GeneratePointPotentialFuncion[Gridpoints_,
	rGrid_,fGrid_,qGrid_,
	DefaultCutoff_,DefaultSize_]:=
	With[{
		pointF=Unique[$cont<>"pointF"],
		sph2orth=
			Evaluate[CoordinateTransform["Spherical"->"Cartesian",{#,#2,#3}]]&,
		splineCircle=
			Function[{m,r,angles},
				With[{a=
					Replace[Mod[angles//N,2 \[Pi]],
						({s_,e_}/;e<=s):>
							{s,e+2\[Pi]}
						]},
					With[{
						seg=
							If[Quotient[Abs[Last@a-First@a]//N,\[Pi]/2]==4,
								3,
								Quotient[Abs[Last@a-First@a]//N,\[Pi]/2]],
						\[Phi]=
							If[Quotient[Abs[Last@a-First@a]//N,\[Pi]/2]==4,
								\[Pi]/2,
								Mod[Abs[Last@a-First@a]//N,\[Pi]/2]
								]
						},
						BSplineCurve[
							m+#&/@
								If[Length[m]==2,
									Identity,
									Transpose[Append[#,ConstantArray[0,Length[First@#]]]]&
									]@Dot[
										r*RotationMatrix[First@angles],
										Transpose@Join[
											Take[{{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}},2*seg+1],
											RotationMatrix[seg \[Pi]/2].#&/@{
												{1,Tan[\[Phi]/2]},
												{Cos[\[Phi]],Sin[\[Phi]]}
												}
											]],
							SplineDegree->2,
							SplineKnots->
								Join[
									{0,0,0},
									Riffle[#,#]&@Range[seg+1],
									{seg+1}],
							SplineWeights->
								Join[
									Take[{1,1/Sqrt[2],1,1/Sqrt[2],1,1/Sqrt[2],1},2 seg+1],
									{Cos[\[Phi]/2],1}
									]
								
							]
						]
					]
				]
		},
		SetAttributes[pointF,Temporary];
		pointF[A_,F_,
				X_:Gridpoints,rX_:rGrid,\[Phi]X_:fGrid,
				\[Theta]X_:qGrid,mode_:All,function_:({Point[#1],PointSize[#2]}&),
				cutOff_:DefaultCutoff,op_:1,size_:DefaultSize
				]:=
			Module[{selection,ordering={rX,Sort@\[Phi]X,Sort@\[Theta]X},choices=mode},
				If[MatchQ[choices,Except[_List|_Integer|_String|_Rule]],
					choices={"Points","Radial","Azimuthal","Polar"}];
				selection={{{},{},{}},{{},{},{}},{{},{},{}}};
				With[{repPattern=
					Function[{n,v},
						With[{y=Replace[v,{_Integer:>Range[v],_List:>v,_:>{v}}]},
							{1,2,3}/.{
								n:>(Cases[y,_Integer|All|None|_Spacings|_Select]/.{
									l:{_Integer..}:>
										Range[Length@ordering[[n]]][[l]],
									{___,None,___}->
										{},
									o:{
										Select[r_?(0<#<=1)&]|
										Select[{rm_,rM_}/;(0<rm<1&&rm<rM<=1)]
										}:>
										Range@@(Floor/@(Flatten@{o[[1,1]]*Length@ordering[[n]]})),
									{Spacings[i_]}:>
										With[{R=Range[Length@ordering[[n]]]},
											Table[Floor[i*k],{k,Floor[R/i]}]
											],
									o_:>
										(Range[Length@ordering[[n]]])
									}),
								n2_Integer:>
									Replace[Cases[y,(n2->l_):>l],
										{
											({}|{All})->
												Range[Length@ordering[[n2]]],
											o:{Select[r_/;0<r<=1]|Select[{rm_,rM_}/;(0<rm<1&&rm<rM<=1)]}:>
												Range@@(Floor/@(Flatten@{o[[1,1]]*Length@ordering[[n2]]})),
											{Spacings[i_]}:>
												With[{R=Range[Length@ordering[[n2]]]},
													Table[Floor[i*k],{k,Floor[R/i]}]
													],
											c_:>
												Range[Length@ordering[[n2]]][[Flatten@{c}]]}
										]
								}]
							]},
					ReplaceAll[choices/.{
						"Radial"->1,
						"Azimuthal"->2,
						"Polar"->3},
						{(i2:(1|2|3)->x_):>
							(selection[[i2]]=repPattern[i2,x]),
						c:(1|2|3):>
							(selection[[c]]=
								{
									Range[Length@ordering[[1]]],
									Range[Length@ordering[[2]]],
									Range[Length@ordering[[3]]]
									})
						}]
					];
				selection=
					MapThread[
						Intersection@@({#1,#2,#3}/.{}->Range[Max@Flatten[{#1,#2,#3}]])&,
						selection];
				selection=
					MapThread[#1[[#2]]&,{ordering,selection}];
				MapThread[
					If[
						(cutOff[#1]=!=False) &&
						AllTrue[Range[3],
							With[{l=#2},
								MemberQ[selection[[#]],l[[#]] ]&
								]
							],
					{Opacity[op],F[#1],function[sph2orth@@#2,size]},
					{}]&,
					{A,X}]
				];
			pointF
		];


GenerateBlobPotential[Gridpoints_,rGrid_,fGrid_,qGrid_,DefaultCutoff_]:=
	With[{
		blobF=Unique[$cont<>"blobF"],
		pointF=
			GeneratePointPotential[
				Gridpoints,rGrid,fGrid,qGrid,
				DefaultCutoff,.2]
		},
		SetAttributes[blobF,Temporary];
		blobF[A_,F_,X_:Gridpoints,mode_:All,cutOff_:DefaultCutoff]:=
			pointF[A,F,X,rGrid,fGrid,qGrid,mode,
				({Point[#1],PointSize[#2]}&),cutOff,.1,.2];
		blobF
		];


GenerateLinePotentialFunction[
	Gridpoints_,rGrid_,fGrid_,qGrid_,
	DefaultCutoff_,DefaultSize_]:=
	With[{
		lineF=Unique[$cont<>"lineF"],
		sph2orth=
			Evaluate[CoordinateTransform["Spherical"->"Cartesian",{#,#2,#3}]]&,
		splineCircle=
			Function[{m,r,angles},
				With[{a=
					Replace[Mod[angles//N,2 \[Pi]],
						({s_,e_}/;e<=s):>
							{s,e+2\[Pi]}
						]},
					With[{
						seg=
							If[Quotient[Abs[Last@a-First@a]//N,\[Pi]/2]==4,
								3,
								Quotient[Abs[Last@a-First@a]//N,\[Pi]/2]],
						\[Phi]=
							If[Quotient[Abs[Last@a-First@a]//N,\[Pi]/2]==4,
								\[Pi]/2,
								Mod[Abs[Last@a-First@a]//N,\[Pi]/2]
								]
						},
						BSplineCurve[
							m+#&/@
								If[Length[m]==2,
									Identity,
									Transpose[Append[#,ConstantArray[0,Length[First@#]]]]&
									]@Dot[
										r*RotationMatrix[First@angles],
										Transpose@Join[
											Take[{{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}},2*seg+1],
											RotationMatrix[seg \[Pi]/2].#&/@{
												{1,Tan[\[Phi]/2]},
												{Cos[\[Phi]],Sin[\[Phi]]}
												}
											]],
							SplineDegree->2,
							SplineKnots->
								Join[
									{0,0,0},
									Riffle[#,#]&@Range[seg+1],
									{seg+1}],
							SplineWeights->
								Join[
									Take[{1,1/Sqrt[2],1,1/Sqrt[2],1,1/Sqrt[2],1},2 seg+1],
									{Cos[\[Phi]/2],1}
									]
								
							]
						]
					]
				]
		},
		SetAttributes[lineF,Temporary];
		lineF[A_,F_,
			X_:Gridpoints,rX_:rGrid,\[Phi]X_:fGrid,\[Theta]X_:qGrid,
			mode_:All,function_:Line,cutOff_:DefaultCutoff,op_:1,
			size_:DefaultSize]:=
				Module[{
					switchPattern={-1,-2,-2,-3,-3,-1},choices=mode,points=False,
					basecount,ordering,selection,lengths,angles
					},
					ordering={rX, \[Phi]X,Sort@\[Theta]X};
					lengths=Length/@ordering;
					angles={2\[Pi]/lengths[[2]],\[Pi]/lengths[[3]]};
					If[MatchQ[choices,Except[_List|_Integer|_String|_Rule]],
						choices={"Points","Radial","Azimuthal","Polar"}
						];
					selection={{{},{},{}},{{},{},{}},{{},{},{}}};
					With[{repPattern=
						Function[{n,v},
							With[{y=Replace[v,{_Integer:>Range[v],_List:>v,_:>{v}}]},
								{1,2,3}/.{
									n:>
									ReplaceAll[
										Cases[y,_Integer|All|None|_Spacings|_Select],{
											l:{_Integer..}:>
												Range[Length@ordering[[n]]][[l]],
											{___,None,___}->
												{},
											o:{
													Select[r_/;0<r<=1]|
													Select[{rm_,rM_}/;(0<rm<1&&rm<rM<=1)]
													}:>
												(Range@@(Floor/@(Flatten@{o[[1,1]]*Length@ordering[[n]]}))),
											{Spacings[i_]}:>
												With[{R=Range[Length@ordering[[n]]]},
													Table[Floor[i*k],{k,Floor[R/i]}]
													],
											o_:>
												(Range[Length@ordering[[n]]])
										}],
									n2_Integer:>
										Replace[Cases[y,(n2->l_):>l],{
											({}|{All})->
												Range[Length@ordering[[n2]]],
											o:{Select[r_/;0<r<=1]|Select[{rm_,rM_}/;(0<rm<1&&rm<rM<=1)]}:>
												Range@@(Floor/@(Flatten@{o[[1,1]]*Length@ordering[[n2]]})),
											{Spacings[i_]}:>
												With[{R=Range[Length@ordering[[n2]]]},
													Table[Floor[i*k],{k,Floor[R/i]}]
													],
											c_:>
												Range[Length@ordering[[n2]]][[Flatten@{c}]]
											}]
									}
								]
							]},
						ReplaceAll[choices/.{"Radial"->1,"Azimuthal"->2,"Polar"->3},
							{
								(i2:(1|2|3)->x_):>
									(selection[[i2]]=repPattern[i2,x]),
								c:(1|2|3):>
									(
										selection[[c]]={
											Range[Length@ordering[[1]]],
											Range[Length@ordering[[2]]],
											Range[Length@ordering[[3]]]
											}
										)
								}]
						];
					points=MemberQ[choices,("Points"|0)];
					With[{R=Reap[
						MapThread[
							With[{Px=#1,r=#2[[1]],f=#2[[2]],q=#2[[3]],x=sph2orth@@#2,tx={
								Position[ordering[[1]],#2[[1]]][[1,1]],
								Position[ordering[[2]],#2[[2]]][[1,1]],
								Position[ordering[[3]],#2[[3]]][[1,1]]
								}},
								If[cutOff[Px]=!=False,
									Module[{p1,p2,p3,p4,p5,p6,counter=1},
											p1=tx+{1,0,0};p2=tx+{0,1,0};p3=tx+{0,0,1};
											p4=tx-{1,0,0};p5=tx-{0,1,0};p6=tx-{0,0,1};
											If[p1[[1]]>lengths[[1]],p1[[1]]=lengths[[1]]];
											If[p3[[3]]>lengths[[3]],p3[[3]]=lengths[[3]]];
											If[p4[[1]]==0,p4[[1]]=1];
											If[p6[[3]]==0,p6[[3]]=1];
											If[points,
												Sow@
													{
														F[Px],
														PointSize[Switch[size,_?NumberQ,size+.05,_,size]],
														Point[x]
														}
												];
											Do[
												With[{
													reps={
														1:>
															With[{y=sph2orth@@(ordering[[#,p[[#]]]]&/@{1,2,3})},
																With[{cp=x+Normalize[y-x]*Norm[y-x]/2},
																	Sow[{
																		CapForm["Butt"],
																		Thickness[size],
																		Opacity[op],
																		{F[Px],Line[{x,cp}]}
																		}]
																	]
																],
														2:>
															With[{y=
																splineCircle[
																	{0,0,x[[3]]},
																	Norm@x[[1;;2]],
																	With[{a=angles[[1]],n=tx[[2]],m=p[[2]]},
																		Sort@{f,f+a/2*Sign[m-n]}
																		]
																	]},
																Sow[{
																	CapForm["Butt"],
																	Thickness[size],
																	Opacity[op],
																	{F[Px],y}}
																	]
																],
														3:>
															With[{y=
																splineCircle[
																	{0,0,0},
																	r,
																	Sort@{q,q+(p[[3]]-tx[[3]])*angles[[2]]/2}
																	]},
																With[{
																	r1=(
																		GeometricTransformation[#,
																			RotationTransform[-\[Pi]/2,{0,1,0}]
																			]&
																			),
																	r2=(
																		GeometricTransformation[#,
																			RotationTransform[
																				f-angles[[1]]*lengths[[2]]/4,
																				{0,0,1}]
																			]&
																			)
																	},
																	Sow[{
																		CapForm["Butt"],
																		Thickness[size],
																		Opacity[op],
																		{F[Px],r2[r1[y]]}}
																		]
																	]
																]}
													},
												If[p!=tx,
													If[
														AllTrue[Range[3],
															MemberQ[selection[[counter,#]],p[[#]]]&
															],
														Replace[counter,reps]
														]
													];
												];
												counter=Mod[++counter,3,1];,
												{p,{p1,p2,p3,p4,p5,p6}}
												]													
											]
										]
								]&,
							{A,X}
							];
						][[2]]
					},
					If[Length@R>0,R[[1]],R]
					]
				];
		lineF
		];


GenerateBlendPotentialFuncion[Gridpoints_,
	rGrid_,fGrid_,qGrid_,
	DefaultCutoff_]:=
	With[{
		blendF=Unique[$cont<>"blendF"],
		lineF=
			GenerateLinePotentialFunction[
				Gridpoints,rGrid,fGrid,qGrid,
				DefaultCutoff,.01]
		},
		SetAttributes[blendF,Temporary];
		blendF[A_,F_,
			X_:Gridpoints,rX_:rGrid,\[Phi]X_:fGrid,\[Theta]X_:qGrid,
			mode_:All,function_:Line,cutOff_:DefaultCutoff]:=
				lineF[A,F,X,rX,\[Phi]X,\[Theta]X,mode,function,cutOff,1,.01];
		blendF
		]


SphericalDVRPotentialObjectFunction[Gridpoints_,PotentialArray_,
		radialGridpoints_:None,angularGridpoints_:None,azimuthalGridpoints_:None,
		DefaultDrawMode_:Point,DefaultColorFunction_:"FuschiaTones",
		DefaultSize_:Small,DefaultMode_:All,DefaultCutoff_:(True&)]:=
	Module[{
			PotentialGraphics,
			rGrid=radialGridpoints,fGrid=angularGridpoints,qGrid=azimuthalGridpoints},
			If[rGrid==None,rGrid=Gridpoints[[All,1]]];
			If[fGrid==None,fGrid=Gridpoints[[All,2]]];
			If[qGrid==None,qGrid=Gridpoints[[All,3]]];
			With[{
				pointF=
					GeneratePointPotentialFunction[
						Gridpoints,rGrid,fGrid,qGrid,
						DefaultCutoff,DefaultSize],
				blobF=
					GenerateBlobPotentialFunction[
						Gridpoints,rGrid,fGrid,qGrid,
						DefaultCutoff],
				lineF=
					GenerateLinePotentialFunction[			
						Gridpoints,rGrid,fGrid,qGrid,
						DefaultCutoff,DefaultSize],
				blendF=
					GeneratBlendPotentialFunction[
						Gridpoints,rGrid,fGrid,qGrid,
						DefaultCutoff]
				},
				PotentialGraphics[
					X_:Gridpoints,V_:PotentialArray,
					FP_:DefaultDrawMode,potCo_:DefaultColorFunction,
					rX_:rGrid,fX_:fGrid,qX_:qGrid,
					mode_:DefaultMode,cutOffFunction_:DefaultCutoff]:=
					If[MatchQ[FP,False|None],
						{Null,{}},
						With[{
							A=If[MatrixQ@V,Diagonal[V],V],
							R=MinMax@If[MatrixQ@V,Diagonal[V],V],
							potF=
								Replace[potCo,_String|_List:>ColorData[potCo]]
							},
							{
								BarLegend[{potF@Rescale[#,R]&,R}],
								Replace[FP,{
									Point:>
										pointF[A,potF@Rescale[#,R]&,
											X,rX,fX,qX,
											mode,({Point[#1],PointSize[#2]}&),
											cutOffFunction],
									Line:>
										lineF[A,potF@Rescale[#,R]&,
											X,rX,fX,qX,mode,Line,cutOffFunction],
									Blend:>
										blendF[A,potF@Rescale[#,R]&,
											X,rX,fX,qX,mode,Line,cutOffFunction],
									"Blobby":>
										blobF[A,potF@Rescale[#,R]&,
											X,rX,fX,qX,mode,cutOffFunction],
									{Point,f_}:>
										pointF[A,potF@Rescale[#,R]&,X,rX,fX,qX,mode,f,cutOffFunction],
									f_:>
										f[A,potF@Rescale[#,R]&,X,rX,fX,qX,mode,cutOffFunction]
										}]
								}]
						]
					];
		PotentialGraphics		
		]


splineCircle::usage="Constructs a circle based on spline points. Comes from StackOverflow"
VariableSetBar::usage="A SetterBar which has a paired slider so that it can display many values compactly"
LabeledInterval::usage="An IntervalSlider with editable label"


Begin["`graphicsStuff`"];


ClearAll[splineCircle];
splineCircle[m_List,r_,angles_List: {0,2 \[Pi]}]:=
	Module[{seg,\[Phi],start,end,pts,w,k},
		{start,end}=Mod[angles//N,2 \[Pi]];
		If[end<=start,end+=2 \[Pi]];
		seg=Quotient[end-start//N,\[Pi]/2];
		\[Phi]=Mod[end-start//N,\[Pi]/2];
		If[seg==4,seg=3;\[Phi]=\[Pi]/2];
		pts=
			r*RotationMatrix[start].#&/@
			Join[
				Take[{{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}},
					2*seg+1],
				RotationMatrix[seg \[Pi]/2].#&/@{{1,Tan[\[Phi]/2]},{Cos[\[Phi]],Sin[\[Phi]]}}];
		If[Length[m]==2,
			pts=m+#&/@pts,
			pts=m+#&/@Transpose[Append[Transpose[pts],ConstantArray[0,Length[pts]]]]];
		w=Join[Take[{1,1/Sqrt[2],1,1/Sqrt[2],1,1/Sqrt[2],1},2 seg+1],{Cos[\[Phi]/2],1}];
		k=Join[{0,0,0},Riffle[#,#]&@Range[seg+1],{seg+1}];
		BSplineCurve[pts,SplineDegree->2,SplineKnots->k,SplineWeights->w]
		]/;Length[m]==2||Length[m]==3


Options[LabeledInterval]=Flatten@{
	Options@IntervalSlider,
	Options@Labeled,
	FilterRules[Options@InputField,Except[FieldSize]],
	FieldSize->3
	};
SetAttributes[LabeledInterval,HoldFirst];
LabeledInterval[dynamicVar_,variableRange_List,(labelpos__?(Head[#]=!=Rule&)|___),ops:OptionsPattern[]]:=
	DynamicModule[
		{sl,lab,f1,f2,dynamset,variable=If[Head@dynamicVar===Dynamic,dynamicVar,Dynamic@dynamicVar]},
		dynamset[var_Dynamic,val_,part__:None]:=
			With[{hp=Block[{Dynamic=HoldPattern},var]},
				If[part===None,
					Set[hp,val],
					Block[{v=ReleaseHold@hp},Part[v,part]=val;hp=v]
				]
			];
		sl=IntervalSlider[variable,variableRange[[;;Min@{3,Length@variableRange}]],FilterRules[{ops},Options@IntervalSlider]];
		If[Length[variableRange]<4,
			f1=variableRange[[1]]+.25*(variableRange[[2]]-variableRange[[1]]);
			f2=variableRange[[2]]-.25*(variableRange[[2]]-variableRange[[1]]);,
			{f1,f2}=variableRange[[4]]
		];
		lab=Row[{
			InputField[Dynamic[dynamicVar[[1]],
				Function[{v},dynamset[variable,v,1]]],
				FieldSize->OptionValue@FieldSize,
				FilterRules[{ops},Options[InputField]]],
			InputField[Dynamic[dynamicVar[[2]],
				Function[{v},dynamset[variable,v,2]]],
				FieldSize->OptionValue@FieldSize,
				FilterRules[{ops},Options[InputField]]]
			}];
		Labeled[sl,lab,labelpos,FilterRules[{ops},Options@Labeled]]
	]


Clear["VariableSetBar"]
Options[VariableSetBar]=Flatten[{
Options[SetterBar],Options[Animator],Context->Automatic,RealVarName->Automatic,
AdjustmentRange->Automatic,Choices->10,"SynchronousAdjustment"->True}];
SetAttributes[VariableSetBar,HoldFirst];
vsbcontext=$Context;
VariableSetBar[variable_,variableRange_List,ops:OptionsPattern[]]:=(
	(*Begin["variableSetBarContext`"];*)
	(*variableSetBarContext`dm=*)DynamicModule[
		{S1,S2,adjustrange,
			varrange={1,OptionValue[Choices]},c=0,
			var,
			n=variableRange[[1]],valchoices,setvar,stringAssign,RET,
			cont=Switch[OptionValue[Context],
						Automatic,$Context,
						_,OptionValue[Context]]
		},
			
			adjustrange=Switch[OptionValue[AdjustmentRange],
							Automatic,If[Head@variableRange[[1]]==List//TrueQ,
											{0,Max[{Length[variableRange[[1]]]-OptionValue[Choices],0}]},
											{0,variableRange[[-1]]-OptionValue[Choices]}
										],
							_Integer,{0,OptionValue[AdjustmentRange]},
							_,OptionValue[AdjustmentRange]];
			stringAssign[strVar_,val_]:=ToExpression@(strVar<>"="<>ToString@val);
			SetAttributes[stringAssign,HoldFirst];
			valchoices=Switch[variableRange,
								({_Integer,_Integer,_Integer}|{_Integer,_Integer}),Range@@variableRange,
								_,variableRange];
			varrange[[-1]]=Min@{varrange[[-1]],Length[valchoices]};
			var=If[Head[variable]==Dynamic//TrueQ,
					variable,
					Dynamic[variable]
					];
			S2=If[OptionValue["SynchronousAdjustment"],
					Animator[Dynamic[c],Append[adjustrange,1],4,AnimationRunning->False,
						FilterRules[{ops},Options[Animator]]],
					Slider[Dynamic[c],Append[adjustrange,1]],FilterRules[{ops},Options[Slider]]];
			(*setvar=StringReplace[ToString@var,{"Dynamic["->"","]"->""}];*)
			S1=Row[{
				Button["\[LeftArrow]",
					n=ToExpression@setvar;
					If[n-1>=adjustrange[[1]]+varrange[[1]],n+=-1];
					stringAssign[setvar,n];
					If[n<c+varrange[[1]],c+=-1],
					ImageSize->{Small,Medium},
					Appearance->"Frameless"
					],
				Dynamic[
					If[OptionValue["SynchronousAdjustment"],
						Which[
							(*n<=varrange[[1]],n=varrange[[1]]+1,
							n>adjustrange[[2]]+varrange[[ 2]],n=adjustrange[[2]]+varrange[[2]],*)
							n<c+varrange[[1]],n+=1;stringAssign[setvar,n],
							n>c+varrange[[-1]],n+=-1;stringAssign[setvar,n]
							];
					n=ToExpression[setvar]
					];
					If[Head@setvar==Symbol,setvar=StringReplace[ToString@var,{"Dynamic["->"","]"->""}]];
					SetterBar[var,valchoices[[c+ varrange[[1]];;c+varrange[[2]] ]](*,Appearance\[Rule]*),FilterRules[{ops},Options[SetterBar]]]
					],
				Button["\[Rule]",
					n=ToExpression@setvar;
					If[n+1<=adjustrange[[2]]+varrange[[-1]],n+=1];
					stringAssign[setvar,n];
					If[n>c+varrange[[-1]],c+=1]
					,ImageSize->{Small,Medium},
					Appearance->"Frameless"
					]
				}];
		Column[{S1,S2}]
		](*;
		End[]
		variableSetBarContext`dm*)
)


End[];


VariableSetBar=`graphicsStuff`VariableSetBar
LabeledInterval=`graphicsStuff`LabeledInterval
splineCircle=`graphicsStuff`splineCircle


Options[SphericalDVRPlot]=Flatten[{
	"PlotReturn"->Manipulator,
	Options[Manipulate],
	FilterRules[Options[Graphics3D],
		Except[(Axes|AxesOrigin|ImageSize|Boxed|SphericalRegion|Ticks|Lighting)]],
	Lighting->"Neutral",
	ImageSize->{350,350},
	Axes->True,
	AxesOrigin->{0,0,0},
	Boxed->False,
	SphericalRegion->True,
	Ticks->{Automatic,None,None},
	ColorFunction->"Rainbow",
	"PotentialColoring"->"TemperatureMap",
	"PotentialPointSize"->Small,
	"EnergyDigits"->3,
	"Interactivity"->Normal,
	"PotentialMode"->True,
	"PotentialCutOff"->(True&),
	"WavefunctionValueMin"->10^-10,
	"SquareWavefunction"->False,
	Joined->True,
	List->False,
	"WavefunctionPointSize"->Normal,
	"WavefunctionStyle"->Point,
	Opacity->1,
	"WavefunctionValueMax"->Automatic,
	"ManipulatorStep"->Small,
	"WavefunctionSelection"->All,
	"RadialPointSelection"->All,
	"AzimuthalPointSelection"->All,
	"PolarPointSelection"->All,
	"PotentialSelection"->All,
	"ZeroPointEnergy"->Automatic,
	Paneled->True,
	Tooltip->True,
	Verbose->False,
	AddTo->{}
}];
SphericalDVRPlot[
	solutions:{{(_?NumericQ)..},_}|None,
	gridpoints_List,potential:_List|None:None,
	ops:OptionsPattern[]]:=
	Module[
		{
			wavefunctionPlotFunction,wavefunctionPlotWrapper,
			potentialPlotObjectFunction,potentialPlotObjectWrapper,
			rX,\[Phi]X,\[Theta]X,
			X,T,V,\[CapitalLambda],\[CapitalPsi],\[Psi],axesThing,plotLab,
			waveSet,wavePlot,potentialPlot,
			maxProb=OptionValue["WavefunctionValueMax"],
			Ec=Max[{10^-30,OptionValue["WavefunctionValueMin"]}],
			FP,potentialMode,ps,colorPoints,boxsize,volElFactor,
			bg=OptionValue[Background],
			pointFunc,coFunc=OptionValue[ColorFunction],
			potCo=OptionValue["PotentialColoring"],
			zpe=OptionValue@"ZeroPointEnergy",
			num=OptionValue["WavefunctionSelection"]
			},
		(*-----------------------------------------------------------------------------*)
		(*Calculates box size and figures out what axes elements to put in*)
		{X,T}=gridpoints;
		X={#1,ArcCos[#2],#3}&@@@Cases[X,{_?NumericQ,_?NumericQ,_?NumericQ},\[Infinity]];
		X=SortBy[X,Last];
		V=Replace[potential,None->ConstantArray[0,Length@X]];
		{rX,\[Theta]X,\[Phi]X}=DeleteDuplicates[X[[All,#]]]&/@{1,2,3};
		plotLab=OptionValue[PlotLabel];
		(*Gets the label for the plot*)
		
		(*the potential is assumed to be an array or sparse array representing the potential at the gridpoints*)
		{\[CapitalLambda],\[CapitalPsi]}=
			Replace[solutions,
				None:>{
					ConstantArray[0,Length@X],
					ConstantArray[ConstantArray[0,Length@X],Length@X]
					}];
		Switch[zpe,Automatic,zpe=-\[CapitalLambda][[1]],None,0];
		\[CapitalLambda]=zpe+\[CapitalLambda];
		(*These are the components which come out of SphericalDVRWavefunctions*)
		
		(*Gets the actual values of r,\[Phi], and \[Theta] for use later in the variable trace*)
		boxsize=Max[X[[All,1]]];
		(*The box has a size of max r*)
		With[{
			splineCircle=
				Function[{m,r,angles},
					With[{a=
						Replace[Mod[angles//N,2 \[Pi]],
							({s_,e_}/;e<=s):>
								{s,e+2\[Pi]}
							]},
						With[{
							seg=
								If[Quotient[Abs[Last@a-First@a]//N,\[Pi]/2]==4,
									3,
									Quotient[Abs[Last@a-First@a]//N,\[Pi]/2]],
							\[Phi]=
								If[Quotient[Abs[Last@a-First@a]//N,\[Pi]/2]==4,
									\[Pi]/2,
									Mod[Abs[Last@a-First@a]//N,\[Pi]/2]
									]
							},
							BSplineCurve[
								m+#&/@
									If[Length[m]==2,
										Identity,
										Transpose[Append[#,ConstantArray[0,Length[First@#]]]]&
										]@Dot[
											r*RotationMatrix[First@angles],
											Transpose@Join[
												Take[{{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}},2*seg+1],
												RotationMatrix[seg \[Pi]/2].#&/@{
													{1,Tan[\[Phi]/2]},
													{Cos[\[Phi]],Sin[\[Phi]]}
													}
												]],
								SplineDegree->2,
								SplineKnots->
									Join[
										{0,0,0},
										Riffle[#,#]&@Range[seg+1],
										{seg+1}],
								SplineWeights->
									Join[
										Take[{1,1/Sqrt[2],1,1/Sqrt[2],1,1/Sqrt[2],1},2 seg+1],
										{Cos[\[Phi]/2],1}
										]
									
								]
							]
						]
					]
			},
			axesThing=
				Which[
					TrueQ[Not[OptionValue[Axes]]],{},
					(*If "Axes" is False*)
					TrueQ[OptionValue[Axes]==None],{},
					(*If "Axes" is None*)
					True,
					(*else*)
						With[{u=1+boxsize,shift=1.5},
							With[{c=
								splineCircle[{0,0,0},u,{0,2\[Pi]}],
								text=Inset[Text["\[Pi]"],{-u,shift,0},{0,0}]
								},
								{c,text,
									Inset[Text["\[CurlyPhi]=0"],{u,shift,0},{0,0}],
									Inset[Text["\[Theta]=0"],{0,shift,u},{0,0}],
									Inset[Text["\!\(\*FractionBox[\(\[Pi]\), \(2\)]\)"],{0,u,shift},{0,0}],
									Inset[Text["3\!\(\*FractionBox[\(\[Pi]\), \(2\)]\)"],{0,-u,shift},{0,0}],
									GeometricTransformation[{c,text},RotationTransform[-(\[Pi]/2),{0,1,0}]]
									}
							]
						]
					]
			];
		(*-----------------------------------------------------------------------------*)
		(*Puts the wave functions in plottable form*)
		num=
			Replace[num,{
				All:>Range[1,Length[\[CapitalLambda]]],
				_Integer:>Range[1,num],
				_List:>num,
				_->{1}
				}];
			(*Selects the number of wavefunctions to be plotted*)
		Replace[coFunc,
			_String|_List:>
				(coFunc=ColorData[coFunc])
			];
		volElFactor[r_,\[Phi]_,\[Theta]_]:=r^2 Sin[\[Theta]];
		\[Psi][n_]:=
			MapThread[
				Append[#1,If[OptionValue["SquareWavefunction"],#2^2,#2]]&,
				{X,\[CapitalPsi][[n]]}
				];
		If[TrueQ[maxProb==Automatic],
			With[{m=Max[Abs/@ \[Psi][num[[1]]][[All,4]]]},
				maxProb=Ceiling[  m,10^-2 ]
				]
			];
		(*Gets the max probability used in coloring the gridpoints and calculates the values to be plotted*)
		(*-----------------------------------------------------------------------------*)
		(*Deals with the potential field points (if any are to be used)*)
		Module[{p=OptionValue["PotentialMode"],m},
			p=
				With[{
					baseReplacements={
						"Network"->Line,
						"Traces"->{Line,{1}},
						"Circles"->{Line,{2}},
						"Arcs"->{Line,{3}},
						"Fan"->{Line,{1,3}},
						"Cone"->{Line,{1,2}},
						"Curves"->{Line,{2,3}},
						"BroadNetwork"->Blend,
						"BroadTraces"->{Blend,{1}},
						"BroadCircles"->{Blend,{2}},
						"BroadArcs"->{Blend,{3}},
						"BroadFan"->{Blend,{1,3}},
						"BroadCone"->{Blend,{1,2}},
						"BroadCurves"->{Blend,{2,3}}
						}
					},
					Replace[p,{
						{s:(_String|_Rule),v__}:>
							(Replace[s,baseReplacements]->If[Length@{v}>1,{v},v]),
						s:(_String|_Rule):>
							Replace[s,baseReplacements]
						}]
					];
			{p,m}=
				Replace[p,{
					{x_,y_}:>{x,y},
					{x_,y__}:>{x,{y}},
					((l:_List:None|v_)->c_):>
						With[{cho=
							Replace[c,{
								(_Rule|_RuleDelayed)->{c},
								{(_Rule|_RuleDelayed)..}->c,
								{(_List|_Rule|_RuleDelayed)..}:>
									MapIndexed[
										If[MatchQ[#1,(_Rule|_RuleDelayed)],
											#1,
											#2[[1]]->#1]&,
										c],
								o_:>
									{
										1->{o,2->o,3->o},
										2->{o,1->o,3->o},
										3->{o,1->o,2->o}
										}
								}]
							},
							If[l===None,
								{v,cho},
								{l[[1]],
									Cases[Flatten@cho,
										(Alternatives@@Thread[(l[[2]])->_])]
											~Join~
										Cases[l[[2]],Except@(Alternatives@@First/@cho)]}
								]
							],
					(a:(_->_)->b_):>{a,b},
					_:>{p,{1,2,3}}
					}];
			FP=
				Replace[p,{
					(False|None|"None")->
						False,
					(True|Point)->
						Point,
					(Joined|Line)->
						Line,
					("Field"|Blend)->
						Blend,
					("Dispersed"|"Spread"|"Blobby")->
						"Blobby",
					_String->
						Point,
					(a_->b_):>
						{a,b}
					}];
			potentialMode=m
			];
		ps=
			PointSize[
				With[{
					ws=OptionValue["WavefunctionPointSize"],
					D=(Max@rX-Min@rX)/(Length@rX*boxsize)
					},
					Switch[ws,
						"Sparse",D/2,
						Small,.85*D,
						Normal,D,
						"Dense",1.25*D,
						"Blobby",2*D,
						_,ws]
					]
				];
		With[{
			sph2orth=
				Evaluate[CoordinateTransform["Spherical"->"Cartesian",{#,#2,#3}]]&
			},
			If[TrueQ@OptionValue[Tooltip],
				pointFunc[\[CurlyPhi]_,\[Lambda]_]:=
					Tooltip[
						Point[sph2orth@@\[CurlyPhi][[1;;3]]],
						Column[
							Function[{r,j,q,y},{
								Row[{"R: ",r}],
								Row[{"\[Phi]: ",j}],
								Row[{"\[Theta]: ",q}],
								Row[{"\[Psi](R,\[Phi],\[Theta]): ",y}]
								}]@@(
								NumberForm[#,OptionValue["EnergyDigits"]]&@@@(
									{#1,#2 180/\[Pi],#3 180/\[Pi],#4-\[Lambda]}&@@\[CurlyPhi]
									)
								)
							]
						],
				pointFunc[\[CurlyPhi]_,\[Lambda]_]:=
					Point[sph2orth@@\[CurlyPhi][[1;;3]]]
				]
			];
		(*This function formats a gridpoint as a tooltip, allowing precise information to be gotten about it*)

	Replace[potCo,
		_String|_List:>
			(potCo=ColorData[potCo])
		];
	potentialPlotObjectFunction=
		SphericalDVRPotentialObjectFunction[X,V,
			rX,\[Phi]X,\[Theta]X,FP,
			potCo,OptionValue["PotentialPointSize"],
			potentialMode,OptionValue["PotentialCutOff"]
			];
	Options[potentialPlotObjectWrapper]={
		"PotentialMode"->FP,
		"PotentialColoring"->potCo,
		"PotentialPointSize"->OptionValue["PotentialPointSize"],
		"PotentialCutOff"->OptionValue["PotentialCutOff"],
		Mode->potentialMode
		};
	potentialPlotObjectWrapper[pOps:OptionsPattern[]]:=
		Module[{
			mode=OptionValue@Mode,
			potentialColoring=OptionValue@"PotentialColoring",
			drawMode=
				Replace[OptionValue@"PotentialMode",{
					(False|None|"None")->False,
					(True|Point)->Point,
					(Joined|Line)->Line,
					("Field"|Blend)->Blend,
					("Dispersed"|"Spread"|"Blobby")->"Blobby",
					_String->Point
					}],
			cutOff=OptionValue@"PotentialCutOff"
			},
			Replace[potentialColoring,
				_String|_List:>
					(potentialColoring=ColorData[potentialColoring])
				];
			potentialPlotObjectFunction[X,V,drawMode,potentialColoring,rX,\[Phi]X,\[Theta]X,mode,cutOff]
			];
	colorPoints=potentialPlotObjectFunction[];
	(*This produces the fieldpoints. 
		Should be rewritten to format them as lines between adjacent field points, 
			giving a spider-web form of the potential.
		Find same \[CurlyPhi],\[Theta] closest r, same r,\[CurlyPhi] closest \[Theta] and same r,\[Theta] closest \[CurlyPhi].
		Draw as average color (as average values colored by the coloring function)*)
	(*-----------------------------------------------------------------------------*)
	(*Does the actual dirty work of plotting*)
			(*takes the points and makes a graph out of them*) 
	With[{eFunc=Function[{n},\[CapitalLambda][[n]]]},

	wavefunctionPlotFunction=
		SphericalDVRWavefunctionPlotFunction[X,\[Psi],eFunc,
			coFunc,pointFunc,colorPoints,
			rX,\[Phi]X,\[Theta]X,
			OptionValue["RadialPointSelection"],
				OptionValue["AzimuthalPointSelection"],
				OptionValue["PolarPointSelection"],
			OptionValue["EnergyDigits"],boxsize,axesThing,ps,
			FilterRules[
				With[{pops=Alternatives@@Keys@{ops}//Except},
					Flatten[
						{
							PlotLabel->plotLab,
							FilterRules[Options[SphericalDVRPlot],pops],
							ops
							}
						]
						],
						Options[SphericalDVRWavefunctionPlotFunction]
					]
				];
	Options[wavefunctionPlotWrapper]=
		With[{base={
			"PotentialMode"->colorPoints,
			Number->num[[1]],
			Axes->axesThing,
			Min->1.Ec,
			Max->maxProb,
			PointSize->ps,
			AddTo->OptionValue@AddTo,
			"PotentialColoring"->potCo,
			ColorFunction->coFunc,
			BarLegend->colorPoints[[1]],
			PlotLegends->{True,True},
			"RadialPointSelection"->OptionValue@"RadialPointSelection",
			"AzimuthalPointSelection"->OptionValue@"AzimuthalPointSelection",
			"PolarPointSelection"->OptionValue@"PolarPointSelection"}},
		Flatten[{
			base,
			FilterRules[{ops},Except[Alternatives@@(#[[1]]&/@base)]]
			}]
		];
	wavefunctionPlotWrapper[wPlotOps:OptionsPattern[]]:=
			With[{
				potentialColoring=
					Replace[OptionValue@"PotentialColoring",
						p:_String|_List:>
							ColorData[p]
						],
				colFunc=
					Replace[OptionValue@ColorFunction,
						p:_String|_List:>
							ColorData[p]
						],
				pSize=OptionValue@PointSize,
				legends=OptionValue@PlotLegends,
				n=OptionValue@Number,min=OptionValue@Min,max=OptionValue@Max,
				rSel=OptionValue@"RadialPointSelection",
				\[Phi]Sel=OptionValue@"AzimuthalPointSelection",
				\[Theta]Sel=OptionValue@"PolarPointSelection",
				epi=OptionValue@AddTo,
				ax=OptionValue@Axes,
				dops=FilterRules[{wPlotOps},Options[Graphics3D]],
				pm=OptionValue@"PotentialMode"},
				With[{s=
					Sequence[n,min,max,
						OptionValue@BarLegend,
						BarLegend[{Function[x,colFunc[Rescale[x,{0,max}]]],{0,max}}],
						colFunc,
						TrueQ@legends[[1]],TrueQ@legends[[2]],
						rSel,\[Phi]Sel,\[Theta]Sel,
						pSize,ax,pm,epi]},
					If[(Length@dops)>0,
						wavefunctionPlotFunction[s,dops],
						wavefunctionPlotFunction[s]
						]
					]
				]
			];
	Switch[OptionValue["PlotReturn"],
		"Inputs",
			ClearAttributes[\[Psi],Temporary];
			{X,V,\[Psi]},
		"Functions",
			With[{s={
				wavefunctionPlotFunction,wavefunctionPlotWrapper,
				potentialPlotObjectFunction,potentialPlotObjectWrapper
				}},
				ClearAttributes[s,Temporary]
				];
			<|
				"WavefunctionFull"->wavefunctionPlotFunction,
				"Wavefunctions"->wavefunctionPlotWrapper,
				"PotentialFull"->potentialPlotObjectFunction,
				"Potential"->potentialPlotObjectWrapper
				|>,
		"Potential",
			With[{g=colorPoints},Graphics3D[g[[2]],Boxed->OptionValue@Boxed] ],
		"Wavefunction",
			wavefunctionPlotWrapper[],
		_,
			Module[{pstep=Switch[OptionValue["ManipulatorStep"],
							"Ultrafine",.00001,
							Fine,.0001,
							Small,.005,
							Medium,.01,
							Coarse,.1,
							_,1.OptionValue["ManipulatorStep"]]
			(*dofunc*)},
			(*dofunc=wavefunctionPlotFunction*)
			Module[{manipulate=True,args,drawops},
				Switch[OptionValue["Interactivity"],
					None,(*Provides just the graphic*)
						manipulate=False;
						args=
							HoldComplete@
								Sequence[
									num[[1]],1.Ec,maxProb,colorPoints[[1]],
									BarLegend[{coFunc@Rescale[#,{0,maxProb}]&,{0,maxProb}}],
									coFunc,
									True,True
									],
					Less,(*Lets the \[Psi] number vary and the minimum probability*)
						args=
							HoldComplete@
								Sequence[n,1.Ec,maxProb,
									colorPoints[[1]],
									BarLegend[{coFunc@Rescale[#,{0,maxProb}]&,{0,maxProb}}],
									coFunc,
									fF,gF];
						drawops=
							Sequence[
								Control@{{n,num[[1]],"\[Psi]"},
									VariableSetBar[#,{num},
										"SynchronousAdjustment"->False,
										ImageSize->Small]&,
									ControlPlacement->Top},
								Row@{
									Control@{
										{fF,True,"Show Potential   "},
										{True,False}
										},
									Control@{
										{gF,True,"Show Wavefunction"},
										{True,False}}
										},
								ControlPlacement->Bottom,
								Paneled->False
								],
					Normal,(*Lets the \[Psi] number, minimum probability, and max probability vary*)
						args=
							HoldComplete@
								Sequence[n,c[[1]],c[[2]],colorPoints[[1]],
									BarLegend[{coFunc@Rescale[#,{0,c[[2]]}]&,{0,c[[2]]}}],
									coFunc,
									fF,gF];
						drawops=
							Sequence[
								Control@{
									{n,num[[1]],"\[Psi]"},
									VariableSetBar[#,num,
										"SynchronousAdjustment"->False,
										ImageSize->Small]&,
									ControlPlacement->Top
								},
								Column[{
									Control@{
										{c,{1.Ec,1.maxProb},"\[Psi]-Bounds"},
										LabeledInterval[#,{0,1,pstep},Bottom,
											FieldSize->10,Appearance->Frameless,Method->"Stop"
											]&},
									Row@{
										Control@{
											{fF,True,"Show Potential   "},
											{True,False}},
										Control@{
											{gF,True,"Show Wavefunction"},
											{True,False}}
										}
									},
								Alignment->Left],
								ControlPlacement->Bottom,
								Paneled->False],
					"More",(*Lets the \[Psi] number, min prob, max prob, and r, \[Phi], \[Theta] selections vary*)
						args=
							HoldComplete@
								Sequence[n,c[[1]],c[[2]],colorPoints[[1]],
									BarLegend[{coFunc@Rescale[#,{0,c[[2]]}]&,{0,c[[2]]}}],
									coFunc,
									fF,gF,r,f,q];
						drawops=
							Sequence[
								Control@{{n,num[[1]],"\[Psi]"},
									VariableSetBar[#,num,
										"SynchronousAdjustment"->False,
										ImageSize->Small]&,
									ControlPlacement->Top},
									Grid[{
										{
											Control@{
												{c,{1.Ec,1.maxProb},"\[Psi]-Bounds"},
												LabeledInterval[#,{0,1,pstep},Bottom,
													FieldSize->10,Appearance->Frameless,Method->"Stop"]&
												},
											Control@{
												{r,Flatten@{OptionValue["RadialPointSelection"]},"R Selection"},
												Append[Range[1,Length[rX]],All],ControlType->TogglerBar}
												},
										{
											Control@{{fF,True,"Show Potential   "},{True,False}},
											Control@{
												{f,Flatten@{OptionValue["AzimuthalPointSelection"]},
												"\[Phi] Selection"},
												Append[Range[1,Length[\[Phi]X]],All],
												ControlType->TogglerBar}
												},
										{
											Control@{{gF,True,"Show Wavefunction"},{True,False}},
											Control@{
												{q,Flatten@{OptionValue["PolarPointSelection"]},
												"\[Theta] Selection"},
												Append[Range[1,Length[\[Theta]X]],All],
												ControlType->TogglerBar} 
											}
										},
										Alignment->Left],
										ControlPlacement->Bottom,
										Paneled->False],
					Most,
						args=
							HoldComplete@
								With[{cps=potentialPlotObjectWrapper["PotentialMode"->mo,Mode->ms]},
									With[{s=
										List[n,c[[1]],c[[2]],cps[[1]],
											BarLegend[{coFunc@Rescale[#,{0,c[[2]]}]&,{0,c[[2]]}}],
											coFunc,
											fF,gF,r,f,q,pos,ax,cps]
										},
										Sequence@@s]
									];
						drawops=
							Sequence[
								Control@{{n,num[[1]],"\[Psi]"},
									VariableSetBar[#,num,
										"SynchronousAdjustment"->False,
										ImageSize->Small]&,
									ControlPlacement->Top},
								Grid[{
									{
										Control@{
											{c,{1.Ec,1.maxProb},"\[Psi]-Bounds"},
											LabeledInterval[#,{0,1,pstep},Bottom,
												FieldSize->10,Appearance->Frameless,Method->"Stop"]&
											},
										Control@{
											{r,Flatten@{OptionValue["RadialPointSelection"]},"R Selection"},
											Prepend[Range[1,Length[rX]],All],
											ControlType->TogglerBar}
										},
									{
										Control@{{pos,ps,"Point Size"},0,.2},
										Control@{
											{f,Flatten@{OptionValue["AzimuthalPointSelection"]},
											"\[Phi] Selection"},
											Prepend[Range[1,Length[\[Phi]X]],All],
											ControlType->TogglerBar}
											},
									{
										Row@{
											Control@{{fF,True,"Show Potential"},{True,False}},
											Control@{{gF,True,"Show Wavefunction"},{True,False}}},
											Control@{
												{q,Flatten@{OptionValue["PolarPointSelection"]},
												"\[Theta] Selection"},
												Prepend[Range[1,Length[\[Theta]X]],All],
												ControlType->TogglerBar}
												},
									{
										Control@{
											{mo,OptionValue@"PotentialMode","Potential Mode"},
												{
													Point->"Points","Blobby"->"Dispersed",
													Line->"Network",Blend->"BroadNetwork"}
													},
										Control@{
											{ms,Flatten@{OptionValue@"PotentialSelection"},
											"Potential Selection"},
											{"Points","Radial","Azimuthal","Polar"},
											ControlType->TogglerBar}
										},
									{
										Control@{
											{ax,axesThing,"Show Axes"},
											{{},axesThing},
											ControlType->Checkbox}
											}
									},
									Alignment->Left
									],
								ControlPlacement->Bottom,
								Paneled->False
							],
					_,
						args=
							HoldComplete@
								Sequence[n,1.Ec,maxProb,colorPoints[[1]],
									BarLegend[{coFunc@Rescale[#,{0,maxProb}]&,{0,maxProb}}],
									coFunc,
									True,True];
						drawops=
							Sequence[
								Control@{{n,num[[1]],"\[Psi]"},
									VariableSetBar[#,num,
										"SynchronousAdjustment"->False,
										ImageSize->Small]&},
								Paneled->False
								]
					];
				If[TrueQ@OptionValue[Paneled],
					Panel,
					Identity]@
					With[{d=wavefunctionPlotFunction,a=args,o=drawops},
						If[manipulate==True,
							Manipulate[
								Column[{
									With[{sub=Subscript["\[Psi]",n]},
										If[OptionValue["SquareWavefunction"],Row[{sub,"\[Conjugate]",sub}],sub]],
											d[ReleaseHold@a]
										}],
								o],
							Column[{
								With[{sub=Subscript["\[Psi]",num[[1]]]},
									If[OptionValue["SquareWavefunction"],Row[{sub,"\[Conjugate]",sub}],sub]],
										d[ReleaseHold@a]
								}]
							]
						]
				]
			]
		]
	];


End[];


ChemDVREnd[];


$SphericalDVR=
	<|
		"Name"->"Spherical",
		"Dimension"->3,
		"FormatGrid"->SphericalDVRFormatGrid,
		"PointLabels"->Flatten@Lookup[{$RadialDVR,$MeyerDVR,$LegendreDVR},"PointLabels"],
		"Range"->{{1,2},{0,\[Pi]},{0,2\[Pi]}},
		"Grid"->SphericalDVRPoints,
		"KineticEnergy"->SphericalDVRK,
		"PotentialEnergy"->SphericalDVRV,
		"Wavefunctions"->SphericalDVRWavefunctions,
		"WavefunctionGrid"->SphericalDVRWavefunctionGrid,
		"View"->SphericalDVRPlot
		|>



