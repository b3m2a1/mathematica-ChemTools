(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemDVRBegin[];


Cartesian2DC2DVRFormatGrid::usage=""
Cartesian2DC2DVRPoints::usage=""
Cartesian2DC2DVRKineticMatrix::usage=""
Cartesian2DC2DVRPotentialMatrix::usage=""
Cartesian2DC2DVRWavefunctions::usage=""
Cartesian2DC2DVRPlotFunction::usage=""


ChemDVRNeeds/@{"Cartesian2DDVR", "Cartesian1DCsDVR"};


Begin["`Private`"];


Cartesian2DC2DVRPoints[
	points:{_Integer, _Integer},
	X:{{_?NumericQ,_?NumericQ}, {_?NumericQ,_?NumericQ}}:{{-10,10}, {-10,10}}
	]:=
	Table[
		{x, y},
		{x, 
			Cartesian1DCsDVRPoints[points[[{1}]], X[[{1}]]]
			},
		{y, 
			Cartesian1DDVRPoints[points[[{2}]], X[[{2}]]]
			}
		]


symmTCMYBit=
	Compile[
		{
			{ix, _Integer}, {jx, _Integer},
			{iy, _Integer}, {jy, _Integer},
			{Np, _Integer}, 
			{cX, _Real},
			{cY, _Real}
			},
		If[ix == jx,
				(-1)^(iy - jy)*cY*
					If[iy == jy,
					 	Pi^2/3,
					 	2/(iy - jy)^2
						],
				0
				]
		]


symmTCMXBit=
	Compile[
		{
			{ix, _Integer}, {jx, _Integer},
			{iy, _Integer}, {jy, _Integer},
			{Np, _Integer}, 
			{cX, _Real},
			{cY, _Real}
			},
		If[iy == jy,
			 (
					(-1)^(ix - jx)*cX*
						If[ix == jx,
						 	Pi^2/3,
						 	2/(ix - jx)^2
							]
					),
				0
				]
		]


With[{symmTCMXBit=symmTCMXBit,symmTCMYBit=symmTCMYBit},
	symmTCMBit=
		Compile[
			{
				{ix, _Integer}, {jx, _Integer},
				{iy, _Integer}, {jy, _Integer},
				{Np, _Integer}, 
				{cX, _Real},
				{cY, _Real}
				},
			symmTCMYBit[
				ix, jx,
				iy, jy,
				Np,
				cX, cY
				] +
			symmTCMXBit[
				ix, jx,
				iy, jy,
				Np,
				cX, cY
				]
			]
		]


With[{symmTCMBit=symmTCMBit},
symmPlus=
	Compile[
		{
			{ix, _Integer}, {jx, _Integer}, 
			{iNx, _Integer}, {jNx, _Integer}, 
			{iy, _Integer}, {jy, _Integer},
			{iNy, _Integer}, {jNy, _Integer},
			{Np, _Integer},
			{Nx, _Integer}, {Ny, _Integer},
			{cX, _Real}, {cY, _Real}
			},
			1/2*(
				2*symmTCMBit[
					ix, jx, 
					iy, jy, 
					Np, 
					cX, cY
					]+(*
				symmTCMBit[
					iNx, jx, 
					iNy, jy, 
					Np, 
					cX, cY
					]+*)
				2*symmTCMBit[
					ix, jNx, 
					iy, jNy, 
					Np, 
					cX, cY
					](*+
				symmTCMBit[
					iNx, jNx, 
					iNy, jNy, 
					Np, 
					cX, cY
					]*)
				)
		]
	];


With[
	{
		symmTCMBit=symmTCMBit,
		symmTCMXBit=symmTCMXBit,
		symmTCMYBit=symmTCMYBit
		},
symmMinus=
	Compile[
		{
			{ix, _Integer}, {jx, _Integer}, 
			{iNx, _Integer}, {jNx, _Integer}, 
			{iy, _Integer}, {jy, _Integer},
			{iNy, _Integer}, {jNy, _Integer},
			{Np, _Integer},
			{Nx, _Integer}, {Ny, _Integer},
			{cX, _Real}, {cY, _Real}
			},
			1/2*(
				If[ix!=jx&&ix+jx>Nx, -1, 1]*
					(
						symmTCMXBit[
							ix, jx, 
							iy, jy, 
							Np, 
							cX, cY
							]+
						symmTCMXBit[
							iNx, jx, 
							iNy, jy, 
							Np, 
							cX, cY
							]
						)+
				symmTCMYBit[
					ix, jNx, 
					iy, jNy, 
					Np, 
					cX, cY
					]+
				symmTCMYBit[
					iNx, jNx, 
					iNy, jNy, 
					Np, 
					cX, cY
					]
				)
		]
	];


Options[Cartesian2DC2DVRKineticMatrix]=
	{
		"Mass1"->1,
		"Mass2"->1,
		"HBar"->1,
		"ScalingFactor"->1,
		"UseExact"->False
		};
Cartesian2DC2DVRKineticMatrix[grid_,ops:OptionsPattern[]]:=
	Module[
		{
			\[HBar]=OptionValue["HBar"],
			dx=Abs[Subtract@@Sort[grid[[All, 1, 1]]][[;;2]]], 
			xPoints=Length@grid,
			mx=OptionValue@"Mass1", 
			dy=Abs[Subtract@@Sort[grid[[1, All, 2]]][[;;2]]],
			yPoints=Length@grid[[1]],
			my=OptionValue@"Mass2",
			head,
			sf=OptionValue["ScalingFactor"]
			},
		With[{f1=symmPlus, f2=symmMinus, Np=xPoints*yPoints},
			head=
				If[Np>100000, ParallelTable, Table];
			{
				head[
					With[
						{
							ix=1+Floor[(i-1)/(yPoints)], jx=1+Floor[(j-1)/(yPoints)],
							iNx=1+Floor[(Np-i)/(yPoints)], jNx=1+Floor[(Np-j)/(yPoints)],
							iy=Mod[i, yPoints, 1], jy=Mod[j, yPoints, 1],
							iNy=Mod[Np-i+1, yPoints, 1], jNy=Mod[Np-j+1, yPoints, 1]
							},
						(* 
					Why this 1/5 was necessary I don't really know
					*)
						(*If[i!=j, 1/5, 1]**)
						f1[
							ix, jx,
							iNx, jNx,
							iy, jy,
							iNy, jNy,
							Np, xPoints, yPoints,
							sf*(\[HBar]^2)/(2*mx*dx^2),
							sf*(\[HBar]^2)/(2*my*dy^2)
							]
						],
					{i, xPoints*yPoints},
					{j, xPoints*yPoints}
					],
				head[
					With[
						{
							ix=1+Floor[(i-1)/(yPoints)], jx=1+Floor[(j-1)/(yPoints)],
							iNx=1+Floor[(Np-i)/(yPoints)], jNx=1+Floor[(Np-j)/(yPoints)],
							iy=Mod[i, yPoints, 1], jy=Mod[j, yPoints, 1],
							iNy=Mod[Np-i+1, yPoints, 1], jNy=Mod[Np-j+1, yPoints, 1]
							},
						(* 
					Why this 1/5 was necessary I don't really know
					*)
						(*If[i!=j, 1/5, 1]**)
						f2[
							ix, jx,
							iNx, jNx,
							iy, jy,
							iNy, jNy,
							Np, xPoints, yPoints,
							sf*(\[HBar]^2)/(2*mx*dx^2),
							sf*(\[HBar]^2)/(2*my*dy^2)
							]
						],
					{i, xPoints*yPoints, 1, -1},
					{j, xPoints*yPoints, 1, -1}
					]
				}
			]
		]


Options[Cartesian2DC2DVRPotentialMatrix]={Function->(Norm[(#/2)^2]&)};
Cartesian2DC2DVRPotentialMatrix[grid_,ops:OptionsPattern[]]:=
	With[{func=OptionValue@Function},
		With[{A=func/@Flatten[grid, 1]},
			{
				DiagonalMatrix@A,
				DiagonalMatrix@Reverse@A
				}
			]
		]


Options[Cartesian2DC2DVRPlotFunction]=
	Options[Cartesian2DDVRPlotFunction]
Cartesian2DC2DVRPlotFunction[
	solutions_,
	grid_,
	potentialMatrices_,
	ops:OptionsPattern[]
	]:=
	Cartesian2DDVRPlotFunction[
		solutions,
		Join[
			Map[
				{-1, -1}*#&,
				Reverse[grid],
				{2}
				],
			grid
			],
		ArrayFlatten[
			{
				{potentialMatrices[[2]], 0},
				{0, potentialMatrices[[1]]}
				}
			],
		ops
		]


End[];


$Cartesian2DC2DVR=
	<|
		"Name"->"Symmetric Cartesian C2 2D",
		"Dimension"->2,
		"PointLabels"->{"x"|"y"|"z", "x"|"y"|"z"},
		"Range"->{{-10,10}, {-10, 10}},
		"Grid"->Cartesian2DC2DVRPoints,
		"KineticEnergy"->Cartesian2DC2DVRKineticMatrix,
		"PotentialEnergy"->Cartesian2DC2DVRPotentialMatrix,
		"Wavefunctions"->Cartesian1DCsDVRWavefunctions,
		"View"->Cartesian2DC2DVRPlotFunction
		|>


ChemDVREnd[];


$Cartesian2DC2DVR



