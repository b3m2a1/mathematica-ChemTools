(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemDVRBegin[];


MeyerDVRFormatGrid::usage="Formats the grid";
MeyerDVRPoints::usage="Generates the grid";
MeyerDVRK::usage="";
MeyerDVRV::usage="";
MeyerDVRWavefunctions::usage="";
MeyerDVRPlot::usage="";


Begin["`Private`"];


MeyerDVRFormatGrid[grid_,points_]:=grid;


MeyerDVRPoints[{points_Integer},
	X:{{_?NumericQ,_?NumericQ}}:{{0,2.\[Pi]}}
	]:=
	DeleteDuplicatesBy[Mod[#,2\[Pi]]&][
		Subdivide@@Append[X[[1]],points]
		]


Options[MeyerDVRK]=
	{
		"Mass"->1,
		"HBar"->1,
		"ScalingFactor"->1,
		"UseExact"->False
		};
MeyerDVRK[gridpoints_,ops:OptionsPattern[]]:=
	With[
		{
			X=gridpoints,
			p=Length@gridpoints,
			\[HBar]=OptionValue@"HBar",
			m=OptionValue["Mass"],
			ex=TrueQ@OptionValue["UseExact"],
			s=OptionValue["ScalingFactor"]
			},
	Table[
			(s*\[HBar])*
			If[i==j,
				(p^2/2+1)*1/6,
				((-1)^(i-j))/
					(2*Sin[(\[Pi]*(i-j))/p]^2)
				],
			{i,p},
			{j,p}
			]
		];


Options[MeyerDVRV]={Function->Sin};
MeyerDVRV[gridpoints_,ops:OptionsPattern[]]:=
	With[{P=OptionValue[Function],X=gridpoints,p=Length@gridpoints},
		SparseArray[Band[{1,1}]->P/@X,{p,p}]
		];


Clear["MeyerDVRWavefunctions"]
MeyerDVRWavefunctions[T_,V_]:=
	With[{S=#[[{1,2},Ordering[First@#]]]&@Eigensystem[T+V]},
		With[{phase=Sign/@S[[2,1]]},
			{First@S,phase*#&/@Last@S}
			]
		];


Options[MeyerDVRPlot]=
	DeleteDuplicatesBy[
		Flatten@{
			FilterRules[Options[ListPolarPlot],Except[Joined|ColorFunction]],
			Labeled->True,
			"EnergyShift"->False,
			"WavefunctionSelection"->Automatic,
			"EnergyDigits"->3,
			"ShowPotential"->True,
			"SquareWavefunction"->False,
			Manipulate->True,
			ColorFunction->"BrightBands"
			},
		First];
MeyerDVRPlot[solutions_,gridpoints_,potential_,ops:OptionsPattern[]]:=
	Module[
		{
			X,V=potential,\[CapitalLambda],\[CapitalPsi],\[Psi],
			waveSet,wavePlot,potentialPlot,volEl,
			num=
				Replace[OptionValue["WavefunctionSelection"],
					Automatic:>If[OptionValue@Manipulate//TrueQ,All,5]
					]},
		X=gridpoints;
		{\[CapitalLambda],\[CapitalPsi]}=solutions;
		num=
			Which[
				num===All,
					Range[1,Length[\[CapitalLambda]]],
				MatchQ[num,_List],
					num,
				MatchQ[num,_Integer],
					Range[1,num],
				True,
					Range[1,Floor[Length[\[CapitalLambda]]/2]]
				];
		volEl[x_]:=
			Sqrt[1-x^2];
		\[Psi][n_]:=
			Reverse@SortBy[First]@
				With[
					{
						S=OptionValue["EnergyShift"],
						Q=TrueQ@OptionValue["SquareWavefunction"]
						},
					MapThread[
						{#,If[S,\[CapitalLambda][[n]],0]+If[Q,Power[#2,2],#2]}&,
						{X,\[CapitalPsi][[n]]}]
					];
		waveSet=\[Psi]/@num;
		wavePlot=
			MapThread[
				ListPolarPlot[#,
					PlotLegends->
						If[TrueQ@OptionValue[Labeled],
							Row[{
								Subscript["\[Psi]",ToString[#2]],
								": E=",
								Round[\[CapitalLambda][[#2]],1.0*10^(-1*OptionValue["EnergyDigits"])]
								}],
							None
							],
					ColorFunctionScaling->False,
					ColorFunction->
						With[{c=ColorData[OptionValue[ColorFunction]][#2/Length@num]},
							Function[{x,y,\[Theta],r},Darker[c,\[Theta]/(1.5\[Pi])]]
							],
					FilterRules[{
						ops
						},
						Options[ListPolarPlot]
						],
					Joined->True
				]&,{
				waveSet,
				num
				}];
		potentialPlot=
			If[TrueQ@OptionValue["ShowPotential"],
				With[{
					pset=
						With[{D=Diagonal[V],M=Max@Diagonal@V,m=Max[waveSet[[All,All,2]]]},
							Reverse@SortBy[First]@
								MapThread[
									{#1,Abs[m/M]#2}&,
									{X,D}
									]
							]},
					With[{p=1,M=Max[pset[[All,2]]],m=Min[pset[[All,2]]]},
						Graphics[{
							Arrowheads[Small],
							Table[
								{GrayLevel[Rescale[pset[[i,2]],{m,M},{0,.9}]],
									Arrow[-#2*{Sin[#1],Cos[#1]}&@@@Take[pset,{i,(i+1)}]]
									},
								{i,Floor[Length[pset]/p]-1}]
							}]
						]
					],
				{}];
		If[OptionValue[Manipulate],
			With[{
				wp=wavePlot,pp=potentialPlot},
				Manipulate[
					Show[wp[[n]],pp],
					{{n,1,"Wavefunction"},1,Length[wp],1}
					]
				],
			Show[Append[wavePlot,potentialPlot]]
			]
		]


End[];


$MeyerDVR=
	<|
		"Name"->"Meyer 1D",
		"Dimension"->1,
		"FormatGrid"->MeyerDVRFormatGrid,
		"PointLabels"->{("\[CurlyPhi]"|"\[Phi]"|"phi"|"Phi"|"Angular"|"angular")},
		"Range"->{{0,2\[Pi]}},
		"Grid"->MeyerDVRPoints,
		"KineticEnergy"->MeyerDVRK,
		"PotentialEnergy"->MeyerDVRV,
		"Wavefunctions"->MeyerDVRWavefunctions,
		"View"->MeyerDVRPlot
		|>;


ChemDVREnd[];


$MeyerDVR



