(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemDVRBegin[];


Cartesian2DDVRFormatGrid::usage=""
Cartesian2DDVRPoints::usage=""
Cartesian2DDVRKineticMatrix::usage=""
Cartesian2DDVRPotentialMatrix::usage=""
Cartesian2DDVRWavefunctions::usage=""
Cartesian2DDVRPlotFunction::usage=""


ChemDVRNeeds/@{"Cartesian1DDVR"};


Begin["`Private`"];


Cartesian2DDVRPoints[
	points:{_Integer, _Integer},
	X:{{_?NumericQ,_?NumericQ}, {_?NumericQ,_?NumericQ}}:{{-10,10}, {-10,10}}
	]:=
	Table[
		{x, y},
		{x, Subdivide@@Flatten@{N@X[[1]],points[[1]]-1}},
		{y, Subdivide@@Flatten@{N@X[[2]],points[[2]]-1}}
		]


Options[Cartesian2DDVRKineticMatrix]=
	Join[
		FilterRules[
			Options[Cartesian1DDVRKineticMatrix],
			Except@"Mass"
			],
		{
			"Mass1"->1,
			"Mass2"->1
			}
		];
Cartesian2DDVRKineticMatrix[grid_, ops:OptionsPattern[]]:=
	Module[
		{
			cartDVR1=
				Cartesian1DDVRKineticMatrix[
					grid[[All, 1, 1]], 
					FilterRules[
						{
							"Mass"->
								OptionValue["Mass1"],
							ops
							},
						Options[Cartesian1DDVRKineticMatrix]
						]
					],
			cartDVR2=
				Cartesian1DDVRKineticMatrix[
					grid[[1, All, 2]],
					FilterRules[
						{
							"Mass"->
								OptionValue["Mass2"],
							ops
							},
						Options[Cartesian1DDVRKineticMatrix]
						]
					],
			ptsX=Length@grid,
			ptsY=Length@grid[[1]],
			k1SparseRules,
			k2SparseRules
			},
			k1SparseRules=
				Flatten[
					Table[
						Band[{(i-1)*ptsY+1, (j-1)*ptsY+1},{i*ptsY, j*ptsY}]->
						cartDVR1[[i, j]],
						{i, ptsX},
						{j, ptsX}
						],
					1
					];
			k2SparseRules=
				{
					Band[{1, 1}]->
						ConstantArray[cartDVR2, ptsX]
					};
			With[{k3=SparseArray[k2SparseRules]},
				SparseArray[k1SparseRules, Dimensions[k3]]+k3
				]
		]


	(*
	This was my old n^4 implementation. Much, much worse.
	*)
	(*Developer`ToPackedArray@
		If[(ptsX*ptsY)>100000,
			ParallelTable,
			Table
			][
			With[
				{
					ix=1+Floor[(i-1)/(ptsY)], jx=1+Floor[(j-1)/(ptsY)],
					iy=Mod[i, ptsY, 1], jy=Mod[j, ptsY, 1]
					},
				If[iy!=jy,
						0.,
						cartDVR1[[ix, jx]]
						]+
				If[ix!=jx,
						0.,
						cartDVR2[[iy, jy]]
						]
				],
			{i, ptsX*ptsY},
			{j, ptsX*ptsY}
			]*)


End[];


$Cartesian2DDVR=
	<|
		"Name"->"Cartesian 2D",
		"Dimension"->2,
		"PointLabels"->{"x"|"y"|"z", "x"|"y"|"z"},
		"Range"->{{-10,10}, {-10, 10}},
		"Grid"->Cartesian2DDVRPoints,
		"KineticEnergy"->Cartesian2DDVRKineticMatrix,
		"Defaults"->
			{
				"PotentialFunction"->"HarmonicOscillator",
				"PlotMode"->{"Cartesian", 1}
				}
		|>


ChemDVREnd[];


$Cartesian2DDVR



