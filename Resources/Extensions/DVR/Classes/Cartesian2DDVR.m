(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ChemDVRBegin[];


Cartesian2DDVRFormatGrid::usage=""
Cartesian2DDVRPoints::usage=""
Cartesian2DDVRKineticMatrix::usage=""
Cartesian2DDVRPotentialMatrix::usage=""
Cartesian2DDVRWavefunctions::usage=""
Cartesian2DDVRPlotFunction::usage=""


ChemDVRNeeds/@{"Cartesian1DDVR"};


Begin["`Private`"];


Cartesian2DDVRPoints[
	points:{_Integer, _Integer},
	X:{{_?NumericQ,_?NumericQ}, {_?NumericQ,_?NumericQ}}:{{-10,10}, {-10,10}}
	]:=
	Table[
		{x, y},
		{x, Subdivide@@Flatten@{N@X[[1]],points[[1]]-1}},
		{y, Subdivide@@Flatten@{N@X[[2]],points[[2]]-1}}
		]


Options[Cartesian2DDVRKineticMatrix]=
	Join[
		FilterRules[
			Options[Cartesian1DDVRKineticMatrix],
			Except@"Mass"
			],
		{
			"Mass1"->1,
			"Mass2"->1
			}
		];
Cartesian2DDVRKineticMatrix[grid_, ops:OptionsPattern[]]:=
	Module[
		{
			cartDVR1=
				Cartesian1DDVRKineticMatrix[
					grid[[All, 1, 1]], 
					FilterRules[
						{
							"Mass"->
								OptionValue["Mass1"],
							ops
							},
						Options[Cartesian1DDVRKineticMatrix]
						]
					],
			cartDVR2=
				Cartesian1DDVRKineticMatrix[
					grid[[1, All, 2]],
					FilterRules[
						{
							"Mass"->
								OptionValue["Mass2"],
							ops
							},
						Options[Cartesian1DDVRKineticMatrix]
						]
					],
			ptsX=Length@grid,
			ptsY=Length@grid[[1]],
			k1SparseRules,
			k2SparseRules
			},
			k1SparseRules=
				Flatten[
					Table[
						Band[{(i-1)*ptsY+1, (j-1)*ptsY+1},{i*ptsY, j*ptsY}]->
						cartDVR1[[i, j]],
						{i, ptsX},
						{j, ptsX}
						],
					1
					];
			k2SparseRules=
				{
					Band[{1, 1}]->
						ConstantArray[cartDVR2, ptsX]
					};
			With[{k3=SparseArray[k2SparseRules]},
				SparseArray[k1SparseRules, Dimensions[k3]]+k3
				]
		]


	(*
	This was my old n^4 implementation. Much, much worse.
	*)
	(*Developer`ToPackedArray@
		If[(ptsX*ptsY)>100000,
			ParallelTable,
			Table
			][
			With[
				{
					ix=1+Floor[(i-1)/(ptsY)], jx=1+Floor[(j-1)/(ptsY)],
					iy=Mod[i, ptsY, 1], jy=Mod[j, ptsY, 1]
					},
				If[iy!=jy,
						0.,
						cartDVR1[[ix, jx]]
						]+
				If[ix!=jx,
						0.,
						cartDVR2[[iy, jy]]
						]
				],
			{i, ptsX*ptsY},
			{j, ptsX*ptsY}
			]*)


Options[Cartesian2DDVRPotentialMatrix]={Function->(Norm[(#/2)^2]&)};
Cartesian2DDVRPotentialMatrix[grid_,ops:OptionsPattern[]]:=
	With[{func=OptionValue@Function},
		With[{A=func/@Flatten[grid,1]},
			SparseArray[Band[{1,1}]->A]
			]
		]


Options[Cartesian2DDVRListPlot]=
	DeleteDuplicatesBy[First]@
	Flatten@{
		"WavefunctionSelection"->Automatic,
		AxesOrigin->{0,0},
		Scaled->1,
		"ShowEnergy"->True,
		"PotentialStyle"->Automatic,
		"EnergyDigits"->3,
		"ZeroPointEnergy"->0,
		LabelingFunction->Automatic,
		"CutOff"->Automatic,
		Manipulate->True,
		PlotRange->Automatic,
		"PlotList"->
			Automatic,
		"SquareWavefunction"->False,
		FilterRules[Options[ListPlot3D],
			Except[AxesOrigin|PlotRange|LabelingFunction]
			]
		};
Cartesian2DDVRListPlot[
	solutions_,
	grid2D_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	Module[
		{\[CapitalLambda],X,\[Psi],
		scale=OptionValue[Scaled],
		num=
			Replace[OptionValue["WavefunctionSelection"],{
				Automatic:>If[TrueQ@OptionValue@Manipulate, All, 1]
				}],
		dataRange,
		potential=
			If[potentialMatrix//MatrixQ,
				Diagonal@potentialMatrix,
				potentialMatrix],
		squared=OptionValue@"SquareWavefunction",
		lf=Replace[OptionValue@LabelingFunction,{
				Automatic->(
					Row@{Subscript["\[Psi]",#1],": E=",
						1.Round[#2, 10^(-OptionValue["EnergyDigits"])]}&),
				None->False}],
		plotWave,
		waveSet,
		Ec=
			Replace[OptionValue["CutOff"],
				Automatic:>
					10^-(
						RealExponent[Length[grid2D]*Length[grid2D[[1]]]]
						)
				],
		wavePlot,potentialPlot,
		\[Lambda]Plot,plotRange,len,
		grid=Flatten[grid2D, 1]
		},
		{\[CapitalLambda],X}=solutions;
		len=Length@X;
		num=
			Flatten@List@Replace[num,
				{
					All:>Range[1,len],
					_List:>num,
					_Integer:>Range[1,num],
					_->{1}
					}];
		\[Psi]=Function[MapThread[Append[#1, If[squared,#2^2,#2]]&,{grid, X[[#]]}]];
		plotWave[n_]:=
			With[{psiReal=Select[\[Psi][n], Abs[#[[3]]]>=Ec&]},
				If[OptionValue["ShowEnergy"]//TrueQ,
					With[{
						s={1, 1, scale},
						\[Lambda]={0,0, \[CapitalLambda][[n]]}
						},
						\[Lambda]+s*#&/@psiReal
						],
					With[{s={1, 1,scale},\[Lambda]={0,0,\[CapitalLambda][[n]]}},
						s*#&/@psiReal
						]
					]
			];
		waveSet=\[Psi]/@num;
		dataRange=
			CoordinateBounds@
				Select[Flatten[waveSet,1], Abs[#[[3]]]>=Ec&];
		waveSet=
			Select[#,
				dataRange[[1,1]]<=#[[1]]<=dataRange[[1,2]]&&
					dataRange[[2,1]]<=#[[2]]<=dataRange[[2,2]]&
				]&/@(plotWave/@num);
		wavePlot[sel_, lFunc_:lf]:=
			ListPlot3D[
				waveSet[[sel]],
				FilterRules[{
					ops,
					PlotRange->
						{dataRange[[1]], dataRange[[2]], All},
					PlotLegends->
						If[lFunc===False,
							None,
							(lFunc@@#)&/@
								Thread@{
									num[[ sel ]],
									\[CapitalLambda][[ num[[ sel ]] ]]
									}
							],
					ClippingStyle->None
					},
					Options@ListPlot3D
					]
				];
		potentialPlot=
			With[{op=OptionValue["PotentialStyle"]},
				If[op===None,
					Nothing,
					ListPlot3D[
						MapThread[Append, {grid, potential}],
						PlotStyle->
							Replace[op,
								Automatic->
									Directive[Opacity[.1], Gray]
								],
						ClippingStyle->
							None
						]
					]
				];
		\[Lambda]Plot[sel_]:=
			ListPlot3D[
				MapThread[Append, {grid, ConstantArray[#, Length[grid]]}],
				PlotStyle->
					Directive[Opacity[.1], Red],
				ClippingStyle->
					None
				]&/@\[CapitalLambda][[ num[[sel]] ]];
		If[Length@num>1,
			If[OptionValue@Manipulate,
				With[{
					wp=wavePlot,N=num,
					lF=With[{f=lf[#1,#2]},f&],
					potPlot=potentialPlot,L=\[CapitalLambda],
					\[Lambda]P=\[Lambda]Plot, pl=TrueQ@OptionValue@"PlotList"
					},
					Manipulate[
						If[!pl||pl (* just here for when I decided what to do with it *),
							Show[
								wp[N[[i]],lF],
								{
									potPlot,
									If[OptionValue["ShowEnergy"]//TrueQ,\[Lambda]P[{i}],Sequence@@{}]
									},
								FilterRules[{ops}, Options[Graphics3D]]
								]
							],
						{{i,1,""},1,Length@N,1}
						]
					],
				If[OptionValue@"PlotList"===False,
					Show[
						wavePlot[All],
						{
							potentialPlot,
							If[OptionValue["ShowEnergy"]//TrueQ,
								\[Lambda]Plot[All],
								Sequence@@{}
								]
							},
						FilterRules[{ops},
							Options[Graphics3D]
							]
						],
					Show[
						wavePlot[#, lf],
						{
							potentialPlot,
							If[OptionValue["ShowEnergy"]//TrueQ,
								\[Lambda]Plot[All],
								Sequence@@{}
								]
							},
						FilterRules[{ops},
							Options[Graphics3D]
							]
						]&/@num
					]
			],
			Show[
				wavePlot[All],
				{
					potentialPlot,
					If[OptionValue["ShowEnergy"]//TrueQ,
						\[Lambda]Plot[All],
						Sequence@@{}
						]
					},
				FilterRules[{ops(*, PlotRange->plotRange*)},
					Options[Graphics3D]
					]
				]
			]
	];


Cartesian2DDVRPlotFunction::inpfl=
	"Failed to construct appropriate InterpolatingFunctions";


Options[Cartesian2DDVRDensityPlot]=
	DeleteDuplicatesBy[First]@
	Flatten@{
		"WavefunctionSelection"->Automatic,
		"InterpolatingWavefunctions"->Automatic,
		Scaled->1,
		"ShowEnergy"->True,
		"PotentialStyle"->Automatic,
		"EnergyDigits"->3,
		"ZeroPointEnergy"->0,
		LabelingFunction->Automatic,
		"CutOff"->Automatic,
		Manipulate->True,
		PlotRange->Automatic,
		"SquareWavefunction"->False,
		"PlotList"->
			Automatic,
		FilterRules[Options[DensityPlot],
			Except[AxesOrigin|PlotRange|LabelingFunction]
			]
		};
Cartesian2DDVRDensityPlot[
	solutions_,
	grid2D_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	Module[
		{
			engs,
			funcs,
			cutoff=
				Replace[
					OptionValue["CutOff"], 
					Automatic:>
						If[OptionValue[ColorFunctionScaling]=!=False,
							.1,
							10^-(
								RealExponent[Length[grid2D]*Length[grid2D[[1]]]]
								)
							]
					],
			cf=
				Replace[OptionValue["ColorFunction"],
					{
						Automatic->ColorData["Rainbow"],
						s:_String|_List:>ColorData[s]
						}
					],
			oppp,
			listup=
				Replace[OptionValue["PlotList"],
					Except[True|False]:>
						!TrueQ@OptionValue[Manipulate]
					]
			},
		funcs=
			Flatten@List@
			Replace[OptionValue["InterpolatingWavefunctions"],
				Except[{((_->_InterpolatingFunction)|_InterpolatingFunction)..}]:>
					ChemDVRDefaultInterpolatingWavefunctions[
						grid2D,
						solutions,
						FilterRules[{ops},
							Options@ChemDVRDefaultInterpolatingWavefunctions
							]
						]
				];
		oppp=
			DeleteDuplicatesBy[First]@
			FilterRules[
					{
						If[NumberQ@cutoff,
							ColorFunction->
								With[{cut=cutoff, col=cf},
									Function[
										If[#>cut, col[##], White(*GrayLevel[1, 0]*)]
										]
									],
							ColorFunction->
								cf
							],
						ops,
						PlotRange->All
						},
					Options@DensityPlot
					];
		engs=
			Replace[funcs,
				{
					(e_->_InterpolatingFunction):>e,
					_->Indeterminate
					},
				1
				];
		funcs=
			Replace[
				funcs,
				(_->f_InterpolatingFunction):>f,
				1
				];
		If[MatchQ[funcs, {__InterpolatingFunction}],
			With[{reg=funcs[[1, 1]], opp=oppp, funs=funcs},
				If[TrueQ@OptionValue[Manipulate],
					Manipulate[
						DensityPlot[
							funs[[i]][x,y]^2//Evaluate,
							{x, reg[[1,1]], reg[[1,2]]},
							{y, reg[[2,1]], reg[[2,2]]},
							opp
							],
						{{i, 1, ""}, 1, Length@funs, 1}
						],
					If[Length@#>0,
						#,
						#[[1]]
						]&@
						Map[
							DensityPlot[
								#[x,y]^2(*//Echo*)//Evaluate,
								{x, reg[[1,1]], reg[[1,2]]}(*//Echo//Evaluate*),
								{y, reg[[2,1]], reg[[2,2]]}(*//Echo//Evaluate*),
								oppp(*//Echo*)//Evaluate
								]&,
							funcs
							]
					]
				],
			Message[Cartesian2DDVRPlotFunction::inpfl];
			$Failed
			]
		]


Cartesian2DDVRPlotFunction::nomet=
	"Method `` not understood";


Options[Cartesian2DDVRPlotFunction]=
	Join[
		Options[Cartesian2DDVRListPlot],
		Options[Cartesian2DDVRDensityPlot],
		{
			"PlotMethod"->ListPlot3D
			}
		];
Cartesian2DDVRPlotFunction[
	solutions_,
	grid2D_,
	potentialMatrix_,
	ops:OptionsPattern[]
	]:=
	With[{m=OptionValue["PlotMethod"]},
		Switch[m,
			ListPlot3D,
				Cartesian2DDVRListPlot[solutions, grid2D, potentialMatrix,
					FilterRules[{ops},
						Options[Cartesian2DDVRListPlot]
						]
					],
			DensityPlot,
				Cartesian2DDVRDensityPlot[solutions, grid2D, potentialMatrix,
					FilterRules[{ops},
						Options[Cartesian2DDVRDensityPlot]
						]
					],
			_,
				Message[Cartesian2DDVRPlotFunction::nomet, m]
			]
		]


End[];


$Cartesian2DDVR=
	<|
		"Name"->"Cartesian 2D",
		"Dimension"->2,
		"PointLabels"->{"x"|"y"|"z", "x"|"y"|"z"},
		"Range"->{{-10,10}, {-10, 10}},
		"Grid"->Cartesian2DDVRPoints,
		"KineticEnergy"->Cartesian2DDVRKineticMatrix,
		"PotentialEnergy"->Cartesian2DDVRPotentialMatrix,
		"View"->Cartesian2DDVRPlotFunction
		|>


ChemDVREnd[];


$Cartesian2DDVR



